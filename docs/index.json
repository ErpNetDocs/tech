{
  "advanced/business-rules/action-types/fail.html": {
    "href": "advanced/business-rules/action-types/fail.html",
    "title": "FAIL | ERP.net Tech Docs",
    "keywords": "FAIL Usually used to include additional validations in the system - validations which are currently not implemented in the system. The FAIL syntax is simple - the user just set that the current business rule throws an error. He is also able to set the error text as a constant. The constant may be entered as first parameter type and value. For example: ActionNo: 1 ; Action Type: FAIL; Parameter1 Type: Constant ; Parameter1 Value: 'error message text' ."
  },
  "advanced/business-rules/action-types/index.html": {
    "href": "advanced/business-rules/action-types/index.html",
    "title": "Action types | ERP.net Tech Docs",
    "keywords": "Action types The following types of actions are available to the user when creating a user business rules: FAIL NOTIFYUSER SENDMAIL SETVALUE WARNING"
  },
  "advanced/business-rules/action-types/notifyuser.html": {
    "href": "advanced/business-rules/action-types/notifyuser.html",
    "title": "NOTIFYUSER | ERP.net Tech Docs",
    "keywords": "NOTIFYUSER Name NOTIFYUSER Description Used for creating notifications with a specific text for the object for which the business rule has been triggered, which are later going to be sent to the users that were indicated in the rule by the Notifications system. More specifically, the action creates a record in the Notifications table for each of the Users specified in Parameter1 (if there are more than one), whereUserId = the Id of the user in Parameter1 ValueSubject = Parameter2 ValueNotificationClass = Parameter3 Value, if emty - set a default value which is\"BR\" + \"_\" + \"UserBusinessRule.Code\" e.g. \"BR_0005\".DataObject = the Extensible Data Object of the Aggregate Root of the Entity for which the rule has been triggered. For more info, see Aggregates and Extensible Data Objects . If there are not explicitly created Notification Settings for the Class specified in Parameter3, the notification will only be sent as an in-app notification. IMPORTANT: The NOTIFYUSER action is not compatible with all Business rules - Events . For more info, see the Compatible Events Chart below. Parameter 1 - The user/users for which the notification is going to be created. We can set either the UserId or the User's login. If there are more than one recipients they can be entered in a comma-separated list, but the list must contain only UserIds (Id1,Id2,...IdN) or only User's logins (Login1,Login2,...LoginN). Parameter 1 Type Guid, String, List Parameter 2 - The text which is going to be displayed in the notification. Parameter 2 Type String // usually used in combination with the Formatted String parameter type. Parameter 3 (optional) - The Class which will be set for the notification. If the Parameter is not explicitly set will be used a default value. The default value is \"BR\" + \"_\" + \"UserBusinessRule.Code\" e.g. \"BR_0005\".For more information about Classes, see Notifications . Parameter 3 Type String Example see the Example section below Version Introduced in: 2020.1 Compatible Events Chart The NOTIFYUSER action is not compatible with all Business rules - Events . For more info look into the following chart. Event Type Compatibility with NOTIFYUSER Client Commit (e.g. CLIENTCOMMIT, AGGREGATECLIENTCOMMIT) compatible Document Events - (e.g. STATECHANGING, STATECHANGED, VOIDING) compatible Commit (e.g. COMMIT) not compatible// NOTIFYUSER will create a notification but it will not be displayed to the user in real time. The notification will be displayed at the next login into the program. Front-End (e.g ATTRIBUTECHANGING, ATTRIBUTECHANGED) not compatible// NOTIFYUSER will not create a notification. Example А Business rules that creates a notification for the Sales Person, when one of his Sales Orders has been released. Repository Crm.Sales.SalesOrders Events Event Type Event Parameter Execution Priority Change of State RELEASED Normal Actions Action No Action Type Parameter1 Type Parameter1 Value Parameter2 Type Parameter2 Value Parameter3 Type Parameter3 Value 1 NOTIFYUSER Attribute SalesPersonId Formatted String Sales Order {DocumentNo} has been released. Constant Sales_Person_SOReleased"
  },
  "advanced/business-rules/action-types/sendmail.html": {
    "href": "advanced/business-rules/action-types/sendmail.html",
    "title": "SENDMAIL | ERP.net Tech Docs",
    "keywords": "SENDMAIL Name SENDMAIL Description Used for sending notification emails using Business rules . The email can be sent to more than one recipients and the email's subject and body can be customized according to the particular business reason needs (for more info see the 'Subject and Body Customization' section below) . The address from which the emails are sent is the e-mail address that is set in the \"From e-mail address for system notifications\" field in the EnterpriseOne Application Server Settings. Note that the SENDMAIL action is performed asynchronously. I.e. it is performed every time when the Event happens (and the conditions are met) and it does not matter whether the event has finished successfully or not. This means that if we have a SENDMAIL Business rules that is triggered when we are saving a product, for example - an email will be sent every time when a product saving is initiated and even if during the saving is thrown an error, the email is going to be sent regardless that action has failed. IMPORTANT: The Sendmail action is not compatible with all Business rules - Events . For more info, see the Compatible Events Chart below. Parameter 1 [TO] - the email address/es to which the mail is going to be sent. If there are more than one recipients they can be entered in a comma-separated list (email1,email2...,emailN). Parameter 1 Type Constant, Attribute (the attribute's type must be String) Parameter 2 [SUBJECT] - The line with the subject of the email. Parameter 2 Type Constant, Attribute (the attribute's type must be String) Parameter 3 [BODY] - The content of the body of the email. Supports multi-line, for more info see the 'Subject and Body Customization' section below. Parameter 3 Type Constant, Attribute (the attribute's type must be String) Example see the end of the article Introduced In Version 2019.1 Note: Currently, the parameters of the business rules can include up to 256 symbols. Compatible Events Chart The SENDMAIL action is not compatible with all Business Rules - Events . For more info look into the following chart. Event Type Compatibility with SENDMAIL Client Commit (e.g. CLIENTCOMMIT, AGGREGATECLIENTCOMMIT) compatible Document Events - (e.g. STATECHANGING, STATECHANGED, VOIDING) compatible Commit (e.g. COMMIT) compatible but not recommended - if possible, use CLIENTCOMMIT instead Front-End (e.g ATTRIBUTECHANGING, ATTRIBUTECHANGED) not compatible, the server will not send an email Subject and Body Customization The text in the parameters for Subject and Body can be customized according to the specific needs. For added convenience, we've made a couple of implementations in order to provide more formatting capabilities and to facilitate the action as a whole. escape charts The following escape chars are handled: \\n - newline - supported in the Body \\r\\n - also new line - supported in the Body { - insert opening curly bracket '{' in output. - supported in both the Subject and the Body } - insert closing curly bracket '}' in output. - supported in both the Subject and the Body HTML tags - supported in the Body The body could be also formatted using HTML. In order for the text to be recognized as HTML, the body has to contain the tag . The place of the tag is irrelevant, if the tag is placed somewhere in the body's text it is considered that the whole text is written in HTML. use of Domain Attributes in text - supported in both the Subject and the Body In the text of both parameters for Subject and Body, we can now reach and use the domain attributes' values (system domain attributes and calculated attributes). They are calculated for the particular entity record for which the rule is executed. In order for the domain attribute to be property recognized by the system, it needs to be surrounded with curly brackets '{...}'. Currently are supported the following options: \\1. Attributes: {DocumentDate}. \\2. References: {Customer}. \\3. Reference path: {Customer.Party.PartyName}. Note that Child Collections are not supported. Domain Attributes formatting - supported in both the Subject and the Body The domain attribute values can be formatted with the standard .Net format specifiers and the system-specific attributes. For more information, see Format specifiers . Example А Business rules that sends an email with \"Order Confirmation\" to the customer and the Sales Manager when a Sales Order has been released. Repository Crm.Sales.SalesOrders Events Event Type Event Parameter Execution Priority Change of State RELEASED Normal Actions Action No Action Type Parameter1 Type Parameter1 Value Parameter2 Type Parameter2 Value Parameter3 Type Parameter3 Value 1 SENDMAIL Constant salesmanager@mail.com,customer@gmail.com Constant Order No{DocumentNo} has been confirmed Constant <p>Dear Customer,</p><p><b> Your order has been confirmed! </b></p><br/><p><h3>SUMMARY</h3></p><p>Order Number: <i>{DocumentNo}</i></p><p>Order Date: <i>{DocumentDate:dd-MM-yyyy}</i></p><p>Shipping Address: <i>{ShipToPartyContactMechanism. ContactMechanism.Name}</i></p><p>Delivery Date: <i>{RequiredDeliveryDate:dd-MM-yyyy}</i></p><p>Order Total: <i>{#CalculatedAttributeTotalSalesOrderAmount:C}</i></p><p>Payment Method: <i>{PaymentType.Name}</i></p><br/><p>Please expect your parcel to arrive on the delivery date stated above at the address or at the office of the courier company.</p><br/><p>Kind Regards,</p><strong>{SalesPerson.Person.FirstName} {SalesPerson.Person.LastName}<strong/></html> A representation of the email which is going to be received by the recipients: Subject: \"Order No00329 has been confirmed\" Body: \"Dear Customer, Your order has been confirmed! SUMMARY Order Number: 00329 Order Date: 10-05-2019 Shipping Address: 21 Lombard St Delivery Date: 12-05-2019 Order Total: $14.82 Payment Method: Cash on Delivery Please expect your parcel on the delivery date stated above at the address or at the office of the courier company. Kind Regards, John Smith \""
  },
  "advanced/business-rules/action-types/setvalue.html": {
    "href": "advanced/business-rules/action-types/setvalue.html",
    "title": "SETVALUE | ERP.net Tech Docs",
    "keywords": "SETVALUE The SETVALUE action is used to update information or data in the system implicitly. When all conditions of the business rules are met and the specified event has happened, then the SETVALUE action updates the value of the specified attribute available for the repository (including the custom properties for the particular entity). The SETVALUE action requires the following parameters: Parameter 1 - the value which is updated (set). Currently, the available parameter type is \"Attribute\". So, in Parameter 1 value the user enters the name of the attribute, which value has to be modified. Parameter 2 - the value which is set in Parameter 1. Currently, the available parameter types are \"Attribute\" and \"Constant\". If the parameter type is Attribute, in parameter value the name of the attribute is selected. The selected attribute value would be used to be set as value of parameter 1. If the parameter type is \"Constant\", then in parameter value a constant value has to be entered and every time the user business rule is execute, the parameter 1 attribute would be set to the constant value. The format of the different type of constants is described here: Parameter Type CONST . Example: Repository Crm.Sales.SalesOrders Events Event Type Event Parameter Execution Priority Change of State RELEASING Normal Actions Action No Action Type Parameter1 Type Parameter1 Value Parameter2 Type Parameter2 Value 1 SETVALUE Attribute Notes Constant 'Approved'"
  },
  "advanced/business-rules/action-types/warning.html": {
    "href": "advanced/business-rules/action-types/warning.html",
    "title": "WARNING | ERP.net Tech Docs",
    "keywords": "WARNING Usually used to show a non-blocking message, that helps users in certain situation. It may be useful when we just want to show a reminder, instead of stopping the transaction with an error using a FAIL business rule. The WARNING syntax is simple - the message that is going to be shown is set as a first parameter of the WARNING action. * Example:* ActionNo: 1 ; Action Type: WARNING; Parameter1 Type: Constant ; Parameter1 Value: 'warning message text' ."
  },
  "advanced/business-rules/events/index.html": {
    "href": "advanced/business-rules/events/index.html",
    "title": "Events | ERP.net Tech Docs",
    "keywords": "Events"
  },
  "advanced/business-rules/examples/index.html": {
    "href": "advanced/business-rules/examples/index.html",
    "title": "Examples | ERP.net Tech Docs",
    "keywords": "Examples"
  },
  "advanced/business-rules/index.html": {
    "href": "advanced/business-rules/index.html",
    "title": "User business rules | ERP.net Tech Docs",
    "keywords": "User business rules User Business Rules are business rules which the user defines on his own. They may be used to provide some kind of validation which is not available in the system business rules or to create working logic which is not currently available in the software. They may be registered on different layers - BackEnd and/or FrontEnd. The BackEnd means that the user business rule is processed on the server. A FrontEnd user business rule is processed in the client application. The user business rule consist of the following information: \"where?\" \"when?\" and on \"what conditions?\" something (\"what?\") should happen. The user business rules have the following information: Code - unique code of the rule; Name - the name of the user business rule; Repository Name - the name of the repository for which the business rule is defined. For example - Invoices or Invoice Lines. Its value may be selected from a dropdown list and the value contains the path to the selected value, dot separated. For example: if the user needs to create user business rule so he can use it in the Invoices forms or in the Invoices navigators, the Repository should be \"Crm.Invoicing.Invoices\". If the rule is created to be used in the invoice lines, then the Repository should be \"Crm.Invoicing.InvoiceLines\"; Notes - notes, comments, short information on the user business rules usage, purpose and more; IsActive - the user business rule may be activated and deactivated; Layer - currently this is unavailable. All user business rules are registered in the BackEnd layer. The events which has to happen so the user business rule to be activated are described in the User Business Rules - Events panel. It is consisted of the following information: Event Type - the event for which to register the user business rule; Event Parameter - registration parameter. The meaning of this parameter is determined by the type of the event. For more information on event parameters see Business rules - Events ; Execution Priority - execution priority. Lowes values indicate earlier priorities. Possible values are: 30-Early, 50-Normal; 70-Late; Layer - currently this is unavailable. All events are events of the BackEnd layer. The conditions which have to be met when the event happen so the rule to be processed are entered as follows: Condition No - consecutive number of the condition, unique within the user business rule. Attribute Name - the name of the attribute which will be validated in the condition. Comparison Type - what is the comparison type. The available options are: =, !=, >=, <=, Like, IsNull, Value - the constant value to which the value of attribute (specified in the Attribute Name) is compared to. So the condition is met when the value of the specified attribute and the specified value compose a true statement with the selected comparison type. For example, IsActive = True or Quantity < 100.0 and more. Note If there are more than one conditions, the rule would be applied when all conditions are true. The actions which may be executed by the rule contain the following information: Action No - consecutive number of the action, unique within the user business rule; Action Type - specifies the type of action to be performed by the rule. Possible values are: SETVALUE and FAIL. For more information on the action types see Business rules Actions - Action types ; Parameter1 Type, Parameter2 Type, Parameter3 Type - the type of the parameter specifies how to obtain the parameter value; Parameter1 Value, Parameter2 Value, Parameter3 Value - the actual value of the parameter."
  },
  "advanced/business-rules/parameter-types/index.html": {
    "href": "advanced/business-rules/parameter-types/index.html",
    "title": "Parameter types | ERP.net Tech Docs",
    "keywords": "Parameter types"
  },
  "advanced/business-rules/QA/index.html": {
    "href": "advanced/business-rules/QA/index.html",
    "title": "Q & A | ERP.net Tech Docs",
    "keywords": "Q & A"
  },
  "advanced/calculated-attributes/examples/calculate-standartpriceperlot.html": {
    "href": "advanced/calculated-attributes/examples/calculate-standartpriceperlot.html",
    "title": "Calculate standart price per lot based on the ingredients and the operations in the recipe | ERP.net Tech Docs",
    "keywords": "Calculate standart price per lot based on the ingredients and the operations in the recipe With this attribute, we can calculate the StandartPricePerLot that is going to be automatically set in the product’s definition we save the recipe. The StandartPricePerLot is determined by the prices of the ingredients and the operations used in the particular recipe. After that, we can use this attribute in a Business rule which to fill in the PricePerLotValue of the product in the recipe. 10: ADD EXP:20 EXP:25 20: SUM CHILD:Ingredients ATTRIB:PriceValue 25: SUM CHILD:Operations EXP:30 30: MULTIPLY EXP:40 EXP:45 40: DIVIDE ATTRIB:StandardPricePerHourValue CONST:60.00 45: CAST EXP:50 CONST:System.Decimal 50: ADD ATTRIB:RunTimeMinutes EXP:60 60: ADD ATTRIB:WaitTimeMinutes EXP:70 70: ADD ATTRIB:SetupTimeMinutes ATTRIB:MoveTimeMinutes Explanation: 10: Add the value of EXP:20 to the value of EXP:25. 20: Sum all recipe's ingredients PriceValues. 25: Sum EXP:30 for all of the recipe's operations. 30: Multiply the value of EXP:40 and EXP:45. 40: Divide the StandardPricePerHourValue by 60.00 to get the StandardPrice per minute. 45: Cast EXP:50 to decimal. 50: Add the values of RunTimeMinutes to EXP:60 => EXP:70 to get the full execution time of the operation."
  },
  "advanced/calculated-attributes/examples/check-for-first-releasing.html": {
    "href": "advanced/calculated-attributes/examples/check-for-first-releasing.html",
    "title": "Check whether the releasing of the document is first or not | ERP.net Tech Docs",
    "keywords": "Check whether the releasing of the document is first or not Sometimes we may want to know whether the Released state of document is selected for a first time or not (i.e. if the event is First Releasing). For examples a business case may require a certain business rule to be executed only when first releasing the document. The calculated attributes are a tool which when triggered perform their calculation in real time. This means that if we use a calculated attribute as a condition for a business rule, the condition may be fulfilled today, but not tomorrow and if we reselect the document state it may trigger actions that are no longer needed for this record ( for more information see How to start a Business Rule only on First Releasing? ). To avoid such occurrence, we can use a calculated attribute to define whether the releasing of the document is first or not. 10: IIF EXP:20 CONST:false CONST:true 20: EQUAL EXP:30 CONST:30 30: CAST ATTRIB:State CONST:System.Int32 Explanation: 10: Check if EXP:20 is true or false. If EXP:20 is True - the calculated attribute displays 'True', else - 'False'. 20: Check if EXP:20 is equal to \"30\". 30: Cast the State of the document to integer. State Released is stored as \"30\", for more information see DocumentState Enumeration ."
  },
  "advanced/calculated-attributes/examples/check-if-field-is-changed-in-adjustment.html": {
    "href": "advanced/calculated-attributes/examples/check-if-field-is-changed-in-adjustment.html",
    "title": "Check if a value of a field is changed in the adjustment document | ERP.net Tech Docs",
    "keywords": "Check if a value of a field is changed in the adjustment document With the current attribute, we can check if the value of a field in the adjustment document is equal to the value of the same filed in the original (adjusted) document. When we have such information, we can determine if the value of this filed is being or has been changed in the adjustment document. Using this attribute, we can for example, create a Business rule which would allow us to prohibit the correction of the value of this field. 10: IIF EXP:20 CONST:False EXP:30 20: EQUAL REF:AdjustedDocument CONST:NULL 30: IIF EXP:40 CONST:False CONST:True 40: EQUAL ATTRIB:@Property1 EXP:50 50: GETOBJVALUE REF:AdjustedDocument ATTRIB:@Property1 Explanation: 10: Check if EXP:20 is true or false. If EXP:20 is True - the calculated attribute displays 'True', else - 'False'. 20: Check if there is AdjustedDocument. If there is no reference to an Adjusted document, then the document is not an Adjustment document. 30: Check if EXP:40 is true or false. 40: Check if the value of the custom property 'Property1' is equal to EXP:50. 50: Get the value of the 'Property1' of the adjusted document."
  },
  "advanced/calculated-attributes/examples/check-if-quantity-is-whole-number.html": {
    "href": "advanced/calculated-attributes/examples/check-if-quantity-is-whole-number.html",
    "title": "Check if the quantity is a whole number | ERP.net Tech Docs",
    "keywords": "Check if the quantity is a whole number The current calculated attribute returns true if the quantity in the Sales Order line is whole number, and False - if it is decimal number. The repository of the attribute is Crm.Sales.SalesOrders. It expressions are as follows: 10: IIF EXP:20 CONST:True CONST:False 20: EQUAL ATTRIB:QuantityValue EXP:30 30: CEILING ATTRIB:QuantityValue Explanation: 10: check if expression 20 is true. If so - return True, else - return False 20: check if attribute QuantityValue is equal to expression 30 30: get the smallest integral value greater than or equal to the value in attribute QuantityValue"
  },
  "advanced/calculated-attributes/examples/check-if-system-type-is-in-cash.html": {
    "href": "advanced/calculated-attributes/examples/check-if-system-type-is-in-cash.html",
    "title": "Check if the system type of payment type in the sales order is 'In Cash' | ERP.net Tech Docs",
    "keywords": "Check if the system type of payment type in the sales order is 'In Cash' With this attribute we can check if the System Type of Payment type which is set in the Sales Order is 'In Cash'. When we have that information we can, for example, use the attribute to create a Business Rule (for more information, see @Allow a Credit Limit Override When the Client Pays in Cash) that allows a Credit Limit Override when the Client pays in cash. 10: IIF EXP:20 CONST:True CONST:False 20: EQUAL EXP:25 EXP:30 25: CAST CONST:0 CONST:System.Nullable`1[Aloe.EnterpriseOne.Model.Finance.Payments.PaymentTypesRepository+SystemType] 30: GETOBJVALUE REF:PaymentType ATTRIB:SystemType Explanation: 10: Return True of False according to the result of EXP:20 20: Check if EXP:25 is equal to EXP:30 25: Converts '0' to type System.Nullable`1[Aloe.EnterpriseOne.Model.Finance.Payments.PaymentTypesRepository+SystemType] using CAST 30: Get the System Type of the Payment Type which is set in the Sales Order. Note When using EQUAL we should make sure that we are comparing Parameters from the same type. If we don’t know which is the type of the particular object or what is the value that it is going to return we can use the Aloe.EnterpriseOne.Model Documentation . In the particular example we can check PaymentTypesRepository.SystemType Enumeration , where we can see that the value that corresponds to the System Type in 'Cash' is '0'."
  },
  "advanced/calculated-attributes/examples/check-if-user-has-authorization.html": {
    "href": "advanced/calculated-attributes/examples/check-if-user-has-authorization.html",
    "title": "Check if the current user has authorization | ERP.net Tech Docs",
    "keywords": "Check if the current user has authorization If we want to determine if the user that is currently logged in the system is authorized (to do, see, or edit an entity, for example) we need to know which Group have such rights. When we have that information, we can simply create a calculated attribute that checks if the User is a part of this Group: 10: IIF EXP:20 CONST:True CONST:False 20: GTE EXP:30 CONST:1 30: SUM EXP:40 CONST:1 40: SELECT REPO:Systems.Security.UserGroups EXP:50 50: WHERE EXP:60 EXP:80 60: EQUAL ATTRIB:UserId EXP:70 70: GETOBJVALUE INPUT:10 SYS:UserId 80: EQUAL ATTRIB:GroupId CONST:5daf849d-9986-462f-9171-a23c1c5839b7 Explanation: 10: Check if EXP:20 is true or false. If EXP:20 is True - the calculated attribute displays the 'True' message, else - 'False'. 20: Check if the list EXP:30 returns at least one record. 30: Return the count of records in the filtered list of EXP:40. 40: Select 'User Groups' filtered by EXP:50. 50: The Filters are expression 60, expression 80... 60: Check if the UserId is equal to EXP:70. 70: Get the Id of the user that is currently editing the entity. 80: Check if the GroupId is equal to the Id of an authorized group."
  },
  "advanced/calculated-attributes/examples/compare-unit-and-standard-unit-price.html": {
    "href": "advanced/calculated-attributes/examples/compare-unit-and-standard-unit-price.html",
    "title": "Compare unit price and standard unit price | ERP.net Tech Docs",
    "keywords": "Compare unit price and standard unit price The following calculated attribute calculates if the Unit Price in the Sales Order Lines is greater than the Standard Unit Price of the product and returns a message: 10: IIF EXP:20 CONST:'OK!' CONST:'Not OK!' 20: GT ATTRIB:UnitPriceValue ATTRIB:StandardUnitPriceValue Explanation: 10: Checks if EXP:20 is true or false. If EXP:20 is True - the calculated attribute displays the 'OK!' message, else - 'Not OK!'. 20: Checks if ATTRIB:UnitPriceValue is greater than ATTRIB: StandardUnitPriceValue. If so - returns True, else - False. The same validation may be achieved by using other operator: 10: IIF EXP:20 CONST:'Not OK!' CONST:'OK!' 20: LTE ATTRIB:UnitPriceValue ATTRIB:StandardUnitPriceValue Explanation: 10: Checks if EXP:20 is true or false. If EXP:20 is True - the calculated attribute displays the 'Not OK!' message, else - 'OK!'. 20: Checks if ATTRIB:UnitPriceValue is less than or equal to ATTRIB:StandardUnitPriceValue. If so - returns True, else - False."
  },
  "advanced/calculated-attributes/examples/convert-property-to-number.html": {
    "href": "advanced/calculated-attributes/examples/convert-property-to-number.html",
    "title": "Convert a value of a custom property to a number | ERP.net Tech Docs",
    "keywords": "Convert a value of a custom property to a number The values of the custom properties are a specific type of value and the CONVERT operator does not know how to handle it properly. For this reason, if we want to covert a custom property's value to a number, we have to CAST it first. Example - Multiply standard price per lot by a coefficient stored in a property Lets say, for example, we want to multiply the standard price per lot of the product by a coefficient stored as a product's custom property @CustomProperty1. Note The repository of the attributes is General.Products.Products RIGHT calculated attribute: 10: MULTIPLY ATTRIB:StandardPricePerLotValue EXP:20 20: CONVERT EXP:30 CONST:System.Decimal 30: CAST ATTRIB:@CustomProperty1 CONST:System.String Explanation: 10: Multiply the value of the 'Standard Price Per Lot' by EXP: 20. 20: Convert EXP:30 to a decimal number. 25: Cast the value of custom property 'CustomProperty1' to a string. WRONG calculated attribute: 10: MULTIPLY ATTRIB:StandardPricePerLotValue EXP:20 20: CONVERT ATTRIB:@CustomProperty1 CONST:System.Decimal Explanation: 10: Multiply the value of the 'Standard Price Per Lot' by EXP: 20. 20: Convert the value of custom property 'CustomProperty1' to a decimal number. Note When we want to convert CustomPropertyValue to numeric value (for example Decimal), we need to CAST it to a string first!"
  },
  "advanced/calculated-attributes/examples/day-from-document-date.html": {
    "href": "advanced/calculated-attributes/examples/day-from-document-date.html",
    "title": "Specific day from document date | ERP.net Tech Docs",
    "keywords": "Specific day from document date A Calculated Attribute is added with the following parameters: Repository Name:Crm.Sales.SalesOrders Name:TenDaysFromDocumentDay And the Calculated Attribute expressions are as follows: 10: ADDDAYS ATTRIB:DocumentDate CONST:10 Explanation: 10: Add 10 days to the date in DocumentDate If showed in the Sales Order form, this attribute calculates and displays 10 days added to the DocumentDate."
  },
  "advanced/calculated-attributes/examples/format-property-date.html": {
    "href": "advanced/calculated-attributes/examples/format-property-date.html",
    "title": "Format date type custom property | ERP.net Tech Docs",
    "keywords": "Format date type custom property The current example shows how you can format the values of date type custom properties using a calculated attribute 10: FORMATSTRING EXP:20 CONST:yyyy MM dddd 20: CONVERT EXP:30 CONST:System.DateTime 30: CONCAT EXP:40 EXP:50 40: SUBSTRING EXP:100 CONST:0 CONST:4 50: CONCAT CONST:- EXP:60 60: CONCAT EXP:70 EXP:80 70: SUBSTRING EXP:100 CONST:4 CONST:2 80: CONCAT CONST:- EXP:90 90: SUBSTRING EXP:100 CONST:6 CONST:2 100: FORMATSTRING ATTRIB:@Property1 CONST:V Explanation: // We assume that the value of the custom poperty is 20200315 10: Format the date returned from EXP:20 applyig the date format type 'yyyy MM dddd' e.g. '2020 03 Sunday'. 20: Convert the type of the value returned from EXP:30 to DateTime 30: Concatenate the text from EXP:40 to the text from EXP:50 e.g. '2021' + '-03-15' 40: Get the first 4 characters from EXP:100 e.g. '2021' 50: Concatenate the character '-' to the text from EXP:60 e.g. '-' + '03-15' 60: Concatenate the text from EXP:70 to the text from EXP:80 e.g. '09' + '-15' 70: Get the first 2 characters from the string from EXP:100, starting from character 4 e.g. '03' 80: Concatenate the character '-' to the text from EXP:90 e.g. '-' + '15' 90: Get the first 2 characters from the string from EXP:100, starting from character 6 e.g. '15' 100: Get the value of custom property \"Property1\" e.g. '20200315'"
  },
  "advanced/calculated-attributes/examples/get-atp.html": {
    "href": "advanced/calculated-attributes/examples/get-atp.html",
    "title": "Get available to promise (ATP) quantity | ERP.net Tech Docs",
    "keywords": "Get available to promise (ATP) quantity This example shows how you can create a calculated attribute which gets the avaible to promise (ATP) quantity on a particular date using the AvailableToPromise View . In the example we are showing how get the ATP quantity in a shipment order line on its Required Delivery Date. Note The repository of the attributes is Logistics.Shipment.ShipmentOrderLines 10 GETOBJVALUE EXP:20 ATTRIB:ATPBaseValue 20 FIRST EXP:30 30 SORT EXP:40 ATTRIB:FromDate CONST:DESC 40 SELECT REPO:Logistics.Inventory.DemandManagement.AvailableToPromise EXP:50 50 WHERE EXP:80 EXP:60 60 AND EXP:110 EXP:70 70 AND EXP:140 EXP:170 80 EQUAL ATTRIB:ProductId EXP:90 90 GETOBJVALUE INPUT:10 EXP:100 100 GETOBJVALUE REF:ParentSalesOrderLine ATTRIB:ProductId 110 EQUAL ATTRIB:StoreId EXP:120 120 GETOBJVALUE INPUT:10 EXP:130 130 GETOBJVALUE REF:ParentSalesOrderLine ATTRIB:LineStoreId 140 EQUAL ATTRIB:EnterpriseCompanyId EXP:150 150 GETOBJVALUE INPUT:10 EXP:160 160 GETOBJVALUE REF:ShipmentOrder ATTRIB:EnterpriseCompanyId 170 LTE ATTRIB:FromDate EXP:180 180 GETOBJVALUE INPUT:10 EXP:190 190 GETOBJVALUE REF:ShipmentOrder ATTRIB:RequiredDeliveryDate Explanation: 10: Get the \"ATPBaseValue\" of the AvailableToPromise record returned by EXP:20 20: Get the first record of the list returned by EXP:30 30: Sort the list returned by EXP:40 - descending by the value of the \"FromDate\" attribute 40: Select the AvailableToPromise records which are matching the clauses of EXP:50 50: Filter the the records for which EXP:80 and EXP:60 are True 60: Filter the the records for which EXP:110 and EXP:70 are True 70: Filter the the records for which EXP:140 and EXP:170 are True 80: Return True if the ProductId of the AvailableToPromise record is equal to EXP:90 90: Get EXP:100 from the repository of EXP:10 i.e. of the current Shipment Order Line 100: Get the ProductId of the ParentSalesOrderLine 110: Return True if the StoreId of the AvailableToPromise record is equal to EXP:120 120: Get EXP:130 from the repository of EXP:10 i.e. of the current Shipment Order Line 130: Get the LineStoreId of ParentSalesOrderLine 140: Return True if the EnterpriseCompanyId of the AvailableToPromise record is equal to EXP:150 150: Get EXP:160 from the repository of EXP:10 i.e. of the current Shipment Order Line 160: Get the EnterpriseCompanyId of the ShipmentOrder 170: Return True if the FromDate of the AvailableToPromise record lower or equal to EXP:180 180: Get EXP:160 from the repository of EXP:10 i.e. of the current Shipment Order Line 160: Get the RequiredDeliveryDate of the ShipmentOrder"
  },
  "advanced/calculated-attributes/examples/get-current-availability-of-product.html": {
    "href": "advanced/calculated-attributes/examples/get-current-availability-of-product.html",
    "title": "Get current availability of a product | ERP.net Tech Docs",
    "keywords": "Get current availability of a product This example shows how to create a calculated attribute which returns the sum of the currently available Quantity Base of a particular product. In the example below are applied filters by Product, Store, Store Bin, Lot and Serial Number, because of the specification of the repository of the calculation attribute. Other filters, such as Product Variant and Enterprise Company could be also added if needed. The example is created for Consumption Order Lines, but such attribute could be created for other documents or definitions as well. Repository Name: Production.ShopFloor.ConsumptionOrderLines 10: SUM EXP:20 ATTRIB:QuantityBaseValue 20: FILTER EXP:30 EXP:70 30: SELECT REPO:Logistics.Inventory.CurrentBalances EXP:40 40: WHERE EXP:50 50: EQUAL ATTRIB:ProductId EXP:60 60: GETOBJVALUE INPUT:10 ATTRIB:ProductId 70: AND EXP:100 EXP:80 80: AND EXP:130 EXP:90 90: AND EXP:150 EXP:170 100: EQUAL ATTRIB:StoreId EXP:110 110: CAST EXP:120 CONST:System.Guid 120: GETOBJVALUE INPUT:10 ATTRIB:StoreId 130: EQUAL ATTRIB:StoreBinId EXP:140 140: GETOBJVALUE INPUT:10 ATTRIB:StoreBinId 150: EQUAL ATTRIB:LotId EXP:160 160: GETOBJVALUE INPUT:10 ATTRIB:LotId 170: EQUAL ATTRIB:SerialNumberId EXP:180 180: GETOBJVALUE INPUT:10 ATTRIB:SerialNumberId Explanation: 10: Sum Quantity Base from the filtered list returned by EXP:20 20: Filter the list from EXP:30 by the clauses of EXP:70 30: Select repository \"Logistics.Inventory.CurrentBalances\" and filter by the clauses in EXP:40 40: Filter the list above by the records WHERE/in which the clauses in EXP:50 are True 50: Check whether ATTRIB:ProductId is equal to EXP:60 60: Get ATTRIB:ProductId from the repository of EXP:10 70: EXP:100 and EXP:80 80: EXP:130 and EXP:90 90: EXP:150 and EXP:170 100: Check whether ATTRIB:StoreId is EQUAL to EXP:110 110: CAST EXP:120 to System.Guid 120: Get ATTRIB:StoreId from the repository of EXP:10 130: Check whether ATTRIB:StoreBinId is EQUAL to EXP:140 140: Get ATTRIB:StoreBinId from the repository of EXP:10 150: Check whether ATTRIB:LotId is EQUAL to EXP:160 160: Get ATTRIB:LotId from the repository of EXP:10 170: Check whether ATTRIB:SerialNumberId is EQUAL to EXP:180 180: Get ATTRIB:SerialNumberId from the repository of EXP:10"
  },
  "advanced/calculated-attributes/examples/get-custom-property-from-parent-offer-line.html": {
    "href": "advanced/calculated-attributes/examples/get-custom-property-from-parent-offer-line.html",
    "title": "Get a value of a custom property in sales order lines from the parent offer line | ERP.net Tech Docs",
    "keywords": "Get a value of a custom property in sales order lines from the parent offer line With this attribute we can for example, determine what is the value of a particular customer property which is set for the parent offer line of the current sales order line. Currently, offer lines customer properties are not automatically transferred to the sales order. Thus, we can use this attribute in a User Business Rule to automate the process. For more information how to create a such User Business Rule , see topic ' How to Use Business Rules to Set a Value into a Custom Property? '. Repository: Crm.Sales.SalesOrderLines 10: GETOBJVALUE EXP:20 ATTRIB:@Propery1 20: FIRST EXP:30 30: FILTER EXP:70 EXP:40 40: EQUAL ATTRIB:LineNo EXP:50 50: CAST EXP:60 CONST:System.Int32 60: GETOBJVALUE INPUT:10 ATTRIB:ParentLineNo 70: GETOBJVALUE EXP: 80 CHILD:Lines 80: CAST REF:ParentDocument CONST:Aloe.EnterpriseOne.Model.Crm.Presales.Offer Explanation: 10: Get the record of custom property \"Propery1\" from EXP:20. 20: Get the first value of EXP:30. 30: Filter the list from EXP:70 with the filters from EXP:40. 40: Check in the LineNumber of the offer line is equal to the value from EXP:50. 50: Cast EXP:60 to \"System.Int32\". 60: Get the ”ParentLineNo“ of the sales order line which is an input for EXP:10. 70: Get the list of child line of the object of EXP:80. 80: Cast the “Parent Document” of the sales order line to \"Aloe.EnterpriseOne.Model.Crm.Presales.Offer\" in order to define the type/entity of the parent document."
  },
  "advanced/calculated-attributes/examples/get-value-and-description-of-referent-object.html": {
    "href": "advanced/calculated-attributes/examples/get-value-and-description-of-referent-object.html",
    "title": "Get value and description of referent object | ERP.net Tech Docs",
    "keywords": "Get value and description of referent object At first - some additional information - when a value is set to a custom property of an object, a new record is added to the \"General.PropertyValue\" repository. The new record has its own Id, and the id of the specific object - EntityItemId. So in a calculated attribute we need to filter the value which are for the specific property (PropertyId) of the specific object (EntityItemId) and then get the value or description. Let's see an example: The current example shows how the get the description of a property of the customer and show it in the Offer form. Such calculated attribute would have the following parameters: Repository Name:Crm.Presales.Offers And the Calculated Attribute expressions are as follows: 10: GETOBJVALUE EXP:20 ATTRIB:Description 20: FIRST EXP:30 30: SELECT REPO:General.PropertyValues EXP:40 40: WHERE EXP:50 50: AND EXP:60 EXP:70 60: EQUAL ATTRIB:PropertyId CONST:e7005814-6140-4708-a9d8-aaaeb5b151ed 70: EQUAL ATTRIB:EntityItemId EXP:80 80: GETOBJVALUE INPUT:10 ATTRIB:CustomerId Explanation: 10: get the attribute Description of the object in expression 20 20: get the first record in the list from expression 30 30: select repository \"General.PropertyValues\" filtered by expression 40 40: the filter is expression 50 50: expression 60 AND expression 70 60: check if the attribute PropertyId is equal to the constant of \"e7005814-6140-4708-a9d8-aaaeb5b151ed\" (this is a Guid) 70: check if the attribute EntityItemId is equal to expression 80 80: get the attribute CustomerId of the input object of expression 10 If we need the value of the property, the first expression may be set to GETOBJVALUE EXP:20 ATTRIB:PropertyValueField."
  },
  "advanced/calculated-attributes/examples/index.html": {
    "href": "advanced/calculated-attributes/examples/index.html",
    "title": "Examples | ERP.net Tech Docs",
    "keywords": "Examples Calculate standart price per lot based on the ingredients and the operations in the recipe Check if a value of a field is changed in the adjustment document Check if the current user has authorization Check if the quantity is a whole number Check if the system type of payment type in the sales order is 'In Cash' Check whether the releasing of the document is first or not Compare unit price and standard unit price Convert a value of a custom property to a number Format date type custom property Get a value of a custom property in sales order lines from the parent offer line Get available to promise (ATP) quantity Get current availability of a product Get value and description of referent object Sales amounts of the customer for the last 30 days Specific day from document date Total quantity and scrap quantity in recipe ingredients"
  },
  "advanced/calculated-attributes/examples/sales-amounts-last-30-days.html": {
    "href": "advanced/calculated-attributes/examples/sales-amounts-last-30-days.html",
    "title": "Sales amounts of the customer for the last 30 days | ERP.net Tech Docs",
    "keywords": "Sales amounts of the customer for the last 30 days Let's say the user want to show a field in the Sales Order which calculates the sales amounts of the selected customer for the last 30 days. Such calculated attribute actually represents a report with specific filters. If a user tries to get the sales of a client for the last 30 days, he would open Sales Order Lines report and set the following filters: Client Enterprise Company Enterprise Company Location (eventually) DocumentState (at least Released) Void (he probably won't need voided documents) Document Date So the calculated attribute must SELECT the Sales Order Lines table and filter the records as described above. Such calculated attribute would have the following parameters: Repository Name:Crm.Sales.SalesOrders Name:SOAmountsForTheLast30days And the Calculated Attribute expressions are as follows: 10: SUM EXP:20 ATTRIB:LineAmountValue 20: SELECT REPO:Crm.Sales.SalesOrderLines EXP:30 30: WHERE EXP:40 EXP:90 40: AND EXP:50 EXP:70 50: EQUAL EXP:60 CONST:30 60: CAST EXP:61 CONST:System.Int32 61: GETOBJVALUE REF:Document ATTRIB:State 70: EQUAL EXP:80 CONST:False 80: GETOBJVALUE REF:Document ATTRIB:Void 90: AND EXP:100 EXP:130 100: AND EXP:101 EXP:160 101: EQUAL EXP:110 EXP:120 110: GETOBJVALUE REF:SalesOrder ATTRIB:CustomerId 120: GETOBJVALUE INPUT:10 ATTRIB:CustomerId 130: GTE EXP:140 EXP:150 140: GETOBJVALUE REF:SalesOrder ATTRIB:DocumentDate 150: ADDDAYS EXP:151 CONST:-30 151: GETOBJVALUE INPUT:10 ATTRIB:DocumentDate 160: EQUAL EXP:170 EXP:180 170: GETOBJVALUE REF:SalesOrder ATTRIB:EnterpriseCompanyId 180: GETOBJVALUE INPUT:10 ATTRIB:EnterpriseCompanyId Explanation: 10: Sum all records from expression 20 by their attribute LineAmountValue 20: Select 'Sales Order Lines' filtered by expression 30 30: the filter is expression 40 AND expression 50 40: expression 50 AND expression 70 50: check if expression 60 is equal to expression 30 60: cast expression 61 to \"System.Int32\" (this is integer) 61: get the value of attribute State of the referent object Document 70: check if expression 80 is equal to \"False\" 80: get the value of attribute Void of the referent object Document 90: expression 100 AND expression 130 100: expression 101 AND expression 160 101: check if expression 110 is equal to expression 120 110: get the value of attribute CustomerId of the referent object SalesOrder 120:get the value of attribute CustomerId of the input object of expression 10 130: check if expression 140 is greater than or equal to expression 150 140: get the value of attribute DocumentDate of the referent object SalesOrder 150: add to expression 151 the value of \"-30\" 151: get the value of attribute DocumentDate of the input object of expression 10 160: check if expression 170 is equal to expression 180 170: get the value of attribute EnterpriseCompanyId of the referent object SalesOrder 180: get the value of attribute EnterpriseCompanyId of the input object of expression 10"
  },
  "advanced/calculated-attributes/examples/total-quantity-and-scrap-in-recipe-ingredients.html": {
    "href": "advanced/calculated-attributes/examples/total-quantity-and-scrap-in-recipe-ingredients.html",
    "title": "Total quantity and scrap quantity in recipe ingredients | ERP.net Tech Docs",
    "keywords": "Total quantity and scrap quantity in recipe ingredients If the user wants to see what is the total Quantity of the material in a Recipe which would include the Used Quantity and the Scrap Rate, he would add the following Calculated Attribute: Repository Name:Production.Technologies.RecipeIngredients Name:TotalUsedQuantity And the Calculated Attribute expressions are as follows: 10: ADD ATTRIB:UsageQuantityValue EXP:20 20: MULTIPLY ATTRIB:UsageQuantityValue ATTRIB:ScrapRate Explanation: 10: Add the result from expression 20 to the attribute UsageQuantityValue 20: Multiply UsageQuantityValue and ScrapRate"
  },
  "advanced/calculated-attributes/index.html": {
    "href": "advanced/calculated-attributes/index.html",
    "title": "User Calculated Attributes | ERP.net Tech Docs",
    "keywords": "User Calculated Attributes User Calculated Attributes are user-defined objects, which extend the system entities. Calculated attributes are defined like formulas. When the value of a calculated attribute is requested, it is calculated \"on the fly\", in real time. Note Calculated attribute formulas are compiled to native executable format. Their calculation speed is very similar to the speed of the system defined calculated attributes. Example - Get default payment term days Suppose, that in a Sales Order, we want to display the customers default payment term (in days). In the Sales Order, we can define the following Calculated Attribute: No Operation Param1 Param2 Param3 10 GETREF REF:Customer ATTRIB:DefaultPaymentTermDays Explanation: GETREF - gets information from a related entity. The related entity is specified in Param1. The desired information is specified in Param2. Line number 10 is the only line in the calculated attribute The return value is the value of the attribute DefaultPaymentTermDays in the Customer entity. Example - Complex filter and summation The following calculated attribute sums all sales order lines, whose product: has a user data attribute, called \"CustPropPrj\", equal to '500' has a Name, containing the word 'Tool' No Operation Param1 Param2 Param3 10 SUM EXP:20 ATTRIB:LineAmount 20 FILTER CHILD:Lines EXP:30 30 IN ATTRIB:Product EXP:40 40 FILTER QUERY:Gen_Products EXP:50 50 AND EXP:60 EXP:70 60 EQUALS ATTRIB:CustPropPrj CONST:500 70 LIKE ATTRIB:Name CONST:'Tool' Explanation: Line 10: Iterates through the data set, specified on Line 20 (EXP:20), then SUMs the attribute LineAmount. Line 20: Filters the Lines subset with the filter, specified in Line 30 (EXP:30). Line 30: Creates a filter, which will be satisfied only by products, specified in the query on Line 40 (EXP:40). Line 40: Creates a query, which filters the products with the condition, specified on Line 50. Line 50: Specifies that the condition is comprised of two conditions, linked with AND. Line 60: Specifies that the first condition is the value of an attribute, called CustPropPrj should be 500. Line 70: Specifies that the second condition is that the Name of the product should contain 'Tool'. This example demonstrates, that Calculated Attributes can calculate very complicated formulas, query the database, get related values, etc."
  },
  "advanced/calculated-attributes/operators/add.html": {
    "href": "advanced/calculated-attributes/operators/add.html",
    "title": "ADD - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "ADD - Calculated Attribute Operator Specification Value Name ADD Description The operator returns the sum (total) of two numbers. Parameter 1 Name Number1 Parameter 1 Type numeric type - int, double or decimal Parameter 2 Name Number2 Parameter 2 Type numeric type - int, double or decimal Parameter 3 Name Parameter 3 Type Return Value Number1 + Number2 Note Ensure that the numbers which are summed up are from the the same type. For example, Parameter 1 and Parameter 2 must be both integers, doubles, or decimals. Example The following example adds '0.25' to the the value of the Quantity field in Sales Order Lines and returns the sum of the two numbers. 10: ADD ATTRIB:QuantityValue CONST:0.25 OUTPUT: If 'QuantityValue = 1', the output will be '1.25'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More Examples Total quantity and scrap quantity in recipe ingredients"
  },
  "advanced/calculated-attributes/operators/adddays.html": {
    "href": "advanced/calculated-attributes/operators/adddays.html",
    "title": "ADDDAYS - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "ADDDAYS - Calculated Attribute Operator Specification Value Name ADDDAYS Description Adds the specified number of days to the date. Parameter 1 Name Date Parameter 1 Type Date Parameter 2 Name NumDays Parameter 2 Type int Parameter 3 Name Parameter 3 Type Return Value Date + NumDays Example 10: ADDDAYS ATTRIB:DocumentDate CONST:5 OUTPUT: If 'DocumentDate = 2000-01-20', the output will be '2000-01-25'. Note The repository of the attribute is Crm.Sales.SalesOrders"
  },
  "advanced/calculated-attributes/operators/and.html": {
    "href": "advanced/calculated-attributes/operators/and.html",
    "title": "AND - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "AND - Calculated Attribute Operator Specification Value Name AND Description Checks if the two conditions are True. If so - the operator returns True. If any of the specified conditions are not True, the operator returns False. Parameter 1 Name Condition1 Parameter 1 Type boolean Parameter 2 Name Condition2 (optional) Parameter 2 Type boolean Parameter 3 Name Condition3 (optional) Parameter 3 Type boolean Return Value Condition1 AND Condition2 Note Parameter 1 and Parameter 2 are optional. If only Parameter 1 has value, the result is its value (Parameter 1). Example 10: AND EXP:20 EXP:30 20: EQUAL ATTRIB:LineNo CONST:10 30: EQUAL ATTRIB:Notes CONST:Apple OUTPUT: If 'LineNo = 10' and 'Notes = Apple', the output will be 'True'. If 'LineNo = 50' and 'Notes = Apple', the output will be 'False'. If 'LineNo = 10' and 'Notes = Pear', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More Examples Sales amounts of the customer for the last 30 days Get value and description of referent object"
  },
  "advanced/calculated-attributes/operators/cast.html": {
    "href": "advanced/calculated-attributes/operators/cast.html",
    "title": "CAST - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "CAST - Calculated Attribute Operator Specification Value Name CAST Description Casts the parameter to the specified type. Parameter 1 Name param Parameter 1 Type any type Parameter 2 Name type Parameter 2 Type string - 'System.Int32', 'System.String', 'System.Decimal', 'System.Double' and all standart .net types. Parameter 3 Name Parameter 3 Type Return Value Returns the param converted to the type. Note The CAST operator is a secondary operator, used by the other operators to convert their parameters to the same type. The type is usually entered as a constant (CONST). Example The following example converts the value of the 'State' of a Sales Order, whoose type is Enum, to an integer number. Conveting to integer allows comparison between the states (lower -> higher): 10: CONVERT ATTRIB:State CONST:System.Int32 OUTPUT: If 'State = Released', the output will be '30'. Note The repository of the attribute is Crm.Sales.SalesOrders More Examples Check whether the releasing of the document is first or not Check if the system type of payment type in the sales order is 'In Cash'"
  },
  "advanced/calculated-attributes/operators/ceiling.html": {
    "href": "advanced/calculated-attributes/operators/ceiling.html",
    "title": "CEILING - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "CEILING - Calculated Attribute Operator Specification Value Description Returns the smallest integer that is greater than or equal to the specified number. Parameter 1 Name Number1 Parameter 1 Type double or decimal Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return Value The nearest integer which is larger than Number1. Example The following example gets the smallest integer that is greater than or equal to 'Quantity' of a Sales Order Line: 10:CEILING ATTRIB:QuantityValue OUTPUT: If 'QuantityValue = 14.15', the output will be '15'. If 'QuantityValue = 14', the output will be '14'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/concat.html": {
    "href": "advanced/calculated-attributes/operators/concat.html",
    "title": "CONCAT - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "CONCAT - Calculated Attribute Operator Specification Value Description Concatenates two strings. Parameter 1 Name String1 Parameter 1 Type string Parameter 2 Name String2 Parameter 2 Type string Parameter 3 Name - Parameter 3 Type - Return Value String1 + String2 Example The following example concatenates the word 'Red' with the value of the field 'Notes' in Sales Order Lines: 10: CONCAT CONST:Red ATTRIB:Notes OUTPUT: If 'Notes = Apple', the output will be 'RedApple'. Note The repository of the attribute is Crm.Sales.SalesOrderLines If we want to expand the example we can add a space between the both strings: 10: CONCAT CONST:Red EXP:20 20: CONCAT CONST:' ' ATTRIB:Notes OUTPUT: If 'Notes = Apple', the output will be 'Red Apple'."
  },
  "advanced/calculated-attributes/operators/convert.html": {
    "href": "advanced/calculated-attributes/operators/convert.html",
    "title": "CONVERT - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "CONVERT - Calculated Attribute Operator Specification Value Description Returns an object of the specified type and whose value is equivalent to the specified object. This conversion requires absolutely correct input data - if the data is not in the correct form, data loss may occur. For example: if the user tries to convert the string value of '3.12' to decimal, the conversion would be successful. If the conversion of the string is not possible, this may lead to data loss, but no error would be returned. Parameter 1 Name param Parameter 1 Type decimal, int, string or date Parameter 2 Name type Parameter 2 Type string - 'System.Int32', 'System.String', 'System.Decimal', 'System.DateTime' and all standard .net types Parameter 3 Name - Parameter 3 Type - Return Value Returns the param converted to the type. Example The following example converts the value of the 'Quantity' of a Sales Order Line, which is a decimal number, to an integer number: 10: CONVERT ATTRIB:QuantityValue CONST:System.Int32 OUTPUT: If 'QuantityValue = 12.14', the output will be '12'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More Examples Convert a value of a custom property to a number"
  },
  "advanced/calculated-attributes/operators/count.html": {
    "href": "advanced/calculated-attributes/operators/count.html",
    "title": "COUNT - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "COUNT - Calculated Attribute Operator Specification Value Description Gets the number of elements contained in the list. Parameter 1 Name list Parameter 1 Type list - repository, child. Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return Value int Introduced In Version 2020.1 Example The following example returns the number of lines in the current document (SalesOrder): 10: COUNT CHILD:Lines Note The repository of the attribute is Crm.Sales.SalesOrders If we want to expand the example and if we want to get the number of lines with quantity greater than or equal to 10, the following attribute would do the job: 10: COUNT EXP:20 20: FILTER CHILD:Lines EXP:30 30: GTE ATTRIB:QuantityValue CONST:10.00"
  },
  "advanced/calculated-attributes/operators/divide.html": {
    "href": "advanced/calculated-attributes/operators/divide.html",
    "title": "DIVIDE - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "DIVIDE - Calculated Attribute Operator Specification Value Name DIVIDE Description Divide one number by second number. Parameter 1 Name Number1 Parameter 1 Type numeric type - int, double or decimal Parameter 2 Name Number2 Parameter 2 Type numeric type - int, double or decimal Parameter 3 Name Parameter 3 Type Return Value Number1 / Number2 Note Ensure that the numbers of both parameters are from the the same type. For example, Parameter 1 and Parameter 2 must be both integers, doubles, or decimals. Example 10: DIVIDE ATTRIB:QuantityValue CONST:2.00 OUTPUT: If 'QuantityValue = 6.00', the output will be '3.00'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More Examples Calculate standart price per lot based on the ingredients and the operations in the recipe"
  },
  "advanced/calculated-attributes/operators/equal.html": {
    "href": "advanced/calculated-attributes/operators/equal.html",
    "title": "EQUAL - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "EQUAL - Calculated Attribute Operator Specification Value Name EQUAL Description Checks if two values are equal. If they are equal, the return value is True, else - the return value is False. Parameter 1 Name Value1 Parameter 1 Type numeric type - int, double or decimal; string; Parameter 2 Name Value2 Parameter 2 Type numeric type - int, double or decimal; string; Parameter 3 Name Parameter 3 Type Return Value boolean (True or False) Note Ensure that the values which are compared up have the same type. For example, Parameter 1 and Parameter 2 must be both integers, or doubles, or decimals, or strings. Example 10: EQUAL ATTRIB:LineNo CONST:30 OUTPUT: If 'LineNo = 30', the output will be 'True'. If 'LineNo = 10', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More Examples Check if the quantity is a whole number Check whether the releasing of the document is first or not Get current availability of a product"
  },
  "advanced/calculated-attributes/operators/filter.html": {
    "href": "advanced/calculated-attributes/operators/filter.html",
    "title": "FILTER - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "FILTER - Calculated Attribute Operator Specification Value Name FILTER Description Filters the specified list by the condition. Parameter 1 Name list Parameter 1 Type list of objects Parameter 2 Name condition Parameter 2 Type boolean Parameter 3 Name Parameter 3 Type Return Value Returns sub-list, which meets the condition. Example The following example returns a list with all of lines in the current document (SalesOrder) whose quantity is '1.00': 10: FILTER CHILD:Lines EXP:30 30: EQUAL ATTRIB:QuantityValue CONST:1.00 Note The repository of the attribute is Crm.Sales.SalesOrders"
  },
  "advanced/calculated-attributes/operators/first.html": {
    "href": "advanced/calculated-attributes/operators/first.html",
    "title": "FIRST - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "FIRST - Calculated Attribute Operator Specification Value Name FIRST Description Returns the first element in the list. Parameter 1 Name list Parameter 1 Type list of objects Parameter 2 Name Parameter 2 Type Parameter 3 Name Parameter 3 Type Return Value Returns the first element of list. Note The FIRST operator returns the first met element of the list, but the criateria about which element is actually first may not match your expectations. If the sorting of the elements matters, please use in combinations with the SORT - Calculated Attribute Operator and ORDERBY - Calculated Attribute Operator operators. Example The following example returns the first met line of the current document (SalesOrder): 10: FIRST CHILD:Lines Note The repository of the attribute is Crm.Sales.SalesOrders If we want to expand the example we can sort the line ascending by line number. This way the atrribute will return the line with lowest line number: 10: FIRST EXP:20 20: SORT CHILD:Lines ATTR:LineNo CONST:ASC"
  },
  "advanced/calculated-attributes/operators/floor.html": {
    "href": "advanced/calculated-attributes/operators/floor.html",
    "title": "FLOOR - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "FLOOR - Calculated Attribute Operator Specification Value Name FLOOR Description Returns the largest integer less than or equal to the specified number. Parameter 1 Name Number1 Parameter 1 Type double or decimal Parameter 2 Name Parameter 2 Type Parameter 3 Name Parameter 3 Type Return Value Returns the largest integer less than or equal to Number1. Example The following example gets the largest integer that is less than or equal to 'Quantity' of a Sales Order Line: 10: FLOOR ATTRIB:QuantityValue OUTPUT: If 'QuantityValue = 14.85', the output will be '14'. If 'QuantityValue = 14', the output will be '14'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/formatstring.html": {
    "href": "advanced/calculated-attributes/operators/formatstring.html",
    "title": "FORMATSTRING - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "FORMATSTRING - Calculated Attribute Operator Specification Value Description Returns the specified object, formatted by the specified rules. Parameter 1 Name Param1 Parameter 1 Type object (any type) Parameter 2 Name Format Parameter 2 Type constant - the format argument must contain a valid .NET format string, either as a standard format string (for example, \"C\" or \"D\") or as a pattern of custom characters for dates and numeric values (for example, \"MMMM DD, yyyy (dddd)\"). For more information about the supported format specifiers, see Format Specifiers . Parameter 3 Name - Parameter 3 Type - Return Value Param1 as a string formatted by the rule in Format. Note For more information about the supported format specifiers, see Format Specifiers . Example Here are some examples of the diffrent formats and format specifiers: 10: FORMATSTRING CONST:DocumentDate CONST:yyyy MM dddd OUTPUT: If 'DocumentDate = 2020-03-15', the output will be '2020 03 Sunday'. ( the language of the day of the week depends on the local regional settings ) 10: FORMATSTRING ATTRIB:QuantityValue CONST:n6 OUTPUT: If 'QuantityValue = 150.00', the output will be '150,000000'. ( the decimal symbol separator depends on the local regional settings ) 10: FORMATSTRING ATTRIB:LineAmountValue CONST:C OUTPUT: If 'LineAmountValue = 150.00', the output will be '150.00 $'. ( the decimal symbol separator and the currency symbol depends on the local regional settings ) Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/getobjvalue.html": {
    "href": "advanced/calculated-attributes/operators/getobjvalue.html",
    "title": "GETOBJVALUE - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "GETOBJVALUE - Calculated Attribute Operator Specification Value Description Gets the specified value from the specified object. This operator is used when the user wants the retrieve a value from object different than the current one. The current object is listed in the 'Repository Name' field in the current row. Parameter 1 Name obj Parameter 1 Type object Parameter 2 Name value Parameter 2 Type attribute value Parameter 3 Name - Parameter 3 Type - Return Value Returns value from obj. Example The following example returns the value of the field 'Default Delivery Term Days' set in the definition of the Customer set the current Sales Order: 10: GETOBJVALUE REF:Customer ATTRIB:DefaultDeliveryTermDays OUTPUT: If 'DefaultDeliveryTermDays = 5', the output will be '5'. Note The repository of the attribute is Crm.Sales.SalesOrders More Examples Check if a value of a field is changed in the adjustment document Get value and description of referent object"
  },
  "advanced/calculated-attributes/operators/getvalue.html": {
    "href": "advanced/calculated-attributes/operators/getvalue.html",
    "title": "GETVALUE - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "GETVALUE - Calculated Attribute Operator Specification Value Description Gets the value from the current object. Parameter 1 Name Value Parameter 1 Type attribute value Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return Value Value Example The following example returns the value of the Notes of the current Sales Order Line: 10: GETVALUE ATTRIB:Notes OUTPUT: If 'Notes = Apple', the output will be 'Apple'. Note The repository of the attribute is Crm.Sales.SalesOrderLiness"
  },
  "advanced/calculated-attributes/operators/gt.html": {
    "href": "advanced/calculated-attributes/operators/gt.html",
    "title": "GT - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "GT - Calculated Attribute Operator Specification Value Description Checks if an attribute value is greater than another attribute's value (or a constant). Parameter 1 Name attribute1 Parameter 1 Type numeric (int, double, decimal) or datetime type Parameter 2 Name attribute2 Parameter 2 Type numeric (int, double, decimal) or datetime type Parameter 3 Name - Parameter 3 Type - Return Value If attribute1 > attribute2 the returned value is True, if else - the operator returns False. Note Ensure that the attributes which are compared have the same type. For example, Parameter 1 and Parameter 2 must be both integers, or doubles, or decimals, or datetime. Example 10: GT ATTRIB:LineNo CONST:30 OUTPUT: If 'LineNo = 40', the output will be 'True'. If 'LineNo = 30', the output will be 'False'. If 'LineNo = 20', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More Examples Compare unit price and standard unit price"
  },
  "advanced/calculated-attributes/operators/gte.html": {
    "href": "advanced/calculated-attributes/operators/gte.html",
    "title": "GTE - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "GTE - Calculated Attribute Operator Specification Value Description Checks if an attribute value is greater than or equal to another attribute's value (or a constant). Parameter 1 Name attribute1 Parameter 1 Type numeric (int, double, decimal) or datetime type Parameter 2 Name attribute2 Parameter 2 Type numeric (int, double, decimal) or datetime type Parameter 3 Name - Parameter 3 Type - Return Value If attribute1 >= attribute2 the returned value is True, if else - the operator returns False. Note Ensure that the attributes which are compared have the same type. For example, Parameter 1 and Parameter 2 must be both integers, or doubles, or decimals, or datetime. Example 10: GT ATTRIB:LineNo CONST:30 OUTPUT: If 'LineNo = 40', the output will be 'True'. If 'LineNo = 30', the output will be 'True'. If 'LineNo = 20', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/iif.html": {
    "href": "advanced/calculated-attributes/operators/iif.html",
    "title": "IIF - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "IIF - Calculated Attribute Operator Specification Value Description Depending on a specified condition, returns the second or the third argument. Parameter 1 Name Condition Parameter 1 Type Boolean Parameter 2 Name TrueValue Parameter 2 Type any type Parameter 3 Name FalseValue Parameter 3 Type any type Return Value When Condition is True, returns TrueValue. When Condition is False, returns FalseValue Example 10: IIF EXP:20 CONST:'Quantity is 1.00' CONST: 'Quantity is not 1.00' 20: EQUAL ATTRIB:QuantityValue CONST:1.00 OUTPUT: If 'QuantityValue = 1.00', the output will be 'Quantity is 1.00'. If 'QuantityValue = 2.00', the output will be 'Quantity is not 1.00'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More Examples Compare unit price and standard unit price Check if a value of a field is changed in the adjustment document"
  },
  "advanced/calculated-attributes/operators/in.html": {
    "href": "advanced/calculated-attributes/operators/in.html",
    "title": "IN - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "IN - Calculated Attribute Operator Specification Value Description Determines whether a specified value matches any value in a list. The operator is used in combination with SELECT and FILTER as condition. It can be used to search through values of string and guid types. It cannot be used to search through numeric values or dates. Parameter 1 Name param Parameter 1 Type String or Guid Parameter 2 Name list of values Parameter 2 Type the values must be equal to the param type Parameter 3 Name - Parameter 3 Type - Return Value True or False depending on if param equals a member of the list of values. Note Single quotes are only necessary when the values which we compare to are strings. Example The following example checks whether there are Sales Orders with Notes 'Apple' and 'Pear' into the datatabase: 10: SELECT REPO:Crm.Sales.SalesOrders EXP:20 20: WHERE EXP:30 30: IN ATTRIB:Notes CONST:'Apple', 'Pear' OUTPUT: If there is atleast one Sales Order with 'Notes = Apple', the output will be 'True'. If there is atleast one Sales Order with 'Notes = Pear', the output will be 'True'. If there are NO Sales Orders with 'Notes = Apple OR Pear', the output will be 'False'."
  },
  "advanced/calculated-attributes/operators/incnum.html": {
    "href": "advanced/calculated-attributes/operators/incnum.html",
    "title": "INCNUM - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "INCNUM - Calculated Attribute Operator Specification Value Description The INCNUM operator increases the value of its parameter by 1. The operator can be used only for String values whоose last character is a number. The INCNUM operator can be used for consecutive numbering of documents and nomenclatures. Parameter 1 Name Value Parameter 1 Type string Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return Value ++Value Note If you try to increment the string value whоose last character is a number 'AA01', the incrementation will be successful and result will be 'AA02'; If you try to increment a value whoоse type is Decimal, Int or Date, the incrementation won't be successful and the Calculated Attribute won't be compilated; If the value is a string whose last character is not a number ('AA', for example), the incrementation won't be successful. Examples The following example shows how to increase the LotNumber of the Lot by 1 with the INCNUM operator: 10: INCNUM ATTRIB:Number OUTPUT: If 'Number = 0001'', the output will be '0002'. If 'Number = AA01'', the output will be 'AA02'. Note The repository of the attribute is Logistics.Inventory.Lots"
  },
  "advanced/calculated-attributes/operators/index.html": {
    "href": "advanced/calculated-attributes/operators/index.html",
    "title": "Operators | ERP.net Tech Docs",
    "keywords": "Operators ADD - Calculated Attribute Operator ADDDAYS - Calculated Attribute Operator AND - Calculated Attribute Operator CAST - Calculated Attribute Operator CEILING - Calculated Attribute Operator CONCAT - Calculated Attribute Operator CONVERT - Calculated Attribute Operator COUNT - Calculated Attribute Operator DIVIDE - Calculated Attribute Operator EQUAL - Calculated Attribute Operator FILTER - Calculated Attribute Operator FIRST - Calculated Attribute Operator FLOOR - Calculated Attribute Operator FORMATSTRING - Calculated Attribute Operator GETOBJVALUE - Calculated Attribute Operator GETVALUE - Calculated Attribute Operator GT - Calculated Attribute Operator GTE - Calculated Attribute Operator IIF - Calculated Attribute Operator IN - Calculated Attribute Operator INCNUM - Calculated Attribute Operator LEFT - Calculated Attribute Operator LEN - Calculated Attribute Operator LIST - Calculated Attribute Operator LT - Calculated Attribute Operator LTE - Calculated Attribute Operator MULTIPLY - Calculated Attribute Operator NOT - Calculated Attribute Operator OR - Calculated Attribute Operator ORDERBY - Calculated Attribute Operator POS - Calculated Attribute Operator REGEX - Calculated Attribute Operator REPLACE - Calculated Attribute Operator RIGHT - Calculated Attribute Operator ROUND - Calculated Attribute Operator SELECT - Calculated Attribute Operator SORT - Calculated Attribute Operator SUBSTRING - Calculated Attribute Operator SUM - Calculated Attribute Operator TODAY - Calculated Attribute Operator TOLOWER - Calculated Attribute Operator TOP - Calculated Attribute Operator TOUPPER - Calculated Attribute Operator WHERE - Calculated Attribute Operator"
  },
  "advanced/calculated-attributes/operators/left.html": {
    "href": "advanced/calculated-attributes/operators/left.html",
    "title": "LEFT - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "LEFT - Calculated Attribute Operator Specification Value Description Gets the first n characters of a string (starting from left). Parameter 1 Name String Parameter 1 Type string Parameter 2 Name NumChars Parameter 2 Type int Parameter 3 Name - Parameter 3 Type - Return Value Returns the first Numchars characters of the String. Example The following example returns the first 3 characters of the Notes set in the Sales Order: 10: LEFT ATTRIB:Notes CONST:3 OUTPUT: If 'Notes = Apple', the output will be 'App'. If 'Notes = I am', the output will be 'I a'. Note The repository of the attribute is Crm.Sales.SalesOrders"
  },
  "advanced/calculated-attributes/operators/len.html": {
    "href": "advanced/calculated-attributes/operators/len.html",
    "title": "LEN - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "LEN - Calculated Attribute Operator Specification Value Description Returns the length of the string. Parameter 1 Name String Parameter 1 Type string Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return Value Returns the length of a string. Note The spaces are included when calculating the length. Example The following example returns the lenght of the Notes set in the Sales Order: 10: LEN ATTRIB:Notes OUTPUT: If 'Notes = Apple', the output will be '5'. If 'Notes = I am', the output will be '4'. Note The repository of the attribute is Crm.Sales.SalesOrders"
  },
  "advanced/calculated-attributes/operators/like.html": {
    "href": "advanced/calculated-attributes/operators/like.html",
    "title": "LIKE - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "LIKE - Calculated Attribute Operator Specification Value Description Searches for a specified pattern in a string. It is usually used in a combination with the wildcars '%' and '_': The '%' symbol is used to define 0 or more characters before and after the searched string. '_' is used to define specifically 1 character. Parameter 1 Name String1 Parameter 1 Type string Parameter 2 Name Mask Parameter 2 Type string Parameter 3 Name - Parameter 3 Type - Return Value True in case String1 matches Mask. False in case String1 does not match the Mask. Examples 'a%' → Finds any values that start with \"a\". '%a' → Finds any values that end with \"a\". '%a%' → Finds any values that have \"a\" in any position. '_a%' → Finds any values that have \"a\" in the second position. 'a_%_%' → Finds any values that start with \"a\" and are at least 3 characters in length. 'a%o' → Finds any values that start with \"a\" and ends with \"o\". The following example returns True if the the string contains 'Apple' and after 'Apple' there is exactly one character: 10 LIKE ATTRIB:Notes CONST:%Apple_ OUTPUT: If 'Notes = Apples', the output will be 'True'. If 'Notes = Green Apples', the output will be 'True'. If 'Notes = apples', the output will be 'False'. If 'Notes = Apple', the output will be 'False'. If 'Notes = Green Bananas', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrders"
  },
  "advanced/calculated-attributes/operators/list.html": {
    "href": "advanced/calculated-attributes/operators/list.html",
    "title": "LIST - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "LIST - Calculated Attribute Operator Specification Value Description Returns a list with the string values of the specified attribute of the list of objects.The values in the created list are separated by a separator. If there is no indicated separator, then the list is separated with \", \" (comma + space) by default. Parameter 1 Name list Parameter 1 Type list of objects Parameter 2 Name attribute Parameter 2 Type attribute of the object // An attribute of a referent object could be used as well. For more information, see the example below. Parameter 3 Name separator (optional) // If Parameter3 is not specified, then the default separator is \", \" (comma + space) Parameter 3 Type string Return Value (attributeValue1, attributeValue2, ...) Introduced In Version 2019.1 Example 10: LIST CHILD:Lines EXP:20 CONST:'; ' 20: GETOBJVALUE REF:Product ATTRIB:Name OUTPUT: 'ProductsName1; ProductName2 ...' Note The repository of the attribute is Crm.Sales.SalesOrders"
  },
  "advanced/calculated-attributes/operators/lt.html": {
    "href": "advanced/calculated-attributes/operators/lt.html",
    "title": "LT - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "LT - Calculated Attribute Operator Specification Value Description Checks if an attribute value is smaller than another attribute's value (or a constant). Parameter 1 Name attribute1 Parameter 1 Type numeric (int, double, decimal) or datetime type Parameter 2 Name attribute2 Parameter 2 Type numeric (int, double, decimal) or datetime type Parameter 3 Name - Parameter 3 Type - Return Value If attribute1 < attribute2 the returned value is True, if else - the operator returns False. Note Ensure that the attributes which are compared have the same type. For example, Parameter 1 and Parameter 2 must be both integers, or doubles, or decimals, or datetime. Example 10: LT ATTRIB:LineNo CONST:30 OUTPUT: If 'LineNo = 20', the output will be 'True'. If 'LineNo = 30', the output will be 'False'. If 'LineNo = 40', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/lte.html": {
    "href": "advanced/calculated-attributes/operators/lte.html",
    "title": "LTE - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "LTE - Calculated Attribute Operator Specification Value Description Checks if an attribute value is smaller than or equal to another attribute's value (or a constant). Parameter 1 Name attribute1 Parameter 1 Type numeric (int, double, decimal) or datetime type Parameter 2 Name attribute2 Parameter 2 Type numeric (int, double, decimal) or datetime type Parameter 3 Name - Parameter 3 Type - Return Value If attribute1 <= attribute2 the returned value is True, if else - the operator returns False. Note Ensure that the attributes which are compared have the same type. For example, Parameter 1 and Parameter 2 must be both integers, or doubles, or decimals, or datetime. See the example in @(Compare Unit Price And The Standard Unit Price). Example 10: LTE ATTRIB:LineNo CONST:30 OUTPUT: If 'LineNo = 20', the output will be 'True'. If 'LineNo = 30', the output will be 'True'. If 'LineNo = 40', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More Examples Compare unit price and standard unit price"
  },
  "advanced/calculated-attributes/operators/multiply.html": {
    "href": "advanced/calculated-attributes/operators/multiply.html",
    "title": "MULTIPLY - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "MULTIPLY - Calculated Attribute Operator Specification Value Description Multiply the specified numbers. Parameter 1 Name Number1 Parameter 1 Type numeric type - int, double or decimal Parameter 2 Name Number2 Parameter 2 Type numeric type - int, double or decimal Parameter 3 Name - Parameter 3 Type - Return Value Number1 * Number2 Note Ensure that the numbers of both parameters are from the the same type. For example, Parameter 1 and Parameter 2 must be both integers, doubles, or decimals. Example 10: MULTIPLY ATTRIB:QuantityValue CONST:2.00 OUTPUT: If 'QuantityValue = 3.00', the output will be '6.00'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More Examples Total quantity and scrap quantity in recipe ingredients ."
  },
  "advanced/calculated-attributes/operators/not.html": {
    "href": "advanced/calculated-attributes/operators/not.html",
    "title": "NOT - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "NOT - Calculated Attribute Operator Specification Value Description Returns logical negation on an expression. Parameter 1 Name Condition Parameter 1 Type boolean Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return Value False - if Condition is True; True - if Condition is False Example 10: NOT EXP:20 20: EQUAL ATTRIB:LineNo CONST:10 OUTPUT: If 'LineNo = 10', the output will be 'False'. If 'LineNo = 20', the output will be 'True'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/or.html": {
    "href": "advanced/calculated-attributes/operators/or.html",
    "title": "OR - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "OR - Calculated Attribute Operator Specification Value Description Checks if any of the conditions are True. If so - the operator returns True. If all specified conditions are not True, the operator returns False. Parameter 1 Name Condition1 Parameter 1 Type boolean Parameter 2 Name Condition2 Parameter 2 Type boolean Parameter 3 Name - Parameter 3 Type - Return Value Condition1 OR Condition2 Example 10: OR EXP:20 EXP:30 20: EQUAL ATTRIB:LineNo CONST:10 30: EQUAL ATTRIB:LineNo CONST:20 OUTPUT: If 'LineNo = 10', the output will be 'True'. If 'LineNo = 20', the output will be 'True'. If 'LineNo = 30', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/orderby.html": {
    "href": "advanced/calculated-attributes/operators/orderby.html",
    "title": "ORDERBY - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "ORDERBY - Calculated Attribute Operator Specification Value Description Clause, that specifies a column or expression on which the query result set is sorted. Used as a clause of SELECT. Parameter 1 Name attribute Parameter 1 Type any type Parameter 2 Name order (optional) //if not set, the default is ASC Parameter 2 Type const - ASC or DESC Parameter 3 Name inner clauses (optional) Parameter 3 Type expression Return Value Ordered result set of a query by the specified column or expression. Introduced In Version (In implementation) Example 10: SELECT REPO:General.Products.Products EXP:20 20: TOP CONST:5 EXP:30 30: ORDERBY ATTR:PartNumber CONST:ASC EXP:40 40: WHERE ..."
  },
  "advanced/calculated-attributes/operators/pos.html": {
    "href": "advanced/calculated-attributes/operators/pos.html",
    "title": "POS - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "POS - Calculated Attribute Operator Specification Value Description Searches term in string, returns first position or -1 if not found. Parameter 1 Name term Parameter 1 Type string Parameter 2 Name string Parameter 2 Type string Parameter 3 Name - Parameter 3 Type - Return Value Returns the position of term in string. If there are more than one occurrences of term in string, returns the first position. If term is not part of string, returns -1."
  },
  "advanced/calculated-attributes/operators/regex.html": {
    "href": "advanced/calculated-attributes/operators/regex.html",
    "title": "REGEX - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "REGEX - Calculated Attribute Operator Specification Value Description Returns whether the string matches the regex mask. Parameter 1 Name String1 Parameter 1 Type string Parameter 2 Name Mask Parameter 2 Type regex expression Parameter 3 Name - Parameter 3 Type - Return Value True - if String1 matches Mask; False - if String1 does not match the Mask ."
  },
  "advanced/calculated-attributes/operators/replace.html": {
    "href": "advanced/calculated-attributes/operators/replace.html",
    "title": "REPLACE - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "REPLACE - Calculated Attribute Operator Specification Value Description Replaces old with new value in string. Parameter 1 Name String1 Parameter 1 Type string Parameter 2 Name OldValue Parameter 2 Type string Parameter 3 Name NewValue Parameter 3 Type string Return Value A string that is equivalent to String1 except that all instances of OldValue are replaced with NewValue. If OldValue is not found in String1, the operator returns String1."
  },
  "advanced/calculated-attributes/operators/right.html": {
    "href": "advanced/calculated-attributes/operators/right.html",
    "title": "RIGHT - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "RIGHT - Calculated Attribute Operator Specification Value Description Gets the last n characters of a string. Parameter 1 Name String Parameter 1 Type string Parameter 2 Name NumChars Parameter 2 Type int Parameter 3 Name - Parameter 3 Type - Return Value Returns the last NumChars characters of String."
  },
  "advanced/calculated-attributes/operators/round.html": {
    "href": "advanced/calculated-attributes/operators/round.html",
    "title": "ROUND - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "ROUND - Calculated Attribute Operator Specification Value Description Rounds mathematically with the specified precision. Parameter 1 Name Number Parameter 1 Type double or decimal Parameter 2 Name DecimalPlaces (optional) Parameter 2 Type int Parameter 3 Name - Parameter 3 Type - Return Value Number, rounded up to the digit, specified in DecimalPlaces Note Parameter 2 is optional. If Parameter 2 is not set, it is considered 0 (zero)."
  },
  "advanced/calculated-attributes/operators/select.html": {
    "href": "advanced/calculated-attributes/operators/select.html",
    "title": "SELECT - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "SELECT - Calculated Attribute Operator Specification Value Description Gets the objects matching the clauses. Parameter 1 Name Repository Parameter 1 Type repository Parameter 2 Name Clauses (optional, but highly advisable) // For more information see the 'FILTER AND WHERE filtering of a SELECT' section below) Parameter 2 Type operators ( WHERE , TOP ) Parameter 3 Name - Parameter 3 Type - Return Value Returns a list of objects from Repository matching Clauses. Note The SELECT operator returns limited number of records - 20 000. This limit is only for the returned records count, so as setting much filters as possible are highly recommended (filters in the WHERE clause). Example The WHERE clause of the SELECT statement supports the following operators: AND TOP EQUAL GT GTE LT LTE The operators which are not supported by the SELECT operator but may be used by the FILTER operator are: NOT OR LIKE FILTER AND WHERE filtering of a SELECT Having this in mind is really important when extracting lists from the database. When using SELECT operator we send a request to the database and it is preferred to set as much WHERE filters as possible. But if there is a filter, which is not supported by the EnterpriseOne Server, then the list that is returned by the select may be filtered additionally with the FILTER operator. The disadvantages are that the SELECT statement make a direct request to the database, which may reflect on the productivity and may slow down the calculation of the attribute. When using the SELECT operator the user has to apply as much WHERE filters as possible, because this would limit the amount of data which would be extracted from the database into the client. And then, if the select statement does not provide enough filters, the result from the select may be filtered by the FILTER operator which operates on the already loaded data in the client. Here are some examples to picture the information by far: If there is a need of a list of documents which DocumentTypeId is equal to 'bbd8e7ae-c0e0-4c1b-8730-7d68fa52971e' or '89ca5ca4-ad57-44c7-9b33-2ff44e054bff'. The documents are Work Orders. So the following calculated attribute would be incorrect: 10: SELECT REPO:Production.ShopFloor.WorkOrders EXP:20 20: WHERE EXP:30 30: OR EXP:40 EXP:50 40: EQUAL CONST:bbd8e7ae-c0e0-4c1b-8730-7d68fa52971e 45: ATTRIB:DocumentTypeId CONST:System.Guid 50: EQUAL EXP:45 CONST:89ca5ca4-ad57-44c7-9b33-2ff44e054bff This calculated attribute is incorrect and would return errors when used. So, we can set calculated attribute which selects the work orders and then to filter the list, which the SELECT operator returned and apply the FILTER operator for more precision. So the correct calculated attribute is as follows: 10: FILTER EXP:20 EXP:30 20: SELECT REPO:Production.ShopFloor.WorkOrders 30: OR EXP:40 EXP:50 40: EQUAL EXP:45 CONST:bbd8e7ae-c0e0-4c1b-8730-7d68fa52971e 45: CAST ATTRIB:DocumentTypeId CONST:System.Guid 50: EQUAL ATTRIB:DocumentTypeId CONST:89ca5ca4-ad57-44c7-9b33-2ff44e054bff"
  },
  "advanced/calculated-attributes/operators/sort.html": {
    "href": "advanced/calculated-attributes/operators/sort.html",
    "title": "SORT - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "SORT - Calculated Attribute Operator Specification Value Description Sorts the input list according to the specified attribute and order. Parameter 1 Name list Parameter 1 Type list Parameter 2 Name attribute Parameter 2 Type any type Parameter 3 Name order (optional) Parameter 3 Type string - ASC or DESC Return Value Returns the input list from parameter1, sorted by the specified attribute and in the specified order. If not specified, the default order is ascending (ASC) Example Take the last line of a sales order (ordered by LineNo), which has quantity >= 0: SalesOrder=> 10: FIRST EXP:20 20: SORT EXP:30 ATTR:LineNo CONST:DESC 30: FILTER CHILD:Lines EXP:40 40: GTE ATTR:QuantityValue CONST:0"
  },
  "advanced/calculated-attributes/operators/substring.html": {
    "href": "advanced/calculated-attributes/operators/substring.html",
    "title": "SUBSTRING - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "SUBSTRING - Calculated Attribute Operator Specification Value Description Returns a sub-string with the specified start and length. Parameter 1 Name string Parameter 1 Type string Parameter 2 Name start Parameter 2 Type int Parameter 3 Name len Parameter 3 Type int Return Value Part of string, starting from position start and with length of len."
  },
  "advanced/calculated-attributes/operators/sum.html": {
    "href": "advanced/calculated-attributes/operators/sum.html",
    "title": "SUM - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "SUM - Calculated Attribute Operator Specification Value Description Returns the sum of Value for all elements in the specified list. Parameter 1 Name List Parameter 1 Type list of objects Parameter 2 Name Value Parameter 2 Type numeric type - int, double or decimal Parameter 3 Name - Parameter 3 Type - Return Value Returns the sum of the Values of the elements in the List. More Examples Sales amounts of the customer for the last 30 days"
  },
  "advanced/calculated-attributes/operators/today.html": {
    "href": "advanced/calculated-attributes/operators/today.html",
    "title": "TODAY - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "TODAY - Calculated Attribute Operator Specification Value Description This operator returns today's date, according to the server's regional settings. Parameter 1 Name - Parameter 1 Type - Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return Value Today's date"
  },
  "advanced/calculated-attributes/operators/tolower.html": {
    "href": "advanced/calculated-attributes/operators/tolower.html",
    "title": "TOLOWER - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "TOLOWER - Calculated Attribute Operator Specification Value Description Returns the string, converted to lowercase. Parameter 1 Name string Parameter 1 Type string Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return Value string (in lowercase)"
  },
  "advanced/calculated-attributes/operators/top.html": {
    "href": "advanced/calculated-attributes/operators/top.html",
    "title": "TOP - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "TOP - Calculated Attribute Operator Specification Value Description Clause, returning only the first n elements Parameter 1 Name Number Parameter 1 Type int Parameter 2 Name Clauses Parameter 2 Type operators WHERE Parameter 3 Name - Parameter 3 Type - Return Value The first Number elements. Note The TOP operator is used with the WHERE operator."
  },
  "advanced/calculated-attributes/operators/toupper.html": {
    "href": "advanced/calculated-attributes/operators/toupper.html",
    "title": "TOUPPER - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "TOUPPER - Calculated Attribute Operator Specification Value Description Returns the string, converted to uppercase. Parameter 1 Name string Parameter 1 Type string Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return Value string (in uppercase)"
  },
  "advanced/calculated-attributes/operators/where.html": {
    "href": "advanced/calculated-attributes/operators/where.html",
    "title": "WHERE - Calculated Attribute Operator | ERP.net Tech Docs",
    "keywords": "WHERE - Calculated Attribute Operator Specification Value Description Clause which filters by the specified conditions. The second and the third parameters are optional. Parameter 1 Name Condition1 Parameter 1 Type boolean Parameter 2 Name boolean Parameter 2 Type Condition2 (optional) Parameter 3 Name boolean Parameter 3 Type Condition3 (optional) Return Value Clause, filtered by Condition1 AND Condition2 AND Condition3 Note The operator is used with operator SELECT ."
  },
  "advanced/calculated-attributes/parameter-types/index.html": {
    "href": "advanced/calculated-attributes/parameter-types/index.html",
    "title": "Parameter Types | ERP.net Tech Docs",
    "keywords": "Parameter Types The type of the parameter specifies how to obtain the parameter value. Several types are available: CONST - when used, indicates that the Value for this parameter type would be a constant for every calculation of the calculated attribute. For more information, see Parameter Type CONST . ATTRIB - the value of system or user-defined attribute; REF - reference to another object; CHILD - detailed objects, related to the current master object; EXP - the value of the expression with the specified number (the user specifies the number in the Value field); INPUT - the input parameter for the specified expression number (the user specifies the number in the Value field); REPO - a repository; SYS - the value of a particular system variable as Login, Today, EnterpriseCompanyId and others. The Parameter Types are used in every calculated attributes. For examples see Calculated Attributes - Examples ."
  },
  "advanced/calculated-attributes/parameter-types/parameter-type-const.html": {
    "href": "advanced/calculated-attributes/parameter-types/parameter-type-const.html",
    "title": "Parameter type CONST | ERP.net Tech Docs",
    "keywords": "Parameter type CONST When used, indicates that the Value for this parameter type would be a constant for every calculation of the calculated attribute. The formats of the different types of values which are entered are as follows: Value Description Example NULL null or empty value NULL Boolean true or false value True Integer a whole number (not a fractional number) that can be positive, negative, or zero 93 Decimal number, containing decimal symbol - '.' 93.012 Date date values used in the 'yyyy-MM-dd' format 2020-12-25 Guid Global Unique Identifier - used for objects identification 6B29FC40-CA47-1067-B31D-00DD010662DA String explicitly denoted string, entered in single quotation marks 'Example text.' Type used with CAST . Used for type conversions and the constant is the type to which we want to convert. System.Int32 Everything else is treated as string!"
  },
  "advanced/calculated-attributes/parameter-types/parameter-type-sys.html": {
    "href": "advanced/calculated-attributes/parameter-types/parameter-type-sys.html",
    "title": "Parameter type SYS | ERP.net Tech Docs",
    "keywords": "Parameter type SYS SYS parameter type is used for system variables. They can be applied when we need to acquire information for the current user, date, time, enterprise company and oth.. The list of those variables is as follows: Value Description Example (returned value) Login The login of the user that is currently logged in the program. admin UserId The id of the user that is currently logged in the program. 9da64839-a8d0-491d-aebb-4d18fa42b014 RoleName The name of role that is currently set for the user. Administration RoleId The role that is currently set for the user. c764ff2b-38ca-4906-893a-2a21a1691f43 Today Current date. 23.6.2017 0:00:00 Now Current date-time from the server time zone. 23.6.2017 13:25:33 UtcNow Current date-time in Coordinated Universal Time (UTC) 23.6.2017 10:25:33 EnterpriseCompanyId The id of the enterprise company that is currently set for the user. b0e80577-fbbe-4c9b-811e-20b6c6dd465f EnterpriseCompanyLocationId The id of the enterprise company location that is currently set for the user. f2947790-e21f-4def-b533-fdc00a343ce6 Example (usage): 10: GETVALUE SYS:Login The line returns the login of the user that is currently logged in the program."
  },
  "advanced/calculated-attributes/QA/HowToCheckIfACustomPropertyHasValue.html": {
    "href": "advanced/calculated-attributes/QA/HowToCheckIfACustomPropertyHasValue.html",
    "title": "How to check if a custom property has value? | ERP.net Tech Docs",
    "keywords": "How to check if a custom property has value? When there is a need to check if a custom property of an object has value, usually we can just CAST the custom property to a string and then check if it is equal to null. However, the syntax of the calculated attribute should be tailored to the specifics of the Property Type of the particular custom property. Here are examples for the different custom property types which are universal to all repositories. The custom property code which is verified is CustomProperty1. Note that when a custom property is cast to string, only its value will be processed, and not its description. Property Type is 'Text' If the Property Type of the particular custom property is 'Text' use the following expressions: 10: IIF EXP:20 CONST:'null' CONST:'not null' 20: EQUAL EXP:30 CONST:NULL 30: CAST ATTRIB:@CustomProperty1 CONST:System.String Explanation: 10: if EXP:20 is true, return the text 'null, else - return 'not null' 20: if EXP:30 is empty, return true, else - return false 30: cast CustomProperty1 to string Property Type is 'Number' or 'Date' If the Property Type of the particular custom property is 'Number' or 'Date' use the following expressions: 10: IIF EXP:20 CONST:'null' CONST:'not null' 20: OR EXP:30 EXP:40 30: EQUAL EXP:50 CONST:NULL 40: EQUAL EXP:50 CONST:'' 50: CAST ATTRIB:@CustomProperty1 CONST:System.String Explanation: 10: if EXP:20 is true, return the text 'null, else - return 'not null' 20: if EXP:30 OR EXP:40 is true, return true, else - return false 30: if EXP:50 is empty, return true, else - return false 40: if EXP:50 is an empty string, return true, else - return false 50: cast CustomProperty1 to string Property Type is 'Picture' If the Property Type of the particular custom property is 'Picture' use the following expressions: 10: IIF EXP:20 CONST:'null' CONST:'not null' 20: EQUAL EXP:30 CONST:0 30: SUM EXP:40 CONST:1 40: FILTER EXP:70 EXP:50 50: NOT EXP:60 60: EQUAL ATTRIB:Picture CONST:NULL 70: SELECT REPO:General.PropertyValues EXP:80 80: WHERE EXP: 90 EXP:100 90: EQUAL ATTRIB:PropertyId CONST:86ba82c9-8843-e611-82a1-b010410e63e2 100: EQUAL ATTRIB:EntityItemId CONST:47e225e9-f4b6-e611-af28-00155d001f28 Explanation: 10: if EXP:20 is true, return the text 'null, else - return 'not null' 20: if EXP:30 is equal to 0, return true, else - return false 30: count the records of the list returned by EXP:40 40: filter the list returned by EXP:70 by the condition of EXP:50 50: if EXP:60 is true, return false, else - return true 60: if ATTRIB:Picture is equal to NULL, return true, else - return false 70: select the records of table General.PropertyValues filtered by the clauses of EXP:80 80: if EXP:90 AND EXP:100 are true, return true, else - return false 90: if ATTRIB:PropertyId is equal to 86ba82c9-8843-e611-82a1-b010410e63e2, return true, else - return false 100: if ATTRIB: ATTRIB:EntityItemId is equal to 47e225e9-f4b6-e611-af28-00155d001f28, return true, else - return false Note EntityItemId is the Id of the actual entity (particular document, line, product) for which the value is specified."
  },
  "advanced/calculated-attributes/QA/HowToCheckIfAListHaveValues.html": {
    "href": "advanced/calculated-attributes/QA/HowToCheckIfAListHaveValues.html",
    "title": "How to check if a list have values? | ERP.net Tech Docs",
    "keywords": "How to check if a list have values? When working with lists, often there is a need to check if this list actually contains any values (records). For example - there is a calculated attribute which calculates the Quantity in the Sales Order Lines in specified measurement unit. There is always the possibility that the user enter a product which has no dimensions for the required measurement unit. In such cases, an instrument to check the lists records count is needed. The described case is solved by the following expression: SUM(List, 1) This expression returns integer value containing the number of records in the entered list. Here is an example expression and its description. This example is defined in the Sales Order header and checks if the lines contain one specific product. So the Repository of the calculated attribute is Crm.Sales.SalesOrders and its expressions are: 10: SUM EXP:20 CONST:1 20: FILTER CHILD:Lines EXP:30 30: EQUAL ATTRIB:ProductId CONST:d3d83bf0-d1fc-e611-9c53-00155d001f52 Explanation: 10: check the records count in list in expression 20 20: filter the list of Lines (detailed objects of the Sales Order object) by the filter in expression 30 30: check if the ProductId in the line is equal to Guid d3d83bf0-d1fc-e611-9c53-00155d001f52 This calculated attribute returns zero or greater value, depending on the count of the records in the Sales Order Lines with product with id of d3d83bf0-d1fc-e611-9c53-00155d001f52."
  },
  "advanced/calculated-attributes/QA/HowToCheckWhetherAFieldThatPointsToAReferenceObjectHasAValue.html": {
    "href": "advanced/calculated-attributes/QA/HowToCheckWhetherAFieldThatPointsToAReferenceObjectHasAValue.html",
    "title": "How to check whether a field that points to a reference object has a value? | ERP.net Tech Docs",
    "keywords": "How to check whether a field that points to a reference object has a value? Often when we are creating a calculated attribute and we want to get a value from a referent object, first we need to check if the current record has a reference to this object at all. A.k.a. we need to check if a particular Id field has a value or not. The recommended way to perform this validation is to check whether there is a referent object: 20 EQUAL REF:AdjustedDocument CONST:NULL ​ and NOT whether the Id fields itself is empty: 20 EQUAL ATTRIB:AdjustedDocumentId CONST:NULL The first approach is recommended because: a. the second approach may lead to incorrect results - there are cases with wrong results when this approach is used in a SELECT clause or in multiple nested calculated attributes. b. the first approach does not require type conversions - we are directly checking of there is a reference object and we don't have use CAST or CONVERT operators to match the types before the comparison."
  },
  "advanced/calculated-attributes/QA/HowToCreateAnOptimallyFastCalculatedAttribute.html": {
    "href": "advanced/calculated-attributes/QA/HowToCreateAnOptimallyFastCalculatedAttribute.html",
    "title": "How to create an optimally fast calculated attribute? | ERP.net Tech Docs",
    "keywords": "How to create an optimally fast calculated attribute? When creating a calculated attribute there are some things that are good too keep in mind in order to create an optimally fast syntax. Here we are going to describe some advices that should be followed during the design of the attribute. Generally, those advices can be summarized to: Use REF instead of SELECT If you have to use a SELECT – Use WHERE clauses instead of FILTER clauses Filter the FILTER - Filter the list returned to the FILTER as much as you can But let's get into the details. Using a REF means that we are using the collection of elements that have already been loaded in the memory. The REF connection leads only to the records that refer to by the current entity. Using a SELECT means that for each calculation of attribute the system will create a request to the server and will look through the whole table that we have selected. A single table could contain millions of records (or even more). More records inevitably means slower calculation. Like any other design when creating a calculated attribute there usually is more than one way that we can use to calculate the value especially when the calculation is a bit more complicated. Sometimes using SELECT looks like the simplest option (the fist that comes in mind) to reach the value we need, but first, we should always try to think if there is a reference connection that we can use instead in order to achieve a faster calculation. Example: Let's imagine that we need to show a field with Total Line Amount value in the Sales Order Line. Therefore we will need to calculate the Sum of the Line Amount of all Sales Order lines of the particular Sales Order. Such attribute can be created at least two ways (the repository is Crm.Sales.SalesOrderLines): Using a SELECT Using a SELECT (using all records in the Crm.Sales.SalesOrderLines table) 10 SUM EXP:20 ATTRIB:LineAmountValue 20 SELECT REPO:Crm.Sales.SalesOrderLines EXP:30 30 WHERE EXP:40 40 EQUAL ATTRIB:SalesOrderId EXP:50 50 GETOBJVALUE INPUT:10 ATTRIB:SalesOrderId Using a REF Using a REF (using only the lines of the current SalesOrder) 10 SUM EXP:20 ATTRIB:LineAmountValue 20 GETOBJVALUE REF:SalesOrder CHILD:Lines Of course, there are some scenarios in which we want to reach the data of a table to which we simply can use a reference connection. But when using a SELECT the are some tricks that we can use to fast the calculation. When we SELECT a table we can filter its records with WHERE or FILTER clauses. The most important thing that we must know about them is that when using: WHERE clauses – the conditions are applied together with the SELECT to the whole list and directly on the server. Much faster performance in comparison with FILTER, especially for a list with lots of records. FILTER clauses - filters are applied locally (on the client side) to the list that has been returned from the SELECT. Knowing this there are two basic conclusions that we can come to. First, if we should always choose WHERE clauses instead FILTER clauses if possible. Most of the other operators are supported in both cases, but we must say that WHERE clauses have certain limitation. For example, they can not be used along with NOT , OR and LIKE operators (for more information, see SELECT ). If we have no other choice but to use FILTER we proceed to the next paragraph (advice). And second, when we use FILTER clauses we should always try to narrow down the list that we are returning. How to do so? Just apply as much WHERE clauses as possible to the SELECT. This way we are filtering the list before it is returned to the FILTER and therefore it will contain fewer records, which will lead to a faster calculation. As a conclusion, we don’t claim that using a SELECT is a bad thing it is a very powerful tool that just has to be used wisely."
  },
  "advanced/calculated-attributes/QA/HowToDetermineThePartyTypeOfAParty.html": {
    "href": "advanced/calculated-attributes/QA/HowToDetermineThePartyTypeOfAParty.html",
    "title": "How to determine the party type of a party? | ERP.net Tech Docs",
    "keywords": "How to determine the party type of a party? If we need to compare the PartyType to check if it is a company, person or other the following calculation would do the job: CAST ATTRIB:PartyType CONST:System.Int32 Casting the PartyType to integer would return the following values: 0 - Company 1 - Company Location 2 - Person 3 - Store 4 - Company Division"
  },
  "advanced/calculated-attributes/QA/HowToGetAttributeValueFromList.html": {
    "href": "advanced/calculated-attributes/QA/HowToGetAttributeValueFromList.html",
    "title": "How to get attribute value from list? | ERP.net Tech Docs",
    "keywords": "How to get attribute value from list? Often mistake is to try to get a value of an attribute from a list. For example, if we want to get the user who changed the document state: 10: GETOBJVALUE CHILD:StateChanges ATTRIB:UpdateUser This is incorrect expression. The right expression would be to filter the child list and then get the first element of the list. This is an example filtering: 10 GETOBJVALUE EXP:20 ATTRIB:UpdateUser 20 FIRST EXP:30 30 FILTER CHILD:StateChanges EXP:40 40 EQUAL ATTRIB:SystemInitiated CONST:False Explanation: 10: get the value of the UserUpdate field from object in expression 20 20: get the first record in the list in expression 30 30: filter the child list StateChanges by the filter in expression 40 40: check if the attribute SystemInitiated is equal to False"
  },
  "advanced/calculated-attributes/QA/HowToGetSpecificFieldOfAParentDocument.html": {
    "href": "advanced/calculated-attributes/QA/HowToGetSpecificFieldOfAParentDocument.html",
    "title": "How to get specific field of a parent document? | ERP.net Tech Docs",
    "keywords": "How to get specific field of a parent document? When in a calculation attribute there is a need of a value of attribute of the parent document there are two options to get them: The attribute is part of the parent Document table The attribute is part of the specific entity of the parent document If the attribute is part of the parent Document table, than we may get it directly by GETOBJVALUE operator in the following expression: 10: GETOBJVALUE REF:Parent ATTRIB:DocumentNo This expression would be valid for every document which has parent document. But in the second case, when the attribute is part of the specific entity of the parent document (meaning SalesOrder, StoreOrder, StoreTransaction, Payment and etc.) than the user has to tell the calculate attribute what is the parent document. This is done by casting the parent document to the entity which is required (in the example a cast to Offer is used): 10: GETOBJVALUE EXP:20 ATTRIB:DocumentNo 20: CAST REF:Parent CONST:Aloe.EnterpriseOne.Model.Crm.Presales.Offer It is supposed to show such calculated attribute in document form where the parent document is exactly Offer."
  },
  "advanced/calculated-attributes/QA/HowToShowContactOfAPersonInPersonsNavigator.html": {
    "href": "advanced/calculated-attributes/QA/HowToShowContactOfAPersonInPersonsNavigator.html",
    "title": "How to show contact of a Person in Persons navigator? | ERP.net Tech Docs",
    "keywords": "How to show contact of a Person in Persons navigator? The specific of this calculated attribute is that the contact mechanism type is enum type. This is why it is accessed specifically. Its values and codes are as follows: Member name Value Description Address 0 Address value. Stored as 'A'. Mail 1 Mail value. Stored as 'E'. Fax 2 Fax value. Stored as 'F'. MobilePhone 3 MobilePhone value. Stored as 'M'. Other 4 Other value. Stored as 'O'. Telephone 5 Telephone value. Stored as 'T'. WebSite 6 WebSite value. Stored as 'W'. So, lets say we need to get a column with the emails of the persons (if the person has more than one emails - a random one; if a specific email is needed - more filters would be needed). The calculated attribute would have the following expressions: 10 GETOBJVALUE EXP:20 EXP:15 15 GETOBJVALUE REF:ContactMechanism ATTRIB:Name 20 FIRST EXP:21 21 FILTER EXP:30 EXP:22 22 EQUAL EXP:23 EXP:25 23 GETOBJVALUE REF:ContactMechanism ATTRIB:ContactMechanismType 25 CAST CONST:1 CONST:Aloe.EnterpriseOne.Model.General.Contacts.ContactMechanismsRepository+ContactMechanismType 30 SELECT REPO:General.Contacts.PartyContactMechanisms EXP:40 40 WHERE EXP:50 50 EQUAL ATTRIB:PartyId EXP:60 60 GETOBJVALUE INPUT:10 ATTRIB:PartyId Explanation: 10: from the object from EXP:20 get the attribute from EXP:15 15: get the value of the attribute Name from the referent object ContactMechanism 20: get the first element from the list in EXP:21 21: filter the list in EXP:30 by the conditions in EXP:22 22: check if EXP:23 is equal to EXP:25 23: get the value of the attribute ContactMechanismType from the referent object ContactMEchanism 25: cast the constant of \"1\" (this is integer) to type 'Aloe.EnterpriseOne.Model.General.Contacts.ContactMechanismsRepository+ContactMechanismType' 30: select from repository General.Contacts.PartyContactMechanisms and filter it by EXP:40 40: the filter is in EXP:50 50: check if the value of attribute PartyId is equal to EXP:60 60: get the value of attribute PartyId of the input object of expression 10"
  },
  "advanced/calculated-attributes/QA/HowToUseTheCustomerAsACompany.html": {
    "href": "advanced/calculated-attributes/QA/HowToUseTheCustomerAsACompany.html",
    "title": "How to use the customer as a company? | ERP.net Tech Docs",
    "keywords": "How to use the customer as a company? When we work with the customer, we can only get its party attributes as the customer may be company, company location or a person. So if we know that the customer is a company and we need to get his company attributes, we can cast its reference Party to Aloe.EnterpriseOne.Model.General.Contacts.Company. For example, to get the Responsible Person of the company of the customer, the following attribute would do the job: (repository of the attribute: Crm.Customers) Expressions: 10: GETOBJVALUE EXP:20 ResponsiblePersonName 20: CAST REF:Party CONST:Aloe.EnterpriseOne.Model.General.Contacts.Company Note If the customer is not a company, it would return an error."
  },
  "advanced/calculated-attributes/QA/index.html": {
    "href": "advanced/calculated-attributes/QA/index.html",
    "title": "Q & A | ERP.net Tech Docs",
    "keywords": "Q & A How to check if a custom property has value? How to check if a list have values? How to check whether a field that points to a reference object has a value? How to create an optimally fast calculated attribute? How to determine the party type of a party? How to get attribute value from list? How to get specific field of a parent document? How to show contact of a Person in Persons navigator? How to use the customer as a company?"
  },
  "advanced/concepts/aggregates.html": {
    "href": "advanced/concepts/aggregates.html",
    "title": "Aggregates | ERP.net Tech Docs",
    "keywords": "Aggregates What are Aggregates? \"Aggregate is a pattern in Domain-Driven Design. A DDD aggregate is a cluster of domain objects that can be treated as a single unit. An example may be an order and its line-items, these will be separate objects, but it's useful to treat the order (together with its line items) as a single aggregate.\" https://martinfowler.com/bliki/DDD_Aggregate.html Examples For example, in ERP.net, this is one single aggregate: a SalesOrder the Sales Order Lines of this Sales Order the Distributed Amounts for each of these Sales Order Lines the Document Amounts of this Sales Order the Payment Plan of this Sales Order Parent And Root Objects Each object in an aggregate can have a parent object.The parent is the logical \"owner\" of the child object(s). For example: The parent of Sales Order Line is Sales Order . The parent of Distributed Amount is the Sales Order Line . The ultimate object, which has no parent in the aggregate is the Aggregate Root. In this example, this is the Sales Order . Aggregate Events The Commit and ClientCommit events are now available in two different variations: Object Commit / Client-Commit Aggregate Commit / Client-Commit What is the difference? When an object commit event occurs, it means that the object itself was changed. The aggregate event occurs for the object when there is a change in ANY of its constituent objects, but only if the objects is an aggregate root. Lets take a look at the following structure which in EnterpriseOne is one single aggregate: a SalesOrder (which is the aggregate's root) the Sales Order Lines of this Sales Order the Distributed Amounts for each of these Sales Order Lines the Document Amounts of this Sales Order the Payment Plan of this Sales Order In the example above, the Commit event would occur for the Sales Order if and only if the Sales Order object itself has changed. While the Aggregate Commit will occur for the Sales Order if any of the objects in the aggregate has changed. For example, changing just a single Sales Order Line (without changing the Sales Order itself) would still trigger the Sales Order Aggregate event. Note Commit and Client-Commit still have the same meaning. E.g., Commit is the low-level event, which is triggered for everything committed to the database (be it from client request or as a result of some server processing). While Client-Commit is triggered only based on client requests and is considered the more light-weight approach. Note Initially, only the Aggregate Client Commit event would be available for user-defined business rules Business Rules . The Aggregate Commit will be used only internally, for system-defined business rules System Business Rules The reason is to have a more light tread approach. If there is serious need, we can consider adding the Aggregate Commit event in the future for Business Rules . See also: Systems.Core.ExtensibleDataObjects Entity"
  },
  "advanced/concepts/default-language.html": {
    "href": "advanced/concepts/default-language.html",
    "title": "| ERP.net Tech Docs",
    "keywords": "##Default language"
  },
  "advanced/concepts/master-detail-attributes.html": {
    "href": "advanced/concepts/master-detail-attributes.html",
    "title": "Master / Detail Attributes | ERP.net Tech Docs",
    "keywords": "Master / Detail Attributes When a document has the same field in its header and lines then these two fields interact in a specific manner. An example of such fields is the \"Store\" field in the Sales Order header and \"Line Store\" in its Sales Order Lines. The common principle is that if the field in the document header has value, we have to ensure that the corresponding field all document lines contains the same value. On the other hand, if the different lines contain different values - the document's header field must be empty. This principle is very important to avoid misleading the users. Otherwise, if the Store field in the document header could contain a value even if the document lines have different store values - the user may look only in the header and be misled that this store applies to all of its lines as well, which may not be true in all cases. Master / Detail Attributes Concepts and Rules In order to make sure that the main principle described above is followed, is created a set of requirements and rules that are applied for each set of Master/Detail fields. The example for \"Store\" fields in document header/lines is used in the whole description for easy understanding. Concepts In order to allow that different lines may contain different stores and at the same time to follow the main principle - we have to make sure that the Store field in the document header may contain empty (NULL) values. Such value is set only when the document lines have different values. Opposite of this, the value in the field in the document lines is required/mandatory [Required = true] and must always contain a value. It is accepted that the main/leading field is the field in the lines - it is required/mandatory, i.e. there is a guarantee that it always contains a value. For example, if we are generating a Store Orders from Sales Orders - the Store field that is taken into account is the one in the Sales Order lines. We have to create separate Store Orders for each Line Store in order to execute the Sales Order correctly because in the Store Orders there is only one Store field and it is in the header. If the document does not contain any lines, then there is no limitation for the document header value - it doesn't matter if it is empty (NULL) and contains a value (not-NULL). Rules FrontEnd rules When the value of the document header's field is changed, this value is automatically set to ALL document lines. When all document lines have the same value in the Store field, then the field in the document header must contain the same value. The presence of a value in the document header field is an ease for the users - it is not necessary to constantly monitor whether the lines have different values or not. For this reason - after editing the value in the Line Store field and when deleting lines - if it turns out that all lines contain the same Store value, then this value is automatically set in the document header field. When the different document lines have different values in the Store field, then the field in the document header must be empty (NULL). For this reason - after editing the value in the Line Store field and when deleting lines, if it turns out that the line contains a different Store value, then the Store field in the document header is automatically set to an empty value (NULL). When adding a new line, then in the Line Store field is set the default value that equal to the value from the document header (unless another default value is explicitly set). If the document header value is empty (NULL), then as a default value in the new line is considered the value from the previous lines. If this is impossible, hard or inapplicable - then the default value is empty (NULL). BackEnd rules When the document header is saved, the master-detail field's value is updated according to the value of the lines field (if any lines). If all lines contain the same Store value, then this value is automatically set in the document header field. If the line contains different Store values, then the Store field in the document header is automatically set to an empty value (NULL). When а document line is saved, the master-detail field's value is updated according to the value of the field in the header. When the document's header and lines are saved there is a final back end validation. If it turns out that despite the rules above, the values of the master-detail fields do not comply with the rules and principles above is thrown an error: The master attribute '{the name of the field in the header}' should have the same values as the detail '{the name of the field in the lines}' attribute for all lines or null, if there are different values through the lines."
  },
  "advanced/concepts/object-relational-mapping.html": {
    "href": "advanced/concepts/object-relational-mapping.html",
    "title": "Object Relational Mapping | ERP.net Tech Docs",
    "keywords": "Object Relational Mapping Description Entities and Entity Types are terms, frequently used throughout the documentation. Entities are information objects, which represent real-world objects. Entity Type is the collection of all objects of a given type. For example, the Customer XYZ is an entity. Customer ABC is another entity. All customers are of an entity type, called 'Customers'. Definitions Entity - Single object of a given Entity Type. Also called entity object or simply object. It is similar to a data row in a table. Entity Type - The set of all objects of a given type. This is similar to a table. Attribute - a named value, containing information about the entity object. This is similar to a column in a table. Relationship to tables and rows This section contains more advanced information, not usually needed to operate the system. However, a deeper understanding of the inner-workings might help sometimes, especially when one needs to access directly an ERP.net database, using database tools. Generally, Entity Types , Entities , and Attributes are much like Tables , Rows , and Columns . Data of the entities is ultimately stored in the database in the form of tables and rows. However, there is one important distinction - Entity Types and Entities are object-oriented representation of the table data. A technology, called ORM (Object-Relational Mapping) is used to map between entities and tables. In order to illustrate better the difference between objects and tables, let's include some real-world tables and objects: There is an entity type, called 'Party'. It has a descendant (more specialized) entity type, called 'Company'. So, Party is the more abstract and broad term, and Company is just one specialization. Person is another descendant of Party. Let's illustrate this using pseudo-graphics: Party +---- Company +---- Person Each Party has some attributes, like \"Parent Party\" and \"Area\". The company has \"VAT Number\" and \"Registration Type\" attributes. Each Person has \"First Name\" and \"Last Name\". Now, if we look at the tables, they have the following schema: Parties Party Id Parent Party Id Area Id Companies Party Id VAT Number Registration Type Person Party Id First Name Last Name If we look at the objects, they will have the following attributes: Party Parent Party Area Company Parent Party Area VAT Number Registration Type Person Parent Party Area First Name Last Name So, if we use table data, in order to access all attributes of a company or a person, we have to relate (join) data from different tables, using unique Identifiers. The identifiers are the so-called \"surrogate keys\" because they are existing only in the database and have no real-world counterpart. Using such keys and relating data between tables is ordinary in the relational world of the databases. However, internally, the systems use objects, because it is much simpler to process them. Objects already have all the necessary attributes related together and there is no need to use Identifiers or table relations. This is only an introduction to the topic of object-relational mapping. More deeper look would go too deep into the developer details of the subject."
  },
  "advanced/custom-attributes/domain-with-property-allowed-values.html": {
    "href": "advanced/custom-attributes/domain-with-property-allowed-values.html",
    "title": "Domain with Property Allowed Values | ERP.net Tech Docs",
    "keywords": "Domain with Property Allowed Values Domain is the range of the allowed values of the particular Custom Property. It is determined in one of the following ways - sorted by priority: If \"Limit To Allowed Values\" does NOT have a check mark, then any value is valid and the domain is a range of all possible values. If the \"Allowed Values Entity Name\" has a value, then the domain is the set of all records of the specified data type. Note This field should have a value ONLY if \"Limit To Allowed Values\" has a check mark and \"Allowed Values Property\" does not have a value. If the field \"Allowed Values Property\" has a value, then the domain of the current custom property is equal to the domain of the custom property specified in this field. CustomProperty.Domain = CustomProperty.AllowedValuesProperty.Domain Note This field should have a value ONLY if \"Limit To Allowed Values\" has a check mark and \"Allowed Values Entity Name\" does NOT have a value. (Default, Lowest Priority) The domain is the range of the \"Property Allowed Values\" listed in the Gen_Property_Allowed_Values sub-table. Example 1: Let's assume that we have the following properties: Property 1 (Entity Name = Products) Property 2 (Allowed Values Property = Property 1) Property 3 (Entity Name = Products) Property 4 (Entity Name = Companies) Property 5 (Allowed Values Property = Property 2) Property 6 (Limit To Allowed Values = False) In this case, the domains are: Property 1 - Products Property 2 - Products Property 3 - Products Property 4 - Companies Property 5 - Products Property 6 – All possible values Compatible Custom Properties Two custom properties are copy compatible when then and only then their domains are the same. The compatibility allows us to copy values from one custom property to another. It is still possible the copying to throw an error, but this would be caused by different reasons – additional filters set in the definition, for example An important note is that the additional filters do not change the domain of the custom property. They just reduce the range with allowed values. It is also possible future procedures or rules to be added – but they won’t change the actual domain of the custom properties either. In general, we can accept that the domain of the allowed values, from a programming point of view, could be defined as a kind of custom property type. Example 2: If we use the description of Example 1, we can conclude that Property 1 is compatible with Property 2. Both of them are compatible with Property 3 and Property 5. On the other hand Property 1, Property 2, Property 3 and Property 5 are compatible with each other. Property 4 in not compatible with none of the above. Property 6, although it could receive any possible value, is also noncompatible with other custom properties. Inheriting and hereditary root A custom property inherits another custom property by indicating a (hereditary) parent property in the \"Allowed Values Property\" field. The hereditary root is the grand-parent, which does not have a hereditary root on its own. The hereditary root of a custom property clearly defines its domain and is a prerequisite for automatic copying of its allowed values. A hereditary root is defined as follows: If \"Allowed Values Property\" does not have a value, then the hereditary root is the custom property itself Otherwise, the hereditary root is equal to the hereditary root of the parent custom property. This means that: HereditaryRoot (Property) = HereditaryRoot(Property. AllowedValuesProperty) i.e. we look recursively in the relation “Allowed Values Property”. Example 3: If we use the example above, custom properties have the following hereditary roots: Property 1: Property 1 Property 2: Property 1 Property 3: Property 3 Property 4: Property 4 Property 5: Property 1 Property 6: Property 6 Copying Hereditary roots are used to determine the most appropriate \"partner\" for the automatic copying of the allowed values of the custom properties. We will look at an example in which we want to copy custom properties from a Customer to a Sales Order document: Example 4: Let’s assume that: the Customer has the following custom properties: FAVORITE-PRODUCT: (Entity Name = Products) ADVANCE-PRODUCT: (Entity Name = Products) In the Sales Order document type are set the following custom properties: FAVORITE-PRODUCT-CUSTOMER: Allowed Values Property = CUSTOMER. FAVORITE-PRODUCT SALE-ADVANCE-PRODUCT: Allowed Values Property = CUSTOMER.ADVANCE-PRODUCT In this case: All 4 custom properties are \"compatible\". They could inherit values from one another. At the same time, only the following pairs have the same hereditary root: ​ A) FAVORITE-PRODUCT-CUSTOMER and FAVORITE-PRODUCT ​ B) SALE-ADVANCE-PRODUCT and ADVANCE-PRODUCT Copying: Accordingly, when specifying a Customer in Sales Order, only the custom properties that have the same hereditary root will be automatically copied from the Customer to the Document. Custom properties value priorities (when copying to a document) The priority for automatic copying of custom properties to a document is determined according to the following priorities (from the highest to the lowest priority): Note The priorities represent the following logic. If for a custom property is found a value with a higher priority, then – copy the value. If not – search for values with lower priorities Inherited values from the parent document. (Priority 80) The values set in the panel \"Copy customer properties\" (valid only for Sale Orders, but the same priority applies if there is a similar table for other types of data). (Priority 70) Values from custom properties with the same hereditary root in the definition of the „main contractor” of the document. In general cases, this is the party loaded in the field \"To Party\" (an exception are Purchase Invoices, where the Supplier is considered as a \"main contractor\"). (Priority 50) The default values specified in the document type. (Priority 20) If none of the above contains a value for the custom property, but it is specified in the document type – set an empty (NULL) value. (Priority 10) Note Every manual change of value of custom property, should be done after being entered values in all relevant nomenclatures (Enterprise Company, Customer, Parent document etc.)"
  },
  "advanced/custom-attributes/index.html": {
    "href": "advanced/custom-attributes/index.html",
    "title": "Custom Attributes | ERP.net Tech Docs",
    "keywords": "Custom Attributes Custom Attributes (also called \"Custom Properties\") allow the user to extend the data model with user-defined attributes. Custom Attributes store values in the database, extending the system tables. Similarity With System Attributes The custom attributes behave mostly like the system attributes. They can be shown in columns, grouped and filtered in navigators just like system attributes. Again similar to system attributes, they can have default values and shown in the view of data forms. Most of the time, the end users can't distinguish between system and custom attributes. It is up to the implementation team to define custom attributes, which fit best the implementation requirements. Note Many custom attributes can easily be defined and set as \"required\". However, this might endanger the whole ERP implementation, since requiring too much data entry for each operation can alienate the end users from the system. Carefully balance the business needs with the end user comfort."
  },
  "advanced/data-objects/extensible-data-objects.html": {
    "href": "advanced/data-objects/extensible-data-objects.html",
    "title": "Extensible Data Objects EDO | ERP.net Tech Docs",
    "keywords": "Extensible Data Objects EDO Description And Usage The Extensible Data Objects (EDO) is a system in ERP.net, which allows attaching additional data to all entities in the system. Types of additional data, which can currently be attached: File Attachments. Track Changes change tracking data. How It Works? EDO objects are stored in the Sys_Objects entity. The system works in the following way: An object in any entity requires attaching additional data. A new record is created in Sys_Objects. The additional data is created in sub-tables, which have referential integrity to Sys_Objects. The record in Sys_Objects has only untyped soft reference (not referential integrity) to the original record. It contains Entity_Type and Entity_Item_Id fields, which uniquely identify the original record. All additional data is related to Sys_Objects through typed referential integrity. In this way, the only untyped soft reference is the original reference in Sys_Objects , but most data is solidly related through typed referential integrity. Note The Custom attributes system was implemented prior to the Extensible Data Objects system, so it also uses untyped soft reference. If we would have to design the Custom Properties system now, it would be implemented as \"additional data\" to the EDO system. Future Plans The EDO system is very useful for creating additional data, which can be attached to multiple entities. It is not required that the type of data should be attachable to ALL entities. The data model allows attaching data to any entity, but system business rules or Business Rules can be used to limit the entities, which actually \"accept\" the data. Possible (planned) future uses: Comments/Replies - many objects in the system can be augmented by allowing the users to comment and reply to them. All kinds of attachments - links, pictures, other system objects, etc. Tags/Labels for back-link navigation. Future simplified implementation of custom properties. Reactions - Facebook style reactions. Reviews - marketplace style reviews. See also: Systems.Core.ExtensibleDataObjects Entity"
  },
  "advanced/data-objects/index.html": {
    "href": "advanced/data-objects/index.html",
    "title": "Data Objects Management | ERP.net Tech Docs",
    "keywords": "Data Objects Management Data Objects are a design pattern, used to encapsulate logic, which is available to most data records in the system. Each aggregate root is a data object. All data objects have some common attributes, sub-entities and operations. The following data and operations can be associated with a data object: Track changes [File Attachments] For more detailed information, see Extensible Data Objects ."
  },
  "advanced/data-objects/track-changes.html": {
    "href": "advanced/data-objects/track-changes.html",
    "title": "Track Changes | ERP.net Tech Docs",
    "keywords": "Track Changes Track Changes is a system in ERP.net, which can be used to track the changes in any data table. Tracking Levels The tracking levels specify the detail level of the tracking, as per the following table: Track Changes Level Name Description 0 Do Not Track Changes Do not track any changes for this entity. 1 Track Last Change Store information only for the latest modification of the tracked object. 2 Track Object Changes All the data of Level 1 + General tracking information about each update of the object. Do not store information about the changes in the attributes. 3 Track Object & Attribute Changes All the data of Level 2 + Information about the changes in the attributes, excluding the BLOB attributes. The BLOB (Binary Large Objects) attributes are large size attributes like images, files, etc. 4 Track Object, Attribute & BLOB Changes All the data of Level 3 + Changes in the values of BLOB attributes. Effects And Storage The system stores information based on the tracking level. The following topics summarizes the stored data and other considerations and remarks: Level 0 - Do Not Track Changes. No information is stored. Level 1 - Track Last Change Store information only for the latest modification. This is the lightest tracking mode with the least storage requirements. The information is stored in the Systems.Core.ExtensibleDataObjects Entity Note Extensible Data Objects object is created and maintained ONLY for the root object of the object Aggregates ). Upon first update of the tracked object, a new EDO record is created, if there isn't already one. For each successive update of any object in the aggregate, the data in the EDO is updated. The tracking data includes: Version Number - incremented on each update Creation User - the user who initially created the tracked object (if Track Changes was enabled by that time). Creation Time (UTC) - the time of initial creation in Universal Coordinated Time (UTC) timezone. Last Update User - the user who performed the last update OR deleted the object. Last Update Time (UTC) - the time of the last update. Is Deleted - specifies whether the tracked object is deleted. After the tracked object is deleted, the Extensible Data Objects information stays in the DB for some time, but can be purged by cleanup processes. Please note, that when the tracked object is deleted, the deletion user & time are stored in the Last Update User / Time. Level 2 - Track Object Changes With this level, the Extensible Data Objects is still updated, but also, for each modification, a new record is created in two tables: Systems.Core.ObjectChangesets Entity contains data about change-sets. A change-set is one modification request, sent to the server. One request can contain modifications (creates/updates/deletes) of multiple objects. Each change-set stores the following data: User - the user, who initiated the server request. Time (UTC) - server time in UTC, when the request was executed. Application - the name of the client application, which executed the request. Server Version - the version of the server by the time when the request was executed. Object Changes stores one row for each modified object. One change-set can contain data about multiple object changes. The following data is stored: Repository Name - the name of the object repository, containing the object. Entity Item Id - the Id of the tracked object. Change Type - the type of modification: C, U or D for Create/Update/Delete. Root Object Id - the Id of the Extensible Data Objects for the root object of the Aggregates . Level 3 - Track Object & Attribute Changes When this level is selected, all the data for Level 2 is still stored and maintained. But now, also data about each attribute (field) change is also stored. Note This tracking level can consume A LOT of disk space. Use it only when absolutely necessary. Also, make sure to setup some cleanup process (integrated or external). Attribute Changes stores the following data about each attribute change: Attribute Name - the name of the changed attribute New Value - the string representation (culture insensitive) of the new value Some attribute changes might not be \"sensed\" correctly by the system. Since the Track Changes system works at the application level, changes made by direct SQL statements will not be recorded. When a next update occurs, the system will record the changes to the attribute like it is being made by the next update. This behavior is by design. The most frequent effect of this behavior is that the Document No attribute (which is set by SQL statements and not by the application layer) is recorded as being changed by the 2nd modification of the document. Only the new values are stored (not the old values). This design was chosen for the following reasons: We do not store both old values AND new values to save space. If only the old (and not the new) values are stored, the track changes algorithm can save some space (initial object creation do not need to store values), but performance suffers. This was the initial implementation of the track changes system, but it was abandoned. The track changes process needed to synchronously read the previous database value before each update. This slowed down the actual database transactions and it was decided that the \"new values only\" approach would better fit the performance requirements. The storage of the new values can be performed asynchronously AFTER the actual database transaction has completed. In this way, the track changes system has very minor effect on the speed of the every-day OLTP transactions. One drawback of the asynchronous saving is that, upon server crash, the track changes data about the attribute changes might be lost. In this case, the Object Change will still be recorded, because it is recorded synchronously (as part of the transaction). Level 4 - Track Object, Attribute & Blob Changes Same as Level 3, but the values of BLOB attributes are also saved. This can severely affect the storage requirements and should be used only for small tables and as last resort measure. Configuring Track Changes The Track Changes functionality is activated through the Systems.Core.EntitySettings Entity table. Steps: Create a record in Entity Types, specifying the desired entity. In the Track Changes Level field, fill the desired tracking level. Save and close. The tracking will shortly start. For document entities is provided an opportunity for mass activation of the Track Changes system using the DocumentVersioningSystem registry key. For more information see the description key number 42 in the Config Options Reference topic. Note If you try to configure a level lower than the default tracking levels, the option will be ignored. Default Tracking Levels Some entities are configured by default to track their changes. The default tracking level is system configured and cannot be lowered. However, the users can specify higher tracking levels. The following table contains the default system specified tracking levels. Entity Default Tracking Level Activated in version Entities 3 2019.1 Config 3 2019.1 Products 2 2019.1 Parties 4 2019.1 Companies 3 2019.1 Company Locations 3 2019.1 Persons 3 2019.1 Enterprise Companies 3 2019.1 Payment Types 2 2019.1 Payment Accounts 2 2019.1 POS Locations 3 2019.1 POS Terminals 2 2019.1 POS Operators 3 2019.1 POS Roles 3 2019.1 POS Sequences 2 2019.1 Users 3 2019.1 Groups 3 2019.1 User Groups 3 2019.1 Group Access Keys 3 2019.1 Document Types 4 2019.1 Printout Layouts 4 2019.1 Calculated Attributes 3 2019.1 User Business Rules 3 2019.1"
  },
  "advanced/documents/additional-amounts.html": {
    "href": "advanced/documents/additional-amounts.html",
    "title": "Additional Amounts | ERP.net Tech Docs",
    "keywords": "Additional Amounts The additional amounts are a mechanism for reporting financial amounts in documents that are not contained by the document rows and/or do not represent measurement of the main purpose of the document. The main purpose is written in the document rows or in the document header. For example: product price or product cost (goods or services), which is sold or bought; enterprise company asset price or cost (fixed, financial or rental); value/amount of monetary transaction (transfer, payment or obligation). The amounts listed above are base amounts in documents and they are NOT additional. The additional amounts are not proper to be reported along with the main document purpose or they are secondary effect of the main document purpose. These are some examples: VAT (and other taxes) - taxes, like VAT, are not products which the enterprise company is selling, producing or supplying; bеcause of this the taxes are usually reported as additional amounts in the documents; VAT deviation - this is special amount used for equalization of the VAT in the store sales (because of specific roundings); this amount is addition because it is used to obtain the legal rate of the VAT. taxes (as customs) - the same principals as in the taxes are applied; discounts - some types of customer discounts are represented as additional amounts; they are entered as additional amounts when the discount cannot be entered in a specific document row or there are no active promotions or bonus programs, which control this discount; increases and decreases - the same principle is applied as in discounts; if the increases and/or decreases cannot be defined in the rows or as part of a sale instrument such as promotional programs or bonus packages, than they are entered as additional amounts; commissions (and other internal mechanisms for payments or money accounting) - commissions and similar can be entered as additional amounts too; if they are used as additional amounts, they can represent a percent of the document amount and the result can be used for recording internal company performance indicators or personal employees indicators."
  },
  "advanced/documents/adjustment-documents.html": {
    "href": "advanced/documents/adjustment-documents.html",
    "title": "Adjustment Documents | ERP.net Tech Docs",
    "keywords": "Adjustment Documents Using Adjustment Documents is a system to adjust released documents. As the released document states that the execution of the document has already started, therefore the released documents are read-only (see Document States ). So when there is a need to change such a document, the usual way of editing it is not available and a specific system is needed. The Adjustment Documents are separate documents trough which a released document can be edited. They contain the main document that they are making corrections on. So one released document may have more than one correction. The Adjustment Documents are allowed two (see Document States ) - New and Corrective . The Corrective state is specific only for the Adjustment Documents and it is not allowed at the rest of the documents. When the document state is switched from New to Corrective, the changes in the adjustment document are applied to the main released document. Then the field \"Adjustment Number\" is filled in with the consecutive number of the correction. The Adjustment Documents contain only the changes which has to be applied. For example, if there is a released issuing Transaction with 10 PCS and it turns out that now only 8 PCS are issued, in this case, an adjustment issuing Transaction is executed with the quantity of -2 PCS . Thus, it can be considered that the adjustment document is the difference between the current values in the released document and the values, which have to be achieved after the correction. So the current data in every released document are a result of the original data (the document content when released for the first time) and the data added by all adjustment documents. This mechanism is preferred over the direct redaction of the released documents because of easier tracking of the separated corrections that are executed (tracking of these changes is important). For example, in the previous example with the Transactions, the user may easily see that the quantity has been decreased by 2 PCS by the adjustment document. Otherwise, the user would have to compare the consecutive versions of the main document which may be a complicated and uncomfortable task, especially with large documents. Also, this mechanism allows the Adjustment Documents to be used for adjustment of Transitional Documents and sub-documents. Adjustment Document Application The mechanism, when an adjustment document (when the document state is switched to Corrective) is applied on the main released document, is as follows: For each record in the adjustment document its corresponding record in the main document is searched. Matching the records is as follows: ​ a. if the record is in the adjustment document header, than the corresponding record is in the header of the main document; ​ b. if the record is in a row in the adjustment document then the record from the same row table in the main document is searched. The record should have the same natural key as the adjustment record; as natural key usually the document row number is used or another field (if there is no row number); for example, if in the adjustment document there is a row with number 30 , then in the main document a row in the same table and with the same number 30 is searched. If no corresponding record is found in the main document (this is possible only if the current record is in the rows of the adjustment document), then the adjustment record is simply added to the corresponding table in the main document with no changes in it; If a corresponding record is found in the main document, then the system reviews all the fields in the correction record and the following applies to each field: ​ a. if the field is a key field (see the article about Key and Scalar-Valued Fields), then it is checked if it has the same value in the main document and in the adjustment document; if there is a difference, the adjustment is rolled back, and the user is notified by an error message; ​ b. if the field is scalar-valued (see the article about Key and Scalar-Valued Fields), then the value of the adjustment record is added to the value of the main record; ​ c. if the field is neither key nor scalar-valued , then the value of the main record is replaced by the value of the adjustment record. Thus, in the adjustment document, only the changes in the main document are marked. I.e. the user can decrease or increase the value of a scalar-valued field (quantity or amount) or change/replace the value of a field that is neither key nor scalar-valued. Note Key fields cannot be adjusted by adjustment documents! Also if the adjustment document has no record corresponding to a record in the main document, then the original document will not be changed after the correction takes place. For example, if in the main document there is a row with a number 30 , and in the adjustment document there is no such row, then row 30 from the main document will remain unchanged after the correction. What can be done by Adjustment Documents? Can adjust values of non-key fields (the scalar-valued fields are adjusted by adding the value in the adjustment document, and the rest of the fields are adjusted by replacing the value with the one from the adjustment document); New records can be added in row tables; All scalar-valued fields in a row can be reset (so the row will no longer affect the document behavior). What Cannot be done by Adjustment Documents? A value of a key field cannot be changed; A row cannot be deleted. Special Types of Adjustment Documents There are some special types of adjustment documents in ERP.net, which are prepared by the system and the user does not have to fill the scalar values in them. Such types are the Nullify Corrections . They are accessible in all documents and are used to adjust all scalar-valued fields so they become 0 . By this correction, the document no longer \"has value\" (i.e. it does not order or fulfill any quantities or amounts). This is an alternative to document voidance. For the Receiving Orders there two special types of adjustments - Correction according to stored quantities and Correction according to invoiced quantity . The first type automatically calculates the necessary correction so the quantities in the Receiving Order become equal to the quantities from the current Receiving Order which are receipts in the store. This correction is used to eliminate the difference between the Receiving Order and its Transactions. The second type is used to equalize the quantities in the Receiving Order as they are in the Purchase Invoices, created for the current Receiving Order."
  },
  "advanced/documents/document-flow.html": {
    "href": "advanced/documents/document-flow.html",
    "title": "Document Flow | ERP.net Tech Docs",
    "keywords": "Document Flow"
  },
  "advanced/documents/document-fulfillment.html": {
    "href": "advanced/documents/document-fulfillment.html",
    "title": "Document Fulfillment | ERP.net Tech Docs",
    "keywords": "Document Fulfillment Description Fulfillment is related to the document generation. Fulfillment makes sure that all quantities and amounts from the parent document are transferred to the sub-document. Differences in quantities and amounts between the parent and the sub-document require fulfillment. Documents in ERP.net usually require complete fulfillment before their state can be set to Completed. Fulfillment documents A document is fulfilled with another document. For example: Shipment Order is fulfilled by creating a Shipment . Invoice Order is fulfilled by creating an Invoice . ...and so on. As can be seen in the example, different document entity types usually come (at least) in pairs - orders and execution pairs of entity types. Actually, more and more entity types come in triples - requisition, order and transaction; but that is a different discussion. Note Order documents naturally require fulfillment, which is recorded as execution documents. Discrepancies in quantities and amounts between the parent and the sub-document(s) Quantities and amounts in a sub-document may not always represent an exact execution of the parent document. Why there are differences between the parent and the sub-document? Differences can arise for many reasons: Partial execution. For example, we shipped goods partially. In this case, the Shipment does not completely fulfill the Shipment Order. Partial payment by customer. Adjustments to the parent document, because of processing errors. Adjustments to the parent document, by customer request. Adjustments to the sub-document. etc. All these cases require fulfillment before the document state can be set to Completed. Fulfillment tracking Fulfillment tracking is the process of calculating what remains to be fulfilled and how it is divided in the terms of detail lines. For example, a Sales Order from a customer requests shipment of 10 Oranges. We shipped 8 Oranges and 2 Tangerines. Did we fulfill the Sales Order? The system tracks the fulfillment of a document, using several tracking techniques: Natural matching Parent line Fulfillment table Natural matching Natural matching matches the parent and the sub-documents, based on natural attribute values. Note Natural attributes are attributes, representing real-world things. This is in contrast with artificial attributes, which are required by the inner workings of the software system. In the example above, natural matching will compare the values of: Product Product Variant Lot Serial Number So, let’s review the previous example in the light of natural matching. Sales Order: Line 1: Oranges, 10 kg Shipment: Line 1: Oranges, 8 kg Line 2: Tangerines, 2 kg Natural matching will not qualify the shipment of Tangerines as execution of the sale of Oranges, because it is a different Product. Even if the customer agrees to accept the Tangerines, we cannot represent this in the system. Another example. The customer might order specific lot of the product, but they are ready to accept another lot: Sales Order: 10 Oranges, lot 202 Shipment: 10 Oranges, lot 203 This shipment satisfies the customer in the real world. However, using natural tracking, this will be considered a severe difference. The system will propose reversal of the shipment of lot 203 and shipment again of lot 202. Obviously, this is problematic and might confuse the users. Even more problematic, and more real-world example if two or more lines of the Sales Order contain oranges. In this case, natural matching simply does not work well. The benefit of natural matching is that it does not require special (artificial) tracking attributes or tables. However, it does not work well for some real-world scenarios. Natural matching is used in document generations, created in the earlier stages of ERP.net, but is mostly abandoned in newer developments. Parent line Parent line is widely used algorithm in ERP.net for keeping track of the execution. The idea is simple: The sub-document keeps reference to the parent line, which is being executed. For example: Sales Order: Line 1: Oranges, 10 kg Line 2: Apples, 2 pcs Shipment: Line 1: Oranges, 8 kg, Parent Line = 1 Line 2: Tangerines, 2 kg, Parent Line = 1 Line 3: Pears, 2 pcs, Parent Line = 2 Here, we can see that, although we sent Tangerines, they replace the Oranges. And we sent exactly the missing quantity. And we sent Pears, instead of Apples. Note The measurement unit of the sub-document line should be the same as the parent line. Of course, all this has to be arranged with the customer. The important thing is that, once arranged with the customer, we have to represent in it in the system. Parent line system allows that. Fulfillment table As good as parent line algorithm is, it cannot be used in all places. There are cases, where it might simply be impossible or very hard to match all sub-document lines using only parent line. For example, in the WMS, suppose we have the following: Warehouse Requisition: Line 1: Despatch Oranges, 10 pcs Line 2: Despatch Apples, 2 pcs In the optimization phase, the WMS has created the following plan: Warehouse Order: Line 1: Pick Oranges, 30 pcs (because there are also other orders and all will be sorted out on the packing table) Line 2: Pick Apples, 2 pcs Line 3: Move everything to packing table 3. Obviously, we have a problem here establishing a direct relationship with the parent document. The solution is to use Fulfillment table. The fulfillment table is like a notebook, in which we record how much of the quantity has already been created for the sub-document. This allows the system to create complicated sub-documents, without tracking the direct relationship of the created lines with the parent lines. In this example, after creating the Warehouse Order, the fulfillment table will contain: Warehouse Requisition XXX, Execution of Line 1: Qty:10 Warehouse Requisition XXX, Execution of Line 2: Qty:2 The fulfillment table simply contains the executed quantities, without any regard of how they are executed. It does not contain any reference to the sub-document(s). The system tracks the execution, without specifically deciphering the sub-document(s) contents. The fulfillment table algorithm allows the application of complex algorithms for execution. These algorithms do not need to represent the parent document lines 1:1 with the sub-document lines and hence have the freedom to employ complex optimization techniques."
  },
  "advanced/documents/document-generation-and-transitional-documents.html": {
    "href": "advanced/documents/document-generation-and-transitional-documents.html",
    "title": "Document Generation and Transitional Documents | ERP.net Tech Docs",
    "keywords": "Document Generation and Transitional Documents Transitional Documents Transitional documents are documents, which are automatically maintained to always contain the most current information from the parent document. They are automatically generated first and then, on each change in the parent document, are adjusted with the latest changes. Transitional documents, by default, are hidden from the document flow. Since they are totally automated and not user-created, they are usually of no interest to the user. They are used just to keep the document flow contiguous, but are hidden to keep it clean. Not all generations can create transitional documents. Only deterministic generations can create such documents. Transitional document setup To setup a document type as transitional: Go to the document type definition and select \"Transitional Document\". To generate documents of this type, use only generations, that support transitional document generation. Deterministic Generations Not all generations support generating and adjusting (patching) a transitional document. Since the adjustment (patch) procedure supports matching the lines primarily by Line No , the generation should guarantee to always generate the same line numbers, given the same starting document. In other words, if we execute the generation several times for the same document, the same resulting line numbers will be generated. This can be guaranteed if the generation generates the sub-document(s) using data only from the source (parent) document and does not look outside it. Common external data, that can make a generation non-deterministic include: Using date or time Using available quantities Using data from the definitions of related objects Actually, generations sometimes use outside data and are still considered deterministic . The main driving factor is whether the outside data influences the resulting line numbers. If the generation uses outside data, but still maintains generating the same line numbers, it is still considered deterministic for the purposes of document generation. Most commonly, deterministic generations simply: Generate exactly one line for each parent line. Use the line number from the parent line to set the line number of the generated line (e.g. they do not use auto-numbering). For example, let's have the following Sales Order: Sales Order Line 10: Product1 Qty=15 Sales Order Line 20: Product2 Qty=25 Let's have two generations, that use this input to create a Store Order: Generation A Generates the Store Order using strictly the data from the Sales Order and generates: Store Order Line 10 : Product1 Qty=15 Store Order Line 20 : Product2 Qty=25 Generation A is deterministic and can support adjusting transitional documents. Generation B The generation uses the current available quantities to split the lines of the sales order, based on the availability of the different lots. This generation creates: Store Order Line 10 : Product1 Lot11 Qty=8 Store Order Line 20 : Product1 Lot12 Qty=7 Store Order Line 30 : Product2 Lot21 Qty=25 Generation B obviously cannot be used to adjust (patch) the generated document, because the line numbers of the generated document will vary, based on the current availability. Generation B is non-deterministic Adjustment Procedure When a transitional document is generated, if later the document needs to be adjusted (to be in-line with its parent), an Adjustment Document is created. The adjustment document is a document, which contains changes . It is a peer document in the document tree and is usually hidden. The adjustment document is used to adjust (patch) the main document. The adjustment is executed upon setting the \"Adjustment\" document status. After the adjustment, the main document is updated to reflect the changes brought by the adjustment document. Generating Adjustment Documents When a generation, which supports adjusting transitional documents, is executed, it checks the sub-documents. If it founds documents, that can be adjusted (patched), it automatically generates changes-only document(s). The generations usually determine the changes in the following way: If quantity, amount or other scalar attribute is updated, a changes line is generated, containing the numeric difference between the scalars. If notes, dates or other non-scalar attribute is updated, a changes line is generated, containing the new values for the non-scalars. Rule 1 and 2 can be combined. E.g. a changes line can combine both scalar and non-scalar changes. The main difference is, that scalars are updated with difference value, while non-scalars are updated with last value."
  },
  "advanced/documents/document-states.html": {
    "href": "advanced/documents/document-states.html",
    "title": "Document States | ERP.net Tech Docs",
    "keywords": "Document States Description The documents in the system have a current STATE. This state determines the effect on the system and whether the document can be updated. The allowed states of the document are: New - the document is entered and saved in the system but does not affect (on planning, availability, etc.) Planned - the document is planned automatically by the system to occur at some point in the future Firm Planned - the document is planned to occur at some point in the future by a user. Firm Planned status is automatically set by the system if a user edits a Planned document. Released - the document is released for execution. The responsible party starts to execute it. Completed - the activities of the document are finished. Sometimes this state is also referred to as \"Finished\". Closed - the document is verified and no more changes are expected in it. Document Editing Rules Whether a document can be edited by a user depends on its state: New - the document can be edited freely. Planned - the document can be edited, but if you save the changes, the state will automatically change to Firm Planned (see below). Firm Planned - the document can be edited. Released - the document can no longer be edited, but an Adjustment Document can be created and applied (see heading below). Completed - the document cannot be changed, but its state can be returned to Released. Closed - the document cannot be changed, but its state can be returned to Completed. Planned documents reflect a plan, created automatically by the system. On the next planning run, planned documents are usually erased or voided (actually the system tries to erase them, but if they use sequence generators, they can only be voided, not erased). The Firm Planned state helps avoid the voiding. When a user makes changes to Planned document, the system changes the state automatically to Firm Planned in order to protect the user changes before the next planning run. Note Planned sub-documents are also erased or voided when a parent document state changes. This behavior is system defined and cannot be changed. Planned documents can only be protected from voiding by making them Firm Planned. Rules for Changing Document State Changing the document state usually goes straight, from New to Closed. However, sometimes it might be needed to revert back to the previous state. The following table shows when this is allowed: Old State New State Allowed Planned New Allowed Firm Planned Planned Allowed Released Firm Planned Not Allowed Completed Released Allowed Closed Completed Allowed There is a borderline at the Released state - once reached, the state cannot be reverted. The document can only be voided. Parent Document Relationship Type When a document has a Parent Document, there are constraints, which determine which states are allowed. The applicable states depend on the relation between the parent document and the child document. The relationship is contained in the Parent Document Relationship Type attribute. Its possible values are: Sub-Task - the child document is a sub-task that must be completed to complete the parent document Next Task - the child document is not related to the next task and the parent document can be completed without waiting for the child document to be completed. For example, the Sales Order to Store Order relationship is usually of Sub-Task type, because to complete the Sales Order , the Store Order must be completed first. In contrast, the Offer to Sales Order relationship is usually of the Next Task type because the work on the Offer can be completed once the Sales Order is created. There is no need to complete the Sales Order first, to complete the Offer. . The allowed child document states depends on the relationship type and the parent document state. The following table summarizes the allowed states: Relationship Type Parent State Allowed Child States Sub-Task New New Sub-Task Planned New, Planned Sub-Task Firm Planned New, Planned, Firm Planned Sub-Task Released New, Planned, Firm Planned, Released, Completed, Closed Sub-Task Completed Completed, Closed Sub-Task Closed Closed Next Task New New Next Task Planned New, Planned Next Task Firm Planned New, Planned, Firm Planned Next Task Released New, Planned, Firm Planned, Released, Completed, Closed Next Task Completed New, Planned, Firm Planned, Released, Completed, Closed Next Task Closed New, Planned, Firm Planned, Released, Completed, Closed Adjustment Documents Adjustment Documents are documents, which adjust other documents. Adjustments can be made only on documents, which are in the Released or Completed states. Adjustment documents can change only primary measurement values. They are usually used to increase or decrease quantities and/or amounts of released documents. Adjustment Documents are separate documents, but when applied to a main document, they change its internal values. If an adjusted document is opened on the screen, it will look like it always has been adjusted. The previous versions of the document are securely stored and can be revealed by the document history. The adjustment documents come in effect (e.g. change the main document) when their state is changed to the special \"Adjustment state\". As these documents are only used to adjust other documents, they cannot have parent and/or child documents. Planning Only Some documents are created specifically only for planning purposes. They are not intended to be ever released. There is a special flag, which signals this intention to the system, called \"Planning Only\". When this flag is set, the system would allow only New and Planned states for the document. No upper states would be allowed by the system. Usually, the document is later voided by its creator (when the plan changes or actual execution is about to begin). User-Defined Document Statuses Each Document Type can contain user-defined sub-statuses to the system states. For example, one can define the following user statuses for a document type, called \"Direct Production Order\": Document Type(user defined) Document State(system defined) User Status(user defined) Exit Status(Yes/No) Document Type(user defined) Document State(system defined) User Status(user defined) Exit Status(Yes/No) Direct Production Order New Direct Production Order Planned Direct Production Order Firm Planned For Processing Direct Production Order Firm Planned Needs Check Direct Production Order Firm Planned Needs Approval Direct Production Order Firm Planned Approved Yes Direct Production Order Released Started Direct Production Order Released Tested Yes Direct Production Order Completed Direct Production Order Closed Each system state can have as many user statuses, as needed. As shown in the table above, one of the user statuses within each system state can be defined as Exit Status. The Exit Status is required to be reached to move to the next system state. In the example above, in order to release a Direct Production Order, the Firm Planned/Approved state must first be set. This creates a control point for moving ahead of the state. Note The exit User Status-es are usually secured, so that only the authorized users can set them."
  },
  "advanced/documents/generation-procedures.html": {
    "href": "advanced/documents/generation-procedures.html",
    "title": "Generation Procedures Overview | ERP.net Tech Docs",
    "keywords": "Generation Procedures Overview Generation Procedures are automated procedures, which generate Documents from other documents. They are the basis for the Document Flow . Generation Procedures are the arrows in the document flow diagrams. Setup In order to start generating documents, the Generation Procedures need to be configured. The configuration is performed in the Document Type entity, in the Document Type Routes child entity. Each Document Type Route is a configuration for a single Generation Procedure. Generation Procedures Lifetime Stages The current topic describes the stages of the lifetime of a generation procedure: NEW - in development, cannot be used ACTIVE - the generation could be actively used by the users AGEING - triggers a warning, can be silenced. OBSOLETE – triggers a warning e or an error and has to be replaced by an active generation procedure. DEAD – does not work, throws an error, or is permanently deleted. Details When creating a NEW generation procedure if it replaces a generation procedure that is currently in use, the old generation is marked as obsolete and it enters the lifetime stage AGEING. In those cases, the AGEING generation procedures, which later become OBSOLETE have to be replaced with the ACTIVE procedures that have been released, because they maintain the contemporary business logic, methods of computing and have a better and faster performance. The transition does not have to be made immediately after the release of the new version but it has to be performed before the generation procedure enters the stage DEAD i.e. before its Date of Suspension . For every Generation Procedure that is marked as an Obsolete is scheduled a Date of Suspension on which date the Generation Procedure will be discontinued and could no longer be used. The date is added in the obsolete procedure's name e.g. \"To be deleted: 9.2021\". As a result of this date, are defined three periods in which the software will inform users accordingly: AGEING - From ([Date of Suspension] - 3 years) to (Date of Suspension] - 1 year) – a pop-up (balloon) message will be displayed informing the user that it is using an obsolete generation. These messages’ only purpose is to inform the users and they won’t interrupt/stop their operating with the system. The messages will be logged into the Information Messages navigator. The messages will stop popping up if for the particular line of the Document Type's Routes the filed \"Allow Obsolete Generation\" is check-marked. OBSOLETE - From ([Date of Suspension] - 1 year) to ([Date of Suspension]) If the filed \"Allow Obsolete Generation\" is NOT check-marked - an error in a modal window will pop up during the execution of the obsolete generation procedure. The error will inform the users that they are using an obsolete procedure and the generation of the sub-document will be interrupted . The error will stop popping up if for the particular line of the Document Type’s Routes the filed \"Allow Obsolete Generation\" is check-marked. If the filed \"Allow Obsolete Generation\" IS check-marked - a pop-up (balloon) message will be displayed informing the user that it is using an obsolete generation. These messages' only purpose is to inform the users and they won’t interrupt/stop their operating with the system. The messages will be logged into the Information Messages navigator. While using this generation, the popping up of this message could no longer be avoided . DEAD - From [Date of Suspension] onwards - generation ceases to operate and enters the lifetime stage DEAD. An error that can not be avoided will be thrown. With the release of the new main version after the Date of Suspension, the obsolete generation procedure is to be deleted and it will no longer appear in the drop-down lists."
  },
  "advanced/documents/index.html": {
    "href": "advanced/documents/index.html",
    "title": "Documents | ERP.net Tech Docs",
    "keywords": "Documents"
  },
  "advanced/documents/transitional-documents.html": {
    "href": "advanced/documents/transitional-documents.html",
    "title": "Transitional Documents | ERP.net Tech Docs",
    "keywords": "Transitional Documents The main purpose of the transitional documents is to decrease the number of sub-documents in case there are often changes in the data from which sub-documents are created by the Document Fulfillment System and lots of sub-documents are created. Example 1: When creating Payment Orders by Sales Order payment plan (see \"Sales Order Payment Plan\" article) there are preconditions for great multiplication of the number of sub-documents. For example, if the Sales Order has a payment plan with three payments - 40 EUR , 50 EUR , 10 EUR - then initially three Payment Orders will be created (with no Invoice data) for each scheduled playment. When the amount of 60 EUR from the Sales Order is invoiced, two additional payment orders are created - one for -40 EUR and one for -20 EUR for planned payments № 1 and № 2 , which have no invoice data, and two more Payment Orders for 40 EUR and 20 EUR for planned payments № 1 и № 2 with invoice data. So the sub-documents are now seven. When the user release more invoices, more Payment Orders will be created. If an Invoice is voided - even more Payment Orders will be created so the collective state of the sub-documents is reached when the voided Invoice is no longer reported. So the transitional documents are meаnt to decrease the sub-documents number in such cases, and the changes are applied as corrections on already existing sub-documents (see Adjustment Documents ). This is performed only if the existing documents are Released. If they have higher than Released Document State (see Document States ), new documents are created for the discrepancies that occur. In such а case, we call these sub-documents transitional . If a document is transitional is a property of the document type definition. Activating this property is available only when all active procedures which create the current document allow transitional document and are set to create а Released document. Thus, at the first sub-document creation, the sub-documents will have Released document state and the next document changes can be applied as corrections. Thereby, not only the sub-documents number is smaller, and the user does not have to process them (no need to change their state, to edit/correct them so they can reach the values in the parent document, to void additional documents and etc.). This is some kind of automatic processing of these documents by the system. The user has to work only on the parent document. This is where the name of these documents came from - transitional - as these documents do not need direct processing by the user. Example 2: There is a Sales Oder for 100 pcs . It creates transitional Store Order. The first Store Order has 100 pcs . When we correct the parent Sales Order so the quantity is 70 pcs , there are the following two cases: the first is when the primary Store Order has 100 pcs and it is not Releаsed, but Firm Planned (this is possible if its state is returned to Firm Planned before the Sales Order correction or when the Store Order is created before its type is set to transitional). In this case, as there is no released document to correct, so a new Store Order is created with -30 pcs . Now there are two documents; But if the primary Store Order is Released (the usual case), then the discrepancy of -30 pcs is applied as a document correction and the quantity in the primary Store Order is now 70 pcs . Thereby, the sub-document is only one, as the discrepancy documents are not independent documents, they are applied to the primary document as corrections. Example 3 (continue of Example 1): There is a Sales Order with a payment plan for 3 payments - 40 EUR , 50 EUR , and 10 EUR . The Payment Orders are set as transitional documents. Initially, there are no Invoices on this Sales Order so there are three released Payment Orders: payment № 1 , 40 EUR , no Invoice data; payment № 2 , 50 EUR , no Invoice data; payment № 3 , 10 EUR , no Invoice data. Then Invoice # 1 is created based on this Sales Order for 60 EUR . So the first two payments have to be corrected. The first should have Invoice data, the second should have 20 EUR with Invoice data, and the rest 30 EUR do not have Invoice data yet. So for the additional four Payment Orders from Example 1, created to cover the discrepancies, the first two Payment Orders containing -40 EUR and -20 EUR are applied as corrections of the already existing Payment Orders for planned payments № 1 and № 2 , with no invoice data. And the second two orders with invoice data are created as new Released documents as there are no released Payment Orders with Invoice data yet. So now the Payment Orders are: payment № 1 , 0 EUR , no Invoice data; payment № 1 , 40 EUR , Invoice #1; payment № 2 , 30 EUR , no Invoice data; payment № 2 , 20 EUR , Invoice #1; payment № 3 , 10 EUR , no Invoice data; If after that Invoice #1 is edited to 35 EUR (or voided and created again), than the Invoice amount may cover only part of the first payment and this will cause discrepancies/changes in the first four payments. As the Payment Orders are transitional, instead of creating four new documents, the existing Payment Orders will be adjusted: payment № 1 , 5 EUR , no Invoice data; payment № 1 , 35 EUR , Invoice #1; payment № 2 , 50 EUR , no Invoice data; payment № 2 , 0 EUR , Invoice #1; payment № 3 , 10 EUR , no Invoice data; The previous example shows that there are cases when the sub-documents have zero-values in the scalar value fields. This is equal to removing the sub-documents (i.e. it does not order/execute anything anymore). The fact that the sub-documents are not voided or erased completely is useful as in a following action they may be used to be adjusted again with zero-values (thereby they are recovered as active documents)."
  },
  "advanced/index.html": {
    "href": "advanced/index.html",
    "title": "Advanced Section | ERP.net Tech Docs",
    "keywords": "Advanced Section This section contains information for advanced concepts, systems and deep dive in the security. It is intended primarily for advanced ERP implementation consultants. Advanced Systems Documents - document-related concepts and services. Custom attributes - user-defined data attributes. Calculated attributes - user-defined calculations. Business rules - user-defined and system business rules. Data objects - data object extensibility systems. Advanced Concepts Master / Detail attributes Object / Relational mapping Aggregates"
  },
  "advanced/jobs/index.html": {
    "href": "advanced/jobs/index.html",
    "title": "Jobs | ERP.net Tech Docs",
    "keywords": "Jobs Jobs is a system in ERP.net, which automatically runs processes. The types of processes, which are run include document state changing, executing scheduled events, or similar. The jobs are run in non-busy hours without requiring any user interaction. How to create and configure a Job In most cases, in order to create a job, you have to simply create a new record with the desired Job Type in the Job navigator. Most parameters of the jobs have a default value and can operate without additional adjustments. An example is the J30903 Document Print Images - Delete Old Document Print Images jobs, which has only one parameter - \"Print Images Retention Months\" field Enterprise Company's definition, which has a default value of \"60 months\". However, there are jobs that are jobs that are performing more complicated processes and is not logical to be executed for all records in the database. They require configuring additional settings. Such an example is Document state change job . The parameters and therefore the required settings of each job are described in its documentation. Job scheduling Jobs can be started automatically by the jobs execution system following a predefined schedule. Note Currently, only an \"On Idle\" auto-start schedule is available. \"On Idle\" jobs will be started in non-busy hours, subject upon availability of resources. A job is using the \"On Idle\" auto-start schedule when the \"Run On Idle\" option is activated in its definition. The jobs execution system will be started only if the following requirements are met: The time of the day is between 22:00 and 03:00. The current server sessions are less than 5. The last time the job's procedure is completed is more than 12 hours from now. The procedure is not currently working There is no manually stated jobs that are currently running Then the conditions described above are met and then the jobs execution system will start a special long-running procedure called \"System Jobs\". The procedure can be monitored as every other long-running procedure in Procedures navigator in ERP.net or the Procedures tab in the Server Manager. The jobs execution system will create a list of pending jobs and will start executing them sequentially. The list is made on the base of the active jobs defined in the databases. Each job runs a maximum of 5 minutes and then it is cancelled by the job runner. Every job can run up to 30 minutes which make a total of 6 times X 5 minutes runs, then it breaks the loop of pending jobs. If the job is interrupted before it's work is finished it must be started again during the 30 minutes period. If there are more records that have to be processed after the 30 minutes have elapsed, the job will start again on the next day. Execution log Each job execution is logged in Information Messages. The log contains information about the starting time, ending time, the processed records and the errors that have occurred during the processing (if possible and if any). Example: Process: Job J30777 Finish Store Transactions Message: Succeeded: 259; Failed: 0 LOG: [10:00:10] Total: 259 [10:04:42] Succeeded: 259 [10:04:42] Failed: 0 Job Types The following is a list of the types of jobs, which can be scheduled: J30632 Notifications - Delete Old Notifications J30724 Scheduled Document Events - Run Scheduled Events J30777 Documents - Document State Change J30903 Document Print Images - Delete Old Document Print Images Note The table columns and content are explained in Jobs Tamplate"
  },
  "concepts/documents.html": {
    "href": "concepts/documents.html",
    "title": "Documents | ERP.net Tech Docs",
    "keywords": "Documents"
  },
  "concepts/erp-instances.html": {
    "href": "concepts/erp-instances.html",
    "title": "ERP Instances | ERP.net Tech Docs",
    "keywords": "ERP Instances The ERP.net service is a hosted ERP service. Accessing the data is done through ERP Instances. When you sign up at erp.net , you can create and manage a new ERP Instance. An ERP Instance is a tenant in the hosting environment. It is multi-company, e.g. it allows managing multiple related legal entities (companies) in one instance. You don't need to create separate instances for each managed company. Each ERP Instance has a unique name. The instance can be accessed at: https://<<instance_name>>.my.erp.net For example, the demonstration database, DEMODB, is located at: https://demodb.my.erp.net"
  },
  "concepts/index.html": {
    "href": "concepts/index.html",
    "title": "Business Logic Concepts | ERP.net Tech Docs",
    "keywords": "Business Logic Concepts This section contains concepts, applicable to all modules."
  },
  "concepts/multi-company.html": {
    "href": "concepts/multi-company.html",
    "title": "Multi-Company Support In ERP Instances | ERP.net Tech Docs",
    "keywords": "Multi-Company Support In ERP Instances ERP.net allows a single ERP instance (database) to contain multiple companies. The different own companies, stored in the database are called \"Enterprise Companies\". Many data objects (definitions, settings and documents) have an \"Enterprise Company\" attribute. When filled, it specifies that the data is specific to one of the enterprise companies. When the attribute is left blank, the data is valid for all enterprise companies. Some data objects have a required \"Enterprise Company\" attribute. In this case, the data is always specific to one enterprise company. For example, all documents have a required enterprise company attribute. For example, lets have the following Accounts in our chart of accounts: 60201 - Expenses, general 60209 - Other Expenses (specific to \"Company X\", one of the companies, managed in the database) This can be defined as follows: Account Enterprise Company 60201 60209 Company X In much the same way, the products and many other definitions can be defined to belong to only a single enterprise company or to all enterprise companies. Note There is no way to define a data object to belong to several enterprise companies. It is either one or all."
  },
  "concepts/multi-language.html": {
    "href": "concepts/multi-language.html",
    "title": "Multi-language support | ERP.net Tech Docs",
    "keywords": "Multi-language support Description Many string attributes in ERP.net support saving the data in multiple languages. These attributes are called Multi-language Strings. For example, the Product Name of a Product can be entered in many languages simultaneously. When visualizing the data, the correct language version of the string is displayed automatically by the system, depending on the current user language. Note For reports, the report designer can specify whether to use the current user language or always use a fixed language. For example, for a Portuguese invoice, one would require that the labels and data are always displayed in Portuguese. Entering data in multiple languages The client applications of ERP.net usually allow the following abilities regarding multi-language strings: Enter the string in many languages Transliterate a string from one language to another (or all) Translate a string from one language to another (or all) When entering translations for a multi-language string, the client application usually displays a table with cells for each language translation, similar to this: Language Value EN: Toothpaste DE: Zahnpasta Depending on the client application, translation can sometimes also be automated. Some client applications support using an online service, like Google Translate to automatically translate a string to other languages. Translation is better suited to Description and Notes attributes. Transliteration Transliteration is the process of translating one language version of a string to another, based on the sounding of the string. Transliteration works great for person and company names and addresses. It allows branch offices to work in their local language and reports can still be shown in the corporate language. For example, the Russian word \"Иван\" would be transliterated in English as \"Ivan\". Transliteration works in two ways - manual and automatic. Manual transliteration \"Manual\" transliteration is actually automatic, but is initiated manually while editing the different language versions of a multi-language string. While editing multi-language string, the client application usually provides a function button, which transliterates the current language version to other languages. Automatic transliteration Automatic transliteration occurs when the system needs to display some a multi-language string in some language, but that specific language translation is not saved in the database. For example, suppose one employee works in a branch office in Russia and enters \"Иван\" as a person first name. The database saves only the Russian language version. Then another employee at a UK location requests to see the first name of the same person. The system would automatically transliterate the string and display it as \"Ivan\". Note Transliteration works optimally between Latin and Cyrillic."
  },
  "concepts/parties-concepts.html": {
    "href": "concepts/parties-concepts.html",
    "title": "Parties Concepts | ERP.net Tech Docs",
    "keywords": "Parties Concepts Description Parties in ERP.net are one of the most widely used definition. Generally, a party is a participant in any business relations or transaction. Examples of parties include: Business customers Consumer customers Employees in our or external companies Contacts Dealers Company Locations Departments etc... Basic Party Types Parties do not exist by their own. They are always created as another object. Most parties are created as Person or Company. In object terms, it means that Person and Company inherit Party. The Party itself is called to be of type Person or Company. Note Parties cannot be directly created. They are always instantiated as some sub-type, like Person or Company. This diagram shows the relationship between Party, Person and Company: Party Attributes Inheritance The fact, that Person and Company inherit Party also means, that all attributes of Party are also attributes of Person and Company. For example, a Party has an \"Area\" attribute. So, all Person and Company objects would also have an \"Area\" attribute. The opposite is not true. E.g. Person and Company objects have attributes, which are specific to them and are not general Party attributes. For example: Party has \"Parent Party\" and \"Area\" attributes, which are inherited by Company and Person. But persons \"First Name\" and \"Last Name\" are specific only to persons. Neither companies nor generally parties have \"First Name\". Relationships with Other Entity Types Although parties do not exist on their own, they can participate in relationships. For example, a Customer or Supplier Contract are objects, which can have a relationship with a Party. Relationship with Party means, that an actual Customer Contract object would relate to either a Person or a Company. This is shown on the following diagram: Note Customer (Contract), Supplier (Contract) and Dealership (Contract) are actually called simply Customer, Supplier and Dealer in ERP.net. Note The diagram shows, that one Party object can participate in relationships with many Customer Contract objects. In fact, however, the current implementation of ERP.net allows many Customer Contracts per party, but only one for each Enterprise Company. This means, that one party can have only a single Customer Contract with any given Enterprise Company. To clarify the above diagrams, lets provide an example. Suppose we have: A customer, which is a company, called \"ABC\" A supplier, which is a person, named \"John\" This will be represented with the following objects: Party (ABC) Company (ABC), which inherits Party (ABC) Customer (ABC), which points to Party (ABC) Party (John) Person (John), which inherits from Party (John) Supplier (John), which points to Party (John) If we query the system with a query, that can be stated as \"Show me ALL parties\", the result will be: Party (ABC) Party (John) If we query with \"Show me ALL customers\", the result will be: Customer (ABC) Party Hierachy The basic party types are Person and Company, but there are some more party types. Among them are Department and Division. By using all the party types, the data about parties can be nicely organized. Particularly handy is the ability to hierarchically structure the parties. Having the departments and divisions as parties allows flexible representation of the different corporate hierarchies. For example, let's have Corporation A structured in the following way: Corporation A Division 1 Sales Department Marketing Department Division 2 Sales Department Marketing Department Global Marketing Department Global Accounting Department The flexible party hierarchy also allows structuring even different companies in a corporation: Corporation B Company A Consumer Electronics Division Sales Department Business Consulting Division Sales Department Accounting Department Company B Sales Department Accounting Department Corporate Financials Department Note Because our own enterprise companies Multi-Company are also companies (which are parties), party hierarchy can be used for organizing both our own corporate structure and the corporate structure of our business partners. Party Relationships Party Relationships organize the formal and informal relationships between different parties. Using party relationships, information, such as the following can be easily represented: Peter works for Company A Peter is a friend of George Steven is married to Susan since 8/3/2011 John worked for Company B from 1/1/2010 till 3/5/2015 The above information is represented in a table in the following way: From Party Relationship Type To Party From Date To Date Notes Peter works for Company A Peter is friend with George Steven is husband of Susan 8/3/2011 John works for Company B 1/1/2010 3/5/2015 Obviously, From Date and To Date represent the dates when the relationship was established and terminated."
  },
  "includes/erpnet.html": {
    "href": "includes/erpnet.html",
    "title": "| ERP.net Tech Docs",
    "keywords": "ERP.net"
  },
  "includes/name.html": {
    "href": "includes/name.html",
    "title": "| ERP.net Tech Docs",
    "keywords": "ERP.net"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to the ERP.net Technical Documentation | ERP.net Tech Docs",
    "keywords": "Welcome to the ERP.net Technical Documentation The Technical Documentation documents the business logic of ERP.net. It is targeted towards implementation consultants and power users. Learn more Concepts - general concepts, which apply to all modules. Functionality - documentation of the business functions. Advanced - documentation of advanced systems. Other documentations Data Model - reference information about the entities, business rules, generations, etc. Developer Documentation - information for developers."
  },
  "modules/applications/overview.html": {
    "href": "modules/applications/overview.html",
    "title": "ERP.net Integrated Applications | ERP.net Tech Docs",
    "keywords": "ERP.net Integrated Applications ERP.net contains various built-in applications."
  },
  "modules/applications/service/index.html": {
    "href": "modules/applications/service/index.html",
    "title": "Service | ERP.net Tech Docs",
    "keywords": "Service"
  },
  "modules/applications/service/non-agreed-services-and-materials.html": {
    "href": "modules/applications/service/non-agreed-services-and-materials.html",
    "title": "Non Agreed Services And Materials | ERP.net Tech Docs",
    "keywords": "Non Agreed Services And Materials When a Service Activity creates Store Order, in order to invoice the used materials and the services which are performed, the Sales Orders have to include the non-agreed quantities of the materials and the services. The rest of the materials and services are covered by the guarantee, which is agreed in the Service Agreements. The current topic describes the calculation of the non agreed services and materials based on the data in a Service Activity. The agreed services and materials are listed in the Service Agreements, in the ServiceAgreementService and ServiceAgreementMaterial tables. After that the quantities which are listed in there are distributed through the Service Activities. When a Service Activity is released, what part of the agreed quantities has not been used by the previous Service Activities is calculated and the result (the remaining quantities) is distributed in the current document (only if the remaining quantities are not greater than the used quantities recorded in the current document). The distributed quantities are recorded in the Distributed Service Agreement Materials and Distributed Service Agreement Services tables. After all, the non-agreed materials and services are calculated by subtracting the quantities from those tables from the quantities in the current Service Activity. Non Agreed Materials For each Material line in the current Service Activity all records from Distributed Service Agreement Materials table which correspond the current line are derived. The amounts from the Agreed Quantity column are summed up (converted to the measurement unit of the material in the service activity line; the values in Agreed Quantity column are in measurement unit of the Service Agreement) and the sum is subtracted from the quantity in the current line (only if the sum is not greater than the quantity in the current line). This is the calculation: [**non-agreed material quantity**] = if [**Service Activity Material Quantity**] >= [**sum of distributed service agreement materials**] then [**Service Activity Material Quantity**] - [**sum of distributed service agreement materials**] else **0** Example 1: There is a Service Activity with three lines with materials: line #10, Material #1, 10PCS ; line #20, Material #2, 13PCS ; line #30, Material #3, 40PCS . Distributed Service Agreement Materials table has the following data: line #20 from the Service Activity, line #70 from Service Agreement #00007, 4PCS ; line #20 from the Service Activity, line #30 from Service Agreement #00019, 11PCS ; line #30 from the Service Activity, line #10 from Service Agreement #00007, 48KG . Thus, for line #10 from the Service Activity the distributed quantity is 0PCS , for line #20 from the Service Activity the distributed quantity is 15PCS , and if Material #3 has the following dimension: 3KG = 1PCS, than for line #30 the sum is 16 PCS. Thus, the non agreed quantities are calculated s follows: for line #10: [non agreed quantity of the material] = 10PCS - 0PCS = 10PCS; for line #20: [non agreed quantity of the material] = 0PCS (because 13PCS < 15PCS); for line #30: [non agreed quantity of the material] = 40PCS - 16PCS = 24PCS; Non Agreed Services The services are not invoices directly as they are not products, so to invoice them the information in Service Invoicing from the Service definition is used. So, for each Service Activity line with service and for each record in Service Invoicing the following quantity of the product from the Service Invoicing records, is calculated: [**quantity to invoice**] = [**Service Activity Service Quantity**] * [**ServiceInvoicing.QuantityOfProduct**] / [**ServiceInvoicing.QuantityOfService**] The distributed quantities from the Service Agreements which correspond the current service line are subtracted from the described above quantity to invoice . But this is performed in two stages as in the Service agreements there are two methods to describe agreements for services - one is to agree on a certain number of the service , and the second is to agree on certain number from the product from the Service Invoicing . Thus the non-agreed quantity of a specific product which invoices a specific service (i.e. a product listed in the Service Invoicing table of the service definition), happens by the following two formulas: At first, what quantity is not agreed by Service Agreements is calculated. This happens as all distributed quantities for the specified line listed in the Distributed Service Agreement Services table (but only records which are on specific Service Agreements where the Service attribute is selected and Service Product attribute is null) are subtracted from the quantity from the Service Activity line. The following temporary value is calculated: [**preliminary quantity 1**] = if [**Service Activity Service Quantity**] >= [**sum of distributed service agreement services**] then [**Service Activity Service Quantity**] - [**sum of distributed service agreement services**] else **0** Using this preliminary quantity 1 for each product in Service Invoicing in the service definition a preliminary quantity for invoice is calculated: [**preliminary quantity** **2**] = [**preliminary quantity** **1**] * [**ServiceInvoicing.QuantityOfProduct**] / [**ServiceInvoicing.QuantityOfService**] And at the end, from the sum of distributed service agreement services which are for the same product and for which we have calculated the preliminary quantity, the calculated preliminary quantity 2 is subtracted. But only for quantities which are based on Service Agreements lines and which have empty Service attribute and not null Product attribute. Also, the distributed quantities are always converted to the measurement unit which is selected in the Service Invoicing record (as the measurement unit in the Service Agreement may be different). So: [**non agreed quantity of a product for invoicing**] = if [**preliminary quantity** **2**] >= [**sum of the distributed quantities of the product from Service Agreements**] then [**preliminary quantity** **2**] - [**sum of the distributed quantities of the product from Service Agreements**] else **0** Example 2: Lets have Service #1 with the following Service Invoicing data: 1 PCS of Service = 2 PCS of Product #1; 2 PCS of Service = 3 PCS of Product #2. And for Service #2, the invoicing products are: 1 PCS of Service= 4 PCS of Product #1; 1 PCS of Service= 10 PCS of Product #3. There is Service Activity with the following services: line #10, Service #1, 6PCS ; line #20, Service #2, 8PCS . Distributed Service Agreement Services table contains the following: line #10 of the Service Activity, line #40 (with Service #1) from Service Agreement #00023, 2PCS ; line #20 of the Service Activity, line #50 with Service #2) from Service Agreement #00023, 3PCS ; line #20 of the Service Activity, line #30 (with Service Product #3) from Service Agreement #00037, 78KG . So the first preliminary quantity is calculated as follows: for line #10: [preliminary quantity 1] = 6PCS - 2PCS = 4PCS ; for line #20: [preliminary quantity 1] = 8PCS - 3PCS = 5PCS . Then the preliminary quantity for invoicing is: for line #10 and Product #1: [preliminary quantity 2] = 4PCS * 2PCS / 1PCS = 8PCS ; for line #10 and Product #2: [preliminary quantity 2] = 4PCS * 3PCS / 2PCS = 6PCS ; for line #20 and Product #1: [preliminary quantity 2] = 5PCS * 4PCS / 1PCS = 20PCS ; for line #20 and Product #3: [preliminary quantity 2] = 5PCS * 10PCS / 1PCS = 50PCS . And at the end, if the dimensions of Product #3 are 3KG = 1PCS, the final calculations are: for line #10 and Product #1: [non agreed quantity] = 8PCS - 0PCS = 8PCS ; for line #10 and Product #2: [non agreed quantity] = 6PCS - 0PCS = 6PCS ; for line #20 and Product #1: [non agreed quantity] = 20PCS - 0PCS = 20PCS ; for line #20 and Product #3: [non agreed quantity] = 50PCS - 26PCS = 34PCS ."
  },
  "modules/community/overview.html": {
    "href": "modules/community/overview.html",
    "title": "ERP.net Community Management | ERP.net Tech Docs",
    "keywords": "ERP.net Community Management Community Management deals with the management of the external community of a company. This includes all sites, forums, ticketing and support systems involving external users. It also includes the social interaction between internal and external users. Learn More Notifications Social Interactions Digital Marketplace"
  },
  "modules/crm/contacts/index.html": {
    "href": "modules/crm/contacts/index.html",
    "title": "CRM Contacts and tasks | ERP.net Tech Docs",
    "keywords": "CRM Contacts and tasks The Contacts and tasks module is used to manage parties and calendars. When used as part of the sales process, they can initiate the sales process flow: Activity → Opportunity → Offer → Sales Order → Invoice Order → Invoice Activities The activities are like calendar appointments on steroids. Activities Have related party reference, allowing to sort activities by party. Allow attachments of files. Support questionaries (through the use of user defined data attributes) And much more. Activities can be used to automatically create sales opportunities in the Presales module."
  },
  "modules/crm/index.html": {
    "href": "modules/crm/index.html",
    "title": "Customer Relationship Management (CRM) Subsystem | ERP.net Tech Docs",
    "keywords": "Customer Relationship Management (CRM) Subsystem The CRM subsystem in ERP.net is used to manage customer relationships and other front-office activities of a company. General concepts and processes The main process in the CRM subsystem is: Activity → Opportunity → Offer → Sales Order → Invoice Order → Invoice Activity - generic activity, related to a party. Includes support for calendar appointments, reminders, questionnaires, etc. Can be used to represent appointments, scheduled meetings, visits, contracts and just about any generic document. Opportunity - sales opportunity, with expected revenue and probability. It does not have detail line items. Offer - sales offer (quote), with line items. It allows optional selection of some of the items, which the customer has accepted. Sales Order - sales order from the customer. The main sales document. All documents before it are optional. The sales order initiates the logistics and financial processes, related to the sale. Invoice Order - an order to issue an invoice. This is an internal document, which is used to track the invoices, which we have to issue. Invoice - legal and financial document, finalizing the sales process. Note The above diagram shows only the CRM part of the whole process. The full process involves many different modules of the ERP system. Modules There are many modules in the CRM subsystem. They are used to manage the different aspects of the CRM processes: Contacts and tasks - calendar appointments, party definitions, etc. Pre-sales - Opportunities management, quotation, etc. Sales - Sales Orders, customers, etc. Invoicing - Invoicing process management, invoices and BI. POS - Manage point-of-sale activities in physical stores. Marketing - Marketing campaigns, activities, distribution channels, etc. Distribution - field sales, sales person targets management, etc. Pricing - price lists management. Product Configuration - create products based on specs for job shops (made-to-order and engineer-to-order environments). Products - manage products master data - products and product measurements, codes, variants, channel, pictures, groups, etc."
  },
  "modules/crm/invoicing/determine-unit-price-and-line-amount-in-invoice-orders.html": {
    "href": "modules/crm/invoicing/determine-unit-price-and-line-amount-in-invoice-orders.html",
    "title": "Determine Unit Price and Line Amount in Invoice Orders | ERP.net Tech Docs",
    "keywords": "Determine Unit Price and Line Amount in Invoice Orders The Invoice Orders and their lines are created to generate Invoice documents with which to be invoiced particular Sales Order Lines. For this reason, every Invoice Order Lines points to and fulfils exactly one Sales Order Line. In some cases though, when the parent document is a Shipment, for example, the Unit Price and Line Amount could not be copied directly from the parent document. They could not be copied from the Sales Order as well, because the line might be broken down (by lots for example) during the goods issue and the Line Amount will not be the same. Therefore those amounts must be calculated. Calculation Initially, when the Invoice Order and its lines are created the Quantity is copied from the parent documents line, the Unit Price and the discounts are copied from the Parent Sales Order Line. The Quantity and Unit Price values are used for the calculation of the Line Amount . The algorithm is as follows: [LineAmount] = Round( [Quantity] * [Unit Price] * (1 - [Line Standard Discount Percent] ) * (1 - [Line Custom Discount Percent] )) *The Line Amount is rounded up to the second digit. Example: SalesOrderLine1 : Quantity = 3 PCS , UnitPrice = 2.5694 EUR, LineStandardDiscountPercent = 0.00 %, LineCustomDiscountPercent = 25.00 %, LineAmount = 5.78 EUR ShipmentLine1: Quantity = 2 PCS ShipmentLine2: Quantity = 1 PCS InvoiceOrderLine1: Quantity = 2 PCS, UnitPrice = 2.5694 EUR, LineStandardDiscountPercent = 0.00 %, LineCustomDiscountPercent = 25.00 %, LineAmount = 2 2.5694 (0.75) = 3.8541 ~ 3.85 EUR InvoiceOrderLine2: Quantity = 1 PCS, UnitPrice = 2.5694 EUR, LineStandardDiscountPercent = 0.00 %, LineCustomDiscountPercent = 25.00 %, LineAmount = 1 2.5694 (0.75) = 1.92705 ~ 1.93 EUR Then when saving the document the Discrepancy System (for more information see Discrepancy System ) initializes а depletion of the rounded Line Amount which leads to a recalculation of the Unit Price : [Unit Price] = Round( [LineAmount] / (1 - [Line Standard Discount Percent] ) / (1 - [Line Custom Discount Percent]) / [Quantity] ) *The Unit Price is rounded up to the fifth digit. Example: InvoiceOrderLine1: Quantity = 2 PCS, LineAmount = 3.85 EUR, LineStandardDiscountPercent = 0.00 %, LineCustomDiscountPercent = 25.00 %, UnitPrice = 3.85 / 0.75 / 2 = 2.5666666... ~ 2.56667 EUR InvoiceOrderLine2: Quantity = 1 PCS, LineAmount = 1.93 EUR, LineStandardDiscountPercent = 0.00 %, LineCustomDiscountPercent = 25.00 %, UnitPrice = 1.93 / 0.75 / 1 = 2.57333333... ~ 2.57333 EUR"
  },
  "modules/crm/invoicing/index.html": {
    "href": "modules/crm/invoicing/index.html",
    "title": "Invoicing - Invoicing process management, invoices and BI. | ERP.net Tech Docs",
    "keywords": "Invoicing - Invoicing process management, invoices and BI."
  },
  "modules/crm/presales/index.html": {
    "href": "modules/crm/presales/index.html",
    "title": "CRM Presales | ERP.net Tech Docs",
    "keywords": "CRM Presales The presales module is used to manage the presales process. Deals (Opportunities) Activity → Opportunity → Offer → Sales Order → Invoice Order → Invoice The deals in the Crm.Presales.Deals Entity are used to manage sales opportunities to new or existing customers. Note Deal is synonymous to opportunity. The deals: Have appointed sales representative, managing the deal. Do not have line items. They are used to manage deals, which are still not clear enough to detail at this level. Have a percentage probability of success . The percentage is set by the sales representative, based on their own judgement. Have expected sales revenue . Have expected close date . Based on the data above, the team leaders and sales managers have instant and clear visibility over the sales processes. The deals are usually initially created based on General.Contacts.Activities Entity . However, once a deal is created, it can be used to create many more sub-activities to manage related tasks. Offers (quotes) Activity → Opportunity → Offer → Sales Order → Invoice Order → Invoice The deals documents can be easily transformed into Offers (quotes), which contain detailed line items. Entries in the Crm.Presales.Offers Entity allows the customer to be presented with optional items. After approving some or all of the optional items, the offer can generate Crm.Sales.SalesOrders Entity in the Sales module."
  },
  "modules/crm/sales/amount-to-pay.html": {
    "href": "modules/crm/sales/amount-to-pay.html",
    "title": "Amount to pay | ERP.net Tech Docs",
    "keywords": "Amount to pay Amount To Pay is part of Sales Orders and Invoices. It is the final amount which the customer has to pay on the current document (Sales Order or Invoice). It is calculated as the sum of the row amounts and all additional amounts in the current document which has check in the \" Add To Customer \" attribute in their definitions. Example 1: There is an Invoice with two rows: Row #10 - Product 1 , LineAmount: 2 PCS x 12 EUR = 24 EUR Row #20 - Product 2 , LineAmount: 3 PCS x 7 EUR = 21 EUR The document has an additional amount paid by the customer: VAT, Amount Percent: 20% of the line amount of the rows = 0.2 x 45 EUR = 9 EUR So the Amount To Pay is: 54 EUR = 24 EUR + 21 EUR +9 EUR. Relation To Tax Base And VAT (Invoices) In most cases the Amount To Pay matches the sum of Tax Base and VAT, like in Example1 , but a difference is possible. It is possible if there are Additional Amounts which are paid by the customer but are not set as base amounts for VAT additional amount. Example 2: There is an Invoice with Line Amount of 45 EUR and two Additional Amounts which are paid by the customer: VAT, amount: 20% of 45 EUR = 9 EUR Penalty Interest - not a VAT base amount, Amount: 20 EUR So the Amount To Pay is 74 EUR while the sum of Tax Base and VAT is 54 EUR . Example 3: The additional amount VAT (special cases) is set that its base amount type is Tax Base , Add To Customer and Base On Lines are True. Tax Base is not paid by customer. There is an Invoice with two rows: Row #10 - Product 1 , LineAmount: 2 PCS x 12 EUR = 24 EUR Row #20 - Product 2 , LineAmount: 3 PCS x 7 EUR = 21 EUR and Additional Amounts as follows: Tax Base , Amount: 30 EUR VAT , Amount Percent 20% of 30 EUR = 6 EUR In this case the Amount To Pay is 45 EUR while the sum of Base Tax and VAT is 36 EUR ."
  },
  "modules/crm/sales/index.html": {
    "href": "modules/crm/sales/index.html",
    "title": "CRM Sales Module | ERP.net Tech Docs",
    "keywords": "CRM Sales Module Activity → Opportunity → Offer → Sales Order → Invoice Order → Invoice The sales module is used to manage the preparing and issuing of Sales Orders and the related master data."
  },
  "modules/crm/sales/price-types.html": {
    "href": "modules/crm/sales/price-types.html",
    "title": "Price types | ERP.net Tech Docs",
    "keywords": "Price types Price types are used to set additional priority conditions for the prices. 5 is the highest priority level that can be selected in the Priority field of the price. To add an additional higher priority, a price type must be defined and selected as a price type of the price. Priorities among the different price types are set by filling a number in the Ordinal position field in the definition of the price type – the lower the number, the higher the priority. Price types add additional priority under the following algorithm: If a price has a defined price type, this price will be with the highest priority among other prices - no matter their level of priority. If more than one price has a defined price type, the price with the price type that has the lowest ordinal position will be with the highest priority. If more than one price has a defined price type and their price types have equal ordinal positions, the price with the highest priority will be selected."
  },
  "modules/crm/sales/pricing.html": {
    "href": "modules/crm/sales/pricing.html",
    "title": "Pricing | ERP.net Tech Docs",
    "keywords": "Pricing Description When a user enters a sales order (or similar document), the system automatically assigns the appropriate sales price. Selecting the correct price is the main topic of the pricing. Product prices in reality Each product can have multiple prices associated with it. For example, product A can have 3 standard prices: 50.00 USD - open price, for everyone who asks. This price is defined as Standard. 48.00 USD - for regular customers 45.00 USD - for special customers Additionally, product A can have a special price for some customers: 44.00 USD for Customer X 43.50 USD for Customer Y Also, there might be a discount campaign: 42.00 USD for everyone, from 1/1/2021 till 2/2/2021. This price is defined as Promotion and it should be with higher priority than the Standard price. Entering product prices in ERP.net The following table shows how we can define the prices from the above example in ERP.net. Product Customer Price list From date To date Price type Priority Price Product A Standard 1 50.00 Product A Regular 2 48.00 Product A Special 2 45.00 Product A Customer X 3 44.00 Product A Customer Y 3 43.50 Product A 1/1/2021 2/2/2021 Promotion 5 42.00 How ERP.net determines the correct price The most important thing to note is the Price type field. The price type with the lowest Ordinal position is with highest priority. If the Price type field has a blank value, the first thing that is taken into consideration is the Priority field of the price. The higher the priority, the more likely the price will be selected. After the user specifies the customer, date and product, ERP.net filters all prices, that match this criteria. When a price is defined with blank value for Customer, the price is applicable to all customers. The same goes for Price list, From date, To date, etc. Only the Product field is required, it cannot be blank. If it could be blank, this means, that we can define the same price for ALL products. Generally, the algorithm is the following: ERP.net filters the prices, based on Product, Customer, Price list and all other conditional fields. If among the remaining prices, there are prices with defined price type, the one that has a price type with the lowest Ordinal position is selected * If there is more than one price within the same lowest Ordinal position, the one with the highest priority is selected If among the remaining prices, there are no prices with defined price type, the one with the highest priority is selected * If there is more than one price within the same highest priority, the newer one is selected (the one with later From date) So, after the selection process, one and only one price is selected and applied to the sales document. More conditional filtering fields ERP.net employs many more conditional fields, which allow fine-grained tuning of the product pricing strategy. All conditional fields work in the same basic way as described above. The following additional conditional fields further filter down the prices: Enterprise Company - for sales only in the specified enterprise company Min Quantity - for sales quantities above (or equal to) the specified Max Quantity - for sales quantities below (or equal to) the specified Target Group - for customers in the target group Ship To Customer - self explanatory Distribution Channel - self explanatory Customer Type - self explanatory Specifying the price The price is specified using the following fields: Price - the decimal part of the price Currency - the currency of the price Quantity - the quantity for which the price is specified Quantity Measurement Unit - the measurement unit in which the quantity is specified Examples: 5.00 USD for 1 pcs 10.00 EUR for 3 packs"
  },
  "modules/crm/sales/sales-order-payment-plan.html": {
    "href": "modules/crm/sales/sales-order-payment-plan.html",
    "title": "Sales Order Payment Plan | ERP.net Tech Docs",
    "keywords": "Sales Order Payment Plan This topic describes the essence of the Sales Order Payment Plans, the method of calculating the Installments, and the algorithm for creating payment requests under a plan. Sales Order Payment Plans The sales order payment plan determines how the amount of the given sales order is paid (with how many instalments and their individual amounts). For each instalment, there are two main attributes - a method for determining the amount and a method for determining the due dates (the payment term). Methods for determining the amount (specified by the \"Amount Percent\", \"Amount\" and \"Remainder\" fields): an indication of a fixed amount that does not depend on other factors; the amount of the instalment is a percentage of the total amount of the transaction; the amount is the remainder that is not covered by the other instalments. It is mandatory that in every plan there must be exactly one instalment marked as a \"Remainder\" (usually this is the last instalment in the plan). It is necessary to have such an instalment because it \"picks up\" all of the small inaccuracies and differences of rounding (if there are other instalments whose amounts are determined by a percentage). It can also \"picks up\" and the changes in the total amount that happen due to changes in the terms of trade in the Invoices (see Example 3 below). There are two main fields whose values need to be determined in order to define the payment term - Payment Due Start Date (aka Execution Date) and Payment Due Date. Payment Due Start Date (aka Execution Date) is the date when the payment becomes due/executable and Payment Due Date is the last day of the payment term. Due Date Form Methods according to which the payment term is calculated: Specify the date explicitly: the payment due start date is determined by adding \"Payment Term Days\" to the \"Explicit Payment Due Date\" and the due date is \"Explicit execution date\" added with \"Execution term, days\"; Use Sales Order Due Date: “Due Start Date”/”Execution date” and “Payment Due Date” are copied directly from the Sales Order header fields “Payment Due Start Date “ and “Payment Due Date”; Use Sales Order Date: the dates are calculated using the Sales Order “Document date” added with the number of days entered in \"Execution term, days” (for the calculation of the payment start due date) or \"Payment Term Days\" (for the calculation of the due date); Use Invoice Due date: “Due Start Date”/”Execution date” and “Payment Due Date” are copied directly from the Invoice header fields “Payment Due Start Date “ and “Payment Due Date”; Use Invoice Date: the dates are calculated using the Invoice “Document date” added with the number of days entered in \"Execution term, days” (for the calculation of the payment start due date) or \"Payment Term Days\" (for the calculation of the due date); The last two methods use the delivery invoice dates. If they are not yet issued, then the dates are calculated according to the values inserted in the Sales Order header. If for the particular sales order there is no indicated payment plan at all, then it is considered that there is a plan that consists of only one instalment. This instalment is not numbered (see the Create Payment Orders section below) and is for total Amount to Pay of the Sales Order. In a \"service\" instalment the method of determining the payment term depends on whether the Payment Orders for the invoiced amounts will be created from the Sales Order or not (this depends on the setting of the Payment Order generation procedure). If the Payment Orders for invoiced amounts will be generated from the Sales Order, then for the Due Date Form Method is used the “Use Invoice Due date” method, otherwise is used the “Use Sales Order Due date” method. Determining the total payment amount In order to determine the amount of each instalment, it is first necessary to determine what is the total / final amount that has to be paid for this transaction. This is done using the data from several documents - the Sales Order with which the transaction is reflected and all Invoices for this sale (both for the advance and for delivery). For this purpose, two types of Amounts are calculated separately – Sales Order Amounts and Invoice Amounts, which are then summed to obtain the final amount. Invoice Amounts are the Amounts to Pay (see topic Amount To Pay ) of the delivery Invoices. And the Sales Orders Amounts are the paid advances and the remaining part of the Amount to Pay (see topic Amount To Pay ) of the Sales Order, which is not covered by an advance or delivery. To determine the last amount (the remaining part of the Amount to Pay of the Sales Order), the following formula is used: [remaining part] = [Amount to Pay of the Sales Order] - [advances paid] - [invoiced part of the Sales Order] The invoiced part is calculated by determining how much of the Amount to Pay of the Sales Order is covered by the delivery Invoices. This is done for each line of Invoices in two alternative methods: through the \"Covered amount\" field of the Invoice lines; or through the Quantities in the Invoice lines (this is used for the lines in which the \"Covered Amount\" is not filled in). Finally, the results of all lines of delivery Invoices for current Sales Order are summed into [invoiced part of the Sales Order] . It does not matter what the final Amount to Pay for the Invoice is. The reason why the final Amount to Pay of the Invoice is not to be considered is that there may be a change in the trading conditions (prices, discounts, etc.). This should not change the ratio - what part of the Sales Order is covered by this Invoice. The first method is based on this how much of the basе of the Sales Order (the \"Line Amount\" field of the sales order line) is covered by the value of \"Sales Order Amount\" field in the line of the Invoice. This relationship determines what part of the Sales Order line has been invoiced. For example, if the Sales Order lines is for 100.00 BGN and we have 20.00 BGN VAT (ie the Amount to Pay of the Sales Order is 120.00 BGN) and there is one Invoice line in which the covered \"Sales Order Amount\" is 70.00 BGN, then the invoiced part of the Sales Order line is 120.00 * 70.00 / 100.00 = 84.00 BGN. The second method works on the same principle, but the relationship is made between the quantities of the Sales Order line and the Invoice line. For example, if in the Sales Order line there is a Quantity = 10 pcs with a total Amount to Pay = 90.00 BGN and there is only one Invoice line for Quantity = 7 pcs then the invoiced part of the Sales Order line is 90.00 BGN * 7 pc / 10 pc = 63.00 BGN . If in the Invoice there also is an advance deduction, this deduction is also subtracted from the invoiced part (because advances are aggregated in [advances paid] ). If in the example described above there is an advance deduction of 15.00 BGN in the Invoice, then the invoiced part of the Sales Order is (90.00 BGN * 7 pcs / 10pcs) – 15.00 BGN = 48.00 BGN . Example 1: There is a Sales Order with Quantity = 10 pcs for a total Amount to Pay of 90.00 BGN , there already is a paid advance of 15.00 BGN and two delivery Invoices (in which the field \"Sales Order Amount\" is not filled in): one for Quantity = 3 pcs in which we deduct the advance and therefore we have an Amount to Pay of the Invoice 12.00 BGN = (27.00 BGN – 15.00 BGN) ; one for Quantity = 4 pcs , in which trade conditions are changed and so we have an Amount to Pay of the Invoice 41.00 BGN (instead of the expected 36.00 BGN ). The result is: [invoiced part of Sales Order] = (90.00 BGN * 3 pss / 10 pcs) + (90.00 BGN * 4 pcs / 10 pcs) – 15.00 BGN = 48.00 BGN; [remaining part] = 90.00 BGN – 15.00 BGN – 48.00 BGN = 27.00 BGN; Thus, we receive two Invoice Amounts – 12.00 BGN and 41.00 BGN - and two Sales Order Amounts – 15.00 BGN (advance) and 27.00 BGN . The final payment amount is: [total Amount to Pay] = 12.00 BGN + 41.00 BGN + 15.00 BGN + 27.00 BGN = 95.00 BGN In principle, (and from Example 1 ) we see that the total Amount to Pay practically is the Amount to Pay of the Sales Order summed with the increases/decreases that occurred due to a change in the terms of trade in the Invoices. The reason behind the using of such a breakdown of individual (smaller) amounts in the calculation is to avoid a (technical) complex analysis of how exactly the trade terms of the Invoices have changed and how this changes and affects the total amount. Also, these individual amounts help with the creation of Payment Orders. Determination of the instalments amounts The instalments are calculated by computing of the total Amount to Pay and applying the method of determining the instalment amount. Here are two examples: Example 2: There is a Sales Order with a total Amount to Pay 95.00 BGN . For this Sales Order, there is a payment plan with three instalments: the first for 33.30 % , the second for 33.70 % and the third is marked as a \" Remainder \". Thus, we get the following instalments: [Instalment 1] = 95.00 BGN * 33.30 % = 31.635 ~ 31.64 BGN; [Instalment 2] = 95.00 BGN * 33.70 % = 32.015 ~ 32.02 BGN; [Instalment 3] = 95.00 BGN - 31.64 BGN - 32.02 BGN = 31.34 BGN; Example 2 shows that when using a percent-based instalment and we have a change (increase/decrease) in the Amount to Pay because of changing the terms of trade in the invoices, this change is evenly distributed among the instalments. It also illustrates the usefulness of the \"Remainder\" instalment. If it was, instead, 33.00 % , then the total amount of the three instalments (after determining the percentages after the rounding) would be 95.05 BGN and not 95.00 BGN! Example 3: There is a Sales Order with a total Amount to Pay 95.00 BGN . For this Sales Order, there is a payment plan with three instalments - the first for an exact amount of 30.00 BGN , the second for an exact amount of 40.00 BGN and the third is marked as a \"remainder\". Thus, we get the following instalments: [Instalment 1] = 30.00 BGN (fixed amounts do not change); [Instalment 2] = 40.00 BGN (fixed amounts do not change); [Instalment 3] = 95.00 BGN – 30.00 BGN – 40.00 BGN = 25.00 BGN; This example illustrates the other benefits of the \"Remainder\" instalment. When there are only fixed amounts in the previous instalments and there is s change of the trade terms in the Invoices, then this change is reflected in the last instalment. Create Payment Orders When we create Payment Orders by a Sales Order Payment Plan, first we have to determine the Amount (as described above) and the Due Dates for any of the plan instalments. Thereafter, are determined individual Sales Order and Invoices Amounts (those from which the total amount is formed). We make an additional breakdown of the instalments and the instalments are exhausted in the order of creation of the individual amounts. Example 4: Let's use the situation of Example 1 and the payment plan of Example 3 . We get the following breakdown: 15.00 BGN - from [instalment 1] and because of the advance amount of the Sales Order; 12.00 BGN - from [instalment 1] and because of the amount of the first Invoice; 3.00 BGN - from [instalment 1] and because of the amount of the second Invoice; 38.00 BGN - from [instalment 2] and because of the amount of the second Invoice; 2.00 BGN - from [instalment 2] and because of the remaining part amount of the Sales Order; 25.00 BGN - from [instalment 3] and because of the remaining part amount of the Sales Order. More examples of Payment Orders generated by Sales Order Payment Plans there are in topic Transitional Documents . [!NOTE:] In the usual case, the Sales and Invoice Amounts will match the instalments Amounts, in fact, the resulting breakdown will match the payment plan (none of the instalments will be \"broken down\"). Then, for each Amount of the resulting breakdown can be created a separate Payment Order. Whether it will be created or not depends on the settings of the generation procedure. If in settings is indicated that the Payment Orders have to be created for the invoiced the amounts, then for the relevant Invoice Amounts (these are amounts of 12.00 BGN, 3.00 BGN and 38.00 BGN from the example above) are going to be created separate Payment Orders. Otherwise, no Payment Orders are going to be created for those amounts. The same is valid and for the non-invoiced amounts (amounts 15.00 BGN, 2.00 BGN and 25.00 BGN from above) with the only difference that the setting of the generation procedure has another name. The Due Start Date (Amount.DueStartDate) and the Due Date (Amount.DueDate) are the determined dates for the current instalment (from which the amount has been broken down) according to its method. The fields for reference invoice data ( \"Invoice Amount\", \"Referent invoice document type\", \" Referent invoice number\", etc. ...) are filled in depending on whether the amount of the breakdown has been calculated according to the Sales Order or Invoice Amount. The Party (Amount.Party) in the Payment Order is inherited from the Customer and the Location Party is inherited from the \"Ship to Customer\" field in the Sales Order. The instalment number (Amount.InstallmentNumber) in the Payment Order is filled in according to the corresponding field in the instalment from which the amount has been broken down. If the instalment is \"service\" (ie no payment plan has been entered in the Sales Order), then the field for the instalment number in the Payment Order remains blank. The payment account (Amount.PaymentAccount) and the payment type (Amount.PaymentType) in the Payment Order are inherited from the corresponding instalment from the plan. If they are not filled in in the instalment or the instalment is \"service\" then they are inherited from the Sales Order header. Additionally, if the payment type is not filled in both places but the amount is an Invoice Amount and payment type is filled in in the Invoice, then it is inherited from the Invoice. The document notes (Amount.DocumentNotes) in the Payment Order are a combination of the document notes of the Parent document and the notes of the corresponding in the plan. If both are filled in – then they are concatenated, separated by a space (or a new line). And if only one of them is filled in – it is the only one that is inherited."
  },
  "modules/crm/sales/sales-order-row-types.html": {
    "href": "modules/crm/sales/sales-order-row-types.html",
    "title": "Sales Order Row Types | ERP.net Tech Docs",
    "keywords": "Sales Order Row Types The classification of the Sales Order rows describes three main row types - Normal Sale, Sales Return and Neutral operation. The row type is important for some generation procedures from Sales Order. Types The row type is defined by the signs of the quantity value and the amount in it. This criteria is chosen because it is most common and natural. For example, it is possible to define if a Sales Order row is for stock return or not by the values in the ReturnForSalesOrderLine field in the lines or the header field - ReturnForSalesOrder. But it is also possible the user to enter Sales Order for stock return directly negative values in the quantity and/or amount fields without using tools as ReturnForSalesOrderLine or ReturnForSalesOrder. Thus, the signs of the values in the Quantity and Line Amount fields are the most common and natural criterion to determine the row type. Thus, according to the signs of the quantity and the amount, there are three main types of Sales Order rows: normal sale - rows with quantity > 0 or amount > 0; sales return - rows with quantity < 0 or amount < 0; neutral operation - rows with quantity == 0 and amount == 0. Why Defining Row Type Is Important? The types, listed above, are used in the generation procedures of Store Orders and Shipment Orders from Sales Orders and the row type is important. For example, if the row type is sales return, then if the product is shippable or not does not matter - the Store Orders and Invoicing Orders are generated always directly from the Sales Order. If the row type is normal sale - then if the product is shippable or not is important and it defines if Shipment Order has to be created or Store Order and Invoice Order directly from the Sales Order. The rows with neutral operation do not participate in these generation procedures as for a row with zero quantity and zero amount there is no point of creating nor Store Orders, nor Invoice Orders. Row Data Validations And Rules To avoid ambiguity when defining the type of a Sales Order row, certain restrictions are required when entering data in the Sales Orders. For example, quantity < 0 is not allowed with amount > 0 in one row as this row would be normal sale and return sale at the same time, which would lead to double Store Orders and Invoice Orders generation for the current row. These are all restrictions in the data in the Sales Orders, related to the row types definition: the quantity and the amount in the row must be with the same signs (for example, one is > 0 and the second is < 0); if the quantity and the amount in the row are positive, than the ReturnForSalesOrderLine, ReturnForInvoiceLine and HistoricalUnitCost must be null; the header fields \"ReturnForSalesOrder and ReturnForInvoice must be also null; if one of the quantity or the amount in the row is negative and the product is not stocked, than the HistoricUnitCost must be null; if one of the quantity or the amount in the row is negative and the product is stocked, than exactly one of the fields must have value - ReturnForSalesOrderLine and HistoricUnitCost. These restrictions are also required because they maintain the overall validity of the data in the Sales Order according to the business logic of the fields being part of the constraints. Validation are not only applied when the data is entered in the row, they may also appear and during the execution of a generation procedure."
  },
  "modules/financials/Fixed Assets/Depreciation Methods/DeprecationFunctions.html": {
    "href": "modules/financials/Fixed Assets/Depreciation Methods/DeprecationFunctions.html",
    "title": "| ERP.net Tech Docs",
    "keywords": ""
  },
  "modules/financials/Fixed Assets/Depreciation Methods/overview.html": {
    "href": "modules/financials/Fixed Assets/Depreciation Methods/overview.html",
    "title": "Deprecation Methods | ERP.net Tech Docs",
    "keywords": "Deprecation Methods"
  },
  "modules/financials/Fixed Assets/Depreciation Methods/PeriodDeterminationMetods.html": {
    "href": "modules/financials/Fixed Assets/Depreciation Methods/PeriodDeterminationMetods.html",
    "title": "Period Determination Methods | ERP.net Tech Docs",
    "keywords": "Period Determination Methods From next month to last month From current month to last but one month By days Method of calculation First, the quota for each month is calculated: Month quota = Depreciable amount / Int(Month(Depreciation End Date - Depreciation Start Date -1)) For the first month: First month Depreciation = Month quota * ((Number of Days in First month - Depreciation Start Date)/Number of Days in First month) For every next month but last one: Depreciation = Month quota For the last month: Depreciation = Month quota - First month Depreciation Example: Asset with Useful life = 6 months and Depreciable amount = 120 Depreciation Plan = 14.01 - 14.07 Month quota = 120 / 6 months = 20 First month Depreciation = 20 * ((31-14)/31) = 10.97 For 2,3,4,5 and 6th month Depreciation = 20 Last month Depreciation = 20 - 10.97 = 9.03"
  },
  "modules/financials/Fixed Assets/overview.html": {
    "href": "modules/financials/Fixed Assets/overview.html",
    "title": "Fixed Assets | ERP.net Tech Docs",
    "keywords": "Fixed Assets Depreciation Methods"
  },
  "modules/financials/overview.html": {
    "href": "modules/financials/overview.html",
    "title": "ERP.net Financials | ERP.net Tech Docs",
    "keywords": "ERP.net Financials Accounting Cost Accounting Fixed Assets Intrastat Payments VAT"
  },
  "modules/financials/VAT/defining-vat-and-base-for-vat-entries.html": {
    "href": "modules/financials/VAT/defining-vat-and-base-for-vat-entries.html",
    "title": "Defining VAT and Base for VAT Entries | ERP.net Tech Docs",
    "keywords": "Defining VAT and Base for VAT Entries The current article describes how the numeric values are defined - base and VAT, which are saved in the VAT Entries when this document is created automatically from other documents in EnterpriseOne. Currently the documents which creates VAT Entries are: Invoices (they create records in the VAT sales ledger entries); Transactions (they create records in the VAT sales ledger entries) The calculations are performed in three stages: Defining which document rows participate in the calculation. Defining the deal types for each row. Defining the base and the VAT for each deal type. 1. Defining The Participating Rows Which rows participate in the calculation of the base and the VAT is defined for each document individually. The set of rows also depends on that if the document creates VAT sales or purchases ledger entries. In Invoices all rows participate in the calculation. In Purchase Invoices which create VAT purchases ledger entries all rows participate, too. In Purchase Invoices which create VAT sales ledger entries there are two cases: if the document header has value in Sale Deal Type field, then all rows participate in the calculation; if the document header no value in Sales Deal Type field, then only the rows which has value in the Sale Line Deal Type field (this is the same field but in the document rows). In Transactions all rows participate in the calculation. 2. Defining The Deal Types For each row which participate in the calculation, a unique identification of the deal type of the row must be defined. If for any of the rows this definition is impossible, the calculation process is interrupted and error message is displayed. The deal type definition for a row depends on the document which it is part of and on that if the document creates VAT sales or purchases ledger entries. For Invoice row - if the row has value in the Line Deal Type field, then the deal type is defined by this value. Otherwise, the value in the document header is used. For Purchase Invoice (which creates VAT purchases ledger entries) row - the principle is the same as in the Invoice rows - if the row has value in Line Deal Type field, the deal type is defined by this value, otherwise - the Deal Type from the document header is used. For Purchase Invoice (which creates VAT sales ledger entries) row - the same combination of corresponding fields from the rows and the document header is used, except the fields here are Sales Line Deal Type (in the rows) and Sales Deal Type (in the document header). In Transactions all rows use a specific property of the document flows - Deal Type field from table \"Transaction Entry Template\". There are no specified fields in the document rows and header for the Deal Type. 3. Defining Base And VAT For Each Deal Type All bases and VAT amounts are calculated only in base currency. For all deal types, defined in stage 2, two values are calculated - [base] and [VAT]. To calculate them for the current deal type the rows, which has such deal type defined in stage 2, are used. Example 1: There is an Invoice with 7 rows: row #10, Line Deal Type = \"DealType1\", LineAmount = 32 EUR; row #20, Line Deal Type = \"DealType2\", LineAmount = 17 EUR; row #30, Line Deal Type = \"DealType3\", LineAmount = 41 EUR; row #40, Line Deal Type = \"DealType1\", LineAmount = 45 EUR; row #50, Line Deal Type = \"DealType3\", LineAmount = 55 EUR; row #60, Line Deal Type = \"DealType3\", LineAmount = 29 EUR; row #70, Line Deal Type = \"DealType1\", LineAmount = 24 EUR. Thus, in the previous stage for the rows three deal types are defined - DealType1, DealTyope2 and DealType3. Thus, three bases and three VATs must be calculated - [DealType1:base], [DealType2:base], [DealType3:base], [DealType1:VAT], [DealType2:VAT], [DealType3:VAT]. To calculate base and VAT for DealType1 the data from row #10, row #40 and row #70 are used. For the base and VAT of DealType2 only row #20 is used, and for DealType3 - row #30, row #50 and row# 60. The VAT additional amount is set in the Enterprise Company definition (see Additional Amounts ) of the current document. Id the document does not contain the specified VAT additional amount (or there is no such in the EnterpriseOne company definition),the calculation is interrupted by error message. The distributed additional amount on the rows are used in the calculation of the VAT amounts. And to calculate the bases amounts - the distributed VAT additional amounts which are added to the base and also the line amounts (but only if in the VAT additional amount Base On Lines is true). The bases and VATs calculations are performed in three steps: The amounts for each deal type is formed. The rest of the VAT is processed. VAT, which is calculated/distributed incorrectly, is re-distributed. Step 1 For each deal type two values are calculated - base and VAT. So a list of couples is formed, which has as much elements as deal types there are. This is processed only if the VAT in the document is distributed by the current document (it is possible to distribute on other documents - if so, this step is skipped; it is possible to distribute both on the current document and on different documents - then this step is performed). If the step is skipped, then the list is empty. So, for each deal type all rows, which has the specified deal type, are summed up and from each row the distributed VAT is extracted, the distributed amounts which are added to the Base also, and the line amounts, if the VAT is based on lines. The value of [VAT] for the current deal type is the sum of the distributed VAT for all rows with this deal type. And the value of [base] is the sum of the distributed amounts which are added to the VAT base and the line amounts (if the VAT is based on lines). Example 2: Let's use the Invoice from Example 1 . There is an additional amount VAT, which is 32.32 EUR and it is based on the line amounts and second additional amount \"Loyal Customer Discount\". The discount amount is 40 EUR and the distribution of both additional amounts is as follows: row #10, distributed discount -7 EUR, distributed VAT 5 EUR; row #20, distributed discount -1 EUR, distributed VAT 1.12 EUR; row #30, distributed discount -14 EUR, distributed VAT 0 EUR; row #40, distributed discount -0 EUR, distributed VAT 9 EUR; row #50, distributed discount -11 EUR, distributed VAT 0 EUR; row #60, distributed discount -3 EUR, distributed VAT 5.2 EUR; row #70, distributed discount -4 EUR, distributed VAT 4 EUR. Also the VAT amount is distributed not only on the current document but on other document row which has no other additional amounts and line amount of 40 EUR and the distributed VAT is 8 EUR. Then the following calculations for base and VAT for the different deal types of the current document are received: [DealType1: base] = 32 EUR + -7 EUR + 45 EUR + 0 EUR + 24 EUR + -4 EUR = 90 EUR; [DealType2: base] = 17 EUR + -1 EUR = 16 EUR; [DealType3: base] = 41 EUR + -14 EUR + 55 EUR + -11 EUR + 29 EUR + -3 EUR = 97 EUR; [DealType1: VAT] = 5 EUR + 9 EUR + 4 EUR = 18 EUR; [DealType2: VAT] = 1.12 EUR; [DealType3: VAT] = 0 EUR + 0 EUR + 5.2 EUR = 5.2 EUR; Step 2 If any of the following is true: the list of couples of values from Step 1 is empty (this is possible if the VAT is not distributed on the current document); or the VAT is distributed on other documents also or either not the whole VAT is used when forming the VAT amounts in step 1 or not the whole VAT base is used when forming the bases. Then the creation of a new couple of values is necessary - base and VAT. The deal type for this couple is extracted from the deal type field in the document header (and if the document is Transaction - then it is extracted from the document flow). In the base and VAT for this deal type the remaining values from the base and VAT, which are not distributed in Step 1 from the other deal types, are recorded. Example 3: Lets use the data from Example 2 and the Invoice has a deal type in its header - DealType4. The VAT in the document is 32.32 EUR, and [DealType1: VAT] + [DealType2: VAT] + [DealType3: VAT] = 24.32 EUR. So there are 8 EUR remaining. Also the total VAT base (from both documents) is 243 EUR, and [DealType1: base] + [DealType2: base] + [DealType3: base] = 203 EUR. So the remaining base is 40 EUR. So a new couple of values is formed for DealType4: [DealType4: base] = 40 EUR [DealType4: VAT] = 8 EUR Step 3 At the end, there is a newly formed list of couples of values - base and VAT - for a number of deal types. If one of those deal types does not support VAT and its calculated VAT in the list is not a zero, then a need of correction of those VATs and bases calculated by now, appears. The correction is performed by resetting the VATs of all deal types, which VAT is distributed incorrectly in the documents, and these VATs are distributed amongst the other deal types, proportionally to their bases (if after this re-distribution there is still remaining amount because of roundings, then this small amount is distributed to the last deal type which supports VAT). Example 4: Lets use the data from the previous examples and DealType1, DealType2 and DealType4 support VAT, and DealType3 does not. So there is incorrectly distributed VAT of [DealType3:VAT] = 5.2 EUR. So the 5.25 EUR must be relocated to the rest of the deal types - the following correction is achieved: [DealType3: VAT] = 0 EUR; [DealType1: VAT] = 18 EUR + 5.2 EUR * 90 EUR / (90 EUR + 16 EUR + 40 EUR) = 21.21 EUR; [DealType2: VAT] = 1.12 EUR + 5.2 EUR * 16 EUR / (90 EUR + 16 EUR + 40 EUR) = 1.69 EUR; [DealType4: VAT] = 8 EUR + 5.2 EUR * 40 EUR / (90 EUR + 16 EUR + 40 EUR) = 9.42 EUR."
  },
  "modules/financials/VAT/index.html": {
    "href": "modules/financials/VAT/index.html",
    "title": "VAT | ERP.net Tech Docs",
    "keywords": "VAT"
  },
  "modules/index.html": {
    "href": "modules/index.html",
    "title": "ERP.net Internal Apps | ERP.net Tech Docs",
    "keywords": "ERP.net Internal Apps The internal apps in ERP.net are divided in application groups. To learn more about the apps in a group, click it in the following list: Customer Relationship Management (CRM) Subsystem Logistics Note Your ERP instance might contain external applications, which might not be documented here. External applications are tightly integrated in the user menu. Sometimes, external apps replicate the visuals of the internal apps and might be indistinguishable."
  },
  "modules/logistics/index.html": {
    "href": "modules/logistics/index.html",
    "title": "Logistics | ERP.net Tech Docs",
    "keywords": "Logistics"
  },
  "modules/logistics/inventory/index.html": {
    "href": "modules/logistics/inventory/index.html",
    "title": "Inventory Module | ERP.net Tech Docs",
    "keywords": "Inventory Module"
  },
  "modules/logistics/logistics-common-module-concepts/available-to-promise/atp-algorithm.html": {
    "href": "modules/logistics/logistics-common-module-concepts/available-to-promise/atp-algorithm.html",
    "title": "ATP Algorithm | ERP.net Tech Docs",
    "keywords": "ATP Algorithm The Current Stock Holds are added to the unfulfilled Store orders chronology. Thus, save for the physical availability, store orders which are not fulfilled, but planned to be on a specific date, are taken into account (the Planned Release Date field indicates this date). Besides physical availability, other already planned stock movements are taken into account. The calculated quantities for each date from the new chronology are reviewed and the smallest value is selected. This is the ATP quantity for the specified parameters. We use the smallest value. If on a date when we have the smallest value a greater value is entered as ATP quantity, and this quantity is used for a new issuing operation, it will not be enough for all ordered operations. The minimum quantity in the new chronology actually shows the greatest value we can use for the date specified as a parameter without violating other issuing store processes. Let’s apply that to the example from Available to Promise : After adding the physical availability to the chronology, we have: Date Physical availability Start quantity Receipt quantity Issue quantity End quantity 2021/10/01 8 3 - - 11 2021/10/03 8 - - 2 9 2021/10/04 8 - 16 4 21 2021/10/07 8 - - 8 13 2021/10/09 8 - - 7 6 2021/10/14 8 - 8 - 14 2021/10/16 8 - 4 9 9 2021/10/19 8 - - 2 7 Here is the graphical chart for the new chronology: After reviewing the Value Column (or following the lowest values in the graphical chart), you can see that the lowest value is 6 pcs . This is the Available to Promise quantity for 2021/10/01 . Total Calculations (for a period) When calculating the ATP for a whole period (more than one date), the data gathering, as well as the combination of the chronology and the current stock holds, is executed the way we described earlier. After that, for every date in the period greater than or equal to the date specified as a parameter, the ATP is defined as follows: The minimum quantity value for the whole period is defined - let's call it min1 . Then, we pick the last (greatest) date for this value - date1 . For every date from the starting to date1 (including), the ATP is min1 . If there are dates in the chronology after date1 , the minimum quantity value for the period after date1 is min2 . The last date which has this value is date2 . From the date after date1 and before date2 (including), the ATP is min2 . This is repeated until all dates in the chronology are covered. The period we are making calculations for is divided into several sub-periods (at least one, and at most - equal to the number of dates in the chronology). In the first sub-period, there is a minimum value for the ATP. For each subsequent sub-period, the ATP is greater than the ATP for the previous sub-period. For example, let's have have the following chronology for the period between 01.10 and 06.10 , calculated after adding the current physical availability to the data from the unexecuted Store Orders. Date Physical availability Start quantity Receipt quantity Issue quantity End quantity 2021/10/01 12 8 - - 20 2021/10/03 12 - 2 - 22 2021/10/08 12 - 5 - 27 2021/10/09 12 - 2 19 10 2021/10/12 12 - - 7 3 2021/10/15 12 - 28 6 25 2021/10/16 12 - - 7 18 2021/10/20 12 - 6 9 15 2021/10/21 12 - - 3 12 2021/10/24 12 - 24 5 31 2021/10/30 12 - - 6 25 2021/10/31 12 - - 5 20 After reviewing the chronology, we establish that the period from 2021/10/01 to 2021/10/06 is divided to three sub-periods: one from 2021/10/01 to 2021/10/14 , another from 2021/10/15 to 2021/10/23 and a third from 2021/10/24 to 2021/11/06 . For the first period, the minimum value (hence the ATP) is 3 pcs . For the second period, it is 12 pcs , and for the last period, the ATP is 20 pcs . These calculations are represented by a graphic: Modifications in the algorithm implementation There are some specific changes in the ATP calculation for algorithm implementation. When using the unexecuted Store Orders chronology instead of starting with an opening balance for a defined period, the definition of the start quantity for the unexecuted Store Orders is not really effective. All store movements - the unexecuted by now store orders - are used without limits for date and without calculation for the starting value. These movements calculate the ATP for sub-periods. To calculate the ATP for a specific date, we simply take into account the periods before this date and the minimum value from the last period. This method is effective enough. However, problems appear when we want to calculate the ATP for a date before all existing unexecuted Store Orders. There is no Store Orders chronology for this date and as the opening balance is not calculated (it would be zero), the previously mentioned principle for ATP calculation cannot be applied. When the date for which we calculate the ATP is before the earliest unexecuted Store Order, the following principle is applied: All unexecuted Store Orders after the specified date are taken into account, and the ATP is calculated according to their chronology. This is a value Projected Available Balance . The current available physical quantity is calculated - value [ Current Stock Holds ] If there are future unexecuted Store Orders, (i.e., if [ Projected Available Balance ] is not null), then: [ ATP ] = min([ Projected Available Balance ], [ Current Stock Holds ]) Otherwise, [ ATP ] = [ Current Stock Holds ] For example, if the current physical availability is 10 pcs and there are the following unexecuted Store Orders: 2021/10/09 - 2 pcs , receipt; 2021/10/13 - 7 pcs , issue; 2021/10/16 - 6 pcs , receipt. the ATP for the dates from 2021/10/09 to 2021/10/15 (including) is 5 pcs . After this date, it is 11 pcs . If we have the same data from the previous example, but the issue for 2021/10/13 is 1 pcs , then the ATPs would be as follows: before 2021/10/09: 10 pcs (this is the smaller value from the current physical availability and the Projected Available Balance after 2021/10/09 ); from 2021/10/09 to 2020/10/15 (including): 11 pcs ; from 2021/10/16 onward: 17 pcs ."
  },
  "modules/logistics/logistics-common-module-concepts/available-to-promise/atp-reports.html": {
    "href": "modules/logistics/logistics-common-module-concepts/available-to-promise/atp-reports.html",
    "title": "ATP Reports | ERP.net Tech Docs",
    "keywords": "ATP Reports In Version 2018.2, we introduced two new reports – Available to Promise and Available to Promise (By Lots) . These reports show the quantities Available to Promise (ATP) (by product or by product lot) from a current or future date, but not only as a calculated number. The reports allow us to see the separate records for all planned movements and therefore the Projected Available Balance (PAB) for the different dates. Using it, we can see which numbers are behind the value of (ATP) and how it is calculated for the different periods. Details The ATP available on a given date is the quantity that can be promised to orders scheduled for shipment (for more information, see topic Available To Promise ) from that date to the date of the next planned movement. That is why the ATP in the reports is calculated from each scheduled date. In ERP.net, this is the Planned Release Date of the Store Orders. The records represent the chronology of the unfulfilled parts of non-voided Store Orders, which has statuses from Planned to Released included. There is a separate record for each combination of date, product, enterprise company and store . In the Available to Promise (By Lots) report, the records are also separated by a lot . The calculation of ATP is based not only on the data of the Chronology of the Store Orders which are not executed , but also on the information of the Current Stock Holds (see topic Available To Promise ). However, for the particular product or store, there may not be any unfulfilled shipments or deliveries and therefore those records won’t exist in the reports. For this reason, the reports start with an auxiliary line with a fictive “From date” which is equal to 01.01.2000 and contains the information for the starting availability, i.e. the Current Availability . As mentioned above, the rest of the records represent the Chronology of the Store Orders which are not executed . They contain information for: Movements Base - The sum of the quantity of all planned stock movements (issue and receipt) on this date in base measurement unit. Movements To Date Base - A running total of the quantity of all planned stock movements (issue and receipt) until this date (inclusive) in base measurement unit. Projected Availability - Projected Availability in base measurement unit on a particular date. A running total of the projected/expected available quantity calculated by adding supply or subtracting demand in chronological order in base measurement unit. The value includes all expected stock movements (issue and receipt) until this date (inclusive) and the current availability. ATP Base - Indicates the promissory amount in base unit valid from a specified date to the date of the next stock movement. This is the minimum quantity available for use for future issuing operations (sales, use in production, etc.), and which will not violate the planned issue operations."
  },
  "modules/logistics/logistics-common-module-concepts/available-to-promise/index.html": {
    "href": "modules/logistics/logistics-common-module-concepts/available-to-promise/index.html",
    "title": "Available To Promise | ERP.net Tech Docs",
    "keywords": "Available To Promise Description The Available To Promise (ATP) for a product and a date is the minimum quantity available for use in future issuing operations (sales, production, etc). It will not interfere with the issue operations, including this product, no matter if they are already planned, finished, or being executed just now. The calculation of the ATP is made by dates and it has meaning for the present or future dates. There is no use calculating it for past periods. Even more, the ATP Algorithm , which is used for the calculation, is based on the fact that the ATP quantities are calculated for a date greater than or equal to today's date. This is because the current stock holds are used instead of their movements chronology. The parameters, data, and ATP Algorithm used for the ATP calculation are shown below. We will try to calculate the ATP for a specific date. Then, there is a detailed example of an ATP calculation for a long period (more than one date). Parameters The main/required parameters are product , own company , and date . The ATP calculation is executed from the date and for the specified product and own company. Additional parameters can be set as store and lot . If a store is specified, the calculation will be executed only for this store. Otherwise, the data is collected from all stores (as though it is limited by the product, the own company, and the date). The lot specification is similar. Data For a standard ATP calculation, two types of data are used: 1. Current Stock Holds : It shows the availability of the product selected in the specified own company. If a store and a lot are provided, the data is filtered by them. 2. Chronology of the Store Orders which are not executed : It loads the chronology of the unfulfilled parts of non-voided Store Orders, with statuses ranging from \"Planned\" to \"Released\". The data is filtered by the parameters entered for a product, own company, store, and lot. The chronology is sorted by the \"Planned Release Date\" field. The data in this field is fundamental for ATP calculations. For example, let's assume that we have specified a product , own company , store and lot , and we want to calculate the ATP for date 2020/10/01 . The physical availability for this date is 13 pcs , and before that date there are two unfulfilled, released Store Orders - one for receiving 7 pcs with date 2020/09/28 and one for issuing 4 pcs with date 2020/09/29 . The documents after 2020/10/01 are as follows: 2020/10/03 - released issuing store order for 5 pcs , 3 pcs of which are fulfilled with a store transaction on the same date, so the unfulfilled quantity is 2 pcs; 2020/10/03 - released issuing store order for 5 pcs , which is fulfilled with a store transaction marked as single execution and contains 2 pcs from the same date, so the unfulfilled quantity is 0 pcs ; 2020/10/04 - planned receipt store order for 16 pcs , unfulfilled; 2020/10/04 - planned issuing store order for 4 pcs , unfulfilled; 2020/10/07 - planned issuing store order for 8 pcs , unfulfilled; 2020/10/09 - planned issuing store order for 7 pcs , unfulfilled; 2020/10/14 - planned receipt store order for 8 pcs , unfulfilled; 2020/10/16 - planned receipt store order for 4 pcs , unfulfilled; 2020/10/16 - planned issuing store order for 9 pcs , unfulfilled; 2020/10/19 - planned issuing store order for 2 pcs , unfulfilled; The current availability is 8 pcs . It is calculated by adding the two issuing store transactions with date 2020/10/03 to the availability from 2020/10/01 . The unfulfilled store orders chronology is as follows: Date Start quantity Receipt quantity Issue quantity End quantity 2020/10/01 3 - - 3 2020/10/03 - - 2 1 2020/10/04 - 16 4 13 2020/10/07 - - 8 5 2020/10/09 - - 7 -2 2020/10/14 - 8 - 6 2020/10/16 - 4 9 1 2020/10/19 - - 2 -1 The start quantity on 2020/10/01 is calculated by the two issuing store orders before 2020/10/01 . For the next dates, the unfulfilled store orders from the specific date are added. Further Reading: ATP Algorithm ATP Reports"
  },
  "modules/logistics/logistics-common-module-concepts/goods-cost/cost-correction/basic-algorithm-for-cost-correction-calculation.html": {
    "href": "modules/logistics/logistics-common-module-concepts/goods-cost/cost-correction/basic-algorithm-for-cost-correction-calculation.html",
    "title": "Basic Algorithm For Cost Correction Calculation | ERP.net Tech Docs",
    "keywords": "Basic Algorithm For Cost Correction Calculation This algorithm is applied to multiple records: either transaction rows or accumulated records for goods cost (most often opening a balance for а specified period). The algorithm has two stages: The records are ordered chronologically. The cost of the rows that do not include accumulated information is recalculated one by one. The cost of transaction rows in multiple records is recalculated instead of the accumulated data. The mismatch between the newly calculated and the current actual cost is saved in the document Cost Correction . With the release of Cost Correction , the costs in the Transaction rows are updated. Multiple records are generated when all transaction operations for a period (as well as the opening balance at the start of the period) are loaded. It is of great importance for all transaction operations and opening balances to be loaded during the operation. Any of them missing may lead to incorrect cost correction (during stage 2 of the algorithm). Stage 1: Chronological Sorting Of The Records The following criteria is used to order the records chronologically: In case two records share the same Enterprise Company, Store, Product , and Lot (only if the product has a separate cost for each lot), the records with a shorter Transaction Timestamp are placed before the ones with a greater Transaction Timestamp . If the Transaction Timestamps are equal, the receipt goes before the issue operation. If the records have the same Movement Type , it is assumed that the operations have happened at the same time. If two records - part of a transfer or a production process - have opposite Movement Types , then an issue transaction is performed before a receipt transaction (only if the Transaction Timestamp of the issue transaction is smaller than or equal to the receipt transaction). Enterprise Company, Store, Product , and Lot do not affect the order here. The criteria above can’t provide thorough sorting of the records. That is why a topological sorting is applied. Any topological sorting may be used - more than one for a specific partial sorting. The result in the next stage is the same regardless of the sorting method used. Stage 2: Recalculating The Sorted Records When the records are ordered in the previous stage, the cost accumulated from the starting period (average) is calculated. Then, the cost of each record is recalculated. Finally, the recalculation of the next record begins (if there is one in the first place). The recalculation of the record cost is performed as follows: If the record is for accumulated data (opening balance), the record is not recalculated. If the record is an issue transaction, then the cost is calculated according to the average accumulated cost. If the record is a receipt transaction and is part of a transfer or a production process, then its cost is recalculated according to the algorithm from articles Calculating Cost For Produced Products , Calculating Cost For Transferred Products , and Calculating Cost For Returned Products . If the record is a receipt transaction and is not part of a transfer or a production process, the record is not recalculated. Example 1: There are two stores and three products, the first two of which are provided by external suppliers. The third is internally produced. A recalculation of the cost for January 2020 is needed. This is the data for the first store. The second store has no movements recorded (including the current period): Store # 1 , Product # 1 , Opening Balance , before 01 Jan 2020 00:00, 10 PCS, total cost: 100 ; Store # 1 , Product # 2 , Opening Balance , before 01 Jan 2020 00:00, 10 PCS, total cost: 150 ; Store # 1 , Product # 1 , receipt transaction , Transaction Timestamp 05 Jan 2020 17:27 , 10 PCS, total cost: 140 ; Store # 1 , Product # 2 , receipt transaction , Transaction Timestamp 05 Jan 2020 17:27 , 10 PCS, total cost: 190 ; On 16 Jan 2020 , a certain quantity from the third product is manufactured and added in the other store: Store # 1 , Product # 1, issue transaction , Transaction Timestamp 16 Jan 2020 10:12 , 4 PCS, total cost: 48 ; Store # 1 , Product # 2, issue transaction , Transaction Timestamp 16 Jan 2020 10:25, 6 PCS, total cost: 102 ; Store # 2 , Product # 3 , receipt transaction, Transaction Timestamp 16 Jan 2020 14:47, 2 PCS, total cost: 150 . Then, on 19 Jan 2020 , part of the produced quantity is moved to the first store and the transport costs 7 : Store # 2 , Product # 3, issue transaction , Transaction Timestamp 19 Jan 2020 11:32, 1 PCS, total cost: 75 ; Store # 1 , Product # 3, receipt transaction , Transaction Timestamp 16 Jan 2020 11:50, 1 PCS, total cost: 82 . It turns out that there was a receipt transaction on 11 Jan 2020 which is not entered in the system on time: Store # 1 , Product # 1, receipt transaction , Transaction Timestamp 11 Jan 2020 13:44 , 5 PCS, total cost: 85 ; Store # 1 , Product # 2, receipt transaction , Transaction Timestamp 11 Jan 2020 13:44 , 6 PCS, total cost: 44 . The cost of all other store Transactions during this month is incorrect (except the first two receipts on 05 Jan 2020 ) and has to be recalculated. When executing the algorithm with the previous data, the following order of records will be completed after the first stage: Store # 1 , Product # 1, Opening Balance , before: 01 Jan 2020 00:00 ; Store # 1 , Product # 2, Opening Balance , before: 01 Jan 2020 00:00 ; Store # 1 , Product # 1, receipt transaction , Transaction Timestamp: 05 Jan 2020 17:27 ; Store # 1 , Product # 2, receipt transaction , Transaction Timestamp: 05 Jan 2020 17:27 ; Store # 1 , Product # 1, receipt transaction , Transaction Timestamp: 11 Jan 2020 13:44 ; Store # 1 , Product # 2, receipt transaction , Transaction Timestamp: 11 Jan 2020 13:44 ; Store # 1 , Product # 1, issue transaction , Transaction Timestamp: 16 Jan 2020 10:12 ; Store # 1 , , Product # 2, issue transaction , Transaction Timestamp: 16 Jan 2020 10:25 ; Store # 2 , Product # 3, receipt transaction , Transaction Timestamp: 16 Jan 2020 14:47 ; Store # 2 , Product # 3, issue transaction , Transaction Timestamp: 19 Jan 2020 11:32 ; Store # 1 , Product # 3, receipt transaction , Transaction Timestamp: 19 Jan 2020 11:50 . After the recalculation in the second stage for the last five transactions, the following actual costs will be calculated: Store # 1 , Product # 1, issue transaction , Transaction Timestamp: 16 Jan 2020 10:12 , recalculated cost: 52 ; Store # 1 , Product # 2, issue transaction , Transaction Timestamp: 16 Jan 2020 10:25 , recalculated cost: 96 ; Store # 2 , Product # 3, receipt transaction , Transaction Timestamp: 16 Jan 2020 14:47 , recalculated cost: 148 ; Store # 2 , Product # 3, issue transaction , Transaction Timestamp: 19 Jan 2020 11:32 , recalculated cost: 74 ; Store # 1 , Product # 3, receipt transaction , Transaction Timestamp: 19 Jan 2020 11:50 , recalculated cost: 81 . This means that in the Cost Correction document, 5 rows will be created, one for each of thе operations with cost changed, and the rows will save the mismatches: 52 - 48 = 4 , 96 - 102 = - 6 , 148 - 150 = - 2 , 74 - 75 = - 1 and 81 - 82 = - 1 ."
  },
  "modules/logistics/logistics-common-module-concepts/goods-cost/cost-correction/index.html": {
    "href": "modules/logistics/logistics-common-module-concepts/goods-cost/cost-correction/index.html",
    "title": "Cost Correction | ERP.net Tech Docs",
    "keywords": "Cost Correction The current article describes the calculation (and recalculation) of the actual cost . The article Original Cost Calculation describes how the original cost is calculated. Those calculations are accurate as long as the store transactions are entered in their original chronology. If the order is incorrect, so will be the cost. Example 1: There are two receipt transactions and one issuing transaction entered in the system: receipt , Timestamp: 05 Jan 2020 12:45, 4 PCS , total cost: 100 EUR ; receipt , Timestamp: 05 Jan 2020 17:27, 3 PCS , total cost: 75 EUR ; According to the Original Cost Calculation for average cost, the issuing transaction should be: issue , Timestamp: 08 Jan 2020 11:29, 5PCS , total cost: 5 * (175/7) = 125 EUR ; There is another receipt transaction not entered on time. It happened on 07 Jan 2020 and was entered on 08 Jan 2020 : receipt , Timestamp: 07 Jan 2020 23:59, 3PCS , total cost: 105 EUR ; If the third receipt transaction is entered on time, then the unit cost on 08 Jan 2020 would be 280/10 = 28 , not 25 , as it was originally calculated in the issuing transaction. This is happening due to the late entering of the transaction in the system. The cost of the issuing transaction is incorrect and a recalculation is needed. The effect of the incorrect cost from Example 1 may influence not only issuing transactions. If the issuing operation was about ingredient consumption from the Production module, for example, then the cost of the production output would be incorrect as well. This leads to incorrect cost when issuing the production output. If you don't enter the transactions in the system on time, there will be negative consequences. To correct them, there is a Basic Algorithm For Cost Correction Calculation . This algorithm changes the costs as if they were entered on time. There is a document named Cost Correction, where the results from this calculation should be saved. Тhe rows of the document show how the cost is changed (base cost, product cost, store cost, and document cost) for each Transaction row affected. Cost Corrections allow the Original Cost to be changed. In each Transaction row the fields are as follows: [actual/corrected cost] = [original cost] + [adjustment cost] where: [original cost] = the product, store, document, and base cost saved in the Transaction row; [adjustment cost] = the sum of all product, store, document, and base cost values saved in the rows of all the released, non-voided Cost Corrections referring to the current Transaction row. For more specific information, see: Basic Algorithm For Cost Correction Calculation Models For Maintaining The Actual Cost Specific Procedures of Cost Corrections"
  },
  "modules/logistics/logistics-common-module-concepts/goods-cost/cost-correction/models-for-maintaining-the-actual-cost.html": {
    "href": "modules/logistics/logistics-common-module-concepts/goods-cost/cost-correction/models-for-maintaining-the-actual-cost.html",
    "title": "Models For Maintaining The Actual Cost | ERP.net Tech Docs",
    "keywords": "Models For Maintaining The Actual Cost There are two main models to keep the goods cost up-to-date. Right from the start, when we enter (and release) the Transactions, the actual cost is recalculated. The costs of all existing store transactions affected by the current Transaction are also calculated. This leads to a perfect situation where all transactions are correctly calculated no matter when they are entered in the system. In addition, the calculation is performed by the system and the user does not have to control it. The disadvantage of this model is the additional calculations for creating and releasing a Transaction, especially when that Transaction is old. This may lead to slow performance of the Logistics module. The corrections are created periodically by a user instead of immediately for each Transaction. This model provides the easier daily creation of a Transaction with a risk for incorrect costs not covered by Cost Correction (this happens only when store transactions are entered in a non-chronological manner). Dynamic Cost Correction Maintaining the actual cost at all times with the first model is accomplished by using two specific procedures for generating Cost Correction from every Transaction. They have to be created when the Transaction is released and the generation of the Cost Correction updating the cost of the current Transaction is performed first. Thus, when the Transaction is released, it will have its original cost, and the first generation will correct its values if necessary. We assume that the cost of all existing released Transactions before the creation of the current Transaction are correct (as the cost of the current Transaction may be affected by them). Once the first generation corrects the cost of the newly entered Transaction, the second generation corrects the cost of all other transactions that depend on the current Transaction. Thus, after its release, the cost of all Transactions in the system will be actual no matter the date they are entered. The older the transaction, the slower the performance of the two generation procedures will be (this means that more Transactions will be affected by the current transaction). Periodical Cost Correction The second model for Cost Correction does not use automatic generation procedures for the Cost Corrections. Instead, the user manually enters documents for a specified period (month, quarter, etc.) and starts the Basic Algorithm For Cost Correction Calculation for all Transactions in the specified period. For example, if Cost Corrections are performed monthly, the user creates a new Cost Correction document and sets the period from the first date to the last date of the month. Then, he starts the function \" Recalculate the corrections for the period \", which loads all store transactions where Transaction Timestamp is in the specified period. The function then adds the opening balances at the beginning of the period, and this data is executed by the Basic Algorithm For Cost Correction Calculation . So, the actions of the user are limited to entering the start and end dates, starting the function and releasing the document. This is performed for past periods (i.e. not for the current month) for which there will be no more new Transactions, and in which the Cost Corrections are already calculated and released. Otherwise, there may be incorrect cost in the current-period transactions. The recalculation of the cost of all transactions in a specified period may take more time than if the first model is used, but it eases the daily Transactions release significantly. Also, for Periodical Cost Correction , a more appropriate execution time may be picked (for example, during the night)."
  },
  "modules/logistics/logistics-common-module-concepts/goods-cost/cost-correction/specific-procedures-of-cost-corrections.html": {
    "href": "modules/logistics/logistics-common-module-concepts/goods-cost/cost-correction/specific-procedures-of-cost-corrections.html",
    "title": "Specific Procedures of Cost Corrections | ERP.net Tech Docs",
    "keywords": "Specific Procedures of Cost Corrections Apart from the standard method of Cost Correction - loading the store transaction for a specified period (plus the opening balances) and filling in the rows for the correction by the Basic Algorithm For Cost Correction Calculation , there are two more ways to create a Cost Correction document. They use generation procedures available in the Transaction document. Cost Correction Generation Procedure For The Actual Cost Of The Current Transaction This generation procedure updates the cost of the store transactions in the current Transaction document. For each row, the following actions are applied: Loading the actual cost by the current moment (i.e. this is the sum of the original cost from the Transaction row and the addition cost in the row, generated by already created Cost Corrections). This is a sum [current cost] ; Then, the actual cost for the row is calculated - the sum [actual cost] as usual: a. if the Transaction is issuing , the cost is calculated by the average accumulated cost; b. if the record is a receipt transaction and is part of a transfer or production process, its cost is recalculated according to the algorithm from articles Calculating Cost For Produced Products , Calculating Cost For Returned Products and Calculating Cost For Transferred Products ; c. if the record is a receipt transaction and is not part of a transfer or production process, the original cost is considered the actual cost. To make valid calculations, the cost of all store transactions affecting the current transactions should be recalculated correctly. At the end, the difference [actual cost] - [current cost] is calculated. Provided that it is different than zero, a new row is added in the Cost Correction sub-document for the current Transaction row, which contains the difference. Cost Correction generation procedure for the current Transaction results This generation procedure updates the costs of all transactions that depend on the current Transaction rows. The following actions are executed: Loading all store transactions (with the opening balances if needed) which depend on the current document; Тhe Basic Algorithm For Cost Correction Calculation is applied over the loaded set of records; For each store transaction from the set of records, the difference between the algorithm result and the actual cost valid before the creation of the current transaction, is calculated. If it is a non-zero result, a new row in the Cost Correction is added. Loading the records is performed iteratively. Before the first iteration, the following is created: [current set of records] = the transactions in the current Transaction document; [current Movement Type ] = Movement Type of the current Transaction; [result] = [current set of records] + the opening balances for the current store of the current products from the transactions of the [current set of records] (the opening balances are for the Transaction Timestamp date) Then, a cycle of iterations is performed, and for each iteration, the following is executed: if the [current Movement Type ] = receipt , a new set of records is loaded; [new set of records] = all transactions for the stores and the products (and the lots, if the product keeps separated cost for each lot) from the [current set of records] whоse Transaction Timestamp is greater than or equal to the Transaction Timestamp in the [current set of records] . If the [current Movement Type ]= issue and the [current set of records] has records that are part of a transfer/production process, then the [new set of records] is as follows: [new set of records] = all receipt transactions from the specified transfer/production processes, whose Transaction Timestamps are greater than or equal to the Transaction Timestamps in the [current set of records] . The result is updated and the current set of records becomes: [result] = [result] U [new set of records] (the opening balances are added for every new store which is part ot [new set of records] but is not part of [current set of records]) ; [current set of records] = [new set of records] . At the end, if [current Movement Type ] = receipt , then [current Movement Type ] is set to issue and if it was [current Movement Type ] = issue , [current Movement Type] is set to receipt . These iterations are performed until an iteration has a [new set of records] that is empty."
  },
  "modules/logistics/logistics-common-module-concepts/goods-cost/index.html": {
    "href": "modules/logistics/logistics-common-module-concepts/goods-cost/index.html",
    "title": "Goods Cost | ERP.net Tech Docs",
    "keywords": "Goods Cost Currently, the goods cost in ERP.net is calculated by the Transactions documents. For each Transaction the cost is defined either automatically when the document is released or by the parent document. This is determined by the Cost Source field. It has two possible values: ‘Store’ - this value sets out that the cost in the Transaction is defined when releasing the document by the accumulated cost in the store. This is used when issuing transactions are executed. ‘Document’ - the cost is defined by the data in the Transaction rows ( Unit Cost and Line Cost fields). This data is usually inherited by the parent document and used when receipt operations are executed (the only exception is when the receipt operation comes from ‘Reconciliation’ - then, the value in Cost Source is ‘Store’). ‘Store Orders’ enable other modules to set goods cost. They contain not only the quantity but in specific cases, what the goods cost should be. This cost is copied to the Transactions. The Cost Source is set to Document in the Transactions executing the specific Store Order. This is how they participate in the cost definition. For each store transaction (i.e. Transaction document) changing the cost, a specific Timestamp is saved. It indicates the time the operation starts influencing the cost. The field in the Transaction rows is called Transaction Timestamp . Generally, the transactions should be entered in the system in the right chronology. Usually, the Transaction Timestamp is set either by the ‘Transaction release’, or by the ‘Store Orders’ as follows: in the parent Store Order, a specific Transaction Timestamp is set. This value is inherited by the Transaction that executes the ‘Store Order’'; if the parent Store Order has no Transaction Timestamp and the Transaction has today's date or future date, then the Transaction Timestamp is set to current date and time; if the parent Store Order has no Transaction Timestamp and the Transaction has past date, then the Transaction Timestamp is set to XX.XX.XXX 23:59:00, where XX.XX.XXXX is the document's date. If necessary, the Transaction Timestamp may be set manually by the user, although there are certain limitations. For example, if the quantity in the row is 0, the date in Document Date should be no different than the one in Transaction Timestamp . For more information, see the Setting Transaction Timestamp article. Cost types When the Transactions are not entered in the system on time and damage the right chronology, this may generate incorrect costs. To fix this, ERP.net has developed a Cost Correction system, recalculating the cost as if it was entered in the right chronological order. There are two types of goods costs: Original Cost - defined right when entring the document. Depends on the entry order. Cost Adjustment – for the definition of this cost, a special recalculation is used. It compensates the wrong chronology of the transactions. Cost Currency In the Transactions, the cost comes in four currencies: base cost, product cost, store cost, and document cost . For each row, the cost is calculated independently. The base currency comes from the Enterprise Company definition of the current Transaction. Product currency is part of the product definition and if there is no currency, then the base cost is used. Store currency is in the store definition; if there is no currency - the base currency is used. The document currency is set in the Document Currency field. For each store transaction, the cost is calculated in all four currencies when defined automatically. For more specific information about cost calculations see the following articles: Cost Correction Original Cost Calculation"
  },
  "modules/logistics/logistics-common-module-concepts/goods-cost/original-cost-calculation/calculating-cost-for-inventory-reconciliation.html": {
    "href": "modules/logistics/logistics-common-module-concepts/goods-cost/original-cost-calculation/calculating-cost-for-inventory-reconciliation.html",
    "title": "Calculating Cost for Inventory Reconciliation | ERP.net Tech Docs",
    "keywords": "Calculating Cost for Inventory Reconciliation The cost of the issue and receipt store transactions, which are the result of an Inventory Reconciliation, are calculated according to the current availabilities in the store, as on the date of the inventory reconciliation. Since some of the products may not be available, the calculation is performed according to the following algorithm: The current availability of the product on the date of the inventory reconciliation is calculated. If the current availability is different from 0, the Average Cost is taken. If the current availability is 0, the Unit Cost of the last issue store transaction is taken. If there is no previous issue store transaction, the Standard Cost is taken (from the product definition)."
  },
  "modules/logistics/logistics-common-module-concepts/goods-cost/original-cost-calculation/calculating-cost-for-produced-products.html": {
    "href": "modules/logistics/logistics-common-module-concepts/goods-cost/original-cost-calculation/calculating-cost-for-produced-products.html",
    "title": "Calculating Cost For Produced Products | ERP.net Tech Docs",
    "keywords": "Calculating Cost For Produced Products In the production process, some materials (issued from one or multiple stores) are transformed into a certain output (entered into the store). The cost of the issue transactions has to be transferred to the receipt transactions. This is similar to the transfer and return of goods (see Calculating Cost For Transferred Products and Calculating Cost For Returned Products ). However, the calculations are different. During production, the receipt Store Orders are generated by Output Orders. There are two stages for calculating the cost in the receipt Store Orders: Comparison between the rows in the Consumption Orders and the rows in the Output Orders. For each row in the Output Orders, that comparison defines which materials are used for the production of the product in the current row. For each row in the Consumption Orders, the cost of the issue transactions of the current row is distributed by its relevant Output Orders rows from stage 1. In the end, it is provided that on each Output Order row, the distributed amount comes only from the materials that are used for the produced products in the current row. This distributed amount is written as a specifically set cost in the receipt Store Order, which is generated by the Output Order. Stage 1: Comparison Of The Rows In The Consumption And Output Orders Released, non-voided Consumption Orders and Output Orders that are sub-documents of a given Work Order are taken into account. For each row of an Output Order, the following is defined: what part of the materials is used to produce the specified row and from which Consumption Order rows the materials are taken. This data is saved in a Distributed Material Consumptions table (part of the Output Order data). The Output Orders may get materials only from Consumption Orders released before the Output Order. In other words, the release order for Consumption and Output Orders defines how the quantities in their rows will be compared. When a user creates a new Output Order and releases it, the distributed materials are recalculated. This is true for corrections as well. For each Output Order row, the following is executed: All rows for released, non-voided Consumption Orders for the current Work Order Item are filtered (their quantities need to be taken into account). The Consumption Orders are released before the current Output Order. From the quantities of the rows in step 1, quantities of materials distributed on the same Work Order Item by Output Orders (released before the current one) are removed . From what's left of the materials, the necessary quantities for the current row of the Output Order are distributed . They are defined by the Recipe in the Work Order. For the current row, they cannot be distributed in bigger quantities than they are allowed to. Exception is made only for the last Output Orders from each Work Order Item or for the Output Order rows marked as Finished . The rest of the materials are distributed on Finished rows. When releasing new Consumption Orders or voiding released Consumption Orders, these steps are executed again for each Output Order from the current Work Order. This keeps the distributions for these Output Orders up-to-date. Example 1 : There is a Work Order producing 3 PCS of a product. The materials are 9 PCS from Material #1 and 12 PCS from Material #2 . The materials are consumed in two stages: Consumption Order CO#1 , which has 8 PCS from Material #1 and 8 PCS from Material #2 Consumption Order CO#2 , which has 1 PCS from Material #1 and 4 PCS from Material #2 Both Consumption Orders are released and the first Output Order is created for 2 PCS of the Work Order Item. When this Output Order is released, the following materials distribution is calculated: Product, CO#1 , Material #1 , 6 PCS ; Product, CO#1 , Material #2 , 8 PCS . Then, the user creates and releases an Output Order for the rest 1 PCS of the Work Order Item. It distributes the following: Product, CO#1 , Material #1 , 2 PCS . Product, CO#2 , Material #1 , 1 PCS . Product, CO#2 , Material #2 , 4 PCS . In the current stage, it is possible that no issue/receipt store transactions have been released yet. Therefore, this distribution is used to reserve materials for Work Order Items. When the store transactions begin, the cost of the issue transactions is transferred to the receipt transactions (Stage 2) using the already calculated distribution. Sometimes the remaining non-distributed materials from an Output Order are less than what is ordered by the recipe in the current Output Order. In this case, the Output Order is distributed in fewer than the technologically defined quantities. The remaining excess (if, of course, this is requested by following Consumption Orders) will be distributed to the last Output Order of the current work order item (or to a row marked as \"Finished\"). Let's take a look at such an example. Example 2 : We have the same Work Order as in Example 1 . First, CO#1 is released with 5 PCS of Material #1 and 6 PCS of Material #2 . Then, an Output Order is released for the 2 PCS of the work order item. According to the recipe, 6 PCS of Material #1 and 8 PCS of Material #2 should be distributed. By now, no Consumption Orders with such quantities have been released. As a result, the Output Order takes fewer quantities (from CO#1 ): Work Order Item, CO#1 , Material #1 , 5 PCS ; Work Order Item, CO#1 , Material #2 , 6 PCS . Then, CO#2 is released with the rest of the materials quantities - 4 PCS and 6 PCS , respectively. When the second Output Order is released for the remaining 1 PCS , more materials per unit will be distributed than in the first Output Order: Work Order Item, CO#2 , Material #1 , 4 PCS ; Work Order Item, CO#2 , Material #2 , 6 PCS . There are cases when non-distributed materials remain even after the release of the last Output Order on one work order. Usually, this happens if Consumption Orders are released after all Output Orders. As a final result, an Output Order with 0 quantity is released. Such Output Orders are called Completing Output Orders and all remaining materials are distributed to them. Sometimes these orders are not only released, but come before the last Output Order with non-zero quantities. This is done when there are non-distributed materials, though the next Output Orders will not be released soon. The Completing Output Orders (also known as intermediate ) \"collect\" all the remaining material quantities without having to release the next Output Order. The two examples above describe production processes where each material from a Work Order is assigned to exactly one work order item. There are materials which cannot be assigned to a specific work order item (the Work Order Item field in the Ingredients table is empty). Instead, the quantity of the material is distributed to all work order items in the current Work Order. This distribution may be achieved by two methods (different values in the Distribute By field): by Standard Price - the current Standard Price Per Lot of the products from the Work Order rows (the work order items) is used. The price is then multiplied by the quantities in the rows and the result becomes a coefficient for materials distribution; by Measurement - the quantities from the Work Order rows are used as coefficients. Each quantity is converted into a measurement category, which is specified in the material row. All products must have defined product dimensions for the specified category. After the coefficients are defined by one of the methods, the quantities from the Consumption Order are distributed to an Output Order as follows: All rows of released, non-voided Consumption Orders are filtered . The Consumption Orders are released before the current Output Order. The quantities from p.1 are decreased by the material quantities distributed to Output Orders which are released before the current one. The entire remaining materials quantity is distributed by the coefficients among all rows of the current Output Order. To define the coefficients, the quantities from the current Output Order are used. NOTE: If all work order items have a Standard Price Per Lot of 0 (zero), the coefficients would also be 0. In that case, the cost of all materials from p.2 is distributed equally among the work order items. As a result, cost loss is avoided. Example 3 : There is a Work Order with 295 PCS of a given material, which is distributed by Standard Price among four work order items of the Work Order: Product #1 (standard price is 17 EUR), Product #2 (standard price is 9 EUR), Product #2 (standard price is 12 EUR), and Product #4 (standard price is 20 EUR). For each work order item, 2 PCS are produced. First, CO #1 is released for 189 PCS of the material. Then, OO #1 is released with the following: 2 PCS of Product #1 , 1 PCS of Product #2 and 1 PCS of Product #4 . The coefficients for distribution in the current Output Order are: 2 * 17 : 1 * 9 : 1 * 20 = 34 : 9 : 20. According to these coefficients, the following distribution is achieved: Product #1 , CO#1 , Material, 189 * 34 / (34 + 9 + 20) = 102 PCS ; Product #2 , CO#1 , Material, 189 * 9 / (34 + 9 + 20) = 27 PCS ; Product #3 , CO#1 , Material, 189 * 20 / (34 + 9 + 20) = 60 PCS . Then, a new CO #2 is released for the rest 106 PCS , and the last Output Order is released for the rest of the work order items. It has the following coefficients: 1 * 9 : 9 * 12 : 1 * 20 = 9 : 24 : 20. The distribution is calculated as follows: Product #2 , CO#2 , Material, 106 * 9 / (9 + 24 + 20) = 18 PCS ; Product #3 , CO#2 , Material, 106 * 24 / (9 + 24 + 20) = 48 PCS ; Product #4 , CO#2 , Material, 106 * 20 / (9 + 24 + 20) = 40 PCS . Stage 2: Issue Transactions Cost Distribution Once Stage 1 is completed, the cost of the issue transactions is transferred to the receipt transactions. This operation can be explained with the quantity distribution of the materials from the Consumption Orders and the work order items from the Output Orders. The distributions are used to form proportions which help distribute the cost of the Consumption Order transactions among the Output Orders. This distribution is also saved in the \" Distributed Material consumptions \" table (in the Output Order document) and then it is used to set the cost of the receipt Store Transactions correctly. When new issue transactions appear from Consumption Orders, an update of the distributions in all Output Orders (from one Work Order) is executed again. The quantity distributions are complemented by the cost distributions. Let's examine this particular case: There is a row from a Consumption Order which contains 15 PCS , 5 PCS of which are distributed to one Output Order and the rest 10 go to another Output Order. If there are several store transactions to issue all 15 PCS at a cost of 371 EUR, then one-third of it is distributed to the first Output Order and the rest is distributed to the second one. A detailed example follows. Example 4 : There is a Work Order producing 3 PCS of a product. The materials are 9 PCS from Material #1 and 12 PCS of Material #2 . The materials are consumed in two stages: Consumption Order CO#1 , which has 8 PCS from Material #1 and 8 PCS from Material #2 Consumption Order CO#2 , which has 1 PCS from Material #1 and 4 PCS from Material #2 There is an Output Order for 2 PCS of the work order item with the following distribution: Product, CO#1 , Material #1 , 6 PCS ; Product, CO#1 , Material #2 , 8 PCS . The second Output Order is for 1 PCS from the work order item with the following distribution: Product, CO#1 , Material #1 , 2 PCS ; Product, CO#2 , Material #1 , 1 PCS ; Product, CO#2 , Material #2 , 4 PCS . If the issue cost is 40 EUR for Material #1 and 71 EUR for Material #2 from CO#1 and 7 EUR for Material #1 and 39 EUR for Material #2 from CO#2 , then a distribution is calculated where the quantity comparisons are filled with costs. The first Output Order has the following: Product, CO#1 , Material #1 , 6 PCS , 40 * 6 / 8 = 30 EUR ; Product, CO#1 , Material #2 , 8 PCS , 71 * 8 / 8 = 71 EUR . And the cost of the produced product from this Output Order is 30 + 71 = 101 EUR . For the second Output Order, there is the following: Product, CO#1 , Material #1 , 2 PCS , 40 * 2 / 8 = 10 EUR ; Product, CO#2 , Material #1 , 1 PCS , 7 * 1 / 1 = 7 EUR ; Product, CO#2 , Material #2 , 4 PCS , 39 * 4 / 4 = 39 EUR . And the total cost of the produced product is 10 + 7 + 39 = 56 EUR . Issue And Receipt Balance Similarly to Store Transfers and Sales, there is a receipt limitation in the production - it cannot exceed the issue. Unlike Store Transfers and Sales, the validation is a bit more complicated because the product in the issue transactions is different from the product in the receipt transactions. The materials are not the same as the produced product. As a result, the total quantities of issue and receipt transactions cannot be compared directly. The limitation is applied on all store transactions that are caused by a Work Order. For each Transaction Timestamp , the following is executed: All issues (the materials) are summed up with a Transaction Timestamp less than or equal to the current. By their receipts from the Work Order, it is defined what is the largest quantity that is available for production from these materials; All receipts (the produced products) are summed up with a Transaction Timestamp less than or equal to the current; A validation is performed to check if the maximum quantity of the product from p.1 is bigger than or equal to the receipt total from p2. For more information about the validation, see Receipt And Issue Balance Validation In Store Transfers ."
  },
  "modules/logistics/logistics-common-module-concepts/goods-cost/original-cost-calculation/calculating-cost-for-returned-products.html": {
    "href": "modules/logistics/logistics-common-module-concepts/goods-cost/original-cost-calculation/calculating-cost-for-returned-products.html",
    "title": "Calculating Cost For Returned Products | ERP.net Tech Docs",
    "keywords": "Calculating Cost For Returned Products The current article describes how the product cost is formed when returning sold products. This is a receipt returning. This process is very similar to the product transferring (see Calculating Cost For Transferred Products ). However, there’s а difference: instead of transferring the products from one store to another in the current enterprise company, the products are taken out of the store and given to the customer. After that, the customer returns them to the same store. So, the receipt cost (on each row) is defined by the following formula: [receipt cost] = proportional part of the [issue cost] A proportional part of the issue cost is required as not all products can be returned after being sold. The proportion is defined by the ratio between sold and returned quantity. Example 1: A customer buys 10 PCS on 05 Jan 2020 and a few days later returns 3 PCS . The issue transaction is: issue, Timestamp: 05 Jan 2020 11:14, 10 PCS , document cost: 90 . Then, in the receipt Store Order generated by the Returning Sale Order, the following is saved: 3 PCS , document cost: 90 * 3 / 10 = 27 The data for the issue transactions is retrieved as follows: The value in Return For Sales Order Line is taken into account - it connects us to the original line. For this line, the system finds all Store Orders rows referring to it. For each Store Order row, the respective non-voided executions are loaded (Transactions rows) - the store transactions. The document cost is copied from the Line Document Cost field in the transactions rows. There are some specific cases when the calculations from the example described above are not possible. Here, it is necessary to enter the Original Sale Orders Lines in the rows of the Returning Sales Order. Sometimes this is not possible and the original Sales Order does not exist in the system. If a company started working on ERP.net recently and the Original Sales Order had happened before the shift to ERP.net, the Historical Unit Cost field from the Returning Sales Order is used for the definition of the unit cost in the receipt transaction. The formula is as follows: [receipt cost] = [returned quantity] * [historical unit cost] Example 2: There is a product return from a customer for 3 PCS and the original Sales Order does not exist in ERP.net. The Historical Unit Cost field in the Returning Sales Order has to be filled in. If its value is 8 , then the receipt Store Order will have the following: 3 PCS , document cost: 3 * 8 = 24 . Receipt And Issue Cost Balance As with Store Transfers, when returning products, the quantity returned can’t be greater than the quantity sold. This is true for the original Sale document and all the Sales Orders for the products returned. Every store transaction for the Sales Orders is gathered and for each Transaction Timestamp , validation is performed as in the store transfers: The costs from all issue transactions with Transaction Timestamp smaller or equal to the current are summed up; The costs from all receipt transactions with Transaction Timestamp smaller or equal to the current are summed up; The system checks if the issue total is greater or equal to the receipt total. For more details about this validation, see Receipt And Issue Balance Validation In Store Transfers ."
  },
  "modules/logistics/logistics-common-module-concepts/goods-cost/original-cost-calculation/calculating-cost-for-transferred-products.html": {
    "href": "modules/logistics/logistics-common-module-concepts/goods-cost/original-cost-calculation/calculating-cost-for-transferred-products.html",
    "title": "Calculating Cost For Transferred Products | ERP.net Tech Docs",
    "keywords": "Calculating Cost For Transferred Products Store Transfers create two parallel sub-document flows - receipt and issue flow. The cost of the issue store transactions is calculated by the average cost in the store, while the one in the receipt store transactions - specifically by the Store Transfer. It is formed by the following two components: Issue cost (of the issued goods); Additional Amounts in the Store Transfer, added to the products (representing increased goods cost e.g because of transport taxes). For each Store Transfer the following must be valid: [receipt cost] = [issue cost] + [ Additional Amounts for cost] Each Store Transaction row is calculated separately (so [ Additional Amounts for cost] is the additional amount distributed to the current row). These calculations are executed when the receipt Store Order is generated and the calculated cost is saved in the Line Cost field in the rows of the Store Order. So if the generated Store order receipt follows the generation of the issue documents (orders and their executions, providing the issue cost), then the issue cost may be copied to the receipt orders. Example 1 : There is a Store Transfer with two rows - row #1 with Product 1 for 10 PCS and row #2 with Product 2 for 12 PCS . At first, there are two issue transactions: issue, Product 1 , Timestamp: 01 Dec 2020 13:50, 8 PCS , document cost: 88 ; issue, Product 2 , Timestamp: 01 Dec 2020 13:50, 6 PCS , document cost: 90 . Afterwards, Store Orders receipt will be created with the same quantities and set costs in the rows: row #10, Product 1, 8 PCS , line cost: 88 ; row #20, Product 2, 6 PCS , line cost: 90 . When executing this Store Order, the result is Transactions receipt for 8 PCS and 6 PCS with cost of 88 and 90 , respectively. And when the rest of the transfer quantities are issued: issue, Product 1 , Timestamp: 07 Dec 2020 10:05, 2 PCS , document cost: 20 ; issue, Product 2 , Timestamp: 01 Dec 2020 10:05, 6 PCS , document cost: 102 . a new receipt Store Order will be created with rows as follows (the Store Transfer will try to create a new Store Order for the whole issued cost from the four issue transactions. However, a Store Order for the first two issues already exists, so the Discrepancy System will create new order only for the second issues): row #10, Product 1, 2 PCS , line cost: 20 ; row #20, Product 2, 6 PCS , line cost: 102 . When executing this Store Order, the receipt cost will be equal to the issue cost. The next example describes the calculations when there is an additional amount for the transport added to the goods cost. Continuation of Example 1: There is an additional transport amount of 66 (in document currency) distributed in the two rows as follows: 30 on the first row and 36 on the second row. These amounts will be added to the row costs in the generated Store Orders, proportionally to their quantities. So their rows become: Store Order # 1 , row # 10, Product 1, 8 PCS , row cost: 88 + 30 * (8 / 10) = 112 ; Store Order # 1 , row # 20, Product 2, 6 PCS , row cost: 90 + 36 * (6 / 12) = 108 ; Store Order # 1 , row # 10, Product 1, 2 PCS , row cost: 20 + 30 * (2 / 10) = 26 ; Store Order # 1 , row # 20, Product 2, 6 PCS , row cost: 102 + 36 * (6 / 12) = 120 ; The standard generation of Store Orders receipt from Store Transfers always creates a Store Order receipt for the exact quantity already issued by Transactions. The user may change the quantities (only decreasing them - see the end of the current article) in the receipt documents or enter them manually (the cost in the receipt documents has to be proportional to the one calculated by the system). Example 1 (alternative case): If due to correction or manual work the receipt Store Order #1 is as follows: row # 10, Product 1, 5 PCS , row cost: 55 ; row # 20, Product 2, 4 PCS , row cost: 60 ; then, the rest of the cost – 33 for row #10 and 30 for row #20, will be added along with the quantities in the second receipt order: row # 10, Product 1, 5 PCS , row cost: 53 ; row # 20, Product 2, 8 PCS , row cost: 132 ; Issue And Receipt Cost Balance In the examples above, it is possible to receive only less quantity than the issued - the rest will come later. The receipt value in a document cannot be more than the issued’s. It is not possible to receive more than the amount issued from the first store when transferring stocks. Although these cases are just theoretical, they may lead to incorrect cost (especially after Cost Correction , as discrepancies may appear). Example 2: In Store 1, where 5 PCS are available from a product, cost: 100 , and in Store 2, there are 10 PCS from the same products with the cost of 200 . A Transfer from Store 2 to Store 1 for 3 PCS is executed. At first, 1 PCS is issued from Store 2, then immediately all 3 PCS are received. The total availability in both stores is 8 + 9 = 17 instead of 15 . There will also be an artificial cost increase. If this availability and cost condition is kept for some time, there may be incorrect cost calculations of the store transactions. Limitations for what is possible to be entered in the target store from a Store Transfer are required. They are applied when releasing or voiding the released Transactions from the Transfer. A limitation could be: For each Transaction Timestamp on all Transactions of the current Transfer, the following must be true: The sum of the issues up to this Timestamp (including the timestamp) is larger or equal to the sum of the receipts up to this Timestamp (including the timestamp). Example 3: If we use the Store Transfer of 3 PCS from Store 2 to Store 1 from Example 2 , the first issue is as follows: issue , Timestamp: 10 Dec 2020 17:04, 1 PCS , cost: 20 ; Now, the user is not able to make a Transaction receipt for 3 PCS . The user is able to enter up to 1 PCS: in Store 1. receipt , Timestamp: 10 Dec 2020 17:27, 1 PCS, cost: 20 ; The user is not able to change the Transaction Timestamp to a value less than 10 Dec 2020 17:04 . After releasing the Transaction receipt , the user is not able to void the issue Transaction because on 10 Dec 2020 17:27 there will be a total issue of 0 PCS , which is less than the total receipt of 1PCS . For more information about the validation, see Receipt And Issue Balance Validation In Store Transfers ."
  },
  "modules/logistics/logistics-common-module-concepts/goods-cost/original-cost-calculation/calculating-cost-when-returning-rented-assets.html": {
    "href": "modules/logistics/logistics-common-module-concepts/goods-cost/original-cost-calculation/calculating-cost-when-returning-rented-assets.html",
    "title": "Calculating Cost When Returning Rented Assets | ERP.net Tech Docs",
    "keywords": "Calculating Cost When Returning Rented Assets"
  },
  "modules/logistics/logistics-common-module-concepts/goods-cost/original-cost-calculation/index.html": {
    "href": "modules/logistics/logistics-common-module-concepts/goods-cost/original-cost-calculation/index.html",
    "title": "Original Cost Calculation | ERP.net Tech Docs",
    "keywords": "Original Cost Calculation This article describes how the original cost is defined for each store transaction (i.e., for each row of a Transaction). There are two ways to define it: by average cost and by specifying the cost in the parent document. Which way will be used is determined by the business process (procurement, production, transfer, sale) the Transaction is created for. It depends on other modules and their respective documents, which are the main documents in the Transaction flow. The Cost Source field defines which method is used. For more information, see Goods Cost . Average Cost It is used when the Cost Source field is set to Store . These are usually the issue transactions in the store. The only receipt transactions with this source are generated by Reconciliations. Тo define the cost of the current transaction, the following is performed: All valid store transactions are gathered. They are non-voided or (at least) released Transactions and contain the same product, store and enterprise company which date to before the current transaction. The order of the transactions is defined by the Transaction Timestamp . If there are multiple transactions with the same Transaction Timestamp , the receipt transactions are ordered before the issue transactions. The Unit Cost is defined in all currencies (see Goods Cost ) from p.1. The Unit Cost is multiplied by the quantity in the row and the result is saved as a cost in the current transaction (in all currencies). Example 1: For a specified product, store and enterprise company, there are transactions listed below. For issue transactions, the average cost method is used. In the beginning, there are two receipt transactions: receipt , Timestamp: 01 Dec 2020 12:45 , 4 PCS, total cost: 100 ; receipt , Timestamp: 01 Dec 2020 17:27 , 3 PCS, total cost: 61 . These two transactions define the unit cost as ( 100 + 61 ) / ( 4 + 3 ) = 23 . The result is used in the next issue transaction: issue , Timestamp: 03 Dec 2020, 11:29 , 5 PCS, total cost: 5 * 23 = 115 ; Then, there is a receipt transaction: receipt , Timestamp: 04 Dec 2020 15:33 , 6 PCS, total cost: 146 ; The average cost is ( 100 + 61 - 115 + 146 ) / ( 4 + 3 - 5 + 6 ) = 24 . This cost is used in the next issue transactions. Note that the first issue transaction happens at the same time as the receipt transaction, but the receipt transaction is considered before the issue transaction. Because of this, the cost of the issue transaction is affected: issue , Timestamp: 04 Dec 2020 15:33 , 2 PCS, total cost: 2 * 24 = 48 ; issue , Timestamp: 07 Dec 2020 09:54 , 1 PCS, total cost: 1 * 24 = 24 . This example illustrates a case where the product cost is not affected by the presence or absence of a lot. Even if different lots exist in the transactions, the cost is an average. There are products required to have individual costs for each lot (this is described in the product's definition). The principle above is then changed, and in p.1 we take into account transactions that also have a matching lot field. An empty value (no lot) is considered a valid/separate lot. Example 2: There is a receipt Transaction with two lots (so there are two receipt store transactions): receipt , lot # 1 , Timestamp: 01 Dec 2020 13:15 , 10 PCS, total cost: 120 ; receipt , lot # 2 , Timestamp: 01 Dec 2020 12:15 , 8 PCS, total cost: 96 . The unit cost for both lots is 12 . Then come the following issue transactions: issue , lot # 1 , Timestamp: 01 Dec 2020 14:28 , 3 PCS, total cost: 3 * 12 = 36 . The next receipt transaction is only for lot # 1 : receipt , lot # 1 , Timestamp: 02 Dec 2020 10:30 , 7 PCS, total cost: 98 ; Now lot # 1 has a unit cost of ( 120 - 36 + 98 ) / ( 10 - 3 + 7 ) = 13 , while the second lot has a unit cost of 12 . issue , lot # 1 , Timestamp: 05 Dec 2020 17:20 , 4 PCS, total cost: 4 * 13 = 52 ; issue , lot # 2 , Timestamp: 05 Dec 2020 11:12 , 5 PCS, total cost: 5 * 12 = 60 . Specifying The Cost Explicitly This is used when the Cost Source is set to \"Document\". This is the source of all receipt transactions, except for the ones generated by Reconciliation. For each receipt transaction, the cost is calculated separately and according to a formula/calculation that is specific to the current business process. The method involves calculating a number in the document currency (the cost is in only one currency). Then, this number is converted into the rest of the cost currencies (see Goods Cost ). Take the most basic case – procurement, the buying of goods from external suppliers. Here, the cost of the receipt transaction is defined by the price we bought the goods at. It is copied from the Purchase Invoices (see Setting Cost When Purchasing Goods ). A more complicated example is when the cost of the goods is defined by the issue transaction cost of other goods available in the same enterprise company. It is not required to receive the goods from the same store. When transferring goods from one store to another, the issue transaction has a standard average cost. However, the goods received in the second store have to be entered with a cost equal to the one from the first store issue (a greater cost may be set if there are transport or other expenses). The same principle is applied when returning sold goods from a client or receiving back a rented asset. Another example is the production, where the cost of the produced products is formed by the costs of the ingredients, salary expenses, and more. Further reading: Calculating Cost for Inventory Reconciliation Calculating Cost For Produced Products Calculating Cost For Returned Products Calculating Cost For Transferred Products Calculating Cost When Returning Rented Assets"
  },
  "modules/logistics/logistics-common-module-concepts/index.html": {
    "href": "modules/logistics/logistics-common-module-concepts/index.html",
    "title": "| ERP.net Tech Docs",
    "keywords": "Available To Promise Goods Cost Lots Issue Material Requirements Planning Projected Available Balance Setting Transaction Timestamp"
  },
  "modules/logistics/logistics-common-module-concepts/lots-issue.html": {
    "href": "modules/logistics/logistics-common-module-concepts/lots-issue.html",
    "title": "Lots Issue | ERP.net Tech Docs",
    "keywords": "Lots Issue The current article describes the principles of lots issue when goods are issued from the store. Lots issue is actually the obligation to issue products from certain lots before others. The lots are prioritized and the priority is mandatory when goods are issued from the store (i.e. when Store Transactions are released). This priority is at least advisable when lots are entered before the Store Transaction documents (Store Orders, Shipment Orders, Sales Orders and more). The final goal is the lots selection in the document lines to be executed in the correct order. Example 1: In the document line, 10 Pcs of the product have to be sold/shipped/issued and the lot is not specified. The lot with the highest priority (let’s name it [Lot 1#] ) has 17 Pcs available. So following the principle of lots issue, the user has to select/be offered [Lot 1#] in the line. There are cases when the first lot does not have enough available quantity to fulfill the whole line quantity. Then, more than one lot has to be used. The quantity in the line has to be divided into several lines and in each line the lot has to be specified with its quantity. Again, the lots order defines their priority in the lots issue. Example 2: If there are 30 Pcs in the line and no lot is selected, and the three top priority lots - [Lot 1#] , [Lot 2#] , and [Lot 3#] - have available quantities of 17 , 8 , and 12Pcs , then the quantity in the line would be divided into the following lines: - [Lot #1],17 Pcs *; - [Lot #2],8 Pcs *; - [Lot #3],5 Pcs *. * These are the total quantities of each one of the three lots. The document may be saved in other forms, for example - the 17 Pcs of the first lot may be entered as 17 separated lines, each line with quantity of one [Lot #1]. This may be necessary if the product is serialized, each line must have a serial number specified, and the quantity has to be 1 . Actually, it can be said that there is always line breakdown. In Example 1 there is trivial breakdown into only one lot [Lot #1] , 10 Pcs . Defining lots may appear in earlier documents that precede the Store Transactions - Store Orders, Shipment Orders, Sales Orders, etc. In this stage, specifying the lot is recommended. If lots are selected in such a document, they are passed to the next document and may be changed. In some cases, a change may not be recommended and following documents have to keep the selected lots (for example, the customer in the Sales Order requires to receive the lots which are specified in the Sales Order; then, those lots have to be issued from the store). Specifying lots in the Store Transactions is final and mandatory. If it has not happened in previous documents, it has to happen in the Store Transaction. The lots cannot be changed in following documents. Store Transactions differ from the other documents with their limits according to the quantities which may be selected for each lot. In the Store Transactions, quantities are limited to the current stock holds. In other documents, there may be more precise restrictions - the “available to promise” (for specified lot). This is a method used to reserve lots. For example, if a Sales Order reserves the whole available quantity of one lot but there is no Store Transaction yet (so the current stock hold is unchanged), it would be wrong if another Sales Order called for quantities from the same lot. Selecting lots in a document line happens only if the line has no selected lots. If the lot is already specified and there are enough stock holds (with no assurance that the selected lot has the highest priority), only the quantity is validated. Such validation is applied in the Store Transactions, but it is possible to appear earlier (in preceding documents) so the user is warned earlier that he has to select another lot. Lots Issue Methods There are three main lots issuing methods - FIFO (First in, first out), FEFO (First expire, first out), LIFO (Last in, first out). They set the lots priorities. Each product uses a lots issuing method for itself. This is specified in the product definition. The product setting may be specified or null. If it is null, there is no sequence in the product's lots and there are no restrictions which lot should be selected (or the product does not use lots). In such cases, the lot is not mandatory even in the Store Transactions. The priority may be defined by sorting the lots by the date of their first receipt or by the date when they expire: for the FIFO method - the lots are sorted in an ascending order by the date of first receipt; for the FEFO method - the lots are sorted in an ascending order by their expiring dates (if no expiration date is specified, the null date is considered the largest date); for the LIFO method - the lots are sorted in a descending order by the date of first receipt. Example 3: There are 30 Pcs in a document line and lots of the product in the line have the following details (lot, available quantity/current stock hold, date of first receipt, expiry date): [Lot #1], 11 Pcs , 01.12.2021 , 05.01.2022 ; [Lot #2], 17 Pcs , 03.12.2021 , 03.01.2022 ; [Lot #3], 14 Pcs , 07.12.2021 , null . This document line is divided into two or three document lines with quantities from different lots depending on the lots issuing method of the product: when FIFO is selected: -[Lot #1],11 Pcs *; -[Lot #2],17 Pcs *; -[Lot #3],2 Pcs *. when FEFO is selected: -[Lot #2],17 Pcs *; -[Lot #1],11 Pcs *; -[Lot #3],2 Pcs *. when LIFO is selected: -[Lot #3],14 Pcs *; -[Lot #2],16 Pcs *. * Again, additional lines breakdown may be necessary if the product uses serial numbers or other information for the current transaction. If the quantity of Example 3 is 5 Pcs and not 30 Pcs, then no line breakdown would be necessary (to be more precise - the trivial breakdown into one line would happen) and the lot would just be selected in the line depending on which lots issuing method the product uses. When the current stock holds of the product have records for both quantity from a specific lot and quantity with no lot, then the no-lot records have the least priority (because, for example, they may be held for planned receipts which have not arrived yet, and the quantities are only available without being part of the current stock holds; in that case, it would be better if they were used as late as possible while the current stock holds with specified lots are exhausted first). So, for each lots issuing method, the priorities are defined as follows: FIFO: the records with lots whose receipt date has value - highest priority (sorted ascending by this date); the records with lots with null receipt date (they are considered to arrive in the store as late as possible); the records with no lots. FEFO: the records with lots whose expiry date has value - highest priority (sorted ascending by this date); the records with lots with null expiry date (they are considered to expire last); the records with no lots. LIFO: the records with lots with null receipt date - highest priority (they are considered to arrive in the store as late as possible); the records with lots whose receipt date has value (sorted descending by this date); the records with no lots. Lots Issue Ways Lots issue may be done in the following manners: - manually (through the interface - using a panel, list, others); - automatically (by starting a function by the user or a document event - state change). Manual Lot Issue In these cases, the system suggests to the user a list of lots sorted according to the lot issue method (by the date of first receipt or the expiry date). The user selects the lots and their quantities (his choice is limited to the available quantity). The most direct approach is the order (sorting) to be shown in the dropdown list of the lot attribute in the line. Thus, the user does the lots breakdown by selecting a lot, editing the quantity (if necessary) and adding a new line with the same product, where he/she can select the next lot and its quantity. In this case, only lots with available quantity are shown in the dropdown list. Another approach is the sorted list with available lots to be placed in a separated panel/screen. There are fields where the user can enter the quantity for each lot. Thus, the user sees the list and enters the whole breakdown of the line at once instead of entering it line by line. The panel/screen would contain only available lots. In both cases, it is useful for the lists to contain additional information: current stock holds, available quantity (for each lot), date of first receipt, expiry date (as date and duration), notes, etc. Automatic Lot Issue Automatic lot issue is executed by the system when the user starts it or when an event happens. The automatic lot issue uses the same sorted list of the lots as the manual lot issue. The difference is that the lots are always issued strictly in the order of the list. In the manual lot issue, the user has the option not to issue a specific lot and to skip its turn and use another lot. Calculation Of The Quantity In The Last Lot In the lot issue process, it is important to keep in mind that the quantities are entered in the measurement unit of the line. Every quantity fulfillment in the examples is done in the base measurement unit because the current stock holds and the available quantities are always shown in that unit. So, in the examples above, the Quantity Base attribute is used. To enter quantity in the Quantity field (where the measurement unit may differ from the base measurement unit of the product), the Product Dimensions would be used. The problem is that if product dimensions are used for all quantities in the breakdown of the line, the total Quantity might be different from the initial Quantity. This may lead to differences in the quantities in the child and the parent documents and as a result new documents may be created. Example 4: There is a document line with Quantity of 16 l and 30 kg Quantity Base (the product dimension is 1 l = 1.875 kg ). The three lots with highest priorities for this product ( [Lot #1] , [Lot #2] and [Lot #3] ) have current stock holds/available quantities of 10 kg , 10 kg , and 18 kg . In the breakdown of the initial document line, there would be 10 kg of each lot. If we apply the product dimension for each lot to see the quantity in liters, we would have the following: - [Lot #1] , Quantity Base = 10 kg , Quantity = 10 / 1.875 = 5.33333l ; - [Lot #2] , Quantity Base = 10 kg , Quantity = 10 / 1.875 = 5.33333l ; - [Lot #3] , Quantity Base = 10 kg , Quantity = 10 / 1.875 = 5.33333l ; But the total quantity would be 15.99999 l and not 16 l as expected. This problem is solved by using the remainder and not product dimensions for the last document line ( [initial quantity]-[already used quantity] ). This algorithm would make the breakdown of Example 4 as follows: - [Lot #1] , Quantity Base = 10 kg , Quantity = 10 / 1.875 = 5.33333l ; - [Lot #2] , Quantity Base = 10 kg , Quantity = 10 / 1.875 = 5.33333l ; - [Lot #3] , Quantity Base = 10 kg , Quantity = 16 - 5.33333 - 5.33333 = 5.33334 l . Example 5: The same approach for calculating the quantity in the last line from the breakdown is applied in cases of trivial breakdowns (when there is only one lot). Then, the only quantity in the breakdown is the last line. For example, if the line has Quantity of 2 l and Quantity Base of 0.66667 kg (3 l = 1 kg), and the first lot (with highest priority) has current stock holds/available quantity of 10 kg , then the only breakdown is not supposed to be multiplied by 3 to have the quantity in liters (as it would make 0.66667 * 3 = 2.00001 l). The calculation should be 2 - 0 = 2 l (this is the initial quantity minus the already used quantity - 0)."
  },
  "modules/logistics/logistics-common-module-concepts/material-requirements-planning.html": {
    "href": "modules/logistics/logistics-common-module-concepts/material-requirements-planning.html",
    "title": "Material Requirements Planning | ERP.net Tech Docs",
    "keywords": "Material Requirements Planning Material Requirements Planning (MRP) is a planning process designed to match supply with demand. MRP does this by creating Supply (Purchase/Work/Transfer) Orders to meet or exceed the demand, according to the MRP parameters. Some information could be obtained from here: https://en.wikipedia.org/wiki/Material_requirements_planning The MRP process in ERP.net is an implementation which mostly follows the general theory. However, in order to use MRP, you need to do the ERP.net-specific setup. Document Types and Routes Setup The document routes should be properly set-up. The main input parameter for MRP is demand . It is calculated based entirely on Store Orders with state = Planned . Therefore, the document routes for Sales Orders, Purchase Orders, Work Orders, etc. should be adequately designed to generate Store Orders with a Planned state. If a Store Order is generated solely for the purposes of MRP demand management, it can be set with the Planning_Only attribute. This attribute does not allow the setting of Firm Planned (or higher) states. Simplified Description of a Single MRP Run When MRP is run for a warehouse (Store), it does the following to each product: Calculates demand. Determines whether a supply action is needed. Determines the required quantity. Creates a Purchase/Work/Transfer Order for the desired quantity. When MRP is run for multiple warehouses (Stores), the system tries to prioritize the supply order of the warehouses. This might not always be successful, especially in cases of circular supply orders. Terms There are many terms used in MRP. We will try to provide simple descriptions for some of them: Projected Available Balance (PAB) - An inventory balance projected into the future. It is the sum of on-hand inventory minus requirements plus scheduled receipts and planned orders. Planning Bucket - the smallest period whose demand and supply are planned as a single unit. In ERP.net, it is fixed as 1 day . In theory, it could be a day, week, month or some mixed system (for example, days in the near future, weeks in the far future, etc.). Planning Horizon - the period of time in the future for which demand is matched with supply. In ERP.net, it is currently fixed to 180 days . The Planning Buckets (also known as \"buckets\") exist only within the time frame specified by the Planning Horizon. When we say \"bucket\", it is a Planning Bucket in the future, but within the Planning Horizon . Time Fences Time fences are boundaries between different periods in the planning horizon. From today to Demand Time Fence (DTF) - the time period in the (near) future for which actual demand is considered accurate, and forecasts - inaccurate. The planning process considers only demand. From DTF to Planning Time Fence (PTF) - the time period between the DTF and PTF for which it is unknown whether the demand or the forecast is more accurate. The planning process considers bigger either the demand or forecast for each bucket. After PTF - only the forecasts are considered accurate. The planning process considers only forecasts. Product Supply Definitions The MRP process is set-up through the Product Supply definitions. Each definition contains the planning parameters for one product and one warehouse (Store). Every warehouse (Store) needs to create a separate product supply definition for each product, which will be planned for this warehouse. The Product Supply definitions parametrize the when , how much , and how of the MRP planning system. Procurement Type Procurement Type specifies what to do when a supply order needs to be created. The options are: Buy - Create a Purchase Order Make - Create a Work Order Transfer - Create a Transfer Order Order Policy The Order Policy specifies when the supply is not enough and a supply order needs to be created. The options are: MRP - a supply order is created for: any demand for a bucket OR if the Projected Available Balance for any bucket is less than the Planning Safety Stock . OPS - a supply order is created if the PAB for any bucket is less than the specified Order Point . OPT - a supply order is created if by the time of expected arrival of the ordered goods, the PAB is less than the specified Order Point . PRS - a supply order is created unconditionally on each order cycle. Planning Order Cycle Days specifies the number of days in the order cycle. Lot Sizing Method The Lot Sizing Method specifies how much should be ordered. It is divided in two separate calculations: Algorithm calculations. Order modifiers The selected algorithm calculates some order quantity. Then, order modifiers adjust the quantity with minimum, maximum, and lot-size modifiers. The algorithms are: FOQ - Fixed Order Quantity - orders unconditionally what is specified in the Fixed Order Quantity. EOQ - Economic Order Quantity - orders the specified period in an efficient way, balancing between order-fixed and holding costs. For more information, see https://en.wikipedia.org/wiki/Economic_order_quantity . LFL - Lot For Lot - orders the calculated demand for the bucket. LFP - Lot For Period - orders the required quantity for the bucket but adds enough quantity for the specified period ahead. ROP - Reorder Point - orders up to the specified Planning Maximum Inventory . ROT - Reorder Point with Time Planning - orders up to the specified Planning Maximum Inventory but also adjusts the quantity with the expected usage for the time the goods are in transit."
  },
  "modules/logistics/logistics-common-module-concepts/projected-available-balance.html": {
    "href": "modules/logistics/logistics-common-module-concepts/projected-available-balance.html",
    "title": "Projected Available Balance | ERP.net Tech Docs",
    "keywords": "Projected Available Balance Description Projected Available Balance (PAB) shows the inventory balance projected into the future. It is the running sum of the Current Stock Holds with scheduled receipts added, minus planned issue Stock Orders. The Projected Available Balance is used in the calculation of the Available to Promise . The algorithm In the Projected Available Balance , two kinds of data are used: Current Stock Holds - this is the quantity available placed in store today; Chronology of the Store Orders which are not executed - includes all Store Orders (or their unfilled parts) which are not completed yet. Note that if there are expected Store receipts or issues for a past date which are still not executed, the algorithm assumes that they are being executed today . For example: Let's assume that today (2021/05/05) we have 10 pcs from product A in store S ; There is an expected delivery from 3 days ago (2021/05/02) for 8 pcs , which has not been executed yet; We have the following planned store movements: on 2021/05/07 , planned receipt of 15 pcs ; on 2021/05/09 , planned issue of 4 pcs ; on 2021/05/13 , planned receipt of 10 pcs ; on 2021/05/15 , planned issue of 7 pcs ; on 2021/05/15 , planned receipt of 2 pcs ; on 2021/05/20 , planned issue of 3 pcs ; With this data provided, we can calculate the following PAB: Date Start quantity Issue quantity Receipt quantity PAB 2021/05/05 10 - 8 18 2021/05/07 - - 15 33 2021/05/09 - 4 - 29 2021/05/13 - - 10 39 2021/05/15 - 7 2 34 2021/05/20 - 3 - 31 The PAB line can be seen on the following chart: All documents in ERP.net that may lead to store movements can be set to generate Planned or Firmed Store Orders - directly or through other documents. With this setting, the documents can be involved in the Projected Available Balance and Available to Promise calculations."
  },
  "modules/logistics/logistics-common-module-concepts/setting-transaction-timestamp/index.html": {
    "href": "modules/logistics/logistics-common-module-concepts/setting-transaction-timestamp/index.html",
    "title": "Setting Transaction Timestamp | ERP.net Tech Docs",
    "keywords": "Setting Transaction Timestamp The current article describes the principles for defining a Transaction Timestamp in the Transactions rows. A timestamp is essential for goods cost definition. It represents the exact moment when a specific transaction starts affecting the goods cost. For more information, see Goods Cost and its sub-articles. Usually, transaction timestamps are set automatically with no need for user intervention. This is executed in two general ways: On Transaction release, if there is no transaction timestamp, then it is set automatically by the date of the Transaction and/or by the current date and time. When the automatic set of the timestamp in the Transaction release does not set the correct date and time in accordance with to the business process, a transaction timestamp is defined in the Store Orders (or another document generating Transactions, such as Reconciliations). Thus, another module which controls and executes the orders is available to set a specific Transaction Timestamp defined by its business logic. Users can change the Transaction Timestamp in one of two ways: By editing the Store Orders (their Transaction Timestamps will be copied to the executing Transactions). By editing the Transactions directly (before their release or afterwards by Adjustment Documents ). No matter how the timestamp is set, it has to comply with the following restrictions: if the quantity in the Transaction row is different from 0, then the Document Date should match the date of the Transaction Timestamp . More detailed description of the logic behind the automatic set of the Transaction Timestamp may be found in the following articles: More Specific Cases Of Setting The Transaction Timestamp Setting Transaction Timestamp by Store Orders Setting Transaction Timestamp In Reconciliations Setting Transaction Timestamp On Transaction Release"
  },
  "modules/logistics/logistics-common-module-concepts/setting-transaction-timestamp/more-specific-cases-of-setting-the-transaction-timestamp.html": {
    "href": "modules/logistics/logistics-common-module-concepts/setting-transaction-timestamp/more-specific-cases-of-setting-the-transaction-timestamp.html",
    "title": "More Specific Cases of Setting the Transaction Timestamp | ERP.net Tech Docs",
    "keywords": "More Specific Cases of Setting the Transaction Timestamp When generating Cost Transactions from Receiving Orders, there is a specific way of getting the Transaction Timestamps . It is wrong because of the irregular generation procedure: direct Transaction creation from another module is not supposed to happen, as the other modules are not supposed to work with internal module operations. In this transaction generation, only the cost is filled in (all quantities are 0). It is the cost coming from the Purchase Invoices, for the quantities which are already entered in the store by the Receiving Order. To have correct time and date for the cost, the generated Transaction should have a specific Transaction Timestamp equal to the Transaction Timestamp with which the quantities enter the store. If the cost is entered later, the products will turn out with zero cost. For examples and more detailed information about goods cost when purchasing, see Setting Cost When Purchasing Goods ."
  },
  "modules/logistics/logistics-common-module-concepts/setting-transaction-timestamp/setting-transaction-timestamp-by-store-orders.html": {
    "href": "modules/logistics/logistics-common-module-concepts/setting-transaction-timestamp/setting-transaction-timestamp-by-store-orders.html",
    "title": "Setting Transaction Timestamp by Store Orders | ERP.net Tech Docs",
    "keywords": "Setting Transaction Timestamp by Store Orders Sometimes, the algorithm for automatic set of Transaction Timestamps on Transaction release may not choose the best possible dates and times. This is usually because of the specific logic of the business process of ordering store transactions which are unknown to the Logistics module. It is possible to set Transaction Timestamps for the ordered transactions in the Store Orders. The module that contains the specific business logic helps setting better and more accurate times and dates in the Store Orders. When the orders are fulfilled, these Transaction Timestamps will be copied to the Transactions and will remain unchanged on Transaction Release. The current article describes some specific cases which require setting the Transaction Timestamp by the Store Orders. In Transitional Store Orders For more information about transitional documents, see Transitional Documents . When a Store Order is Transitional, all its rows are filled in with the creation date and time of the parent document. The logic here is as follows: If the Store Order is set to transitional, then it is considered that it will happen automatically along with the parent document. So, the Transaction Timestamps will inherit the creation date and time of the parent document. Example 1 : There is a Work Order where all documents except for the Transactions (Consumption Orders, Output Orders and Store Orders) are transitional . On release, the Store Orders generate released Transactions, i.e. the process is completely automatic. At first, the Work Order has the following technological ratio: producing 1 PCS of a product, the materials are 1 PCS of material #1 and 1 PCS of material #2 . On Work Order release, all sub-documents are created, and the materials are issued with a Transaction Timestamp of [19 Jan 2020 14:00:07] and the produced product has a Transaction Timestamp of [19 Jan 2020 14:00:09] . Also, because of the quick creation and release of all sub-documents, these are the Transaction Timestamps for creating the producing sub-documents (the Consumption Order is created on [19 Jan 2020 14:00:07] and the Output Order - on [19 Jan 2020 14:00:09] . Then, on 22 Jan 2020 the Work Order is adjusted and the quantity of the first material is changed from 1 PCS to 2 PCS . If in the transitional Store Orders the Transaction Timestamp fields are left blank, when releasing the new Transaction for the additional 1 PCS of material #1 , its Transaction Timestamp would be [19 Jan 2020 23:59:00] because it was released later than its Document Date. In this case, we would have the following chronology: 1 PCS of material #1 , issue , 19 Jan 2020 14:00:07 ; 1 PCS of material #2 , issue , 19 Jan 2020 14:00:07 ; 1 PCS of produced product, receipt , 19 Jan 2020 14:00:09 ; 1 PCS of material #1 , issue , 19 Jan 2020 23:59:00 At 14:00:09 there will be a receipt of 1 PCS of the product for which 2 PCS of material #1 are needed. By now, only 1 PCS is issued (the other piece is issued later). This leads to failure in the issue and receipt balance validation (see Receipt And Issue Balance Validation In Store Transfers and Calculating Cost For Produced Products because of incorrect time of the last issue transaction. When the Store Orders are transitional, the Transaction Timestamp is equal to the time and date of creation of the parent document, so the last issue transaction will also have Transaction Timestamp [19 Jan 2020 14:00:07] and the problem with the issue/receipt balance would not appear again. In Store Orders Created from Completing Output Orders When Completing Output Orders are generated from the Work Order document form, specific date and time are set as a Transaction Timestamp in the rows of the Output Order. For each row in the Output Order, the greatest or the last Transaction Timestamp of all timestamps marking the moment the production has entered the store, is set as a Transaction Timestamp (this is the maximum date and time in all receipt transaction rows created by the current Work Order row, which has quantity different from 0). After that, the Transaction Timestamps from the Completing Output Order are passed to the Store Orders and copied to the Transaction rows. The Completing Output Orders actually distribute the cost of the materials which are not issued on time. As a standard, it is considered that later issues of materials are distributed to the last manufactured products. This is why the greatest Transaction Timestamp of all non-zero receipt transactions for the specified product is set as a Transaction Timestamp . In Store Orders Created by Consumption Orders for Material In the generation procedure of Store Orders by Consumption Orders, there is also a specific way of setting the Transaction Timestamp in the Store Orders rows. It appears only if the quantity in the specified row is negative and the greatest transaction timestamp from all material issue transactions in the generated Store Order is used as a Transaction Timestamp . The Consumption Order rows with negative quantities return unnecessary (exceeding) materials. This process has to be entered in the store with the same cost, as issued. If the material is issued in more than one transaction, the issue transaction preceding the return of the materials is unknown, so the last issue is used as a reference. In Store Orders Created by Shipment Orders for Products Return This case is similar to the return of materials to the production. If the quantity of the current Shipment Order row is negative, the greatest transaction timestamp from the relevant Store Order row (of all issue transactions happening by now) is set as a Transaction Timestamp ."
  },
  "modules/logistics/logistics-common-module-concepts/setting-transaction-timestamp/setting-transaction-timestamp-in-reconciliations.html": {
    "href": "modules/logistics/logistics-common-module-concepts/setting-transaction-timestamp/setting-transaction-timestamp-in-reconciliations.html",
    "title": "Setting Transaction Timestamp In Reconciliations | ERP.net Tech Docs",
    "keywords": "Setting Transaction Timestamp In Reconciliations In Reconciliations, Transaction Timestamps which are about to be generated in the Store Transactions rows are calculated the same way as on Release. In the Reconciliation document form, when the current availability of the products is calculated and stored in the rows, Transaction Timestamps are filled in as follows: If the Reconciliation has a present or future Document Date, then the Transaction Timestamp in the row has the current date and time. if the Reconciliation has a past Document Date, then the Transaction Timestamp is XX.XX.XXXX 23:59:00, where XX.XX.XXXX is the document date. The same principle is used for Reconciliation release, in case there are rows with empty Transaction Timestamps . When the Reconciliation creates Transactions for discrepancies, the dates and times already set in the Reconciliation are copied to the newly created Store Transactions. Thus, the Transaction Timestamps in the Transactions are defined by the current creation time or Reconciliation release and not by the current release time (of the Store Transaction)."
  },
  "modules/logistics/logistics-common-module-concepts/setting-transaction-timestamp/setting-transaction-timestamp-on-transaction-release.html": {
    "href": "modules/logistics/logistics-common-module-concepts/setting-transaction-timestamp/setting-transaction-timestamp-on-transaction-release.html",
    "title": "Setting Transaction Timestamp On Transaction Release | ERP.net Tech Docs",
    "keywords": "Setting Transaction Timestamp On Transaction Release On first release of the document, the Transaction Timestamp is set automatically in each Transaction row that has no value. If the Transaction has inherited some specific dates and times from the Store Orders or the user has entered them manually, these values will remain unchanged and the new dates and times will be set only in the rows with no values for Transaction Timestamp . When releasing the Transaction, the values in the rows with no Transaction Timestamps are set according the following business rules: If the Transaction's Document Date is today's date or a future date, the Transaction Timestamp for all rows is the current date and time. If the Transaction's Document Date is in the past, then the Transaction Timestamp is XX.XX.XXXX 23:59:00, where XX.XX.XXXX is the Document Date. When a Transaction is released with a past date, the time is set to 23:59:00 because it is unknown when exactly the transaction happened. It is assumed that it happened after all the other transactions which were released in time. In other words, late transactions are listed at the end of the selected date. If they are too late or cannot be ordered correctly among the other transactions from the same day, then the user may change the time manually - by Adjustment Documents . The time \"23:00:00\" follows the same principles because it helps the user manage late transactions from a given date more easily. For example, if it is necessary for a transaction to come after another one, the user should adjust it in the remaining minute of the current day. If the selected time was \"23:59:59:999\", that would not be possible."
  },
  "modules/logistics/wms/how-it-works/zone-policies.html": {
    "href": "modules/logistics/wms/how-it-works/zone-policies.html",
    "title": "Zone Policies | ERP.net Tech Docs",
    "keywords": "Zone Policies"
  },
  "modules/logistics/wms/index.html": {
    "href": "modules/logistics/wms/index.html",
    "title": "Warehouse Management | ERP.net Tech Docs",
    "keywords": "Warehouse Management Warehouse Management Module follows the concepts of the Warehouse Management Systems WMS . The main objective for implementing a WMS is to optimize the efficiency of the warehouse operations in the Managed Warehouses . Managed Warehouses are physical warehouses, which have managed operation. They exist outside of existing Store definitions. The Stores concept is used for the management of inventory levels and general ledger (accounting) entries. Managed Warehouses are sub-level, which is used to manage all warehouse activities, including: Picking Put-Away Counting Packing/Unpacking Inspection Robot interactions etc. Note One Managed Warehouse can encapsulate the storage and operations of multiple legal entities (Enterprise Companies). While the existing \"Store\" concept is strictly bound to the enterprise company, the warehouse can accommodate goods of multiple entities. It can even be used to store goods from external companies. The most important part for achieving operational effectiveness is to properly organize the layout of the warehouses. Layout optimization is outside the scope of this document. Managed Warehouses are organized using Zones and Locations . Zones are sub-divisions of a warehouse. Note Zones are used to accommodate different storage needs, such as different temperature requirements or turnover rate of the products. The zones are further divided in Locations . Locations have name (like #1-8-20), which is used to uniquely identify them. Note Use Warehouse Management to increase efficiency by automating warehouse routing and identifying storage locations for your products. The two most basic documents of WMS are: Warehouse Requisitions (W.R.) They contain outside requests for warehouse operations (usually inbound/outbound). Warehouse Orders (W.O.) They are the internal plan for execution of W.R. They contain routes, locations, workers, etc. The basic operation flow of WMS is the following: The steps, noted in (parens) in the diagram are as follows: The outside module/department creates W.R. based on its needs. Inside the WMS, the team devises a plan for execution and stores it as a W.O. In the best-case scenario, the creation of WO is totally automated. The workers use their handheld devices to execute the order. Each step is recorded as both Warehouse Transaction and Warehouse Order Execution. After the WO is fully executed, the Warehouse Requisition Execution is updated. After the WR is fully executed, the external module/department updates its execution state. Typically, managed warehouse operations are executed using some sort of handheld device, which is used to scan bar-codes, NFC tags, etc. Push And Pull Task Management When a Warehouse Requisition document comes in, there are many ways we can plan how to fulfill it. The plan is represented by Warehouse Order documents. But how these Order documents are created? There are at least two main ways to organize the work. Pull System The Pull System is the easiest way to organize the execution. Under some circumstances, it can also be the most efficient. In the Pull System, each Warehouse Worker decides when to get (pull) work. Whenever they are ready, they request more work through their mobile app. Pros: Do not require a central planner. Effective for small orders, usually e-Commerce. Very easy to setup. Easy to maintain - no need to plan for workers missing, overloaded, etc. Efficient - workers achieve high efficiency without central planning (but might need more control). Cons: Not good for B2B, because large orders are better served with Push System. Without a central planner, worker control needs to be better controlled. Cannot implement complex order mixing, splitting or other complex work procedures. Push System Under the Push System, there is a central planner, who plans the work and pushes it to the workers. The Push System might be required in more complicated execution environments. Pros: A central planner can better allocate the worker and machine resources to fulfill the requisitions. In complicated execution, the Pull System might be inappropriate. Worker task management is taken away from the workers and controlled centrally. Cons: More expensive - require a central planner. The efficiency of the workers depends heavily on the planner. Choosing The Right Strategy There can be other organizations of the workflow within a warehouse. The ERP.net data model allows implementing almost any conceivable strategy, with the most prominent ones built-in. However, planning the execution can be externalized to custom apps and services. Applying AI/ML strategies for achieving better efficiency is a possible direction. Also, mixing robots with human workers might require using custom strategies."
  },
  "modules/logistics/wms/zone-based-routing.html": {
    "href": "modules/logistics/wms/zone-based-routing.html",
    "title": "Zone Based Routing | ERP.net Tech Docs",
    "keywords": "Zone Based Routing The basic idea With Zone based routing, the rules for processing the goods are determined based on the zone, in which the goods are stored for each step. The zones are sequentially numbered, relative to their \"closeness\" to final shipping. For example: 1 IN -> 2 INSP -> 3 BULK -> 4 PICK -> 5 KIT -> 6 PACK -> 7 OUT RECEIVE ------------> --OPTIMIZE--> ----------------> DISPATCH The main processes in the warehouse - receive, optimize and dispatch, are ordered consecutively through the zone sequence. The receive process starts at the inbound docks and runs until goods are placed in bulk. The optimization process usually deals with replenishment of the picking zones, but can also be used for pre-kitting. The planning of the dispatch process works backwards - from the final step (the dispatch from the outbound docks) to the first step (usually picking). This is similar to how MRP/DRP works, but applied for WMS. Zone based routing and sequencing provides great flexibility in the route formation process, while keeping things simple and understandable for the process designers. It allows the process designers to focus separately on each zone, leaving the complex full routing formation to the system. Zone based routing allows programming of very complicated routes, while still keeping things simple and maintainable. How it works? For each zone, there are rules, which define how the goods will be processed, when they pass the zone. The rules for a zone are defined separately for each of the WMS processes - receive, dispatch and replenishment. The full route is the concatenation of all route steps for each consecutive zone. Hierarchical rules Since zones are hierarchical, for any given zone there might be multiple rules, coming from different levels of the hierarchy. All rules in the hierarchy are combined when creating the routing. Combining the rules is performed separately for each STEP NO within each zone. To determine the \"winning\" rule for each step, the RULE PRIORITY is used within all rules, which satisfy the RULE CONDITIONs. Start and finish of the process The receive process starts at the inbound dock and is planned through the zones, until there are no more steps. Usually, it finishes at the BULK zone. The dispatch process works in the opposite way - it first determines the quantities needed at the outbound docks, and than determines what previous steps could supply these quantities. The optimization process is a middle ground - it just runs for all zones, for which there is a definition for the optimization process. Movement between the zones When a rule has a MOVE task, it orders movement of the goods to another zone. The algorithm for determining the routing steps is then restarted for this new zone and so on until the goods reach their final destination and state. Rule and task conditions Rule conditions are evaluated when the routing is determined. They can be used to alter the routes based on conditions, which are known by the time the route is created. Rule conditions include such things as product group, zone characteristics, etc. Task conditions are evaluated later in the process and hence allow processing based on what is know in real time during the execution of the order. They are first copied to the Warehouse Order. Then, upon actual execution of the order, they are evaluated in real time. Task conditions can be based on runtime characteristics like quality inspection status, lot characteristics, etc."
  },
  "modules/logistics/wms/zones-and-locations.html": {
    "href": "modules/logistics/wms/zones-and-locations.html",
    "title": "Warehouse Zones and Locations | ERP.net Tech Docs",
    "keywords": "Warehouse Zones and Locations Warehouse Zones are used to organize the different storage areas of the warehouse. Zone Hierarchy The zones are organized in a hierarchy, where each zone can have sub-zones, which can have its own sub-zones and so on. For example: Picking Aisle P1 Rack P1.1 Shelf P1.1.1 Shelf P1.1.2 Shelf P1.1.3 Aisle P2 Refrigeration Aisle R1 Rack R1.1 Aisle R2 Carts Cart C1 Bulk Rack B1 Rack B2 Primary and sub-zones In the above example, Picking, Refrigeration, Carts and Bulk are primary zones . Aisle M1, Rack M1.1, etc. are called sub-zones . The primary zones have no parent zone. Sub-zones always have a parent zone. Locations The warehouse locations (sometimes called bins) are used for the actual storage of the goods. They are the leafs in the hierarchy and are structured under the warehouse zones. For example: Zone \"Shelf P1.1.3\" can contain 3 locations: P1.1.3-A P1.1.3-B P1.1.3-C"
  },
  "modules/production/overview.html": {
    "href": "modules/production/overview.html",
    "title": "ERP.net Production | ERP.net Tech Docs",
    "keywords": "ERP.net Production"
  },
  "modules/projects/overview.html": {
    "href": "modules/projects/overview.html",
    "title": "ERP.net Project Management | ERP.net Tech Docs",
    "keywords": "ERP.net Project Management"
  },
  "README.html": {
    "href": "README.html",
    "title": "Welcome to the ERP.net Technical Documentation | ERP.net Tech Docs",
    "keywords": "Welcome to the ERP.net Technical Documentation The documentation uses DocFX to build."
  },
  "reference/config-options-reference.html": {
    "href": "reference/config-options-reference.html",
    "title": "Config Options Reference | ERP.net Tech Docs",
    "keywords": "Config Options Reference The current article contains a list of configuration keys and their values: Key - AllowFirmPlannedParentForReleasedChild a.Action: When the key has value and this value is \"1\" the following is allows: released subdocuments of FirmPlanned document are allowed. b.The user sets it manually. Key - CheckForNonVoidedReferencingDocumentsDisabled a.Action: When the key has value and this value is \"1\", verification for references between the documents is not performed when a document is made void. In all other cases, the verification is performed. b.The user sets it manually. Key - CheckForOverexecutionDisabled a.Action: When the key has value and this value is \"1\", verification for over execution of the parent order documents is not performed. In all other cases, the verification is performed. b.The user sets it manually. Key - CheckForOverinvoicedQuantityInSalesOrderLinesDisabled a.Action: When the key has value and this value is \"1\", verification for invoicing greater quantity than the sold quantity is not performed. In all other cases, the verification is performed. b.The user sets it manually. Key - CheckForTransactionMovementTypeDifferentThanParentStoreOrderMovementTypeDisabled a.Action: When the key has value and this value is \"1\", verification that the movement type of the store transaction is the same as the movement type(s) of the parent store order(s) is not performed. In all other cases, the verification is performed. b.The user sets it manually. Key - Default language a.Action: Defines the default language of multi-language fields. For example: en - English, bg - Bulgarian. b.The user sets it manually. Key - Default_Enterprise_Company_Location_Id/XXX a.Action: Defines the default company location. XXX is the id of the enterprise company. The value is the ID of the default company location. b.Set automatically by the system of the user. Key - Documents/OnlySaveNewVersionsToHistory a. This key is used for compatibility with older versions of the software. The old method of saving a document in the document history is to save the previous version before the current version is saved. The new method is to save the current version. b.Action: When the key has value and this value is \"1\", the new method is applied. In all other cases, the old method is applied. c.The user sets it manually. Key - DontCheckForNegativeUnitPrice a.Action: When the key has value and this value is \"1\", verification for negative values in the Unit Price field is not performed. In all other cases, the verification is performed. b.The user sets it manually. Key - Inv/CheckForNegativeAvailability a.Action: When the key has value \"1\", verification for negative stock balance is performed. The verification checks if the stock balance after the current operation would not become negative and also if the document date is not today's date, the validation checks for not negative stock balance for the dates in the Transaction timestamps in the store transaction rows. If the key has an empty value (null) or its value is different than \"1\" the described validations are not performed. b.The user sets it manually. Key - InvoiceFiscalPrintChangeToState a.Action: This key specifies the document state to which an invoice is switched to after the receipt is printed. The key value is the numeric value of the document states (0 = New, 10 = Planned, 20 = FirmPlanned, 30 = Released, 40 = Completed). In all other cases, the invoice is switched to Released state. b.The user sets it manually. Key - InvoiceFiscalPrintUseDistributedAmountsForUnitPrice a.Action: When the key has value and this value is \"1\", the unit price which is sent to the fiscal printer is calculated through the distributed amounts, which are added to the products. In all other cases, the unit price is calculated as follows: the unit price in the document line with VAT included and discounts in the row. b.The user sets it manually. Key - Last_Used_Enterprise_Company_Id a.Action: Defines the last used by the user enterprise company. The value is the id of the enterprise company. b.Set automatically by the system of the user. Key - Last_Used_Enterprise_Company_Location_Id/XXX a.Defines the last used by the user enterprise company location. The value is the id of the enterprise company location. b.Set automatically by the system of the user. Кеу - SalesOrderFiscalPrintChangeToState a.Action: This key specifies the document state to which a Sales Order is switched to after the receipt is printed. The key value is the numeric value of the document states (0 = New, 10 = Planned, 20 = FirmPlanned, 30 = Released, 40 = Completed). In all other cases, the Sales Order is switched to Released state. b.The user sets it manually. Key - SalesOrderFiscalPrintUseDistributedAmountsForUnitPrice a.Action: When the key has value and this value is \"1\", the unit price which is sent to the fiscal printer is calculated through the distributed amounts, which are added to the products. In all other cases, the unit price is calculated as follows: the unit price in the sales order line with VAT included and discounts in the row. b.The user sets it manually. Key - SalesOrdersOverduePaymentOrdersCheckDisabled a.Action: When the key has value and this value is \"1\", on Sales Order document release overdue Payment Orders check is not performed. In all other cases, such check is performed. b.The user sets it manually. Key - SimpleFilterLayout a.Action: When the value of the key is \"1\", then the \"Use simple layout for filter panels\" option is check-marked and the visualization of the navigator filter panels for the specified user is in the format \"Field OR Value\". If the value of the key is \"0\", then the \"Use simple layout for filter panels\" option is not check-marked and the visualization of the navigator filter panels for the specified user is in the format \"Field: Value\". b.The user set it manually through File tab → Settings → \"Use simple layout for filter panels\". But if the key is not configured for the particular user, then the system will use the default value. The default value depends on the system version: until Version 2019.1 - the default value is \"0\"; in Version 2019.1 and later - the default value is \"1\" Key - CheckInvoiceLinesQuantityUnitDisabled a.Action: When the key has value and this value is \"1\", when an invoice is released the validation if the measurement unit of the invoice line and the invoiced sales order line are the same is not performed. b.The user sets it manually. Key - AllowBaseAmountsFromThirdDocument a.Action: The action of the current key impacts how the additional amounts are distributed. If amount S and B are distributed on document D1 and amount S depends on amount B. When the current key has value and this value is \"1\" the calculation of the additional amounts is performed as follows: - Each B amount which is distributed on the rows of document D1 participates in the calculation of the base amount of amount S no matter which document defines the B amount. When the current key has a value different from \"1\" or the key does not exist: - Amount B participate in the base amount of S amount only if the B amount is defined by the same document as S amount in the referent document of S amount. The preferred document of S amount is the document on which rows S amount is distributed. b.The user sets it manually. Key - CreateReconciliationsByTimestamp a.Action: When this key has value and this value is \"1\", the function \"Add the available products\" in the Reconciliation form and the manually added new rows would use the date of the transaction timestamp in the row, and not the date of the document, to calculate the stocks availability. The stocks availability may be looked at by one of the following methods: - Stock movements in the store by the document date; - Stock movements in the store by the date of the transaction timestamp. b.Usually, the \"i\" method is used to define stock availability (i.e. the quantities at a specified date), and method \"ii\" is used to define the stocks cost (at a specified time) c.The user sets it manually. Key - CostCorrectionsCalculateCostTransferDocumentsCostByDocumentCurrencyReevaluation a.Action: the current key regulates the recalculation of the products costs by the documents which transfer costs (Store Transfers, Work Orders, Sales Returns). When the key has value and this value is \"1\", the recalculation is performed as follows: all costs of the issue and receipt store documents are converted to the currency of the Master document (the document which transfers the cost). If not, usually the base currency of the issue and receipt store documents is used for the recalculation. b.The user sets it manually. Key - ActiveLanguages a.Action: Displays the languages which are active in the current database. If there is no value, all languages are active (currently 15 languages are supported). b.Automatically by the form for editing the languages list, which opens from the Edit Languages menu. Key - CheckForTransactionInvalidLotDisabled a.Action: When this key has value and this value is \"1\", the validation for an invalid lot in the store transaction on document release is not performed. An invalid lot is a lot that is defined for a product, different than the product in the store transaction line. In all other cases, the validation is performed. b.The user sets it manually Key - VisualPasteDisabled - suspended a.Action: When this key has value and this value is \"1\", when rows are pasted in a grid they are pasted all at the same time (as it was in version 2.3). In all other cases when rows are pasted in a grid, they are pasted visually - row by row and field by field. Every value is searched between allowed values in drop-down lists. b.The user sets it manually Note This key is suspended in version 2019.1. In its place there are two new functions in forms and navigators: - Paste Rows - Paste Rows Without On-Screen Validation Key - RealTimeEventsDisabled a.When this key has value and this value is \"1\", ERP.net would not proceed connection with the server which sends real-time events. b.The user sets it manually Key - RealTimeEventsTimeoutSeconds a.Action: Sets the timeout period for waiting for a server response for real-time events, in seconds. If the server does not raise an event in the specified time, the client sends a new request. The value is a number between 5 and 240. If null, the timeout time is 240 seconds (4 minutes). b.The user sets it manually Key - Require strong passwords a.Action: When this key has value and this value is \"1\", strong password validation is performed. Strong password requirements are as follows: the password is at least 8 characters; the password contains characters from 3 out of 4 groups: small letters, capital letters, Nonalphanumeric characters, numbers; the password does not contain the username; the password does not contain \"123\", \"1234\", \"12345\", \"123456\". b.The user sets it manually Key - DisableAccountKeyPropertyDotCheck a.Action: When this key has value and this value is \"1\", when an item key is formed in the accounting voucher rows the validation for no '.' (dot) in the values of the key custom, properties are not performed. For the normal working process of the system, it is important no dots to be part of the values of the key custom properties because the dot is a system character used for item key compilation. b.The user sets it manually Key - AllowPlannedDocumentStateInClient a.Action: When this key has value and this value is \"1\", the document state menu would contain Planned state. In all other cases, the user would not be able to select the Planned state on any document. b.The user sets it manually Key - DisableProductCopyPropertiesFromOtherProduct a.Action: When this key has value and this value is \"1\", the Product Configurator feature for copying the values to custom properties from the custom property which values are Products is deactivated. b.The user sets it manually Key - PaymentTransactionFiscalPrintChangeToState a.This key specifies the document state to which a Payment Transaction is switched to after the receipt is printed. The key value is the numeric value of the document states (0 = New, 10 = Planned, 20 = FirmPlanned, 30 = Released, 40 = Completed). In all other cases, the Payment Transaction is switched to Released state. b.The user sets it manually. Key - Crm/Sales/SalesOrders/ShowFillLotsInLines a.Action: When this key has value and this value is \"1\", the sales order function \"Fill lots in lines\" is activated. b.The user sets it manually. Key - General/Contacts/LoadCalendarForLimitedTime a.Action: When this key has value and this value is \"1\", the calendar in the Activities navigator loads data only for the displayed period (+/- 1 month) when the user scrolls through the calendar. b.The user sets it manually. Key - DisableDocumentRecalculationOnIdle a.Action: When this key has value and this value is \"1\", in the document forms the recalculation of additional amounts, bonus programs, payment plans and etc in real-time would not be performed (Application.Idle event). In such cases, the document would be recalculated only before the COMMIT event and not in real-time while the user enters the b.data in the document form. The method referred by the current key is \"Document.Recalculate\" which performs different actions in the different entities. c.The user sets it manually. Key - DisableParentDocumentReset a.Action: When this key has value and this value is \"1\", on document state change the parent document state is not reset. b.The user sets it manually. Key - RevokedBusinessRules a.Action: When this key has value, the validation and the action of the business rules, which codes are specified as a key value, is not performed. The codes of the business rules must be listed comma-separated (for example 27407, 26881 ..). Since version 2018.2, Business Rule's codes must be set with its full code including \"R\" (eg R27408, R26881 ...). If the key value is changed, the client application requires a restart. b.The user sets it manually. Key - DisableQueryingForSaveOnClose a.Action: When this key has value and this value is \"1\", on closing of a form which is not saved, if there is a change in any table of the form, no information message for saving or undo of the changes appears. b.The user sets it manually. Key - UseLegacyLoadForLotsIssue a.Action: When this key has value and this value is \"1\", for the calculation of the quantity Available to Promise by Lots is used the method that was developed before Version 2018.2. In all other cases, is used the current for Version 2018.2 method which is advisable and has a better performance. b.The user sets it manually. Key - ReservedLicenses (not implemented/ cancelled) Key - EnableCreateGroupForUser a.Action: When this key has value and this value is \"1\" or \"true\" (case-insensitive), when creating a new User into the database a new Group with the User’s name will be created automatically as well. b.The user sets it manually. c.The key is introduced in version: - 2019.1 (in implementation) Note Before version 2019.1 a new User Group was created automatically every time when a new user is created and this behaviour could not be disabled. Since version 2019.1 the behaviour is disabled by default and could be activated manually using the current registry key. Key - DocumentVersioningSystem a.Action: When the value of this key is \"VH\" the system will use the \"old\" document versioning system. If the key's value is \"TC\" the system will not create records using the \"old\" document versioning system and will instead use the Track Changes system. The minimum level that is going to be tracked when the \"TC\" option is activated is \"Track Changes Level 3\". If for the particular document entity is chosen a specific level, then this level will be applied only if it is a higher level than level 3. ( For more information about the track changes system and its levels, please see topic Track Changes Note Please note that the current key affects only entities which are a successor of document entity (such as Sales Orders, Store Orders ...) and NOT entities such as Product Groups, Bonus Programs.. b.The user sets it manually, but if the key is not configured for the particular database or its value is different from \"VH\" or \"TC\", then the system will use the default value. The default value depends on the system version: Version 2019.1 - the default value is \"VH\"; Version 2020.1 and later - the default value is \"TC\"; c.The key is introduced in version: - 2019.1 Key - Crm/Pos/PrintGroupedSalesLinesType a.Action: When the value of this key is \"ShortName\" then items in the fiscal receipt are grouped by \"ShortName\" field in the product. When the value of this key is \"ProductGroup\" then items in the fiscal receipt are grouped by the product group of the product. When the value of this key is different or the key is missing then items in the fiscal receipt are not grouped. b.The key is introduced in version: - 2019.1 Key - UseStartScreen a.Action: When the value of this key is: \"1\" - the form that is going to be opened when the program is started by the specified user will be the Start Screen. \"2\" - the starting form will be the Main Menu. \"0\", different from \"1\" and \"2\" or the key is not configured for the particular database and user - the system will use the default value. The default value for version 2020.1 is Main Menu. Warning: The current key's value will be taken into account only if there is no global policy specifying the use of the start screen for the whole database using the key \"UseStartScreenPolicy\" b.The user sets it manually. c. The key is introduced in version: - 2020.1 Key - UseStartScreenPolicy a.Action: When the value of this key is: \"1\" - the form that is going to be opened when the program is started will be the Start Screen. This applies to all users into the database, regardless of the \"UseStartScreen\" option. \"2\" - the starting form will be the Main Menu. This applies to all users into the database, regardless of the \"UseStartScreen\" option/key. \"0\", different from \"1\" and \"2\" or the key is not configured for the particular database - there is no global policy. Each user decides whether they want to use the start screen using \"UseStartScreen\" option/key. b.The user sets it manually. c.The key is introduced in version: - 2020.1 Key UseDefaultMailClient a.Action: When this key has a value for the particular User and this value is \"1\", then when creating an email the system will start the default Windows mail client. This will apply even if there is a mailbox defined for the user. b. The user sets it manually (directly in the registry or using the option available in tab File => Settings => Use default Windows mail client). c.The key is introduced in version: - 2019.1"
  },
  "reference/country-specific-functionality.html": {
    "href": "reference/country-specific-functionality.html",
    "title": "Country Specific Functionality | ERP.net Tech Docs",
    "keywords": "Country Specific Functionality ERP.net contains some country, region, or other specific functionalities that are needed in order to meet legal or regulatory requirements. Such functionality is the creation of VAT returns and the VAT export files for submission to the National Revenue Agency (Bulgaria), for example. Party Applicable Legislations In Parties, there is a child table with the Applicable Legislations for the particular Party. The table contains information about the countries, states, unions, or other entities whose regulations apply to the Party. The records in this table are used when determining if a business rule must be activated when, for example, it incorporates rules that are specific for the particular country's laws. Bulgaria (BG) List of the System Deal Types and Their Correlation with the Sales and Purchases Ledger's Columns The VAT declaration in ERP.net is a document that serves as a basis for the creation of a VAT return and the VAT export files for submission to the National Revenue Agency. The information in the VAT declaration is based on the VAT Entries created in the system for the particular period. The Entries amounts (Amount Base and VAT Amount Base) are entered in different columns of the Sales and Purchases Ledger of the VAT declaration depending on their Deal Type (for more information about Entries' deal type and amount calculation, see todo: (Defining VAT And Base For VAT Entries)). This article contains information about the correlation between the system Deal Types and the columns of the Sales and Purchases Ledgers according to which the Entries amounts are distributed to those columns. Sales Ledger Column Column Name (EN) Column Name (BG) Deal Type (BG) Additional Conditions Column9_Data Total Base Amount Общ размер на данъчните основи ВОД - Column9_Data Total Base Amount Общ размер на данъчните основи Доставка по чл. 163а от ЗДДС част I (отпадъци) на Приложение 2 - Column9_Data Total Base Amount Общ размер на данъчните основи Доставка по чл. 163а от ЗДДС част II (земеделска продукция) на Приложение 2 - Column9_Data Total Base Amount Общ размер на данъчните основи Доставка по чл.140,146,173(1) или 173(4) - Column9_Data Total Base Amount Общ размер на данъчните основи Износ по глава трета от ЗДДС - Column9_Data Total Base Amount Общ размер на данъчните основи Начисляване на ДДС в др. случаи Apply_Date >= '20160201' Column9_Data Total Base Amount Общ размер на данъчните основи Облагаеми доставки 7/9% - Column9_Data Total Base Amount Общ размер на данъчните основи Облагаеми сделки - Column9_Data Total Base Amount Общ размер на данъчните основи Самоначисляване на ДДС по чл.82,ал.2-5 - Column9_Data Total Base Amount Общ размер на данъчните основи Самоначисляване на ДДС при ВОП - Column10_Data Total VAT Amount Всичко начислен ДДС Начислен ДДС при ползване за лични нужди Apply_Date >= '20160201' Column10_Data Total VAT Amount Всичко начислен ДДС Начисляване на ДДС в др. случаи - Column10_Data Total VAT Amount Всичко начислен ДДС Облагаеми доставки 7/9% - Column10_Data Total VAT Amount Всичко начислен ДДС Облагаеми сделки - Column10_Data Total VAT Amount Всичко начислен ДДС Самоначисляване на ДДС по чл.82,ал.2-5 - Column10_Data Total VAT Amount Всичко начислен ДДС Самоначисляване на ДДС при ВОП - Column11_Data Base Amount 20 Percent Данъчна основа 20% Доставка по чл. 163а от ЗДДС част I (отпадъци) на Приложение 2 - Column11_Data Base Amount 20 Percent Данъчна основа 20% Доставка по чл. 163а от ЗДДС част II (земеделска продукция) на Приложение 2 - Column11_Data Base Amount 20 Percent Данъчна основа 20% Начисляване на ДДС в др. случаи Apply_Date >= '20160201' Column11_Data Base Amount 20 Percent Данъчна основа 20% Облагаеми сделки - Column12_Data VAT Amount 20 Percent Начислен ДДС 20% Начисляване на ДДС в др. случаи Apply_Date >= '20160201' Column12_Data VAT Amount 20 Percent Начислен ДДС 20% Облагаеми сделки - Column13_Data Base Amount EUPurchase Данъчна основа на ВОП Самоначисляване на ДДС при ВОП - Column14_Data Base Amount VATL Article 82 Данъчна основа на доставките по чл.82, ал. 2 - 5 Самоначисляване на ДДС по чл.82,ал.2-5 - Column15_Data VAT Amount EUPurchase VATL Article 82 Начислен ДДС за ВОП и доставките по чл.82, ал. 2 - 5 Самоначисляване на ДДС по чл.82,ал.2-5 - Column15_Data VAT Amount EUPurchase VATL Article 83 Начислен ДДС за ВОП и доставките по чл.82, ал. 2 - 5 Самоначисляване на ДДС при ВОП - Column16_Data VAT amout in case of personal use Начислен данък при ползване за лични нужди Начислен ДДС при ползване за лични нужди Apply_Date >= '20160201' Column16_Data VAT amout in case of personal use Начислен данък при ползване за лични нужди Начисляване на ДДС в др. случаи Apply_Date < '20160201' Column17_Data Base Amount 9 % Данъчна основа 9 % Облагаеми доставки 7/9% - Column18_Data VAT Amount 9 % Начислен ДДС 9 % Облагаеми доставки 7/9% - Column19_Data Base Amount 0 Percent VATL Chapter 3 Данъчна основа 0 % по глава трета от ЗДДС Износ по глава трета от ЗДДС - Column20_Data Base Amount 0 Percent EUSale Данъчна основа 0 % на ВОД ВОД - Column21_Data Base Amount 0 Percent VATL Articles 140 146 173 Данъчна основа 0 % по чл. 140, чл. 146 ал. 1 и чл. 173, ал. 1 и 4 Доставка по чл.140,146,173(1) или 173(4) - Column22_Data Base Amount Service Sales VATL Article 21 Данъчна основа на услугите по чл. 21, ал. 2 Доставка по чл.21(2) в друга държава членка - Column23_Data Base Amount VATL Article 69 Данъчна основа почл. 69, ал. 2 Доставка по чл.69(2) и дистанц. продажба към др.членка - Column24_Data Base Amount Exempted Sales And EUPurchases Данъчна основа на освободени доставки и ВОП Освб. дост. по чл. 21(2), в рамките на ЕС - Column24_Data Base Amount Exempted Sales And EUPurchases Данъчна основа на освободени доставки и ВОП Освободени ВОД, извън територията на България - Column24_Data Base Amount Exempted Sales And EUPurchases Данъчна основа на освободени доставки и ВОП Освободени доставки и освободени ВОП - Column25_Data Base Amount Third Party Operation Данъчна основа от посредник в тристранна операция Доставки като посредник при тристранна операция - Column25_Data Base Amount Third Party Operation Данъчна основа от посредник в тристранна операция Доставки като посредник при тристранна операция (авансови плащания) - Purchases Ledger Column Column Name (EN) Column Name (BG) Deal Type (BG) Additional Conditions Column9_Data Base Amount Without Tax Credit Данъчна основа без право на данъчен кредит Сделки, внос и ВОП без право на данъчен кредит - Column10_Data Base Amount With Full Tax Credit Данъчна основа с право на пълен данъчен кредит Сделки, внос и ВОП с право на пълен данъчен кредит - Column11_Data VAT Amount With Full Tax Credit ДДС с право на пълен данъчен кредит Сделки, внос и ВОП с право на пълен данъчен кредит - Column12_Data Base Amount With Partial Tax Credit Данъчна основа с право на частичен данъчен кредит Сделки, внос и ВОП с право на частичен данъчен кредит - Column13_Data VAT Amount With Partial Tax Credit ДДС с право на частичен данъчен кредит Сделки, внос и ВОП с право на частичен данъчен кредит - Column14_Data Annual Correction Годишна корекция Годишна корекция - Column15_Data Base Amount Third Party Operation Данъчна основа от посредник в тристранна операция Придобиване от посредник в тристранна операция -"
  },
  "reference/format-specifiers.html": {
    "href": "reference/format-specifiers.html",
    "title": "Format Specifiers | ERP.net Tech Docs",
    "keywords": "Format Specifiers Format specifiers are used to state the desired format when formatting object values. In ERP.net they can be used, for example, as a second parameter for the calculated attribute operator FORMATSTRING or in the formatting string (‘:FormatSpecifier’) when referencing domain attributes in the SENDMAIL action (‘{DomainAttribute:FormatSpecifier}’). There are two main types of format specifiers - Standard .Net Format Specifiers (Numeric, Date - Time,..) and Custom Format Specifiers (Multilanguge String, Custom Property). Standard .Net Format Specifiers The standard .Net format specifiers are supported. The list below contains the most frequently used .Net Format Specifiers. For a complete list and more information, please look at the official .Net documentation site. Numeric Format Specifiers 'C', 'c' - abbreviation of Currency. Converts a number to a string that represents a currency amount. Can be used with a precision specifier that indicates the desired number of digits after the decimal point. The decimal symbol separator and the currency symbol depend on the local regional settings. Returns: 123,4656 ('C') → $123,46 123,4656 ('C3') → $123,466 'D', 'd' -abbreviation of Decimal. Converts a number to a string of decimal digits (0-9), prefixed by a minus sign if the number is negative. Can be used with a precision specifier that indicates the desired number of digits after the decimal point. This format is supported only for integral types. Returns:1234 ('D') → 1234 -1234 ('D6') → -001234 'N', 'n' - abbreviation of Number. Converts a number to a string. Can be used with a precision specifier that indicates the desired number of digits after the decimal point. The decimal symbol separator depends on the local regional settings. Returns 123,4656 (N) → 123,47 123,4656 (N3) → 123,466 'P', 'p' - abbreviation of Percent. Multiplies a number by 100 and converts it to a string that represents a percentage. The precision specifier indicates the desired number of decimal places. The decimal symbol separator depends on the local regional settings. Returns 0,488869 (P) → 48,89% 0,488869 (P3) → 48,887% Date and Time Format Strings Standard date and time format specifiers can be used alone (standard date and time format string) or in a combination (custom format string) in order to define the text representation of a date and time value. A standard date and time format string uses a single format specifier to define the text representation of a date and time value. Any date and time format string that contains more than one character, including white space, is interpreted as a custom date and time format string. Standard date and time format strings: 'D', 'd' - Short date pattern. The returned format depends on the pattern set for Short date in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10.5.2019 'D' - Long date pattern. The returned format depends on the pattern set for Long date in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 'f' - Full date/time pattern (short time). The returned format depends on the pattern set for Long date and Short time in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 5:18 'F' - Full date/time pattern (long time).. The returned format depends on the pattern set for Long date and Short time in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 5:18:39 'M', 'm' - Month/day pattern. The returned format depends on the current culture set in the local regional settings. Returns: 2019-05-10 15:18:39.013 → May 10 'u' - Universal sortable date/time pattern. Returns: 2019-05-10 15:18:39.013 → 2019-05-10 15:18:39Z 'U' - Universal full date/time pattern. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 5:18:39 Custom format strings: 'd' - The day of the month, from 1 through 31. 'M' - The month, from 1 through 12. 'y' - The year, from 0 to 99. 'h' - The hour, using a 12-hour clock from 1 to 12. 'H' - The hour, using a 24-hour clock from 00 to 23. 'm' - The minute, from 0 through 59. 's' - The second, from 0 through 59. 'f' - The tenths of a second in a date and time value. '%' - Defines the following character as a custom '/' - Тhe current's culture date seperator. '' - The escape character. \"string\", 'string' - Literal string delimiter. Examples: 2019-05-10 15:18:39.013 ('dd MM yyyy hh:mm:ss.fff')→ 10 05 2019 03:18:39.013 2019-05-10 15:18:39.013 ('yyyy MM dd hh:mm:ss.fff')→ 2019 05 10 03:18:39.013 2019-05-10 15:18:39.013 ('dd M yyyy hh:mm:ss.fff')→ 10 5 2019 03:18 2019-05-10 15:18:39.013 ('dd MMM yyyy hh:mm')→ 10 May 2019 03:18 2019-05-10 15:18:39.013 ('dd/MM/yyyy hh:mm')→ 10.05.2019 03:18 2019-05-10 15:18:39.013 ('dd/MM/yyyy hh:mm')→ 10/05/2019 03:18 2019-05-10 15:18:39.013 (dd-MM-yyyy hh:mm)→ 10-05-2019 03:18 2019-05-10 15:18:39.013 ('dd MM yyyy hh:mm 'h'')→ 10 05 2019 03:18 h Custom Format Specifiers There are also custom format specifiers that are created especially for ERP.net. They are different for the different data types and are described below. Multilanguge String 'C', 'CURRENT' - returns the string of the current value. 'D', 'DUMP' - returns the content of the multilanguage string in the format: EN= DE= 'T', 'TRANSLITERATED' - returns transliteration to the current language. format specifiers for a particular language - returns the translation of the specified language. If there is no transliteration set for this language, returns an empty string. Note: The format specifiers for a particular language are supported since EnterpriseOne Version 2019.1. Language format specifiers: -'EN' - English 'BG' - Bulgarian 'CS' - Czech 'FR' - French 'DE' - German 'EL' - Greek 'HU' - Hungarian 'IT' - Italian 'MK' - Macedonian 'PL' - Polish 'PT' - Portuguese 'RO' - Romanian 'RU' - Russian 'SR' - Serbian 'ES' - Spanish Custom Property 'VD' - abbreviation of Value/Description, returns: : 'V' - abbreviation of Value, returns: 'VDI' - abbreviation of Value/Description/Id, returns: : ( ) 'D' - abbreviation of Description, returns:"
  },
  "reference/forms-with-activated-domain-front-end-logic.html": {
    "href": "reference/forms-with-activated-domain-front-end-logic.html",
    "title": "Forms with Activated Domain Front-End Logic | ERP.net Tech Docs",
    "keywords": "Forms with Activated Domain Front-End Logic When a Domain Front-End Logic is activated for a particular form, this means that it is activated for all referent panels in this form which are a part of the Aggregate . E.i. if it is activated for the Sales Ordes form - it is also activated for panels such as Sales Orders Lines and Payment Plan which are a part of the Sales Order's aggregate, but not for panels such as Document Amounts which are a part of the Document's aggregate. Module Form Activated BindDomainLogic Version Sales Module Customer Types YES 20.1 CustomerCompanyLocations YES 20.1 Customers YES 20.1 Customers - Companies YES 20.1 Customers - Persons YES 20.1 Dealers YES 20.1 Dealers - Companies YES 20.1 Dealers - Persons YES 20.1 Offers YES 2017.1 Price Lists YES 20.1 Price Types YES 20.1 Sales Orders YES 2017.1 Sales Persons YES 20.1 Deals YES 21.1 Line Discounts YES 21.1 Product Prices YES 21.1 Promotional Packages YES 21.1 POS Module POS Devices YES 20.1 POS Locations YES 20.1 POS Operators YES 20.1 POS Roles YES 20.1 POS Work Terminals YES 20.1 Product Types - Tax Groups YES 20.1 Invoicing Module Invoice Orders YES 20.1 Invoices YES 20.1 Products Module Coding Systems YES 20.1 Measurement Categories YES 20.1 Measurement Units YES 20.1 Product - Pictures YES 20.1 Product Groups YES 20.1 Product Types YES 20.1 Products YES 20.1 Products - Codes YES 20.1 Products - Dimensions YES 20.1 Products - Distribution Channels YES 20.1 Products - Variants YES 2017.1 Product Variants - Colors YES 21.1 Product Variants - Sizes YES 21.1 Product Variants - Styles YES 21.1 Configurator Module Product Groups YES 20.1 Products YES 20.1 Product - Custom Properties NO - Product Group - Required Properties NO - Contacts & Tasks Module Activities YES 20.1 Areas YES 20.1 Call Detail YES 20.1 Companies YES 20.1 Companies - Departments YES 20.1 Company EU Configurator YES 20.1 Contact Mechanisms YES 20.1 Party - Pictures YES 20.1 Party Relationship Types YES 20.1 Party Relationships YES 20.1 Reminders YES 20.1 Resources YES 21.1 Resources - Availability YES 20.1 Resources - Resource Instances YES 20.1 Resource Groups YES 21.1 Activities - Time Intervals NO - Companies - Divisions NO - Companies - Employees NO - Companies - Locations NO - Parties NO - Persons NO - Marketing Module Bonus Programs YES 20.1 Campaingns YES 20.1 Distribution Channels YES 20.1 Forecast Items YES 20.1 Marketing Activities YES 20.1 Product Catalogs YES 20.1 Target Groups YES 20.1 Distribution Module Customers - Products YES 20.1 Sales Person Groups YES 20.1 Sales Person Targets NO - Sales Persons NO - Pricing Module Pricing Models YES 20.1 Products YES 20.1 Types NO - Shipment Module Shipment Orders YES 20.1 Shipments YES 20.1 Inventory Management Module Lots YES 20.1 Products - Default Store Bins YES 20.1 Products - Valuation Groups YES 20.1 Scrap Types YES 20.1 Serial Numbers YES 20.1 Store Bins YES 20.1 Store Groups YES 20.1 Store Orders YES 20.1 Stores YES 20.1 Transactions YES 20.1 Cost Corrections YES 21.1 Reconciliations NO - Transfer Orders NO - Logistics Planning Module Product Supply YES 21.1 Procurement Module Receiving Orders YES 20.1 Suppliers YES 20.1 Suppliers - Companies YES 20.1 Suppliers - Persons YES 20.1 Purchase Control Documents YES 21.1 Purchase Operation Types YES 21.1 Purchase Orders NO - Purchase Price Lists YES 21.1 Purchase Product Prices YES 21.1 Requisitions NO - Supplier Types YES 21.1 Products and Technologies Module Products YES 20.1 Principal Recipies YES 21.1 Recipies YES 2015 Production Planning Module Product Supply NO - Resources Module Function Groups YES 21.1 Functions YES 21.1 Operation Groups YES 21.1 Operations YES 21.1 Resource Groups YES 21.1 Resources YES 21.1 Workgroups YES 21.1 Workgroups - Resources YES 21.1 Work Schedules YES 21.1 Shop Floor Module Consumption Orders NO - Output Orders NO - Work Orders NO - Projects Management Module Project Tasks NO - Projects NO - Projects - Risks YES 21.1 Projects Budgeting Module Resources YES 21.1 Resource Groups YES 21.1 Gen_Resources - Resource Instances YES 20.1 Resources - Availability YES 20.1 Product Variants YES 21.1 Projects Executuion Module Work Reports YES 21.1 Projects Setup Module Project Types YES 21.1 Project Types - Participants Roles YES 21.1 Project Types - Work Elements YES 21.1 Project Types - Work Types YES 21.1 Task Types YES 21.1 Payments Module Bulk Payment Orders YES 20.1 Parties - Bank Accounts YES 20.1 Payment Accounts YES 20.1 Payment Orders YES 20.1 Payment Reasons YES 20.1 Payment Slips YES 20.1 Payment Transfers YES 20.1 Payment Types YES 20.1 Payment Transactions NO - Expenses Module Supliers YES 20.1 Supliers - Companies YES 20.1 Supliers - Persons YES 20.1 Purchase Invoice NO - Accounting Module Account Groups NO - Accounts NO - Cost Centers NO - Operations NO - Profit Centers NO - Templates NO - Vouchers NO - Cost Accounting Module Cost Distributions NO - Cost Types NO - Financial Statements NO - Finanse Analisys Module NO - VAT Module Deal Types YES 21.1 Declaring Person NO - Document Type VAT Codes NO - Entries NO - VAT Declarations NO - Intrastat Module Intrastat Declarations YES 21.1 Fixed Assets Module Acquire and Retire Orders NO - Asset Categories YES 21.1 Asset Groups YES 21.1 Asset Transactions NO - Assets YES 21.1 Depreciation Methods YES 21.1 Depreciation Plans YES 21.1 Depreciations YES 21.1 Valuation Methods YES 21.1 Lease-Out Management Module Asset Groups YES 21.1 Asset Types - Consumables YES 21.1 Asset Types - Properties YES 21.1 Assets NO - Assets - Consumables YES 21.1 Assets Types YES 21.1 Service Module Service Activities YES 21.1- Service Agreements YES 21.1 Service Object Types YES 21.1 Service Objects YES 21.1 Service Orders YES 21.1 Service Types YES 21.1 Services YES 21.1 Services - Ivoicing YES 21.1 Vehicles Module Crews YES 21.1 Equipment Types YES 21.1 Map Points YES 21.1 Trips YES 21.1 Vehicle Equipment YES 21.1 Vehicle Sets YES 21.1 Vehicles YES 21.1 Mail Module Mail Messages NO - Mailboxes NO - Data Warehouse Module Data Measures NO - Data Measures Groups NO - Data Values NO - Personal Data (GDPR) Module Personal Data Management Processes YES 21.1 Processing Consents YES 21.1 Rights Requests YES 21.1 Asset Maintanance Module Maintenance Orders YES 21.1 Maintenance Types Groups YES 21.1 Maintenance Types YES 21.1 Managed Asset Groups YES 21.1 Managed Asset Types YES 21.1 Managed Assets YES 21.1 Service Centers YES 21.1 Tracked Parameters YES 21.1 General Administrative Regions YES 21.1 Countries YES 21.1 Currencies YES 21.1 Currency Directories NO - Custom Properties YES 21.1 Custom Properties Categories YES 21.1 Enterprise Companies NO - Communities Notification Settings YES 21.1 Notifications YES 21.1 Document Model Document Amount Types YES 21.1 Document Types - Amounts NO - Document Types YES 21.1 Document Types - Security Conditions NO - Printouts NO - Printouts - Layouts NO - Processes NO - Routes NO - Sales Orders - Default Payment Plans YES 21.1 Sequence Generators NO - Sequences NO - Business Rules Calculated Attributes YES 2018.1 User Business Rules YES 2018.1 Business Processes Business Processes YES 21.1 Process Connections NO - Process Elements NO - Process Groups YES 21.1 Process Instance YES 21.1 Process Lanes YES 21.1 Security Access Keys NO - Audit Log Entries YES 21.1 Column Permissions YES 21.1 Domains NO - Entities NO - Groups NO - Roles NO - Roles - Users NO - Trusted Applications NO - User Groups NO - Users NO - Tools Data Sources NO - Document Jobs NO - External Applications NO - Jobs NO - Reports NO - Translations YES 21.1 Web Hosts NO - Web Sites NO -"
  },
  "reference/index.html": {
    "href": "reference/index.html",
    "title": "Reference Section | ERP.net Tech Docs",
    "keywords": "Reference Section This section contains topics, which contain reference data. Select a topic from the menu to view reference data."
  },
  "reference/module-codes.html": {
    "href": "reference/module-codes.html",
    "title": "Module Codes | ERP.net Tech Docs",
    "keywords": "Module Codes This Topic contains an up-to-date list of ERP.net modules. Generic Access Licenses CAL01 - Concurrent Client Access License ED01 - Edition - Mini ED02 - Edition - Small Business ED03 - Edition - Standard ED04 - Edition - Corporate Applications APP01 - Applications - Project Management APP02 - Applications - Lease-Out Management APP03 - Applications - Vehicle Management APP04 - Applications - Mail APP05 - Applications - Personal Data Management APP06 - Applications - Data Warehouse APP07 - Applications - Enterprise Asset Management APP08 - Applications - EnterpriseOne POS CRM CRM01 - Clients - Sales CRM02 - Clients - Invoices CRM03 - Clients - Products CRM04 - Clients - Product Configuration CRM05 - Clients - Contacts and Tasks CRM06 - Clients - Marketing CRM07 - Clients - Service CRM08 - Clients - Distribution CRM09 - Clients - Unified Communications CRM10 - Clients - Pricing CRM11 - Clients - POS Sales Finance FIN01 - Finance - Payments FIN02 - Finance - Expenses FIN03 - Finance - Accounting FIN04 - Finance - VAT FIN05 - Finance - Fixed Assets FIN06 - Finance - Financial Analysis FIN07 - Finance - Intrastat Reporting FIN08 - Finance - Cost Accounting Logistics LOG01 - Logistics - Shipment LOG02 - Logistics - Inventory Management LOG03 - Logistics - Planning LOG04 - Logistics - Procurement LOG05 - Logistics - Warehouse Management LOG06 - Logistics - Transportation Production PRD01 - Production - Products and Technologies PRD02 - Production - Planning PRD03 - Production - Resources PRD04 - Production - Shop Floor Control Security SEC01 - Security - Sign in with Azure AD Web WEB02 - Web - Client Center Extras X01 - Extras - 10 Companies X02 - Extras - Unlimited Companies X03 - Extras - Store Bins X04 - Extras - Pictures Editor X05 - Extras - Business Intelligence X06 - Extras - Barcode Controlling X07 - Extras - EnterpriseOne API X08 - Extras - Business Process Management X09 - Extras - CSharp Scripting"
  },
  "reference/system-permissions.html": {
    "href": "reference/system-permissions.html",
    "title": "System Permissions | ERP.net Tech Docs",
    "keywords": "System Permissions In ERP.net there are some predefined System Permissions that are created in order to serve certain business cases and allow giving or restricting access of particular functionalities in the system. Each System Permission has a specific Access Key Id that is the same in each database. The records for that which System Permission is granted to which User Groups is kept in the Group Access Keys table. We are adding a list with the predefined System Permissions and their Access Key IDs. This information could, for example, be used to monitor the changes of those permissions using the Track Changes system. System Permission Access Key ID Allow edit persist lot in shipment orders 17f56001-681a-4972-a75f-425e21158e4c Allow credit limit override in sales orders 39c19335-cdd2-4548-8d0d-b10d5fc9fc9f Allow edit unit price in offers and sales orders b85c23e3-f314-467a-9022-53e43c08b585 Allow edit historical unit cost in sales orders c88e4f8a-7e55-4029-9615-a7e2b12ddd1b Allow edit persist lot in sales orders b2a3cef0-e6e3-11e1-aff1-0800200c9a66 Allow edit line discount in offers and sales orders e71c31d2-e315-4a72-d021-f3143c08b58a Allow edit persist lot in store orders aebcc95b-41d1-494e-92f8-e01501b353a8 Allow release of correct logistics transactions that are not validated orders 61e43e33-5bc4-484c-b581-3737e05b0978 Use personal layout views 850945b7-91da-4aa4-9e55-9f8feb72e423 Show more than 2,000 rows d7208a56-2a02-4069-bbe7-a8ce65085094 Show more than 20,000 rows 4a3c7106-e15b-4c97-bae1-5500c0cf47c6 Show more than 200,000 rows 10c58661-8210-4a77-8444-5126b0d99c91 Advanced User 06051ccb-19ef-49f0-a224-2ce2bcea87cf Super User 0ee5ee4b-3cbc-4fd2-aa50-42b1c5fa1d9a Server Control c10b3c23-2cf0-470b-b80d-549e0533c190"
  }
}