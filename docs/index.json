{
  "advanced/calculated-attributes/examples/calculate-standartpriceperlot.html": {
    "href": "advanced/calculated-attributes/examples/calculate-standartpriceperlot.html",
    "title": "Calculate standart price per lot based on the ingredients and the operations in the recipe | ERP.net Tech Docs",
    "keywords": "Calculate standart price per lot based on the ingredients and the operations in the recipe With this attribute, we can calculate the StandartPricePerLot that is going to be automatically set in the product’s definition we save the recipe. The StandartPricePerLot is determined by the prices of the ingredients and the operations used in the particular recipe. After that, we can use this attribute in a business rule which to fill in the PricePerLotValue of the product in the recipe. 10: ADD EXP:20 EXP:25 20: SUM CHILD:Ingredients ATTRIB:PriceValue 25: SUM CHILD:Operations EXP:30 30: MULTIPLY EXP:40 EXP:45 40: DIVIDE ATTRIB:StandardPricePerHourValue CONST:60.00 45: CAST EXP:50 CONST:System.Decimal 50: ADD ATTRIB:RunTimeMinutes EXP:60 60: ADD ATTRIB:WaitTimeMinutes EXP:70 70: ADD ATTRIB:SetupTimeMinutes ATTRIB:MoveTimeMinutes Explanation: 10: Add the value of EXP:20 to the value of EXP:25. 20: Sum all recipe's ingredients PriceValues. 25: Sum EXP:30 for all of the recipe's operations. 30: Multiply the value of EXP:40 and EXP:45. 40: Divide the StandardPricePerHourValue by 60.00 to get the StandardPrice per minute. 45: Cast EXP:50 to decimal. 50: Add the values of RunTimeMinutes to EXP:60 => EXP:70 to get the full execution time of the operation."
  },
  "advanced/calculated-attributes/examples/check-for-first-releasing.html": {
    "href": "advanced/calculated-attributes/examples/check-for-first-releasing.html",
    "title": "Check whether the releasing of the document is first or not | ERP.net Tech Docs",
    "keywords": "Check whether the releasing of the document is first or not Sometimes we may want to know whether the Released state of document is selected for a first time or not. For example, a business case may require a certain business rule to be executed only when first releasing the document. The calculated attributes are a tool which when triggered perform their calculation in real time. This means that if we use a calculated attribute as a condition for a business rule, the condition may be fulfilled today, but not tomorrow and if we reselect the document state it may trigger actions that are no longer needed for this record (for more information, see How to start a business rule only on first releasing ). To avoid such an occurrence, we can use a calculated attribute to define whether the releasing of the document is first or not. 10: IIF EXP:20 CONST:false CONST:true 20: EQUAL EXP:30 CONST:30 30: CAST ATTRIB:State CONST:System.Int32 Explanation: 10: Check if EXP:20 is true or false. If EXP:20 is True - the calculated attribute displays 'True', else - 'False'. 20: Check if EXP:20 is equal to \"30\". 30: Cast the state of the document to integer. State Released is stored as \"30\". For more information see DocumentState enumeration ."
  },
  "advanced/calculated-attributes/examples/check-if-field-is-changed-in-adjustment.html": {
    "href": "advanced/calculated-attributes/examples/check-if-field-is-changed-in-adjustment.html",
    "title": "Check if a value of a field is changed in the adjustment document | ERP.net Tech Docs",
    "keywords": "Check if a value of a field is changed in the adjustment document With the current attribute, we can check if the value of a field in the adjustment document is equal to the value of the same filed in the original (adjusted) document. When we have such information, we can determine if the value of this filed is being or has been changed in the adjustment document. Using this attribute, we can for example, create a business rule which would allow us to prohibit the correction of the value of this field. 10: IIF EXP:20 CONST:False EXP:30 20: EQUAL REF:AdjustedDocument CONST:NULL 30: IIF EXP:40 CONST:False CONST:True 40: EQUAL ATTRIB:@Property1 EXP:50 50: GETOBJVALUE REF:AdjustedDocument ATTRIB:@Property1 Explanation: 10: Check if EXP:20 is true or false. If EXP:20 is True - the calculated attribute displays 'True', else - 'False'. 20: Check if there is AdjustedDocument. If there is no reference to an adjusted document, then the document is not an adjustment document. 30: Check if EXP:40 is true or false. 40: Check if the value of the custom property 'Property1' is equal to EXP:50. 50: Get the value of the 'Property1' of the adjusted document."
  },
  "advanced/calculated-attributes/examples/check-if-quantity-is-whole-number.html": {
    "href": "advanced/calculated-attributes/examples/check-if-quantity-is-whole-number.html",
    "title": "Check if the quantity is a whole number | ERP.net Tech Docs",
    "keywords": "Check if the quantity is a whole number The current calculated attribute returns true if the quantity in the sales order line is whole number, and False - if it is decimal number. The repository of the attribute is Crm.Sales.SalesOrderLines. It expressions are as follows: 10: IIF EXP:20 CONST:True CONST:False 20: EQUAL ATTRIB:QuantityValue EXP:30 30: CEILING ATTRIB:QuantityValue Explanation: 10: check if expression 20 is true. If so - return True, else - return False 20: check if attribute QuantityValue is equal to expression 30 30: get the smallest integral value greater than or equal to the value in attribute QuantityValue"
  },
  "advanced/calculated-attributes/examples/check-if-system-type-is-in-cash.html": {
    "href": "advanced/calculated-attributes/examples/check-if-system-type-is-in-cash.html",
    "title": "Check if the system type of payment type in the sales order is 'In cash' | ERP.net Tech Docs",
    "keywords": "Check if the system type of payment type in the sales order is 'In cash' With this attribute we can check if the system type of payment type which is set in the sales order is 'In Cash'. When we have that information we can, for example, use the attribute to create a business rule (see Allow a credit limit override when the client pays in cash ) that allows a credit limit override when the client pays in cash. 10: IIF EXP:20 CONST:True CONST:False 20: EQUAL EXP:25 EXP:30 25: CAST CONST:0 CONST:System.Nullable`1[Aloe.EnterpriseOne.Model.Finance.Payments.PaymentTypesRepository+SystemType] 30: GETOBJVALUE REF:PaymentType ATTRIB:SystemType Explanation: 10: Return True of False according to the result of EXP:20 20: Check if EXP:25 is equal to EXP:30 25: Converts '0' to type System.Nullable`1[Aloe.EnterpriseOne.Model.Finance.Payments.PaymentTypesRepository+SystemType] using CAST 30: Get the system type of the payment type which is set in the sales order. Note When using EQUAL we should make sure that we are comparing parameters from the same type. If we don’t know which is the type of the particular object or what is the value that it is going to return, we can use the Aloe.EnterpriseOne.Model Documentation . In the particular example, we can check PaymentTypesRepository.SystemType Enumeration , where we can see that the value that corresponds to the system type in 'Cash' is '0'."
  },
  "advanced/calculated-attributes/examples/check-if-user-has-authorization.html": {
    "href": "advanced/calculated-attributes/examples/check-if-user-has-authorization.html",
    "title": "Check if the current user has authorization | ERP.net Tech Docs",
    "keywords": "Check if the current user has authorization If we want to determine if the user that is currently logged in the system is authorized (to do, see, or edit an entity, for example) we need to know which group have such rights. When we have that information, we can simply create a calculated attribute that checks if the user is a part of this group: 10: IIF EXP:20 CONST:True CONST:False 20: GTE EXP:30 CONST:1 30: SUM EXP:40 CONST:1 40: SELECT REPO:Systems.Security.UserGroups EXP:50 50: WHERE EXP:60 EXP:80 60: EQUAL ATTRIB:UserId EXP:70 70: GETOBJVALUE INPUT:10 SYS:UserId 80: EQUAL ATTRIB:GroupId CONST:5daf849d-9986-462f-9171-a23c1c5839b7 Explanation: 10: Check if EXP:20 is true or false. If EXP:20 is True - the calculated attribute displays the 'True' message, else - 'False'. 20: Check if the list EXP:30 returns at least one record. 30: Return the count of records in the filtered list of EXP:40. 40: Select 'User Groups' filtered by EXP:50. 50: The filters are expression 60, expression 80... 60: Check if the UserId is equal to EXP:70. 70: Get the Id of the user that is currently editing the entity. 80: Check if the GroupId is equal to the Id of an authorized group."
  },
  "advanced/calculated-attributes/examples/compare-unit-and-standard-unit-price.html": {
    "href": "advanced/calculated-attributes/examples/compare-unit-and-standard-unit-price.html",
    "title": "Compare unit price and standard unit price | ERP.net Tech Docs",
    "keywords": "Compare unit price and standard unit price The following calculated attribute calculates if the unit price in the sales order lines is greater than the standard unit price of the product and returns a message: 10: IIF EXP:20 CONST:'OK!' CONST:'Not OK!' 20: GT ATTRIB:UnitPriceValue ATTRIB:StandardUnitPriceValue Explanation: 10: Checks if EXP:20 is true or false. If EXP:20 is True - the calculated attribute displays the 'OK!' message, else - 'Not OK!'. 20: Checks if ATTRIB:UnitPriceValue is greater than ATTRIB: StandardUnitPriceValue. If so - returns True, else - False. The same validation may be achieved by using other operator: 10: IIF EXP:20 CONST:'Not OK!' CONST:'OK!' 20: LTE ATTRIB:UnitPriceValue ATTRIB:StandardUnitPriceValue Explanation: 10: Checks if EXP:20 is true or false. If EXP:20 is True - the calculated attribute displays the 'Not OK!' message, else - 'OK!'. 20: Checks if ATTRIB:UnitPriceValue is less than or equal to ATTRIB:StandardUnitPriceValue. If so - returns True, else - False."
  },
  "advanced/calculated-attributes/examples/convert-property-to-number.html": {
    "href": "advanced/calculated-attributes/examples/convert-property-to-number.html",
    "title": "Convert a value of a custom property to a number | ERP.net Tech Docs",
    "keywords": "Convert a value of a custom property to a number The values of the custom properties are a specific type of value and the CONVERT operator does not know how to handle it properly. For this reason, if we want to covert a custom property's value to a number, we have to CAST it first. Example - Multiply standard price per lot by a coefficient stored in a property Lets say, for example, we want to multiply the standard price per lot of the product by a coefficient stored as a product's custom property @CustomProperty1. Note The repository of the attributes is General.Products.Products RIGHT calculated attribute: 10: MULTIPLY ATTRIB:StandardPricePerLotValue EXP:20 20: CONVERT EXP:30 CONST:System.Decimal 30: CAST ATTRIB:@CustomProperty1 CONST:System.String Explanation: 10: Multiply the value of the 'Standard Price Per Lot' by EXP: 20. 20: Convert EXP:30 to a decimal number. 25: Cast the value of custom property 'CustomProperty1' to a string. WRONG calculated attribute: 10: MULTIPLY ATTRIB:StandardPricePerLotValue EXP:20 20: CONVERT ATTRIB:@CustomProperty1 CONST:System.Decimal Explanation: 10: Multiply the value of the 'Standard Price Per Lot' by EXP: 20. 20: Convert the value of custom property 'CustomProperty1' to a decimal number. Note When we want to convert CustomPropertyValue to numeric value (for example, decimal), we need to CAST it to a string first!"
  },
  "advanced/calculated-attributes/examples/day-from-document-date.html": {
    "href": "advanced/calculated-attributes/examples/day-from-document-date.html",
    "title": "Specific day from document date | ERP.net Tech Docs",
    "keywords": "Specific day from document date A calculated attribute is added with the following parameters: Repository Name:Crm.Sales.SalesOrders Name:TenDaysFromDocumentDay And the calculated attribute expressions are as follows: 10: ADDDAYS ATTRIB:DocumentDate CONST:10 Explanation: 10: Add 10 days to the date in DocumentDate If showed in the sales order form, this attribute calculates and displays 10 days added to the DocumentDate."
  },
  "advanced/calculated-attributes/examples/format-property-date.html": {
    "href": "advanced/calculated-attributes/examples/format-property-date.html",
    "title": "Format date type custom property | ERP.net Tech Docs",
    "keywords": "Format date type custom property The current example shows how you can format the values of date type custom properties using a calculated attribute. 10: FORMATSTRING EXP:20 CONST:yyyy MM dddd 20: CONVERT EXP:30 CONST:System.DateTime 30: CONCAT EXP:40 EXP:50 40: SUBSTRING EXP:100 CONST:0 CONST:4 50: CONCAT CONST:- EXP:60 60: CONCAT EXP:70 EXP:80 70: SUBSTRING EXP:100 CONST:4 CONST:2 80: CONCAT CONST:- EXP:90 90: SUBSTRING EXP:100 CONST:6 CONST:2 100: FORMATSTRING ATTRIB:@Property1 CONST:V Explanation: We assume that the value of the custom poperty is 20200315. 10: Format the date returned from EXP:20 applying the date format type 'yyyy MM dddd' e.g. '2020 03 Sunday'. 20: Convert the type of the value returned from EXP:30 to DateTime 30: Concatenate the text from EXP:40 to the text from EXP:50 e.g. '2021' + '-03-15' 40: Get the first 4 characters from EXP:100 e.g. '2021' 50: Concatenate the character '-' to the text from EXP:60 e.g. '-' + '03-15' 60: Concatenate the text from EXP:70 to the text from EXP:80 e.g. '09' + '-15' 70: Get the first 2 characters from the string from EXP:100, starting from character 4 e.g. '03' 80: Concatenate the character '-' to the text from EXP:90 e.g. '-' + '15' 90: Get the first 2 characters from the string from EXP:100, starting from character 6 e.g. '15' 100: Get the value of custom property \"Property1\" e.g. '20200315'"
  },
  "advanced/calculated-attributes/examples/get-atp.html": {
    "href": "advanced/calculated-attributes/examples/get-atp.html",
    "title": "Get available to promise (ATP) quantity | ERP.net Tech Docs",
    "keywords": "Get available to promise (ATP) quantity This example shows how you can create a calculated attribute which gets the avaible to promise (ATP) quantity on a particular date using the AvailableToPromise view. In the example, we are showing how get the ATP quantity in a shipment order line on its required delivery date. Note The repository of the attributes is Logistics.Shipment.ShipmentOrderLines 10 GETOBJVALUE EXP:20 ATTRIB:ATPBaseValue 20 FIRST EXP:30 30 SORT EXP:40 ATTRIB:FromDate CONST:DESC 40 SELECT REPO:Logistics.Inventory.DemandManagement.AvailableToPromise EXP:50 50 WHERE EXP:80 EXP:60 60 AND EXP:110 EXP:70 70 AND EXP:140 EXP:170 80 EQUAL ATTRIB:ProductId EXP:90 90 GETOBJVALUE INPUT:10 EXP:100 100 GETOBJVALUE REF:ParentSalesOrderLine ATTRIB:ProductId 110 EQUAL ATTRIB:StoreId EXP:120 120 GETOBJVALUE INPUT:10 EXP:130 130 GETOBJVALUE REF:ParentSalesOrderLine ATTRIB:LineStoreId 140 EQUAL ATTRIB:EnterpriseCompanyId EXP:150 150 GETOBJVALUE INPUT:10 EXP:160 160 GETOBJVALUE REF:ShipmentOrder ATTRIB:EnterpriseCompanyId 170 LTE ATTRIB:FromDate EXP:180 180 GETOBJVALUE INPUT:10 EXP:190 190 GETOBJVALUE REF:ShipmentOrder ATTRIB:RequiredDeliveryDate Explanation: 10: Get the \"ATPBaseValue\" of the AvailableToPromise record returned by EXP:20 20: Get the first record of the list returned by EXP:30 30: Sort the list returned by EXP:40 - descending by the value of the \"FromDate\" attribute 40: Select the AvailableToPromise records which are matching the clauses of EXP:50 50: Filter the the records for which EXP:80 and EXP:60 are True 60: Filter the the records for which EXP:110 and EXP:70 are True 70: Filter the the records for which EXP:140 and EXP:170 are True 80: Return True if the ProductId of the AvailableToPromise record is equal to EXP:90 90: Get EXP:100 from the repository of EXP:10 i.e. of the current shipment order line 100: Get the ProductId of the ParentSalesOrderLine 110: Return True if the StoreId of the AvailableToPromise record is equal to EXP:120 120: Get EXP:130 from the repository of EXP:10 i.e. of the current shipment order line 130: Get the LineStoreId of ParentSalesOrderLine 140: Return True if the EnterpriseCompanyId of the AvailableToPromise record is equal to EXP:150 150: Get EXP:160 from the repository of EXP:10 i.e. of the current shipment order line 160: Get the EnterpriseCompanyId of the ShipmentOrder 170: Return True if the FromDate of the AvailableToPromise record lower or equal to EXP:180 180: Get EXP:160 from the repository of EXP:10 i.e. of the current shipment order line 160: Get the RequiredDeliveryDate of the ShipmentOrder"
  },
  "advanced/calculated-attributes/examples/get-current-availability-of-product.html": {
    "href": "advanced/calculated-attributes/examples/get-current-availability-of-product.html",
    "title": "Get current availability of a product | ERP.net Tech Docs",
    "keywords": "Get current availability of a product This example shows how to create a calculated attribute which returns the sum of the currently available quantity base of a particular product. In the example below, are applied filters by product, store, store bin, lot and serial number, because of the specification of the repository of the calculation attribute. Other filters like product variant and enterprise company could also be added if needed. The example is created for consumption order lines, but such attribute could be created for other documents or definitions as well. Repository Name: Production.ShopFloor.ConsumptionOrderLines 10: SUM EXP:20 ATTRIB:QuantityBaseValue 20: FILTER EXP:30 EXP:70 30: SELECT REPO:Logistics.Inventory.CurrentBalances EXP:40 40: WHERE EXP:50 50: EQUAL ATTRIB:ProductId EXP:60 60: GETOBJVALUE INPUT:10 ATTRIB:ProductId 70: AND EXP:100 EXP:80 80: AND EXP:130 EXP:90 90: AND EXP:150 EXP:170 100: EQUAL ATTRIB:StoreId EXP:110 110: CAST EXP:120 CONST:System.Guid 120: GETOBJVALUE INPUT:10 ATTRIB:StoreId 130: EQUAL ATTRIB:StoreBinId EXP:140 140: GETOBJVALUE INPUT:10 ATTRIB:StoreBinId 150: EQUAL ATTRIB:LotId EXP:160 160: GETOBJVALUE INPUT:10 ATTRIB:LotId 170: EQUAL ATTRIB:SerialNumberId EXP:180 180: GETOBJVALUE INPUT:10 ATTRIB:SerialNumberId Explanation: 10: Sum Quantity Base from the filtered list returned by EXP:20 20: Filter the list from EXP:30 by the clauses of EXP:70 30: Select repository \"Logistics.Inventory.CurrentBalances\" and filter by the clauses in EXP:40 40: Filter the list above by the records WHERE/in which the clauses in EXP:50 are True 50: Check whether ATTRIB:ProductId is equal to EXP:60 60: Get ATTRIB:ProductId from the repository of EXP:10 70: EXP:100 and EXP:80 80: EXP:130 and EXP:90 90: EXP:150 and EXP:170 100: Check whether ATTRIB:StoreId is EQUAL to EXP:110 110: CAST EXP:120 to System.Guid 120: Get ATTRIB:StoreId from the repository of EXP:10 130: Check whether ATTRIB:StoreBinId is EQUAL to EXP:140 140: Get ATTRIB:StoreBinId from the repository of EXP:10 150: Check whether ATTRIB:LotId is EQUAL to EXP:160 160: Get ATTRIB:LotId from the repository of EXP:10 170: Check whether ATTRIB:SerialNumberId is EQUAL to EXP:180 180: Get ATTRIB:SerialNumberId from the repository of EXP:10"
  },
  "advanced/calculated-attributes/examples/get-custom-property-from-parent-offer-line.html": {
    "href": "advanced/calculated-attributes/examples/get-custom-property-from-parent-offer-line.html",
    "title": "Get a value of a custom property in sales order lines from the parent offer line | ERP.net Tech Docs",
    "keywords": "Get a value of a custom property in sales order lines from the parent offer line With this attribute, we can, for example, determine what is the value of a particular customer property which is set for the parent offer line of the current sales order line. Currently, offer lines customer properties are not automatically transferred to the sales order. Thus, we can use this attribute in a user business rule to automate the process. For more information on how to create such a rule, see How to use business rules to set a value into a custom property? Repository: Crm.Sales.SalesOrderLines 10: GETOBJVALUE EXP:20 ATTRIB:@Propery1 20: FIRST EXP:30 30: FILTER EXP:70 EXP:40 40: EQUAL ATTRIB:LineNo EXP:50 50: CAST EXP:60 CONST:System.Int32 60: GETOBJVALUE INPUT:10 ATTRIB:ParentLineNo 70: GETOBJVALUE EXP: 80 CHILD:Lines 80: CAST REF:ParentDocument CONST:Aloe.EnterpriseOne.Model.Crm.Presales.Offer Explanation: 10: Get the record of custom property \"Propery1\" from EXP:20. 20: Get the first value of EXP:30. 30: Filter the list from EXP:70 with the filters from EXP:40. 40: Check in the LineNumber of the offer line is equal to the value from EXP:50. 50: Cast EXP:60 to \"System.Int32\". 60: Get the ”ParentLineNo“ of the sales order line which is an input for EXP:10. 70: Get the list of child line of the object of EXP:80. 80: Cast the parent document of the sales order line to \"Aloe.EnterpriseOne.Model.Crm.Presales.Offer\" in order to define the type/entity of the parent document."
  },
  "advanced/calculated-attributes/examples/get-value-and-description-of-referent-object.html": {
    "href": "advanced/calculated-attributes/examples/get-value-and-description-of-referent-object.html",
    "title": "Get value and description of referent object | ERP.net Tech Docs",
    "keywords": "Get value and description of referent object At first, when a value is set to a custom property of an object, a new record is added to the \"General.PropertyValue\" repository. The new record has its own Id, and the id of the specific object - EntityItemId. So in a calculated attribute, we need to filter the value for the specific property (PropertyId) of the specific object (EntityItemId) and then get the value or description. Let's see an example: The current example shows how to get the description of a property of the customer and show it in the offer form. Such calculated attribute would have the following parameters: Repository Name:Crm.Presales.Offers And the calculated attribute expressions are as follows: 10: GETOBJVALUE EXP:20 ATTRIB:Description 20: FIRST EXP:30 30: SELECT REPO:General.PropertyValues EXP:40 40: WHERE EXP:50 50: AND EXP:60 EXP:70 60: EQUAL ATTRIB:PropertyId CONST:e7005814-6140-4708-a9d8-aaaeb5b151ed 70: EQUAL ATTRIB:EntityItemId EXP:80 80: GETOBJVALUE INPUT:10 ATTRIB:CustomerId Explanation: 10: get the attribute description of the object in expression 20 20: get the first record in the list from expression 30 30: select repository \"General.PropertyValues\" filtered by expression 40 40: the filter is expression 50 50: expression 60 AND expression 70 60: check if the attribute PropertyId is equal to the constant of \"e7005814-6140-4708-a9d8-aaaeb5b151ed\" (this is a guid) 70: check if the attribute EntityItemId is equal to expression 80 80: get the attribute CustomerId of the input object of expression 10 If we need the value of the property, the first expression may be set to GETOBJVALUE EXP:20 ATTRIB:PropertyValueField."
  },
  "advanced/calculated-attributes/examples/index.html": {
    "href": "advanced/calculated-attributes/examples/index.html",
    "title": "Examples | ERP.net Tech Docs",
    "keywords": "Examples Calculate standart price per lot based on the ingredients and the operations in the recipe Check if a value of a field is changed in the adjustment document Check if the current user has authorization Check if the quantity is a whole number Check if the system type of payment type in the sales order is 'In cash' Check whether the releasing of the document is first or not Compare unit price and standard unit price Convert a value of a custom property to a number Format date type custom property Get a value of a custom property in sales order lines from the parent offer line Get available to promise (ATP) quantity Get current availability of a product Get value and description of referent object Sales amounts of the customer for the last 30 days Specific day from document date Total quantity and scrap quantity in recipe ingredients"
  },
  "advanced/calculated-attributes/examples/sales-amounts-last-30-days.html": {
    "href": "advanced/calculated-attributes/examples/sales-amounts-last-30-days.html",
    "title": "Sales amounts of a customer for the last 30 days | ERP.net Tech Docs",
    "keywords": "Sales amounts of a customer for the last 30 days Let's say a user wants to show a field in the sales order which calculates the sales amounts of the selected customer for the last 30 days. Such calculated attribute actually represents a report with specific filters. If a user tries to get the sales of a client for the last 30 days, he would open a sales order lines report and set the following filters: Client Enterprise company Enterprise company location (eventually) DocumentState (at least Released) Void Document date So the calculated attribute must SELECT the sales order lines table and filter the records as described above. Such calculated attribute would have the following parameters: Repository Name:Crm.Sales.SalesOrders Name:SOAmountsForTheLast30days And the calculated attribute expressions are as follows: 10: SUM EXP:20 ATTRIB:LineAmountValue 20: SELECT REPO:Crm.Sales.SalesOrderLines EXP:30 30: WHERE EXP:40 EXP:90 40: AND EXP:50 EXP:70 50: EQUAL EXP:60 CONST:30 60: CAST EXP:61 CONST:System.Int32 61: GETOBJVALUE REF:Document ATTRIB:State 70: EQUAL EXP:80 CONST:False 80: GETOBJVALUE REF:Document ATTRIB:Void 90: AND EXP:100 EXP:130 100: AND EXP:101 EXP:160 101: EQUAL EXP:110 EXP:120 110: GETOBJVALUE REF:SalesOrder ATTRIB:CustomerId 120: GETOBJVALUE INPUT:10 ATTRIB:CustomerId 130: GTE EXP:140 EXP:150 140: GETOBJVALUE REF:SalesOrder ATTRIB:DocumentDate 150: ADDDAYS EXP:151 CONST:-30 151: GETOBJVALUE INPUT:10 ATTRIB:DocumentDate 160: EQUAL EXP:170 EXP:180 170: GETOBJVALUE REF:SalesOrder ATTRIB:EnterpriseCompanyId 180: GETOBJVALUE INPUT:10 ATTRIB:EnterpriseCompanyId Explanation: 10: Sum all records from expression 20 by their attribute LineAmountValue 20: Select 'Sales Order Lines' filtered by expression 30 30: the filter is expression 40 AND expression 50 40: expression 50 AND expression 70 50: check if expression 60 is equal to expression 30 60: cast expression 61 to \"System.Int32\" (this is integer) 61: get the value of attribute State of the referent object Document 70: check if expression 80 is equal to \"False\" 80: get the value of attribute Void of the referent object Document 90: expression 100 AND expression 130 100: expression 101 AND expression 160 101: check if expression 110 is equal to expression 120 110: get the value of attribute CustomerId of the referent object SalesOrder 120:get the value of attribute CustomerId of the input object of expression 10 130: check if expression 140 is greater than or equal to expression 150 140: get the value of attribute DocumentDate of the referent object SalesOrder 150: add to expression 151 the value of \"-30\" 151: get the value of attribute DocumentDate of the input object of expression 10 160: check if expression 170 is equal to expression 180 170: get the value of attribute EnterpriseCompanyId of the referent object SalesOrder 180: get the value of attribute EnterpriseCompanyId of the input object of expression 10"
  },
  "advanced/calculated-attributes/examples/total-quantity-and-scrap-in-recipe-ingredients.html": {
    "href": "advanced/calculated-attributes/examples/total-quantity-and-scrap-in-recipe-ingredients.html",
    "title": "Total quantity and scrap quantity in recipe ingredients | ERP.net Tech Docs",
    "keywords": "Total quantity and scrap quantity in recipe ingredients If the user wants to see the total quantity of the material in a recipe, which would include the used quantity and the scrap rate, he would add the following calculated attribute: Repository Name:Production.Technologies.RecipeIngredients Name:TotalUsedQuantity And the calculated attribute expressions are as follows: 10: ADD ATTRIB:UsageQuantityValue EXP:20 20: MULTIPLY ATTRIB:UsageQuantityValue ATTRIB:ScrapRate Explanation: 10: Add the result from expression 20 to the attribute UsageQuantityValue 20: Multiply UsageQuantityValue and ScrapRate"
  },
  "advanced/calculated-attributes/index.html": {
    "href": "advanced/calculated-attributes/index.html",
    "title": "User Calculated Attributes | ERP.net Tech Docs",
    "keywords": "User Calculated Attributes User Calculated Attributes are user-defined objects, which extend the system entities. Calculated attributes are defined like formulas. When the value of a calculated attribute is requested, it is calculated \"on the fly\", in real time. Note Calculated attribute formulas are compiled to native executable format. Their calculation speed is very similar to the speed of the system defined calculated attributes. Example - Get default payment term days Suppose, that in a Sales Order, we want to display the customers default payment term (in days). In the Sales Order, we can define the following Calculated Attribute: No Operation Param1 Param2 Param3 10 GETREF REF:Customer ATTRIB:DefaultPaymentTermDays Explanation: GETREF - gets information from a related entity. The related entity is specified in Param1. The desired information is specified in Param2. Line number 10 is the only line in the calculated attribute The return value is the value of the attribute DefaultPaymentTermDays in the Customer entity. Example - Complex filter and summation The following calculated attribute sums all sales order lines, whose product: has a user data attribute, called \"CustPropPrj\", equal to '500' has a Name, containing the word 'Tool' No Operation Param1 Param2 Param3 10 SUM EXP:20 ATTRIB:LineAmount 20 FILTER CHILD:Lines EXP:30 30 IN ATTRIB:Product EXP:40 40 FILTER QUERY:Gen_Products EXP:50 50 AND EXP:60 EXP:70 60 EQUALS ATTRIB:CustPropPrj CONST:500 70 LIKE ATTRIB:Name CONST:'Tool' Explanation: Line 10: Iterates through the data set, specified on Line 20 (EXP:20), then SUMs the attribute LineAmount. Line 20: Filters the Lines subset with the filter, specified in Line 30 (EXP:30). Line 30: Creates a filter, which will be satisfied only by products, specified in the query on Line 40 (EXP:40). Line 40: Creates a query, which filters the products with the condition, specified on Line 50. Line 50: Specifies that the condition is comprised of two conditions, linked with AND. Line 60: Specifies that the first condition is the value of an attribute, called CustPropPrj should be 500. Line 70: Specifies that the second condition is that the Name of the product should contain 'Tool'. This example demonstrates, that Calculated Attributes can calculate very complicated formulas, query the database, get related values, etc. Temporary ADD ADDDAYS AND Calculate standart price per lot based on the ingredients and the operations in the recipe CAST CEILING Check if a value of a field is changed in the adjustment document Check if the current user has authorization Check if the quantity is a whole number Check if the system type of payment type in the sales order is 'In cash' Check whether the releasing of the document is first or not Compare unit price and standard unit price CONCAT CONST CONVERT Convert a value of a custom property to a number COUNT DIVIDE EQUAL Examples FILTER FIRST FLOOR Format date type custom property FORMATSTRING Get a value of a custom property in sales order lines from the parent offer line Get available to promise (ATP) quantity Get current availability of a product Get value and description of referent object GETOBJVALUE GETVALUE GT GTE How to check if a custom property has values? How to check if a list has values? How to check whether a field that points to a reference object has a value? How to create an optimally fast calculated attribute? How to determine the party type of a party? How to get attribute value from list? How to get specific field of a parent document? How to show contact of a person in Persons navigator? How to use a customer as a company? IIF IN INCNUM LEFT LEN LIKE LIST LT LTE MULTIPLY NOT Operators OR ORDERBY Parameter types POS Q & A REGEX REPLACE RIGHT ROUND Sales amounts of a customer for the last 30 days SELECT SORT Specific day from document date SUBSTRING SUM SYS TODAY TOLOWER TOP Total quantity and scrap quantity in recipe ingredients TOUPPER WHERE"
  },
  "advanced/calculated-attributes/operators/add.html": {
    "href": "advanced/calculated-attributes/operators/add.html",
    "title": "ADD | ERP.net Tech Docs",
    "keywords": "ADD Specification Value Name ADD Description The operator returns the sum (total) of two numbers. Parameter 1 Name Number1 Parameter 1 Type numeric type - int, double or decimal Parameter 2 Name Number2 Parameter 2 Type numeric type - int, double or decimal Parameter 3 Name Parameter 3 Type Return value Number1 + Number2 Note Ensure that the numbers which are summed up are from the the same type. For example, Parameter 1 and Parameter 2 must be both integers, doubles, or decimals. Example The following example adds '0.25' to the the value of the Quantity field in sales order lines and returns the sum of the two numbers. 10: ADD ATTRIB:QuantityValue CONST:0.25 OUTPUT: If 'QuantityValue = 1', the output will be '1.25'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More examples: Total quantity and scrap quantity in recipe ingredients"
  },
  "advanced/calculated-attributes/operators/adddays.html": {
    "href": "advanced/calculated-attributes/operators/adddays.html",
    "title": "ADDDAYS | ERP.net Tech Docs",
    "keywords": "ADDDAYS Specification Value Name ADDDAYS Description Adds the specified number of days to the date. Parameter 1 Name Date Parameter 1 Type Date Parameter 2 Name NumDays Parameter 2 Type int Parameter 3 Name Parameter 3 Type Return value Date + NumDays Example 10: ADDDAYS ATTRIB:DocumentDate CONST:5 OUTPUT: If 'DocumentDate = 2000-01-20', the output will be '2000-01-25'. Note The repository of the attribute is Crm.Sales.SalesOrders"
  },
  "advanced/calculated-attributes/operators/and.html": {
    "href": "advanced/calculated-attributes/operators/and.html",
    "title": "AND | ERP.net Tech Docs",
    "keywords": "AND Specification Value Name AND Description Checks if the two conditions are True. If so - the operator returns True. If any of the specified conditions are not True, the operator returns False. Parameter 1 Name Condition1 Parameter 1 Type boolean Parameter 2 Name Condition2 (optional) Parameter 2 Type boolean Parameter 3 Name Condition3 (optional) Parameter 3 Type boolean Return value Condition1 AND Condition2 Note Parameter 1 and Parameter 2 are optional. If only parameter 1 has value, the result is its value (Parameter 1). Example 10: AND EXP:20 EXP:30 20: EQUAL ATTRIB:LineNo CONST:10 30: EQUAL ATTRIB:Notes CONST:Apple OUTPUT: If 'LineNo = 10' and 'Notes = Apple', the output will be 'True'. If 'LineNo = 50' and 'Notes = Apple', the output will be 'False'. If 'LineNo = 10' and 'Notes = Pear', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More examples: Sales amounts of the customer for the last 30 days Get value and description of referent object"
  },
  "advanced/calculated-attributes/operators/cast.html": {
    "href": "advanced/calculated-attributes/operators/cast.html",
    "title": "CAST | ERP.net Tech Docs",
    "keywords": "CAST Specification Value Name CAST Description Casts the parameter to the specified type. Parameter 1 Name param Parameter 1 Type any type Parameter 2 Name type Parameter 2 Type string - 'System.Int32', 'System.String', 'System.Decimal', 'System.Double' and all standart .net types. Parameter 3 Name Parameter 3 Type Return value Returns the param converted to the type. Note The CAST operator is a secondary operator, used by the other operators to convert their parameters to the same type. The type is usually entered as a constant (CONST). Example The following example converts the value of the state of a sales order, whose type is enum, to an integer number. Conveting to integer allows comparison between the states (lower -> higher): 10: CONVERT ATTRIB:State CONST:System.Int32 OUTPUT: If 'State = Released', the output will be '30'. Note The repository of the attribute is Crm.Sales.SalesOrders More examples: Check whether the releasing of the document is first or not Check if the system type of payment type in the sales order is 'In Cash'"
  },
  "advanced/calculated-attributes/operators/ceiling.html": {
    "href": "advanced/calculated-attributes/operators/ceiling.html",
    "title": "CEILING | ERP.net Tech Docs",
    "keywords": "CEILING Specification Value Description Returns the smallest integer that is greater than or equal to the specified number. Parameter 1 Name Number1 Parameter 1 Type double or decimal Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value The nearest integer which is larger than Number1. Example The following example gets the smallest integer that is greater than or equal to the quantity of a sales order line: 10:CEILING ATTRIB:QuantityValue OUTPUT: If 'QuantityValue = 14.15', the output will be '15'. If 'QuantityValue = 14', the output will be '14'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/concat.html": {
    "href": "advanced/calculated-attributes/operators/concat.html",
    "title": "CONCAT | ERP.net Tech Docs",
    "keywords": "CONCAT Specification Value Description Concatenates two strings. Parameter 1 Name String1 Parameter 1 Type string Parameter 2 Name String2 Parameter 2 Type string Parameter 3 Name - Parameter 3 Type - Return value String1 + String2 Example The following example concatenates the word 'Red' with the value of the field Notes in a sales order lines: 10: CONCAT CONST:Red ATTRIB:Notes OUTPUT: If 'Notes = Apple', the output will be 'RedApple'. Note The repository of the attribute is Crm.Sales.SalesOrderLines If we want to expand the example we can add a space between the both strings: 10: CONCAT CONST:Red EXP:20 20: CONCAT CONST:' ' ATTRIB:Notes OUTPUT: If 'Notes = Apple', the output will be 'Red Apple'."
  },
  "advanced/calculated-attributes/operators/convert.html": {
    "href": "advanced/calculated-attributes/operators/convert.html",
    "title": "CONVERT | ERP.net Tech Docs",
    "keywords": "CONVERT Specification Value Description Returns an object of the specified type and whose value is equivalent to the specified object. This conversion requires absolutely correct input data - if the data is not in the correct form, loss may occur. For examplе, if the user tries to convert the string value of '3.12' to decimal, the conversion would be successful. If the conversion of the string is not possible, this may lead to data loss, but no error would be returned. Parameter 1 Name param Parameter 1 Type decimal, int, string or date Parameter 2 Name type Parameter 2 Type string - 'System.Int32', 'System.String', 'System.Decimal', 'System.DateTime' and all standard .net types Parameter 3 Name - Parameter 3 Type - Return value Returns the param converted to the type. Example The following example converts the value of the quantity of a sales order line, which is a decimal number, to an integer number: 10: CONVERT ATTRIB:QuantityValue CONST:System.Int32 OUTPUT: If 'QuantityValue = 12.14', the output will be '12'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More examples: Convert a value of a custom property to a number"
  },
  "advanced/calculated-attributes/operators/count.html": {
    "href": "advanced/calculated-attributes/operators/count.html",
    "title": "COUNT | ERP.net Tech Docs",
    "keywords": "COUNT Specification Value Description Gets the number of elements contained in the list. Parameter 1 Name list Parameter 1 Type list - repository, child. Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value int Introduced in version 2020.1 Example The following example returns the number of lines in the current document (sales order): 10: COUNT CHILD:Lines Note The repository of the attribute is Crm.Sales.SalesOrders If we want to expand the example and get the number of lines with quantity greater than or equal to 10, the following attribute would do the job: 10: COUNT EXP:20 20: FILTER CHILD:Lines EXP:30 30: GTE ATTRIB:QuantityValue CONST:10.00"
  },
  "advanced/calculated-attributes/operators/divide.html": {
    "href": "advanced/calculated-attributes/operators/divide.html",
    "title": "DIVIDE | ERP.net Tech Docs",
    "keywords": "DIVIDE Specification Value Name DIVIDE Description Divide one number by a second number. Parameter 1 Name Number1 Parameter 1 Type numeric type - int, double or decimal Parameter 2 Name Number2 Parameter 2 Type numeric type - int, double or decimal Parameter 3 Name Parameter 3 Type Return value Number1 / Number2 Note Ensure that the numbers of both parameters are from the the same type. For example, Parameter 1 and Parameter 2 must be both integers, doubles, or decimals. Example 10: DIVIDE ATTRIB:QuantityValue CONST:2.00 OUTPUT: If 'QuantityValue = 6.00', the output will be '3.00'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More examples: Calculate standart price per lot based on the ingredients and the operations in the recipe"
  },
  "advanced/calculated-attributes/operators/equal.html": {
    "href": "advanced/calculated-attributes/operators/equal.html",
    "title": "EQUAL | ERP.net Tech Docs",
    "keywords": "EQUAL Specification Value Name EQUAL Description Checks if two values are equal. If they are equal, the return value is True, else - the return value is False. Parameter 1 Name Value1 Parameter 1 Type numeric type - int, double or decimal; string; Parameter 2 Name Value2 Parameter 2 Type numeric type - int, double or decimal; string; Parameter 3 Name Parameter 3 Type Return value boolean (True or False) Note Ensure that the values which are compared up have the same type. For example, Parameter 1 and Parameter 2 must be both integers, or doubles, or decimals, or strings. Example 10: EQUAL ATTRIB:LineNo CONST:30 OUTPUT: If 'LineNo = 30', the output will be 'True'. If 'LineNo = 10', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More examples: Check if the quantity is a whole number Check whether the releasing of the document is first or not Get current availability of a product"
  },
  "advanced/calculated-attributes/operators/filter.html": {
    "href": "advanced/calculated-attributes/operators/filter.html",
    "title": "FILTER | ERP.net Tech Docs",
    "keywords": "FILTER Specification Value Name FILTER Description Filters the specified list by the condition. Parameter 1 Name list Parameter 1 Type list of objects Parameter 2 Name condition Parameter 2 Type boolean Parameter 3 Name Parameter 3 Type Return value Returns sub-list, which meets the condition. Example The following example returns a list with all of lines in the current document (sales order) whose quantity is '1.00': 10: FILTER CHILD:Lines EXP:30 30: EQUAL ATTRIB:QuantityValue CONST:1.00 Note The repository of the attribute is Crm.Sales.SalesOrders"
  },
  "advanced/calculated-attributes/operators/first.html": {
    "href": "advanced/calculated-attributes/operators/first.html",
    "title": "FIRST | ERP.net Tech Docs",
    "keywords": "FIRST Specification Value Name FIRST Description Returns the first element in the list. Parameter 1 Name list Parameter 1 Type list of objects Parameter 2 Name Parameter 2 Type Parameter 3 Name Parameter 3 Type Return value Returns the first element of a list. Note FIRST returns the first met element of the list, but the criteria about which element is actually first may not match your expectations. If the sorting of the elements matters, please use in combinations with the SORT and ORDERBY operators. Example The following example returns the first met line of the current document (sales order): 10: FIRST CHILD:Lines Note The repository of the attribute is Crm.Sales.SalesOrders If we want to expand the example, we can sort the line ascending by line number. This way, the atrribute will return the line with lowest line number: 10: FIRST EXP:20 20: SORT CHILD:Lines ATTR:LineNo CONST:ASC"
  },
  "advanced/calculated-attributes/operators/floor.html": {
    "href": "advanced/calculated-attributes/operators/floor.html",
    "title": "FLOOR | ERP.net Tech Docs",
    "keywords": "FLOOR Specification Value Name FLOOR Description Returns the largest integer less than or equal to the specified number. Parameter 1 Name Number1 Parameter 1 Type double or decimal Parameter 2 Name Parameter 2 Type Parameter 3 Name Parameter 3 Type Return value Returns the largest integer less than or equal to Number1. Example The following example gets the largest integer that is less than or equal to the quantity of a sales order line: 10: FLOOR ATTRIB:QuantityValue OUTPUT: If 'QuantityValue = 14.85', the output will be '14'. If 'QuantityValue = 14', the output will be '14'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/formatstring.html": {
    "href": "advanced/calculated-attributes/operators/formatstring.html",
    "title": "FORMATSTRING | ERP.net Tech Docs",
    "keywords": "FORMATSTRING Specification Value Description Returns the specified object, formatted by the specified rules. Parameter 1 Name Param1 Parameter 1 Type object (any type) Parameter 2 Name Format Parameter 2 Type constant The format argument must contain a valid .NET format string, either as a standard format string (\"C\" or \"D\") or as a pattern of custom characters for dates and numeric values (\"MMMM DD, yyyy (dddd)\"). For more information about the supported format specifiers, see Format Specifiers . Parameter 3 Name - Parameter 3 Type - Return value Param1 as a string formatted by the rule in Format. Note For more information about the supported format specifiers, see Format Specifiers . Example Here are some examples of the diffrent formats and format specifiers: 10: FORMATSTRING CONST:DocumentDate CONST:yyyy MM dddd OUTPUT: If 'DocumentDate = 2020-03-15', the output will be '2020 03 Sunday'. ( the language of the day of the week depends on the local regional settings ) 10: FORMATSTRING ATTRIB:QuantityValue CONST:n6 OUTPUT: If 'QuantityValue = 150.00', the output will be '150,000000'. ( the decimal symbol separator depends on the local regional settings ) 10: FORMATSTRING ATTRIB:LineAmountValue CONST:C OUTPUT: If 'LineAmountValue = 150.00', the output will be '150.00 $'. ( the decimal symbol separator and the currency symbol depends on the local regional settings ) Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/getobjvalue.html": {
    "href": "advanced/calculated-attributes/operators/getobjvalue.html",
    "title": "GETOBJVALUE | ERP.net Tech Docs",
    "keywords": "GETOBJVALUE Specification Value Description Gets the specified value from the specified object. This operator is used when the user wants the retrieve a value from object different than the current one. The current object is listed in the 'Repository Name' field in the current row. Parameter 1 Name obj Parameter 1 Type object Parameter 2 Name value Parameter 2 Type attribute value Parameter 3 Name - Parameter 3 Type - Return value Returns value from obj. Example The following example returns the value of the field 'Default Delivery Term Days' set in the definition of the customer set the current sales order: 10: GETOBJVALUE REF:Customer ATTRIB:DefaultDeliveryTermDays OUTPUT: If 'DefaultDeliveryTermDays = 5', the output will be '5'. Note The repository of the attribute is Crm.Sales.SalesOrders More examples: Check if a value of a field is changed in the adjustment document Get value and description of referent object"
  },
  "advanced/calculated-attributes/operators/getvalue.html": {
    "href": "advanced/calculated-attributes/operators/getvalue.html",
    "title": "GETVALUE | ERP.net Tech Docs",
    "keywords": "GETVALUE Specification Value Description Gets the value from the current object. Parameter 1 Name Value Parameter 1 Type attribute value Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value Value Example The following example returns the value of the notes of the current sales order line: 10: GETVALUE ATTRIB:Notes OUTPUT: If 'Notes = Apple', the output will be 'Apple'. Note The repository of the attribute is Crm.Sales.SalesOrderLiness"
  },
  "advanced/calculated-attributes/operators/gt.html": {
    "href": "advanced/calculated-attributes/operators/gt.html",
    "title": "GT | ERP.net Tech Docs",
    "keywords": "GT Specification Value Description Checks if an attribute value is greater than another attribute's value (or a constant). Parameter 1 Name attribute1 Parameter 1 Type numeric (int, double, decimal) or datetime type Parameter 2 Name attribute2 Parameter 2 Type numeric (int, double, decimal) or datetime type Parameter 3 Name - Parameter 3 Type - Return value If attribute1 > attribute2 the returned value is True, if else - the operator returns False. Note Make sure that the attributes which are compared have the same type. For example, Parameter 1 and Parameter 2 must be both integers, or doubles, or decimals, or datetime. Example 10: GT ATTRIB:LineNo CONST:30 OUTPUT: If 'LineNo = 40', the output will be 'True'. If 'LineNo = 30', the output will be 'False'. If 'LineNo = 20', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More examples: Compare unit price and standard unit price"
  },
  "advanced/calculated-attributes/operators/gte.html": {
    "href": "advanced/calculated-attributes/operators/gte.html",
    "title": "GTE | ERP.net Tech Docs",
    "keywords": "GTE Specification Value Description Checks if an attribute value is greater than or equal to another attribute's value (or a constant). Parameter 1 Name attribute1 Parameter 1 Type numeric (int, double, decimal) or datetime type Parameter 2 Name attribute2 Parameter 2 Type numeric (int, double, decimal) or datetime type Parameter 3 Name - Parameter 3 Type - Return value If attribute1 >= attribute2 the returned value is True, if else - the operator returns False. Note Make sure the attributes which are compared have the same type. For example, Parameter 1 and Parameter 2 must be both integers, or doubles, or decimals, or datetime. Example 10: GT ATTRIB:LineNo CONST:30 OUTPUT: If 'LineNo = 40', the output will be 'True'. If 'LineNo = 30', the output will be 'True'. If 'LineNo = 20', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/iif.html": {
    "href": "advanced/calculated-attributes/operators/iif.html",
    "title": "IIF | ERP.net Tech Docs",
    "keywords": "IIF Specification Value Description Depending on a specified condition, returns the second or the third argument. Parameter 1 Name Condition Parameter 1 Type Boolean Parameter 2 Name TrueValue Parameter 2 Type any type Parameter 3 Name FalseValue Parameter 3 Type any type Return value When Condition is True, returns TrueValue. When Condition is False, returns FalseValue Example 10: IIF EXP:20 CONST:'Quantity is 1.00' CONST: 'Quantity is not 1.00' 20: EQUAL ATTRIB:QuantityValue CONST:1.00 OUTPUT: If 'QuantityValue = 1.00', the output will be 'Quantity is 1.00'. If 'QuantityValue = 2.00', the output will be 'Quantity is not 1.00'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More examples: Compare unit price and standard unit price Check if a value of a field is changed in the adjustment document"
  },
  "advanced/calculated-attributes/operators/in.html": {
    "href": "advanced/calculated-attributes/operators/in.html",
    "title": "IN | ERP.net Tech Docs",
    "keywords": "IN Specification Value Description Determines whether a specified value matches any value in a list. The operator is used in combination with SELECT and FILTER as condition. It can be used to search through values of string and guid types. It cannot be used to search through numeric values or dates. Parameter 1 Name param Parameter 1 Type String or Guid Parameter 2 Name list of values Parameter 2 Type the values must be equal to the param type Parameter 3 Name - Parameter 3 Type - Return value True or False depending on if param equals a member of the list of values. Note Single quotes are only necessary when the values which we compare to are strings. Example The following example checks whether there are sales orders with notes 'Apple' and 'Pear' into the datatabase: 10: SELECT REPO:Crm.Sales.SalesOrders EXP:20 20: WHERE EXP:30 30: IN ATTRIB:Notes CONST:'Apple', 'Pear' OUTPUT: If there is atleast one sales order with 'Notes = Apple', the output will be 'True'. If there is atleast one sales order with 'Notes = Pear', the output will be 'True'. If there are NO sales orders with 'Notes = Apple OR Pear', the output will be 'False'."
  },
  "advanced/calculated-attributes/operators/incnum.html": {
    "href": "advanced/calculated-attributes/operators/incnum.html",
    "title": "INCNUM | ERP.net Tech Docs",
    "keywords": "INCNUM Specification Value Description The INCNUM operator increases the value of its parameter by 1. The operator can be used only for string values whose last character is a number. The INCNUM operator can be used for consecutive numbering of documents and nomenclatures. Parameter 1 Name Value Parameter 1 Type string Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value ++Value Note If you try to increment the string value whose last character is a number 'AA01', the incrementation will be successful and result will be 'AA02'; If you try to increment a value whоse type is decimal, int or date, the incrementation won't be successful and the calculated attribute won't be compilated; If the value is a string whose last character is not a number ('AA', for example), the incrementation won't be successful. Examples The following example shows how to increase the LotNumber of the lot by 1 with the INCNUM operator: 10: INCNUM ATTRIB:Number OUTPUT: If 'Number = 0001'', the output will be '0002'. If 'Number = AA01'', the output will be 'AA02'. Note The repository of the attribute is Logistics.Inventory.Lots"
  },
  "advanced/calculated-attributes/operators/index.html": {
    "href": "advanced/calculated-attributes/operators/index.html",
    "title": "Operators | ERP.net Tech Docs",
    "keywords": "Operators ADD ADDDAYS AND CAST CEILING CONCAT CONVERT COUNT DIVIDE EQUAL FILTER FIRST FLOOR FORMATSTRING GETOBJVALUE GETVALUE GT GTE IIF IN INCNUM LEFT LEN LIST LT LTE MULTIPLY NOT OR ORDERBY POS REGEX REPLACE RIGHT ROUND SELECT SORT SUBSTRING SUM TODAY TOLOWER TOP TOUPPER WHERE"
  },
  "advanced/calculated-attributes/operators/left.html": {
    "href": "advanced/calculated-attributes/operators/left.html",
    "title": "LEFT | ERP.net Tech Docs",
    "keywords": "LEFT Specification Value Description Gets the first n characters of a string (starting from left). Parameter 1 Name String Parameter 1 Type string Parameter 2 Name NumChars Parameter 2 Type int Parameter 3 Name - Parameter 3 Type - Return value Returns the first numchars characters of the string. Example The following example returns the first 3 characters of the notes set in the sales order: 10: LEFT ATTRIB:Notes CONST:3 OUTPUT: If 'Notes = Apple', the output will be 'App'. If 'Notes = I am', the output will be 'I a'. Note The repository of the attribute is Crm.Sales.SalesOrders"
  },
  "advanced/calculated-attributes/operators/len.html": {
    "href": "advanced/calculated-attributes/operators/len.html",
    "title": "LEN | ERP.net Tech Docs",
    "keywords": "LEN Specification Value Description Returns the length of the string. Parameter 1 Name String Parameter 1 Type string Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value Returns the length of a string. Note The spaces are included when calculating the length. Example The following example returns the length of the notes set in the sales order: 10: LEN ATTRIB:Notes OUTPUT: If 'Notes = Apple', the output will be '5'. If 'Notes = I am', the output will be '4'. Note The repository of the attribute is Crm.Sales.SalesOrders"
  },
  "advanced/calculated-attributes/operators/like.html": {
    "href": "advanced/calculated-attributes/operators/like.html",
    "title": "LIKE | ERP.net Tech Docs",
    "keywords": "LIKE Specification Value Description Searches for a specified pattern in a string. It is usually used in a combination with the wildcars '%' and '_': The '%' symbol is used to define 0 or more characters before and after the searched string. '_' is used to define specifically 1 character. Parameter 1 Name String1 Parameter 1 Type string Parameter 2 Name Mask Parameter 2 Type string Parameter 3 Name - Parameter 3 Type - Return value True in case String1 matches Mask. False in case String1 does not match Mask. Examples 'a%' → Finds any values that start with \"a\". '%a' → Finds any values that end with \"a\". '%a%' → Finds any values that have \"a\" in any position. '_a%' → Finds any values that have \"a\" in the second position. 'a_%_%' → Finds any values that start with \"a\" and are at least 3 characters in length. 'a%o' → Finds any values that start with \"a\" and ends with \"o\". The following example returns True if the the string contains 'Apple' and after 'Apple' there is exactly one character: 10 LIKE ATTRIB:Notes CONST:%Apple_ OUTPUT: If 'Notes = Apples', the output will be 'True'. If 'Notes = Green apples', the output will be 'True'. If 'Notes = apples', the output will be 'False'. If 'Notes = Apple', the output will be 'False'. If 'Notes = Green bananas', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrders"
  },
  "advanced/calculated-attributes/operators/list.html": {
    "href": "advanced/calculated-attributes/operators/list.html",
    "title": "LIST | ERP.net Tech Docs",
    "keywords": "LIST Specification Value Description Returns a list with string values of the specified attribute of the list of objects. The values in the list are separated. If there is no indicated separator, then the list is separated with \", \" (comma + space) by default. Parameter 1 Name list Parameter 1 Type list of objects Parameter 2 Name attribute Parameter 2 Type attribute of the object // An attribute of a referent object could be used as well. See the example below. Parameter 3 Name separator (optional) // If Parameter3 is not specified, then the default separator is \", \" (comma + space) Parameter 3 Type string Return Value (attributeValue1, attributeValue2, ...) Introduced In Version 2019.1 Example 10: LIST CHILD:Lines EXP:20 CONST:'; ' 20: GETOBJVALUE REF:Product ATTRIB:Name OUTPUT: 'ProductsName1; ProductName2 ...' Note The repository of the attribute is Crm.Sales.SalesOrders"
  },
  "advanced/calculated-attributes/operators/lt.html": {
    "href": "advanced/calculated-attributes/operators/lt.html",
    "title": "LT | ERP.net Tech Docs",
    "keywords": "LT Specification Value Description Checks if an attribute value is smaller than another attribute's value (or a constant). Parameter 1 Name attribute1 Parameter 1 Type numeric (int, double, decimal) or datetime type Parameter 2 Name attribute2 Parameter 2 Type numeric (int, double, decimal) or datetime type Parameter 3 Name - Parameter 3 Type - Return value If attribute1 < attribute2 the returned value is True, if else - the operator returns False. Note Make sure the attributes which are compared have the same type. For example, Parameter 1 and Parameter 2 must be both integers, or doubles, or decimals, or datetime. Example 10: LT ATTRIB:LineNo CONST:30 OUTPUT: If 'LineNo = 20', the output will be 'True'. If 'LineNo = 30', the output will be 'False'. If 'LineNo = 40', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/lte.html": {
    "href": "advanced/calculated-attributes/operators/lte.html",
    "title": "LTE | ERP.net Tech Docs",
    "keywords": "LTE Specification Value Description Checks if an attribute value is smaller than or equal to another attribute's value (or a constant). Parameter 1 Name attribute1 Parameter 1 Type numeric (int, double, decimal) or datetime type Parameter 2 Name attribute2 Parameter 2 Type numeric (int, double, decimal) or datetime type Parameter 3 Name - Parameter 3 Type - Return value If attribute1 <= attribute2 the returned value is True, if else - the operator returns False. Note Make sure the attributes which are compared have the same type. For example, Parameter 1 and Parameter 2 must be both integers, or doubles, or decimals, or datetime. See the example in Compare unit price and the standard unit price . Example 10: LTE ATTRIB:LineNo CONST:30 OUTPUT: If 'LineNo = 20', the output will be 'True'. If 'LineNo = 30', the output will be 'True'. If 'LineNo = 40', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/multiply.html": {
    "href": "advanced/calculated-attributes/operators/multiply.html",
    "title": "MULTIPLY | ERP.net Tech Docs",
    "keywords": "MULTIPLY Specification Value Description Multiplies the specified numbers. Parameter 1 Name Number1 Parameter 1 Type numeric type - int, double or decimal Parameter 2 Name Number2 Parameter 2 Type numeric type - int, double or decimal Parameter 3 Name - Parameter 3 Type - Return value Number1 * Number2 Note Make sure the numbers of both parameters are from the the same type. For example, Parameter 1 and Parameter 2 must be both integers, doubles, or decimals. Example 10: MULTIPLY ATTRIB:QuantityValue CONST:2.00 OUTPUT: If 'QuantityValue = 3.00', the output will be '6.00'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More examples: Total quantity and scrap quantity in recipe ingredients ."
  },
  "advanced/calculated-attributes/operators/not.html": {
    "href": "advanced/calculated-attributes/operators/not.html",
    "title": "NOT | ERP.net Tech Docs",
    "keywords": "NOT Specification Value Description Returns logical negation on an expression. Parameter 1 Name Condition Parameter 1 Type boolean Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value False - if Condition is True; True - if Condition is False Example 10: NOT EXP:20 20: EQUAL ATTRIB:LineNo CONST:10 OUTPUT: If 'LineNo = 10', the output will be 'False'. If 'LineNo = 20', the output will be 'True'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/or.html": {
    "href": "advanced/calculated-attributes/operators/or.html",
    "title": "OR | ERP.net Tech Docs",
    "keywords": "OR Specification Value Description Checks if any of the conditions are True. If so - the operator returns True. If all specified conditions are not True, the operator returns False. Parameter 1 Name Condition1 Parameter 1 Type boolean Parameter 2 Name Condition2 Parameter 2 Type boolean Parameter 3 Name - Parameter 3 Type - Return value Condition1 OR Condition2 Example 10: OR EXP:20 EXP:30 20: EQUAL ATTRIB:LineNo CONST:10 30: EQUAL ATTRIB:LineNo CONST:20 OUTPUT: If 'LineNo = 10', the output will be 'True'. If 'LineNo = 20', the output will be 'True'. If 'LineNo = 30', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/orderby.html": {
    "href": "advanced/calculated-attributes/operators/orderby.html",
    "title": "ORDERBY | ERP.net Tech Docs",
    "keywords": "ORDERBY Specification Value Description Specifies a column or expression on which the query result set is sorted. Used as a clause of SELECT . Parameter 1 Name attribute Parameter 1 Type any type Parameter 2 Name order (optional) //if not set, the default is ASC Parameter 2 Type const - ASC or DESC Parameter 3 Name inner clauses (optional) Parameter 3 Type expression Return value Ordered result set of a query by the specified column or expression. Introduced in version (In implementation) Example 10: SELECT REPO:General.Products.Products EXP:20 20: TOP CONST:5 EXP:30 30: ORDERBY ATTR:PartNumber CONST:ASC EXP:40 40: WHERE ..."
  },
  "advanced/calculated-attributes/operators/pos.html": {
    "href": "advanced/calculated-attributes/operators/pos.html",
    "title": "POS | ERP.net Tech Docs",
    "keywords": "POS Specification Value Description Searches term in string, returns first position or -1 if not found. Parameter 1 Name term Parameter 1 Type string Parameter 2 Name string Parameter 2 Type string Parameter 3 Name - Parameter 3 Type - Return value Returns the position of term in string. If there are more than one occurrences of term in string, it returns the first position. If term is not part of string, it returns -1."
  },
  "advanced/calculated-attributes/operators/regex.html": {
    "href": "advanced/calculated-attributes/operators/regex.html",
    "title": "REGEX | ERP.net Tech Docs",
    "keywords": "REGEX Specification Value Description Returns whether the string matches the regex mask. Parameter 1 Name String1 Parameter 1 Type string Parameter 2 Name Mask Parameter 2 Type regex expression Parameter 3 Name - Parameter 3 Type - Return value True - if String1 matches Mask; False - if String1 does not match Mask ."
  },
  "advanced/calculated-attributes/operators/replace.html": {
    "href": "advanced/calculated-attributes/operators/replace.html",
    "title": "REPLACE | ERP.net Tech Docs",
    "keywords": "REPLACE Specification Value Description Replaces old with new value in string. Parameter 1 Name String1 Parameter 1 Type string Parameter 2 Name OldValue Parameter 2 Type string Parameter 3 Name NewValue Parameter 3 Type string Return value A string that is equivalent to String1 except that all instances of OldValue are replaced with NewValue. If OldValue is not found in String1, the operator returns String1."
  },
  "advanced/calculated-attributes/operators/right.html": {
    "href": "advanced/calculated-attributes/operators/right.html",
    "title": "RIGHT | ERP.net Tech Docs",
    "keywords": "RIGHT Specification Value Description Gets the last n characters of a string. Parameter 1 Name String Parameter 1 Type string Parameter 2 Name NumChars Parameter 2 Type int Parameter 3 Name - Parameter 3 Type - Return value Returns the last NumChars characters of String."
  },
  "advanced/calculated-attributes/operators/round.html": {
    "href": "advanced/calculated-attributes/operators/round.html",
    "title": "ROUND | ERP.net Tech Docs",
    "keywords": "ROUND Specification Value Description Rounds mathematically with the specified precision. Parameter 1 Name Number Parameter 1 Type double or decimal Parameter 2 Name DecimalPlaces (optional) Parameter 2 Type int Parameter 3 Name - Parameter 3 Type - Return value Number, rounded up to the digit, specified in DecimalPlaces Note Parameter 2 is optional. If Parameter 2 is not set, it is considered 0 (zero)."
  },
  "advanced/calculated-attributes/operators/select.html": {
    "href": "advanced/calculated-attributes/operators/select.html",
    "title": "SELECT | ERP.net Tech Docs",
    "keywords": "SELECT Specification Value Description Gets the objects matching the clauses. Parameter 1 Name Repository Parameter 1 Type repository Parameter 2 Name Clauses (optional, but highly advisable) // For more information, see the section below) Parameter 2 Type operators ( WHERE , TOP ) Parameter 3 Name - Parameter 3 Type - Return value Returns a list of objects from Repository matching Clauses. Note SELECT returns limited number of records - 20 000. This limit is only for the returned records count, so as setting much filters as possible are highly recommended (filters in the WHERE clause). Example The WHERE clause of the SELECT statement supports the following operators: AND TOP EQUAL GT GTE LT LTE The operators which are not supported by the SELECT operator but may be used by the FILTER operator are: NOT OR LIKE FILTER AND WHERE filtering of a SELECT Having this in mind, it is really important when extracting lists from the database. When using SELECT , we send a request to the database and it is preferred to set as much WHERE filters as possible. But if there is a filter not supported by the ERP.net server, then the list that is returned by the select may be filtered additionally with the FILTER operator. The disadvantages are that the SELECT statement makes a direct request to the database, which may reflect on the productivity and may slow down the calculation of the attribute. When using SELECT , the user has to apply as much WHERE filters as possible, because this would limit the amount of data which would be extracted from the database into the client. And then, if the select statement does not provide enough filters, the result from the select may be filtered by the FILTER operator which operates on the already loaded data in the client. Here are some examples to picture the information so far: If there is a need of a list of documents which DocumentTypeId is equal to 'bbd8e7ae-c0e0-4c1b-8730-7d68fa52971e' or '89ca5ca4-ad57-44c7-9b33-2ff44e054bff'. The documents are work orders. So the following calculated attribute would be incorrect: 10: SELECT REPO:Production.ShopFloor.WorkOrders EXP:20 20: WHERE EXP:30 30: OR EXP:40 EXP:50 40: EQUAL CONST:bbd8e7ae-c0e0-4c1b-8730-7d68fa52971e 45: ATTRIB:DocumentTypeId CONST:System.Guid 50: EQUAL EXP:45 CONST:89ca5ca4-ad57-44c7-9b33-2ff44e054bff This calculated attribute is incorrect and would return errors when used. So, we can set calculated attribute which selects the work orders and then to filter the list, which the SELECT operator returned and apply the FILTER operator for more precision. So the correct calculated attribute is as follows: 10: FILTER EXP:20 EXP:30 20: SELECT REPO:Production.ShopFloor.WorkOrders 30: OR EXP:40 EXP:50 40: EQUAL EXP:45 CONST:bbd8e7ae-c0e0-4c1b-8730-7d68fa52971e 45: CAST ATTRIB:DocumentTypeId CONST:System.Guid 50: EQUAL ATTRIB:DocumentTypeId CONST:89ca5ca4-ad57-44c7-9b33-2ff44e054bff"
  },
  "advanced/calculated-attributes/operators/sort.html": {
    "href": "advanced/calculated-attributes/operators/sort.html",
    "title": "SORT | ERP.net Tech Docs",
    "keywords": "SORT Specification Value Description Sorts the input list according to the specified attribute and order. Parameter 1 Name list Parameter 1 Type list Parameter 2 Name attribute Parameter 2 Type any type Parameter 3 Name order (optional) Parameter 3 Type string - ASC or DESC Return жalue Returns the input list from parameter1, sorted by the specified attribute and in the specified order. If not specified, the default order is ascending (ASC) Example Take the last line of a sales order (ordered by LineNo), which has quantity >= 0: SalesOrder=> 10: FIRST EXP:20 20: SORT EXP:30 ATTR:LineNo CONST:DESC 30: FILTER CHILD:Lines EXP:40 40: GTE ATTR:QuantityValue CONST:0"
  },
  "advanced/calculated-attributes/operators/substring.html": {
    "href": "advanced/calculated-attributes/operators/substring.html",
    "title": "SUBSTRING | ERP.net Tech Docs",
    "keywords": "SUBSTRING Specification Value Description Returns a sub-string with the specified start and length. Parameter 1 Name string Parameter 1 Type string Parameter 2 Name start Parameter 2 Type int Parameter 3 Name len Parameter 3 Type int Return value Part of string, starting from position start and with length of len."
  },
  "advanced/calculated-attributes/operators/sum.html": {
    "href": "advanced/calculated-attributes/operators/sum.html",
    "title": "SUM | ERP.net Tech Docs",
    "keywords": "SUM Specification Value Description Returns the sum of Value for all elements in the specified list. Parameter 1 Name List Parameter 1 Type list of objects Parameter 2 Name Value Parameter 2 Type numeric type - int, double or decimal Parameter 3 Name - Parameter 3 Type - Return value Returns the sum of the Values of the elements in the List. More examples Sales amounts of the customer for the last 30 days"
  },
  "advanced/calculated-attributes/operators/today.html": {
    "href": "advanced/calculated-attributes/operators/today.html",
    "title": "TODAY | ERP.net Tech Docs",
    "keywords": "TODAY Specification Value Description Returns today's date, according to the server's regional settings. Parameter 1 Name - Parameter 1 Type - Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value Today's date"
  },
  "advanced/calculated-attributes/operators/tolower.html": {
    "href": "advanced/calculated-attributes/operators/tolower.html",
    "title": "TOLOWER | ERP.net Tech Docs",
    "keywords": "TOLOWER Specification Value Description Returns the string converted to lowercase. Parameter 1 Name string Parameter 1 Type string Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return Value string (in lowercase)"
  },
  "advanced/calculated-attributes/operators/top.html": {
    "href": "advanced/calculated-attributes/operators/top.html",
    "title": "TOP | ERP.net Tech Docs",
    "keywords": "TOP Specification Value Description Clause, returning only the first n elements Parameter 1 Name Number Parameter 1 Type int Parameter 2 Name Clauses Parameter 2 Type operators WHERE Parameter 3 Name - Parameter 3 Type - Return value The first Number elements. Note This operator is used with WHERE ."
  },
  "advanced/calculated-attributes/operators/toupper.html": {
    "href": "advanced/calculated-attributes/operators/toupper.html",
    "title": "TOUPPER | ERP.net Tech Docs",
    "keywords": "TOUPPER Specification Value Description Returns the string converted to uppercase. Parameter 1 Name string Parameter 1 Type string Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value string (in uppercase)"
  },
  "advanced/calculated-attributes/operators/where.html": {
    "href": "advanced/calculated-attributes/operators/where.html",
    "title": "WHERE | ERP.net Tech Docs",
    "keywords": "WHERE Specification Value Description Clause which filters by the specified conditions. The second and the third parameters are optional. Parameter 1 Name Condition1 Parameter 1 Type boolean Parameter 2 Name boolean Parameter 2 Type Condition2 (optional) Parameter 3 Name boolean Parameter 3 Type Condition3 (optional) Return value Clause, filtered by Condition1, Condition2 AND Condition3 Note This operator is used with SELECT ."
  },
  "advanced/calculated-attributes/parameter-types/const.html": {
    "href": "advanced/calculated-attributes/parameter-types/const.html",
    "title": "CONST | ERP.net Tech Docs",
    "keywords": "CONST When used, indicates that the Value for this parameter type would be a constant for every calculation of the calculated attribute. The formats of the different types of values which are entered are as follows: Value Description Example NULL null or empty value NULL Boolean true or false value True Integer a whole number (not a fractional number) that can be positive, negative, or zero 93 Decimal number, containing decimal symbol - '.' 93.012 Date date values used in the 'yyyy-MM-dd' format 2020-12-25 GUID Global Unique Identifier - used for objects identification 6B29FC40-CA47-1067-B31D-00DD010662DA String explicitly denoted string, entered in single quotation marks 'Example text.' Type used with CAST . Used for type conversions and the constant is the type to which we want to convert. System.Int32 Everything else is treated as string!"
  },
  "advanced/calculated-attributes/parameter-types/index.html": {
    "href": "advanced/calculated-attributes/parameter-types/index.html",
    "title": "Parameter types | ERP.net Tech Docs",
    "keywords": "Parameter types The type of the parameter specifies how to obtain the parameter value. Several types are available: CONST - when used, it indicates that the value for this parameter type would be a constant for every calculation of the calculated attribute. For more information, see CONST . ATTRIB - the value of system or user-defined attribute; REF - reference to another object; CHILD - detailed objects, related to the current master object; EXP - the value of the expression with the specified number (the user specifies the number in the Value field); INPUT - the input parameter for the specified expression number (the user specifies the number in the Value field); REPO - a repository; SYS - the value of a particular system variable such as Login, Today, EnterpriseCompanyId, etc. For more information, see SYS . The parameter types are used in every calculated attributes. Here are some examples ."
  },
  "advanced/calculated-attributes/parameter-types/sys.html": {
    "href": "advanced/calculated-attributes/parameter-types/sys.html",
    "title": "SYS | ERP.net Tech Docs",
    "keywords": "SYS SYS parameter type is used for system variables. They can be applied when we need to acquire information for the current user, date, time, enterprise company and others. The list of those variables is as follows: Value Description Example (returned value) Login The login of the user that is currently logged in the program. admin UserId The ID of the user that is currently logged in the program. 9da64839-a8d0-491d-aebb-4d18fa42b014 RoleName The name of role that is currently set for the user. Administration RoleId The role that is currently set for the user. c764ff2b-38ca-4906-893a-2a21a1691f43 Today Current date. 23.6.2017 0:00:00 Now Current date-time from the server time zone. 23.6.2017 13:25:33 UtcNow Current date-time in Coordinated Universal Time (UTC) 23.6.2017 10:25:33 EnterpriseCompanyId The ID of the enterprise company that is currently set for the user. b0e80577-fbbe-4c9b-811e-20b6c6dd465f EnterpriseCompanyLocationId The ID of the enterprise company location that is currently set for the user. f2947790-e21f-4def-b533-fdc00a343ce6 Example (usage): 10: GETVALUE SYS:Login The line returns the login of the user that is currently logged in the program."
  },
  "advanced/calculated-attributes/QA/How-to-check-if-a-custom-property-has-value.html": {
    "href": "advanced/calculated-attributes/QA/How-to-check-if-a-custom-property-has-value.html",
    "title": "How to check if a custom property has values? | ERP.net Tech Docs",
    "keywords": "How to check if a custom property has values? When there is a need to check if a custom property of an object has value, usually we can just CAST the custom property to a string and then check if it is equal to null. However, the syntax of the calculated attribute should be tailored to the specifics of the property type of the particular custom property. Here are examples for the different custom property types which are universal to all repositories. The custom property code which is verified is CustomProperty1. Note that when a custom property is cast to string, only its value will be processed, and not its description. Property type is 'Text' If the property type of the particular custom property is 'Text', use the following expressions: 10: IIF EXP:20 CONST:'null' CONST:'not null' 20: EQUAL EXP:30 CONST:NULL 30: CAST ATTRIB:@CustomProperty1 CONST:System.String Explanation: 10: if EXP:20 is true, return the text 'null, else - return 'not null' 20: if EXP:30 is empty, return true, else - return false 30: cast CustomProperty1 to string Property type is 'Number' or 'Date' If the property type of the particular custom property is 'Number' or 'Date', use the following expressions: 10: IIF EXP:20 CONST:'null' CONST:'not null' 20: OR EXP:30 EXP:40 30: EQUAL EXP:50 CONST:NULL 40: EQUAL EXP:50 CONST:'' 50: CAST ATTRIB:@CustomProperty1 CONST:System.String Explanation: 10: if EXP:20 is true, return the text 'null, else - return 'not null' 20: if EXP:30 OR EXP:40 is true, return true, else - return false 30: if EXP:50 is empty, return true, else - return false 40: if EXP:50 is an empty string, return true, else - return false 50: cast CustomProperty1 to string Property type is 'Picture' If the property type of the particular custom property is 'Picture', use the following expressions: 10: IIF EXP:20 CONST:'null' CONST:'not null' 20: EQUAL EXP:30 CONST:0 30: SUM EXP:40 CONST:1 40: FILTER EXP:70 EXP:50 50: NOT EXP:60 60: EQUAL ATTRIB:Picture CONST:NULL 70: SELECT REPO:General.PropertyValues EXP:80 80: WHERE EXP: 90 EXP:100 90: EQUAL ATTRIB:PropertyId CONST:86ba82c9-8843-e611-82a1-b010410e63e2 100: EQUAL ATTRIB:EntityItemId CONST:47e225e9-f4b6-e611-af28-00155d001f28 Explanation: 10: if EXP:20 is true, return the text 'null, else - return 'not null' 20: if EXP:30 is equal to 0, return true, else - return false 30: count the records of the list returned by EXP:40 40: filter the list returned by EXP:70 by the condition of EXP:50 50: if EXP:60 is true, return false, else - return true 60: if ATTRIB:Picture is equal to NULL, return true, else - return false 70: select the records of table General.PropertyValues filtered by the clauses of EXP:80 80: if EXP:90 AND EXP:100 are true, return true, else - return false 90: if ATTRIB:PropertyId is equal to 86ba82c9-8843-e611-82a1-b010410e63e2, return true, else - return false 100: if ATTRIB: ATTRIB:EntityItemId is equal to 47e225e9-f4b6-e611-af28-00155d001f28, return true, else - return false Note EntityItemId is the ID of the actual entity (particular document, line, product) for which the value is specified."
  },
  "advanced/calculated-attributes/QA/How-to-check-if-a-list-has-values.html": {
    "href": "advanced/calculated-attributes/QA/How-to-check-if-a-list-has-values.html",
    "title": "How to check if a list has values? | ERP.net Tech Docs",
    "keywords": "How to check if a list has values? When working with lists, often there is a need to check if this list actually contains any values (records). For example, there is a calculated attribute which calculates the quantity in the sales order lines in specified measurement unit. There is always the possibility that the user enter a product which has no dimensions for the required measurement unit. In such cases, an instrument to check the lists records count is needed. The described case is solved by the following expression: SUM(List, 1) This expression returns integer value containing the number of records in the entered list. Here is an example expression and its description. This example is defined in the sales order header and checks if the lines contain one specific product. So the repository of the calculated attribute is Crm.Sales.SalesOrders and its expressions are: 10: SUM EXP:20 CONST:1 20: FILTER CHILD:Lines EXP:30 30: EQUAL ATTRIB:ProductId CONST:d3d83bf0-d1fc-e611-9c53-00155d001f52 Explanation: 10: check the records count in list in expression 20 20: filter the list of lines (detailed objects of the sales order object) by the filter in expression 30 30: check if the ProductId in the line is equal to Guid d3d83bf0-d1fc-e611-9c53-00155d001f52 This calculated attribute returns zero or greater value, depending on the count of the records in the sales order line with product with id of d3d83bf0-d1fc-e611-9c53-00155d001f52."
  },
  "advanced/calculated-attributes/QA/How-to-check-whether-a-field-that-points-to-a-reference-object-has-a-value.html": {
    "href": "advanced/calculated-attributes/QA/How-to-check-whether-a-field-that-points-to-a-reference-object-has-a-value.html",
    "title": "How to check whether a field that points to a reference object has a value? | ERP.net Tech Docs",
    "keywords": "How to check whether a field that points to a reference object has a value? Often when we are creating a calculated attribute and we want to get a value from a referent object, first we need to check if the current record has a reference to this object at all - if a particular ID field has a value or not. The recommended way to perform this validation is to check whether there is a referent object: 20 EQUAL REF:AdjustedDocument CONST:NULL and NOT whether the ID fields itself is empty: 20 EQUAL ATTRIB:AdjustedDocumentId CONST:NULL The first approach is recommended because: a. the second approach may lead to incorrect results - there are cases with wrong results when this approach is used in a SELECT clause or in multiple nested calculated attributes. b. the first approach does not require type conversions - we are directly checking of there is a reference object and we don't have use CAST or CONVERT operators to match the types before the comparison."
  },
  "advanced/calculated-attributes/QA/How-to-create-an-optimally-fast-calculated-attribute.html": {
    "href": "advanced/calculated-attributes/QA/How-to-create-an-optimally-fast-calculated-attribute.html",
    "title": "How to create an optimally fast calculated attribute? | ERP.net Tech Docs",
    "keywords": "How to create an optimally fast calculated attribute? When creating a calculated attribute there are some things that are good too keep in mind in order to create an optimally fast syntax. Here we are going to describe some advices that should be followed during the design of the attribute. Generally, those advices can be summarized to: Use REF instead of SELECT If you have to use a SELECT – Use WHERE clauses instead of FILTER clauses Filter the FILTER - Filter the list returned to the FILTER as much as you can But let's get into the details. Using a REF means that we are using the collection of elements that have already been loaded in the memory. The REF connection leads only to the records that refer to by the current entity. Using a SELECT means that for each calculation of attribute the system will create a request to the server and will look through the whole table that we have selected. A single table could contain millions of records (or even more). More records inevitably means slower calculation. Like any other design when creating a calculated attribute there usually is more than one way that we can use to calculate the value especially when the calculation is a bit more complicated. Sometimes using SELECT looks like the simplest option (the fist that comes in mind) to reach the value we need, but first, we should always try to think if there is a reference connection that we can use instead in order to achieve a faster calculation. Example: Let's imagine that we need to show a field with Total Line Amount value in the sales order line. Therefore we will need to calculate the sum of the line amount of all sales order lines of the particular sales order. Such attribute can be created at least two ways (the repository is Crm.Sales.SalesOrderLines): Using a SELECT Using a SELECT (using all records in the Crm.Sales.SalesOrderLines table) 10 SUM EXP:20 ATTRIB:LineAmountValue 20 SELECT REPO:Crm.Sales.SalesOrderLines EXP:30 30 WHERE EXP:40 40 EQUAL ATTRIB:SalesOrderId EXP:50 50 GETOBJVALUE INPUT:10 ATTRIB:SalesOrderId Using a REF Using a REF (using only the lines of the current SalesOrder) 10 SUM EXP:20 ATTRIB:LineAmountValue 20 GETOBJVALUE REF:SalesOrder CHILD:Lines Of course, there are some scenarios in which we want to reach the data of a table to which we simply can use a reference connection. But when using a SELECT the are some tricks that we can use to fast the calculation. When we SELECT a table we can filter its records with WHERE or FILTER clauses. The most important thing that we must know about them is that when using: WHERE clauses – the conditions are applied together with the SELECT to the whole list and directly on the server. Much faster performance in comparison with FILTER , especially for a list with lots of records. FILTER clauses - filters are applied locally (on the client side) to the list that has been returned from the SELECT . Knowing this there are two basic conclusions that we can come to. First, if we should choose WHERE clauses instead FILTER clauses, if possible. Most of the other operators are supported in both cases, but we must say that WHERE clauses have certain limitation. For example, they cannot be used along with NOT , OR and LIKE operators. If we have no choice but to use FILTER we proceed to the next paragraph (advice). And second, when we use FILTER clauses we should always try to narrow down the list that we are returning. How to do so? Just apply as much WHERE clauses as possible to the SELECT . This way we are filtering the list before it is returned to the FILTER and therefore it will contain fewer records, which will lead to a faster calculation. As a conclusion, we don’t claim that using a SELECT is a bad thing it is a very powerful tool that just has to be used wisely."
  },
  "advanced/calculated-attributes/QA/How-to-determine-the-party-type-of-a-party.html": {
    "href": "advanced/calculated-attributes/QA/How-to-determine-the-party-type-of-a-party.html",
    "title": "How to determine the party type of a party? | ERP.net Tech Docs",
    "keywords": "How to determine the party type of a party? If we need to compare the PartyType to check if it is a company, person or other the following calculation would do the job: CAST ATTRIB:PartyType CONST:System.Int32 Casting the PartyType to integer would return the following values: 0 - Company 1 - Company Location 2 - Person 3 - Store 4 - Company Division"
  },
  "advanced/calculated-attributes/QA/How-to-get-attribute-value-from-list.html": {
    "href": "advanced/calculated-attributes/QA/How-to-get-attribute-value-from-list.html",
    "title": "How to get attribute value from list? | ERP.net Tech Docs",
    "keywords": "How to get attribute value from list? An often mistake is to try to get a value of an attribute from a list. For example, if we want to get the user who changed the document state: 10: GETOBJVALUE CHILD:StateChanges ATTRIB:UpdateUser This is incorrect expression. The right expression would be to filter the child list and then get the first element of the list. This is an example filtering: 10 GETOBJVALUE EXP:20 ATTRIB:UpdateUser 20 FIRST EXP:30 30 FILTER CHILD:StateChanges EXP:40 40 EQUAL ATTRIB:SystemInitiated CONST:False Explanation: 10: get the value of the UserUpdate field from object in expression 20 20: get the first record in the list in expression 30 30: filter the child list StateChanges by the filter in expression 40 40: check if the attribute SystemInitiated is equal to \"False\""
  },
  "advanced/calculated-attributes/QA/How-to-get-specific-field-of-a-parent-document.html": {
    "href": "advanced/calculated-attributes/QA/How-to-get-specific-field-of-a-parent-document.html",
    "title": "How to get specific field of a parent document? | ERP.net Tech Docs",
    "keywords": "How to get specific field of a parent document? When in a calculation attribute there is a need of a value of attribute of the parent document there are two options to get them: The attribute is part of the parent document table The attribute is part of the specific entity of the parent document If the attribute is part of the parent document table, than we may get it directly by GETOBJVALUE operator in the following expression: 10: GETOBJVALUE REF:Parent ATTRIB:DocumentNo This expression would be valid for every document which has parent document. But in the second case, when the attribute is part of the specific entity of the parent document (meaning SalesOrder, StoreOrder, StoreTransaction, Payment and etc.) than the user has to tell the calculate attribute what is the parent document. This is done by casting the parent document to the entity which is required (in the example a cast to offer is used): 10: GETOBJVALUE EXP:20 ATTRIB:DocumentNo 20: CAST REF:Parent CONST:Aloe.EnterpriseOne.Model.Crm.Presales.Offer It is supposed to show such calculated attribute in document form where the parent document is exactly offer."
  },
  "advanced/calculated-attributes/QA/How-to-show-contact-of-a-person-in-persons-navigator.html": {
    "href": "advanced/calculated-attributes/QA/How-to-show-contact-of-a-person-in-persons-navigator.html",
    "title": "How to show contact of a person in Persons navigator? | ERP.net Tech Docs",
    "keywords": "How to show contact of a person in Persons navigator? The specific of this calculated attribute is that the contact mechanism type is enum type. This is why it is accessed specifically. Its values and codes are as follows: Member name Value Description Address 0 Address value. Stored as 'A'. Mail 1 Mail value. Stored as 'E'. Fax 2 Fax value. Stored as 'F'. MobilePhone 3 MobilePhone value. Stored as 'M'. Other 4 Other value. Stored as 'O'. Telephone 5 Telephone value. Stored as 'T'. WebSite 6 WebSite value. Stored as 'W'. So, let's say we need to get a column with the emails of the persons (if the person has more than one emails - a random one; if a specific email is needed - more filters would be needed). The calculated attribute would have the following expressions: 10 GETOBJVALUE EXP:20 EXP:15 15 GETOBJVALUE REF:ContactMechanism ATTRIB:Name 20 FIRST EXP:21 21 FILTER EXP:30 EXP:22 22 EQUAL EXP:23 EXP:25 23 GETOBJVALUE REF:ContactMechanism ATTRIB:ContactMechanismType 25 CAST CONST:1 CONST:Aloe.EnterpriseOne.Model.General.Contacts.ContactMechanismsRepository+ContactMechanismType 30 SELECT REPO:General.Contacts.PartyContactMechanisms EXP:40 40 WHERE EXP:50 50 EQUAL ATTRIB:PartyId EXP:60 60 GETOBJVALUE INPUT:10 ATTRIB:PartyId Explanation: 10: from the object from EXP:20 get the attribute from EXP:15 15: get the value of the attribute name from the referent object ContactMechanism 20: get the first element from the list in EXP:21 21: filter the list in EXP:30 by the conditions in EXP:22 22: check if EXP:23 is equal to EXP:25 23: get the value of the attribute ContactMechanismType from the referent object ContactMechanism 25: cast the constant of \"1\" (this is integer) to type 'Aloe.EnterpriseOne.Model.General.Contacts.ContactMechanismsRepository+ContactMechanismType' 30: select from repository General.Contacts.PartyContactMechanisms and filter it by EXP:40 40: the filter is in EXP:50 50: check if the value of attribute PartyId is equal to EXP:60 60: get the value of attribute PartyId of the input object of expression 10"
  },
  "advanced/calculated-attributes/QA/How-to-use-a-customer-as-a-company.html": {
    "href": "advanced/calculated-attributes/QA/How-to-use-a-customer-as-a-company.html",
    "title": "How to use a customer as a company? | ERP.net Tech Docs",
    "keywords": "How to use a customer as a company? When we work with a customer, we can only get its party attributes as they may be company, company location or a person. So if we know that the customer is a company and we need to get his company attributes, we can cast its reference party to Aloe.EnterpriseOne.Model.General.Contacts.Company. For example, to get the responsible person of the company of the customer, the following attribute would do the job: (repository of the attribute: Crm.Customers) Expressions: 10: GETOBJVALUE EXP:20 ResponsiblePersonName 20: CAST REF:Party CONST:Aloe.EnterpriseOne.Model.General.Contacts.Company Note If the customer is not a company, it would return an error."
  },
  "advanced/calculated-attributes/QA/index.html": {
    "href": "advanced/calculated-attributes/QA/index.html",
    "title": "Q & A | ERP.net Tech Docs",
    "keywords": "Q & A How to check if a custom property has values? How to check if a list has values? How to check whether a field that points to a reference object has a value? How to create an optimally fast calculated attribute? How to determine the party type of a party? How to get an attribute value from list? How to get a specific field of a parent document? How to show contact of a person in Persons navigator? How to use the customer as a company?"
  },
  "advanced/concepts/aggregates.html": {
    "href": "advanced/concepts/aggregates.html",
    "title": "Aggregates | ERP.net Tech Docs",
    "keywords": "Aggregates What are аggregates? 'Aggregate is a pattern in domain-driven design. A DDD aggregate is a cluster of domain objects that can be treated as a single unit. An example may be an order and its line-items, these will be separate objects, but it's useful to treat the order (together with its line items) as a single aggregate.\" https://martinfowler.com/bliki/DDD_Aggregate.html Examples For example, in ERP.net, this is one single aggregate: a SalesOrder the sales order lines of this sales order the distributed amounts for each of these sales order lines the document amounts of this sales order the payment plan of this sales order Parent and root objects Each object in an aggregate can have a parent object.The parent is the logical \"owner\" of the child object(s). For example: The parent of sales order line is sales order . The parent of distributed amount is the sales order line . The ultimate object, which has no parent in the aggregate is the aggregate root. In this example, this is the sales order . Aggregate events The Commit and ClientCommit events are now available in two different variations: object commit / client-commit aggregate commit / alient-commit What is the difference? When an object commit event occurs, it means that the object itself was changed. The aggregate event occurs for the object when there is a change in ANY of its constituent objects, but only if the objects is an aggregate root. Lets take a look at the following structure which in ERP.net is one single aggregate: a SalesOrder (which is the aggregate's root) the sales order lines of this sales order the distributed amounts for each of these sales order lines the document amounts of this sales order the payment plan of this sales order In the example above, the Commit event would occur for the sales order if and only if the sales order object itself has changed. While the aggregate commit will occur for the sales order if any of the objects in the aggregate has changed. For example, changing just a single sales order line (without changing the sales order itself) would still trigger the sales order aggregate event. Note Commit and client-commit still have the same meaning. E.g., commit is the low-level event, which is triggered for everything committed to the database (be it from client request or as a result of some server processing). While client-commit is triggered only based on client requests and is considered the more light-weight approach. Note Initially, only the agregate client commit event would be available for user-defined business rules user business rules . The aggregate commit will be used only internally, for system-defined business rules System Business Rules The reason is to have a more light tread approach. If there is serious need, we can consider adding the aggregate commit event in the future for user business rules . See also: Systems.Core.ExtensibleDataObjects Entity"
  },
  "advanced/concepts/default-language.html": {
    "href": "advanced/concepts/default-language.html",
    "title": "| ERP.net Tech Docs",
    "keywords": "##Default language"
  },
  "advanced/concepts/index.html": {
    "href": "advanced/concepts/index.html",
    "title": "| ERP.net Tech Docs",
    "keywords": ""
  },
  "advanced/concepts/master-detail-attributes.html": {
    "href": "advanced/concepts/master-detail-attributes.html",
    "title": "Master / Detail attributes | ERP.net Tech Docs",
    "keywords": "Master / Detail attributes When a document has the same field in its header and lines then these two fields interact in a specific manner. An example of such fields is the Store field in the sales order header and line store in its sales order lines. The common principle is that if the field in the document header has value, we have to ensure that the corresponding field all document lines contains the same value. On the other hand, if the different lines contain different values - the document's header field must be empty. This principle is very important to avoid misleading the users. Otherwise, if the Store field in the document header could contain a value even if the document lines have different store values - the user may look only in the header and be misled that this store applies to all of its lines as well, which may not be true in all cases. Master / Detail attributes concepts and rules In order to make sure that the main principle described above is followed, is created a set of requirements and rules that are applied for each set of Master/Detail fields. The example for Store fields in document header/lines is used in the whole description for easy understanding. Concepts In order to allow that different lines may contain different stores and at the same time to follow the main principle - we have to make sure that the Store field in the document header may contain empty (NULL) values. Such value is set only when the document lines have different values. Opposite of this, the value in the field in the document lines is required/mandatory [Required = true] and must always contain a value. It is accepted that the main/leading field is the field in the lines - it is required/mandatory, i.e. there is a guarantee that it always contains a value. For example, if we are generating a store orders from sales orders - the store field that is taken into account is the one in the sales order lines. We have to create separate store orders for each line store in order to execute the sales order correctly because in the store orders there is only one store field and it is in the header. If the document does not contain any lines, then there is no limitation for the document header value - it doesn't matter if it is empty (NULL) and contains a value (not-NULL). Rules FrontEnd rules When the value of the document header's field is changed, this value is automatically set to ALL document lines. When all document lines have the same value in the Store field, then the field in the document header must contain the same value. The presence of a value in the document header field is an ease for the users - it is not necessary to constantly monitor whether the lines have different values or not. For this reason - after editing the value in the Line Store field and when deleting lines - if it turns out that all lines contain the same Store value, then this value is automatically set in the document header field. When the different document lines have different values in the Store field, then the field in the document header must be empty (NULL). For this reason - after editing the value in the Line Store field and when deleting lines, if it turns out that the line contains a different Store value, then the Store field in the document header is automatically set to an empty value (NULL). When adding a new line, then in the Line Store field is set the default value that equal to the value from the document header (unless another default value is explicitly set). If the document header value is empty (NULL), then as a default value in the new line is considered the value from the previous lines. If this is impossible, hard or inapplicable - then the default value is empty (NULL). BackEnd rules When the document header is saved, the master-detail field's value is updated according to the value of the lines field (if any lines). If all lines contain the same store value, then this value is automatically set in the document header field. If the line contains different store values, then the Store field in the document header is automatically set to an empty value (NULL). When а document line is saved, the master-detail field's value is updated according to the value of the field in the header. When the document's header and lines are saved there is a final back end validation. If it turns out that despite the rules above, the values of the master-detail fields do not comply with the rules and principles above is thrown an error: The master attribute '{the name of the field in the header}' should have the same values as the detail '{the name of the field in the lines}' attribute for all lines or null, if there are different values through the lines."
  },
  "advanced/concepts/object-relational-mapping.html": {
    "href": "advanced/concepts/object-relational-mapping.html",
    "title": "Object relational mapping | ERP.net Tech Docs",
    "keywords": "Object relational mapping Description Entities and Entity types are terms, frequently used throughout the documentation. Entities are information objects, which represent real-world objects. Entity type is the collection of all objects of a given type. For example, the customer XYZ is an entity. Customer ABC is another entity. All customers are of an entity type, called 'Customers'. Definitions Entity - Single object of a given entity type. Also called entity object or simply object. It is similar to a data row in a table. Entity type - The set of all objects of a given type. This is similar to a table. Attribute - a named value, containing information about the entity object. This is similar to a column in a table. Relationship to tables and rows This section contains more advanced information, not usually needed to operate the system. However, a deeper understanding of the inner-workings might help sometimes, especially when one needs to access directly an ERP.net database, using database tools. Generally, entity types , entities , and attributes are much like tables , rows , and columns . Data of the entities is ultimately stored in the database in the form of tables and rows. However, there is one important distinction - entity types and entities are object-oriented representation of the table data. A technology, called ORM (Object-Relational Mapping) is used to map between entities and tables. In order to illustrate better the difference between objects and tables, let's include some real-world tables and objects: There is an entity type, called 'Party'. It has a descendant (more specialized) entity type, called 'Company'. So, Party is the more abstract and broad term, and Company is just one specialization. Person is another descendant of Party. Let's illustrate this using pseudo-graphics: Party +---- company +---- person Each party has some attributes, like 'parent party' and area. The company has VAT number and registration type attributes. Each person has \"first name\" and \"last name\". Now, if we look at the tables, they have the following schema: Parties Party Id Parent party Id Area Id Companies Party Id VAT number Registration type Person Party Id First name Last name If we look at the objects, they will have the following attributes: Party Parent rty Area Company Parent party Area VAT Number Registration type Person Parent party Area First name Last name So, if we use table data, in order to access all attributes of a company or a person, we have to relate (join) data from different tables, using unique identifiers. The identifiers are the so-called \"surrogate keys\" because they are existing only in the database and have no real-world counterpart. Using such keys and relating data between tables is ordinary in the relational world of the databases. However, internally, the systems use objects, because it is much simpler to process them. Objects already have all the necessary attributes related together and there is no need to use Identifiers or table relations. This is only an introduction to the topic of object-relational mapping. More deeper look would go too deep into the developer details of the subject."
  },
  "advanced/concepts/scheduled-document-events/index.html": {
    "href": "advanced/concepts/scheduled-document-events/index.html",
    "title": "Scheduled document events | ERP.net Tech Docs",
    "keywords": "Scheduled document events Scheduled Document Events are postponed events, which will be executed later. Usually, these are numerous recalculation events, resulting from other events. For example, releasing a cost correction creates scheduled events for all affected documents. The Scheduled Document Events have to be executed to be applied. In the case of a scheduled event created by a cost correction, the execution causes a resetting of the document state of the store transactions which was included in the cost correction. The resetting triggers the Accounting Voucher generation procedures and causes the re-accounting of documents, including the adjusted cost. The execution can be performed manually through the \"Execute Scheduled Evens\" navigator or automatically using the job J30724 - Run scheduled events ."
  },
  "advanced/custom-attributes/domain-with-property-allowed-values.html": {
    "href": "advanced/custom-attributes/domain-with-property-allowed-values.html",
    "title": "Domain with property allowed values | ERP.net Tech Docs",
    "keywords": "Domain with property allowed values Domain is the range of the allowed values of the particular custom property. It is determined in one of the following ways - sorted by priority: If Limit To Allowed Values does NOT have a check mark, then any value is valid and the domain is a range of all possible values. If the Allowed Values Entity Name has a value, then the domain is the set of all records of the specified data type. Note This field should have a value ONLY if Limit To Allowed Values has a check mark and Allowed Values Property does not have a value. If the field Allowed Values Property has a value, then the domain of the current custom property is equal to the domain of the custom property specified in this field. CustomProperty.Domain = CustomProperty.AllowedValuesProperty.Domain Note This field should have a value ONLY if Limit To Allowed Values has a check mark and Allowed Values Entity Name does NOT have a value. (Default, Lowest Priority) The domain is the range of the Property Allowed Values listed in the Gen_Property_Allowed_Values sub-table. Example 1: Let's assume that we have the following properties: property 1 (entity name = Products) property 2 (allowed values property = Property 1) property 3 (entity name = Products) property 4 (entity name = Companies) property 5 (allowed values property = Property 2) property 6 (limit to allowed values = False) In this case, the domains are: property 1 - Products property 2 - Products property 3 - Products property 4 - Companies property 5 - Products property 6 – all possible values Compatible custom properties Two custom properties are copy compatible when then and only then their domains are the same. The compatibility allows us to copy values from one custom property to another. It is still possible the copying to throw an error, but this would be caused by different reasons – additional filters set in the definition, for example An important note is that the additional filters do not change the domain of the custom property. They just reduce the range with allowed values. It is also possible future procedures or rules to be added – but they won’t change the actual domain of the custom properties either. In general, we can accept that the domain of the allowed values, from a programming point of view, could be defined as a kind of custom property type. Example 2: If we use the description of Example 1, we can conclude that Property 1 is compatible with Property 2. Both of them are compatible with Property 3 and Property 5. On the other hand Property 1, Property 2, Property 3 and Property 5 are compatible with each other. Property 4 in not compatible with none of the above. Property 6, although it could receive any possible value, is also noncompatible with other custom properties. Inheriting and hereditary root A custom property inherits another custom property by indicating a (hereditary) parent property in the Allowed Values Property field. The hereditary root is the grand-parent, which does not have a hereditary root on its own. The hereditary root of a custom property clearly defines its domain and is a prerequisite for automatic copying of its allowed values. A hereditary root is defined as follows: If Allowed Values Property does not have a value, then the hereditary root is the custom property itself Otherwise, the hereditary root is equal to the hereditary root of the parent custom property. This means that: HereditaryRoot (Property) = HereditaryRoot(Property. AllowedValuesProperty) i.e. we look recursively in the relation Allowed Values Property. Example 3: If we use the example above, custom properties have the following hereditary roots: Property 1: Property 1 Property 2: Property 1 Property 3: Property 3 Property 4: Property 4 Property 5: Property 1 Property 6: Property 6 Copying Hereditary roots are used to determine the most appropriate 'partner' for the automatic copying of the allowed values of the custom properties. We will look at an example in which we want to copy custom properties from a customer to a sales order document: Example 4: Let’s assume that: the customer has the following custom properties: FAVORITE-PRODUCT: (entity name = Products) ADVANCE-PRODUCT: (entity name = Products) In the sales order document type are set the following custom properties: FAVORITE-PRODUCT-CUSTOMER: Allowed Values Property = CUSTOMER. FAVORITE-PRODUCT SALE-ADVANCE-PRODUCT: Allowed Values Property = CUSTOMER.ADVANCE-PRODUCT In this case: All 4 custom properties are 'compatible'. They could inherit values from one another. At the same time, only the following pairs have the same hereditary root: ​ A) FAVORITE-PRODUCT-CUSTOMER and FAVORITE-PRODUCT ​ B) SALE-ADVANCE-PRODUCT and ADVANCE-PRODUCT Copying: Accordingly, when specifying a customer in sales order, only the custom properties that have the same hereditary root will be automatically copied from the customer to the document. Custom properties value priorities (when copying to a document) The priority for automatic copying of custom properties to a document is determined according to the following priorities (from the highest to the lowest priority): Note The priorities represent the following logic. If for a custom property is found a value with a higher priority, then – copy the value. If not – search for values with lower priorities Inherited values from the parent document. (Priority 80) The values set in the panel Copy Customer Properties (valid only for sale orders, but the same priority applies if there is a similar table for other types of data). (Priority 70) Values from custom properties with the same hereditary root in the definition of the 'main contractor' of the document. In general cases, this is the party loaded in the field To Party (an exception are purchase invoices, where the supplier is considered as a 'main contractor'). (Priority 50) The default values specified in the document type. (Priority 20) If none of the above contains a value for the custom property, but it is specified in the document type – set an empty (NULL) value. (Priority 10) Note Every manual change of value of custom property, should be done after being entered values in all relevant nomenclatures (enterprise company, customer, parent document etc.)"
  },
  "advanced/custom-attributes/index.html": {
    "href": "advanced/custom-attributes/index.html",
    "title": "Custom attributes | ERP.net Tech Docs",
    "keywords": "Custom attributes Custom attributes (also called 'custom properties') allow the user to extend the data model with user-defined attributes. Custom attributes store values in the database, extending the system tables. Similarity with system attributes The custom attributes behave mostly like the system attributes. They can be shown in columns, grouped and filtered in navigators just like system attributes. Again similar to system attributes, they can have default values and shown in the view of data forms. Most of the time, the end users can't distinguish between system and custom attributes. It is up to the implementation team to define custom attributes, which fit best the implementation requirements. Note Many custom attributes can easily be defined and set as 'required'. However, this might endanger the whole ERP implementation, since requiring too much data entry for each operation can alienate the end users from the system. Carefully balance the business needs with the end user comfort."
  },
  "advanced/data-objects/default-tracking-levels.html": {
    "href": "advanced/data-objects/default-tracking-levels.html",
    "title": "Default tracking levels | ERP.net Tech Docs",
    "keywords": "Default tracking levels Some entities are configured by default to track their changes. The default tracking level is system configured and cannot be lowered. However, the users can specify higher tracking levels. The following table contains the default system specified tracking levels: Entity Default tracking level Activated in version Calculated attributes 3 2019.1 Companies 3 2019.1 Company locations 3 2019.1 Config 3 2019.1 Document types 4 2019.1 Enterprise companies 3 2019.1 Entities 3 2019.1 Group access keys 3 2019.1 Groups 3 2019.1 Parties 4 2019.1 Payment accounts 2 2019.1 Payment types 2 2019.1 Persons 3 2019.1 POS locations 3 2019.1 POS operators 3 2019.1 POS roles 3 2019.1 POS sequences 2 2019.1 POS terminals 2 2019.1 Printout layouts 4 2019.1 Products 2 2019.1 User business rules 3 2019.1 User groups 3 2019.1 Users 3 2019.1 For more information on track changes, please check out Track changes ."
  },
  "advanced/data-objects/display-format.html": {
    "href": "advanced/data-objects/display-format.html",
    "title": "Display format | ERP.net Tech Docs",
    "keywords": "Display format Overview Each entity object must have a representation as text, so that it can be visualized in a user interface - e.g., in ERP.net Windows Desktop Client or ERP.net Web Client. This is quite a simple task for entity types that have few attributes, but in reality, most do not. Let's see the following usual entity types as examples, Client Product These entity types are one of the most commonly used in a typical workflow. Now we will expand these entity types to real (sample) data- i.e., entities. Client Number Name Sales person nmb001 Nia Cartwright Kristy Griffin 123456 Kamile Farrington Natalie Dunn ab1234 Kurtis Dickinson Anderson Fraser Product Code Name Measurement unit Group 1103 DEO GALERIA PINK F 150 ML pcs Goods 1102-01-011 1U Server pcs Computers 12345678 Remote support h Services Usually, these entities make sense in the context of other ones. E.g., documents, reports, analysis, etc... And therefore, they must be visualized in some way. The most typical way is to display their names (i.e., the \"Name\" attribute): Client Nia Cartwright Kamile Farrington Kurtis Dickinson Product DEO GALERIA PINK F 150 ML 1U Server Remote support Ok, everything seems fine, but what if we need something more? Think in general, not just about printouts or reports, this entity visualization should also apply when we choose a customer or a product (respecting the example above). How will you handle the situation when you have several products, named \"1U Server\" ? Wouldn't it be better to see more information (i.e., additional attribute/s) about each entity? How about if you see what's the product availability at the time you choose it? And this is where the display format becomes important. ERP.net allows you to specify the display format of each entity type. So, if you need more attributes to be displayed or a specific format of your choice, you are free to customize it. Here is an example of how you could customize the products entity type: Display format Visualization {Name:T} DEO GALERIA PINK F 150 ML {Name:T} ({Code}) DEO GALERIA PINK F 150 ML (1103) {Name:T} #{Code} DEO GALERIA PINK F 150 ML #1103 {Code} 1103 {Code}: ({Name:T}) 1103: (DEO GALERIA PINK F 150 ML) The common thing between all display formats is the fact they use string interpolation- it gives you the opportunity to customize how each one of your entity types will be displayed. You can find more information on the topic of string interpolation here . Configuring display format Changing the display format for a entity type is an easy task. Just open its definition and change Display Text Format attribute to the desired one. As a result, each entity of this type (i.e., each customer) will be displayed according to the selected display format. In the picture below you can see how a customer dropdown is shown in the Web Client. Furthermore, it's possible to specify the display format yourself if the predefined formats don't suit you. It's easy- you just have to follow the rules when specifying the interpolation string . Also, you may be wondering how you will know the specific attributes of the entity type you need? You can refer to the ERP.net Domain Model documentation . Following to the example above, all the necessary information is available in the Crm.Customers Entity . Internally the display format attribute for an entity is located in the Systems.Core.EntitySettings Entity table. Examples In this section you can see several examples of different entity types- sample data, available predefined display formats and their corresponding visualization. Customers Customers entity documentation . Sample data Number Name nmb001 Nia Cartwright 123456 Kamile Farrington ab1234 Kurtis Dickinson Display formats Display format Visualization {Party.PartyName:T} Nia Cartwright {Party.PartyName:T} ({Number}) Nia Cartwright (nmb001) {Party.PartyName:T} #{Number} Nia Cartwright #nmb001 {Number} nmb001 {Number}: ({Party.PartyName:T}) nmb001: (Nia Cartwright) {Party.PartyName:T} Kamile Farrington {Party.PartyName:T} ({Number}) Kamile Farrington (123456) {Party.PartyName:T} #{Number} Kamile Farrington #123456 {Number} 123456 {Number}: ({Party.PartyName:T}) 123456: (Kamile Farrington) {Party.PartyName:T} Kurtis Dickinson {Party.PartyName:T} ({Number}) Kurtis Dickinson (ab1234) {Party.PartyName:T} #{Number} Kurtis Dickinson #ab1234 {Number} ab1234 {Number}: ({Party.PartyName:T}) ab1234: (Kurtis Dickinson) Products Products entity documentation . Sample data Name Part number DEO GALERIA PINK F 150 ML 1103 1U Server 1102-01-011 Remote support 12345678 Display formats Display format Visualization {Name:T} DEO GALERIA PINK F 150 ML {Name:T} ({PartNumber}) DEO GALERIA PINK F 150 ML (1103) {Name:T} #{PartNumber} DEO GALERIA PINK F 150 ML #1103 {PartNumber} 1103 {PartNumber}: ({Name:T}) 1103: (DEO GALERIA PINK F 150 ML) {Name:T} 1U Server {Name:T} ({PartNumber}) 1U Server (1102-01-011) {Name:T} #{PartNumber} 1U Server #1102-01-011 {PartNumber} 1102-01-011 {PartNumber}: ({Name:T}) 1102-01-011: (1U Server) {Name:T} Remote support {Name:T} ({PartNumber}) Remote support (12345678) {Name:T} #{PartNumber} Remote support #12345678 {PartNumber} 12345678 {PartNumber}: ({Name:T}) 12345678: (Remote support)"
  },
  "advanced/data-objects/extensible-data-objects.html": {
    "href": "advanced/data-objects/extensible-data-objects.html",
    "title": "Extensible Data Objects-EDO | ERP.net Tech Docs",
    "keywords": "Extensible Data Objects-EDO Description and usage The Extensible Data Objects (EDO) is a system in ERP.net, which allows attaching additional data to all entities in the system. Types of additional data, that can currently be attached: file attachments. Track changes change tracking data. How it works? EDO objects are stored in the Sys_Objects entity. The system works in the following way: An object in any entity requires attaching additional data. A new record is created in Sys_Objects. The additional data is created in sub-tables, which have referential integrity to Sys_Objects. The record in Sys_Objects has only untyped soft reference (not referential integrity) to the original record. It contains Entity_Type and Entity_Item_Id fields, which uniquely identify the original record. All additional data is related to Sys_Objects through typed referential integrity. In this way, the only untyped soft reference is the original reference in Sys_Objects , but most data is solidly related through typed referential integrity. Note The Custom attributes system was implemented prior to the Extensible Data Objects system, so it also uses untyped soft reference. If we would have to design the Custom Properties system now, it would be implemented as 'additional data' to the EDO system. Future plans The EDO system is very useful for creating additional data, which can be attached to multiple entities. It is not required that the type of data should be attachable to ALL entities. The data model allows attaching data to any entity, but system business rules or business rules can be used to limit the entities, which actually 'accept' the data. Possible (planned) future uses: Comments/Replies - many objects in the system can be augmented by allowing the users to comment and reply to them. All kinds of attachments - links, pictures, other system objects, etc. Tags/Labels for back-link navigation. Future simplified implementation of custom properties. Reactions - Facebook style reactions. Reviews - marketplace style reviews. See also: Systems.Core.ExtensibleDataObjects Entity"
  },
  "advanced/data-objects/index.html": {
    "href": "advanced/data-objects/index.html",
    "title": "Data objects management | ERP.net Tech Docs",
    "keywords": "Data objects management Data Objects are a design pattern, used to encapsulate logic, which is available to most data records in the system. Each aggregate root is a data object. All data objects have some common attributes, sub-entities and operations. The following data and operations can be associated with a data object: Track changes [file attachments] For more detailed information, see Extensible Data Objects ."
  },
  "advanced/data-objects/track-changes.html": {
    "href": "advanced/data-objects/track-changes.html",
    "title": "Track changes | ERP.net Tech Docs",
    "keywords": "Track changes Track Changes is a system in ERP.net, which can be used to track the changes in any data table. Tracking levels The tracking levels specify the detail level of the tracking, as per the following table: Track Changes level Name Description 0 Do not track changes Do not track any changes for this entity. 1 Track last change Store information only for the latest modification of the tracked object. 2 Track object changes All the data of Level 1 + General tracking information about each update of the object. Do not store information about the changes in the attributes. 3 Track object & attribute changes All the data of Level 2 + Information about the changes in the attributes, excluding the BLOB attributes. The BLOB (Binary Large Objects) attributes are large size attributes like images, files, etc. 4 Track object, attribute & BLOB changes All the data of Level 3 + Changes in the values of BLOB attributes. Effects and storage The system stores information based on the tracking level. The following topics summarizes the stored data and other considerations and remarks: Level 0 - do not track changes. No information is stored. Level 1 - track last change Store information only for the latest modification. This is the lightest tracking mode with the least storage requirements. The information is stored in the Systems.Core.ExtensibleDataObjects Entity Note Extensible Data Objects object is created and maintained ONLY for the root object of the object aggregates . Upon first update of the tracked object, a new EDO record is created, if there isn't already one. For each successive update of any object in the aggregate, the data in the EDO is updated. The tracking data includes: Version number - incremented on each update Creation user - the user who initially created the tracked object (if Track Changes was enabled by that time). Creation time (UTC) - the time of initial creation in Universal Coordinated Time (UTC) timezone. Last update user - the user who performed the last update OR deleted the object. Last update time (UTC) - the time of the last update. Is deleted - specifies whether the tracked object is deleted. After the tracked object is deleted, the Extensible Data Objects information stays in the DB for some time, but can be purged by cleanup processes. Please note, that when the tracked object is deleted, the deletion user & time are stored in the Last update user / Time. Level 2 - track object changes With this level, the Extensible Data Objects is still updated, but also, for each modification, a new record is created in two tables: Systems.Core.ObjectChangesets Entity contains data about change-sets. A change-set is one modification request, sent to the server. One request can contain modifications (creates/updates/deletes) of multiple objects. Each change-set stores the following data: User - the user, who initiated the server request. Time (UTC) - server time in UTC, when the request was executed. Application - the name of the client application, which executed the request. Server version - the version of the server by the time when the request was executed. Object changes stores one row for each modified object. One change-set can contain data about multiple object changes. The following data is stored: Repository name - the name of the object repository, containing the object. Entity item id - the Id of the tracked object. Change type - the type of modification: C, U or D for Create/Update/Delete. Root object id - the Id of the Extensible Data Objects for the root object of the Aggregates . Level 3 - track object & attribute changes When this level is selected, all the data for Level 2 is still stored and maintained. But now, also data about each attribute (field) change is also stored. Note This tracking level can consume A LOT of disk space. Use it only when absolutely necessary. Also, make sure to setup some cleanup process (integrated or external). Attribute changes - stores the following data about each attribute change: Attribute name - the name of the changed attribute New value - the string representation (culture insensitive) of the new value Some attribute changes might not be 'sensed' correctly by the system. Since the track changes system works at the application level, changes made by direct SQL statements will not be recorded. When a next update occurs, the system will record the changes to the attribute like it is being made by the next update. This behavior is by design. The most frequent effect of this behavior is that the Document No attribute (which is set by SQL statements and not by the application layer) is recorded as being changed by the 2nd modification of the document. Only the new values are stored (not the old values). This design was chosen for the following reasons: We do not store both old values AND new values to save space. If only the old (and not the new) values are stored, the track changes algorithm can save some space (initial object creation do not need to store values), but performance suffers. This was the initial implementation of the track changes system, but it was abandoned. The track changes process needed to synchronously read the previous database value before each update. This slowed down the actual database transactions and it was decided that the 'new values only' approach would better fit the performance requirements. The storage of the new values can be performed asynchronously AFTER the actual database transaction has completed. In this way, the track changes system has very minor effect on the speed of the every-day OLTP transactions. One drawback of the asynchronous saving is that, upon server crash, the track changes data about the attribute changes might be lost. In this case, the Object Change will still be recorded, because it is recorded synchronously (as part of the transaction). Level 4 - track object, attribute & BLOB changes Same as Level 3, but the values of BLOB attributes are also saved. This can severely affect the storage requirements and should be used only for small tables and as last resort measure. Configuring track changes The track changes functionality is activated through the Systems.Core.EntitySettings Entity table. Steps: Create a record in Entity Types , specifying the desired entity. In the Track Changes Level field, fill the desired tracking level. Save and close. The tracking will shortly start. For document entities is provided an opportunity for mass activation of the Track Changes system using the DocumentVersioningSystem registry key. For more information see the description key number 42 in the Config options reference topic. Note If you try to configure a level lower than the default tracking levels, the option will be ignored. Default tracking levels Default tracking levels"
  },
  "advanced/document-amounts/amounts-calculation/explicit-calculation.html": {
    "href": "advanced/document-amounts/amounts-calculation/explicit-calculation.html",
    "title": "Explicit value calculation | ERP.net Tech Docs",
    "keywords": "Explicit value calculation The explicit amount entered through the Input Amount and Input Amount Currency fields, is converted to the document currency. The result is the end amount of the additional amount. Example: There is a document with currency 'EUR' and an additional amount entered as explicit amount - 60 EUR. The additional amount is set to use round Scale up to the second digit after the decimal point. If the conversion rate is 1.96, then the additional amount is: [Input Amount] = ROUND( 60 * 1.96, 2) = 117.60EUR . Check out Percent calculation for comparison."
  },
  "advanced/document-amounts/amounts-calculation/index.html": {
    "href": "advanced/document-amounts/amounts-calculation/index.html",
    "title": "Amounts calculation | ERP.net Tech Docs",
    "keywords": "Amounts calculation There are two common ways to determine the value of additional amounts : setting an explicit amount ; setting an amount as a percent of other amounts (additional or base amounts from the document rows) Whichever method is used becomes a property of the document form inside the Additional Document Amounts panel and the corresponding Input Percent , Input Amount and Input Amount Currency fields. Typically, the user sets a value in the Input Percent field and leaves the other two empty, or in the Input Amount and Input Amount Currency fields, leaving the remaining one empty. In the additional amount definition, the user can control which method for determining the additional amount value is allowed. This is achieved by the Amount Input Allowed and Percent Input Allowed fields. If the second one is True, then the user can set a default percent value which will appear automatically in the documents. The values entered by the user in the Input Percent and Input Amount fields can be managed by the Allowed Directions field: when ‘Allow only positive’ is selected, the user can enter only numbers bigger than or equal to 0; when ‘Allow only negative’ is selected, the user can enter only numbers less than or equal to 0; when ‘Allow all’ is selected, there are no limitations to the value entered in the fields. Note In both methods, the program calculates an end amount rounded to a specific number of digits after the decimal point. This is an option of the additional amount definition – the Round Scale field. The round scale itself is not used in the end amount. As an intermediate amount, it is used for the amount distribution. The rounded amounts are always limited to the second digit after the decimal point before being saved in the database. For further information, refer to: Explicit value calculation Percent value calculation"
  },
  "advanced/document-amounts/amounts-calculation/percent-calculation.html": {
    "href": "advanced/document-amounts/amounts-calculation/percent-calculation.html",
    "title": "Percent value calculation | ERP.net Tech Docs",
    "keywords": "Percent value calculation Here, the percent from Input percent is used. First, we should know the value of the amounts which will be used to apply the percent calculation. It is defined by the additional amount definition in Base On Line field and the Document Amount Type Dependencies panel (also known as Base Additional Amounts ). According to the definitions, the base amount for the additional amount is calculated and used to find the end value of that amount with the following formula: [Amount] = ROUND([Base Amount] * [Input Percent], [Round Scale]) . The Base amount is defined in two steps: Sum the amounts of the current document to all additional amounts listed in the Document Amount Type Dependencies panel. This requires the previous calculation of the other amounts. If the Additional Amount is marked as 'Base On Lines' , then the sum from p.1 is added to the sum of the document rows, multiplied by their specific weights (if there are no weights - then we multiply by 100%). For more information, see Rows weighting . Example 1: If we have the following additional amounts: Corporate discount: Default percent is -3%; Base on lines is True; there are no other additional amounts listed in the Document Amount Type Dependencies panel; Round scale is '2'; Easter bonus: No Default percent; Amount input allowed is True; Percent input allowed is False; Round scale is '2'; VAT: Default percent is 20%; Base on lines is True; the Document Amount Type Dependencies panel states that VAT is applied to corporate discount and Easter bonus; Round scale is '2'; If we have two document rows - one with a line amount of 150 EUR and another with 40 EUR, then we enter an additional Easter bonus value of -10 EUR. The calculations for the three additional amounts are as follows: Corporate discount base amount is 150 EUR + 40 EUR = 190 EUR (only the sum of the document rows); so [Corporate Discount] is calculated = ROUND( 190 EUR * -0.03, 2 ) = -5.70 EUR ; Easter bonus is -10 EUR (there is no currency conversion because the amount is in EUR); VAT is calculated: [base amount] = [document rows amounts] + [Corporate Discount] + [Easter Bonus] = 190 EUR + -5.70 EUR+ -10 EUR = 174.3 EUR ; so [VAT] = ROUND(174.3 EUR * 0.2, 2) = 34.86 EUR Example 2: We have only one additional amount - commission. Its definition has the following properties: Default percent is 5%; Distribute by is 'Product Definition'. The weight of the specific product is 100%; Base on lines is True; Add to customer is False; Add to line is False; Round scale is '2'. The example document has three rows: row #10 with the amount of 150 EUR; row #20 with the amount of 40 EUR; the row contains the specific product; row #30 with the amount of 69 EUR; the row contains the specific product. So the rows have the following specific weights: row #10: weight = 0.00 ; row #20: weight = 1.00 ; row #20: weight = 1.00 ; The base amount for the commission additional amount is calculated as follows: [base amount] = 150 EUR * 0.00 + 40 EUR * 1.00 + 69 EUR * 1.00 = 109 EUR The final result for the amount is: [Commission] = ROUND( 109 EUR * 0.05, 2 ) = 5.45 EUR Note When we have to calculate percent and the document amount is part of the base amount ( Based On Lines is True) and it has rows with different signs (negative and positive amounts), then there is a specific way to calculate the additional amount. Besides the end result, two subtotals are calculated - [positive amount] and [negative amount]. This is achieved by separating the row types - rows with positive amounts and rows with negative amounts - and for every group of rows, the additional amount is calculated separately. So the final result is: [additional amount] = [positive amount] + [negative amount] These two subtotals may be used in the additional amount distribution. For further information, see Amounts distribution . Example 3 : * If we have the following properties in the additional amount, VAT: Default percent is True; Round scale is '2'; Base on lines is True; the example document has the following rows: row #10 with the amount of 74 EUR; row #20 with the amount of 26 EUR; row #30 with the amount of -45 EUR; and the base amount of the additional amount is: [VAT] = ROUND(( 74 EUR+ 26 EUR + -45 EUR ) * 0.2 , 2) = ROUND( 55 EUR * 0.2 , 2) = 11 EUR , But we also have the additional subtotals: [positive VAT amount] = ROUND(( 74 EUR + 26 EUR ) * 0.2 , 2) = ROUND( 100 EUR * 0.2 , 2) = 20 EUR , [negativeVAT amount] = ROUND( -45 EUR * 0.2, 2) = -9 EUR . and their sum is equal to [VAT](20 EUR + -9 EUR = 11 EUR)"
  },
  "advanced/document-amounts/amounts-distribution/by-amount.html": {
    "href": "advanced/document-amounts/amounts-distribution/by-amount.html",
    "title": "Amount distribution by amount | ERP.net Tech Docs",
    "keywords": "Amount distribution by amount When distributing by amount, to define the distribution proportions rows amounts are used. Two types of amounts are used: row amounts (only if the additional amount has Based on line as True); the amounts that are distributed to the rows (only the ones which participate in the base amount of the current additional amount). So, to define the proportion of row i , its coefficient is calculated (initially) as follows: [ ki ] = [distributed to row i amount1] + [distributed to row i amount2] + ... + [distributed to row i amountm]. So amount1, amount2 ... amountm are the additional amounts, to which we add the current additional amount that is distributed (i.e. the amounts, that are listed in its definition in the Document Amount Type Dependencies panel). If there are no such amounts, than in this initial calculation we have [ ki ] = 0 . Also if Base on lines is True (in the current additional amount), than to the initial value for [ ki ] the row amount is added. [ ki ] = [ ki ] + [row i amount]. This is how each row coefficient is calculated. After that the distribution is performed as usual, except for the case when the amount [ S ] is 0 and the additional amount is calculated as a percent. In this case the amount is distributed equally through the rows and for each row the calculation is performed like this: [row i distribution] = ROUND([ ki ] * [Input Percent], [Round Scale). The idea behind this special case is that if a percent is used for the additional amount calculation, than this percent may be used for the calculation of the distributed amount for each row (i.e. to multiply the percent by [ ki ], which is the base amount only for the i row). Hereby, we avoid the disadvantage of the even distribution - the amount distributed to a certain row maynot be equal to the input percent (this is huge problem, for example, in cases like VAT). Example 2, below, demonstrates such distribution. Example 1: There are the following additional amounts: Corporate discount: Input percent: -3% ; Distributed by: Amount ; Round scale: 2 ; Base on line: True . Eastern bonus: Distributed by: Amount ; Round scale: 2 ; Input amount: -10 EUR . VAT: Input percent: 20% ; Distributed by: Amount ; Round scale: 2 ; Base on line: True ; in the Document Amount Type Dependencies panel it is listed that the VAT is applied also on the Corporate discount and Easter bonus additional amounts; The document has two rows: row \\#10 for 150 EUR and row \\#20 for 40 EUR . In Percent value calculation it is explained how the additional amounts are calculated: [Corporate Discount] = - 5.70 EUR [Eastern Bonus] = -10 EUR [VAT] = 34.86 EUR So for the distribution of corporate discount there are the following coefficients [ k1 ] = 150 and [ k2 ] = 40 (only the base line amounts are taken into account). So the [Corporate Discount] is distributed in 150:40 ratio as follows: [Corporate Discount for row #10] = -5.70 EUR * 150 / 190 = -4.50 EUR ; [Corporate Discount for row #20] = -5.70 EUR * 40 / 190 = -1.20 EUR . For the next amount - 'Easter bonus' - the distribution is in the same ratio 150:40. The result is:. [Easter Bonus for row #10] = -10 EUR * 150 / 190 = -7.894736842105263 EUR ~ -7.89 EUR ; [Easter Bonus for row #20] = -10 EUR * 40 / 190 = -2.105263157894737 EUR ~ -2.11 EUR . For the last additional amount, the coefficients are different, because the distributed amounts from the other additional amounts haveto be added to the row amounts. So the coefficients are as follows: [ k1 ] = [Corporate Discount for row #10] + [Easter Bonus for row #10] + [line amount for row #10] = -4.5 + -7.89 + 150 = 137.61; [ k2 ] = [Corporate Discount for row #20] + [Easter Bonus for row #20] + [line amount for row #20] = -1.2 + -2.11 + 40 = 36.69. So the VAT distribution is as follows: [VAT for row #10] = 34.86 EUR * 137.61 / 174.3 = 27.522 EUR ~ 27.52 EUR ; [VAT for row #20] = 34.86 EUR * 36.69 / 174.3 = 7.338 EUR ~ 7.34 EUR . Example 2: There are 20% VAT and three document rows - row #10 with 100 EUR, row #20 with -30 EUR and row #30 for -70 EUR . In this case the VAT is 0 EUR , but it is not appropriate to distribute 0 EUR on each row (no matter what the coefficients are), as by law each row separately must have nonzero VAT. Even if for some reason (for example specifing roundings) the VAT is not equal to 0 , than it is not appropriate to distribute it equally through the rows (as it will be if we distribute by quantity and we have [ S ] = 0 ), because the amounts on each row are different. This is the reason why in these cases a specific calculation of the distributed amounts is applied: [VAT for row #10] = 100 EUR* 0.2 = 20 EUR ; [VAT for row #20] = -30 EUR * 0.2 = -6 * EUR* ; [VAT for row #30] = -70 EUR * 0.2 = -14 * EUR* . Note Also there is a specific case when the additional amount is distributed by amount. If some rows/coefficients in the document are positive and some of them are negative - as it is discribed in Percent value calculation , in these cases except the total amount of the additional amount there are also two subtotals - positive amount/part and negative amount/part. The amount distribution is performed in two stages - at first the positive subtotals are distributed throught the rows with positive amounts and then the negative subtotal is distributed throught the rows with negative amounts. Example 3: There is an additional amount VAT with input percent 20% and three document rows - row #10 with amount of 74 EUR , row #20 with amount of 26 EUR and row #30 with amount of -45 EUR . The VAT amount is 11 EUR and the the subtotals are [positive VAT] = 20 EUR and [negative VAT] = -9 EUR . Then at first the 20 EUR are distributed on row #10 and row #20 in 74:26 ratio: [VAT for row #10] = 20 EUR * 74 / 100 = 14.80 EUR ; [VAT for row #20] = 20 EUR * 26 / 100 = 5.20 EUR And than the [negative VAT] subtotal is distributed on the last document row: [negative VAT] = -9 EUR = [VAT for row #30]"
  },
  "advanced/document-amounts/amounts-distribution/by-product-definition.html": {
    "href": "advanced/document-amounts/amounts-distribution/by-product-definition.html",
    "title": "Amount distribution by product definition | ERP.net Tech Docs",
    "keywords": "Amount distribution by product definition The distribution by product definition is the same as the distribution by amount, the only difference is that row weights are used (see Rows weighting ). So the difference is that the when the additional amount has Based on lines = True, than the distributional coefficientss are multiplied by the rows weightings. So the only difference is in the following calculation formula: [ ki ] = ([ ki ] + [row amount i ]) * [weighting i (from Rows weighting ]. For example (as addition of Example 3 from Percent value calculation ), there is an additional amount commission with input percent of 5% and three rows (row #10 for 150 EUR , row #20 for 40 EUR and row #30 for 69 EUR), which, in relation of Rows weighting , have the following weights: - row #10: weight = 0.00 ; - row #20: weight = 1.00 ; - row #30: weight = 1.00 . The commission amount is 5.45 EUR and the distribution of this amount is calculated by the following coefficients: [ k1 ] = [row amount #10] * [row weight #10] = 150 * 0.00 = 0 ; [ k2 ] = [row amount #20] * [row weight #20] = 40 * 1.00 = 40 ; [ k3 ] = [row amount #30] * [row weight #30] = 69 * 1.00 = 69 . So the amount of 5.45 EUR is distributed in 40:69 ratio as follows: [row #10 commission] = 5.45 EUR * 0 / 109 = 0 EUR ; [row #20 commission] = 5.45 EUR * 40 / 109 = 2 * EUR* ; [row #30 commission] = 5.45 EUR * 69 / 109 = 3.45 * EUR* ."
  },
  "advanced/document-amounts/amounts-distribution/by-quantity.html": {
    "href": "advanced/document-amounts/amounts-distribution/by-quantity.html",
    "title": "Amount distribution by quantity | ERP.net Tech Docs",
    "keywords": "Amount distribution by quantity When using this distributional method the coefficients for calculation of the proportions [ ki ]/[ S ] are defined by the quantities in the rows on which the additional amount is distributed. So at first it is necessary to bring the quantities to the same measurement unit. Therefore, the additional amounts that use this property (Distribute By = Quantity), are required to have a selected option in the Distribute By Measurement Category field. Thus, the base measurement unit in the selected category is the measurement unit which the quantities from all rows will be converted to (if there is a row with product with no dimension for the base measurement unit of the selected measurement category, than the calculation is ceased and an error message is displayed), So, if the [distribution measurement unit] is the measurement unit from the selected category in the additional amount definition, than for each row the coefficients are as follows: [ ki ] = [quantity on row i ] converted to [distribution measurement unit]. Than the additional amount distribution is performed by the standart formula (in proportions [ ki ]/[ S ], if [ S ] is not 0 , or otherwise - equally throught the rows). Example 1: There is a transport additional amount with input amount of 42 EUR , which is payed by goods box . In the transport definition is marked that it is distributed by quantity and that the measurement category is Boxes (where the base measurement unit is boxes ). The document where the additional amount is selected has three rows = row #10 with quantity of 2 boxes , row #20 with quantity of 25 pieces and row #30 with quantity of 18 kg . The product of row #20 has the following dimension: 1 boxes = 10 pieces . The product of row #30 has the following dimension: 1 boxes = 3 kg . Than after converting all row quantities to boxes , the following coefficients are calculated: row #10: [ k1 ] = 2 ; row #20: [ k2 ] = 2.5 ; row #30: [ k3 ] = 6 . Than the amount of 42 EUR is distributed in the 2:2.5:6 ratio and the results are: row #10: 42 EUR * 2 / 10.5 = 8 EUR ; row #20: 42 EUR * 2.5 / 10.5 = 10 EUR ; row #30: 42 EUR * 6 / 10.5 = 24 EUR . Example 2: There is amount of 42 EUR of transport as in Example 1 . Only in the current example the document rows are: row #10 with quantity of 2 boxes , row #20 with quantity of 30 pieces and row #30 with quantity of -15 kg . Than the coefficients are [ k1 ] = 2 , [ k2 ] = 3 and [ k3 ] = -5 and total amount of [S] = 0 . In this case the additional amount is distributed equally through the rows and the result is: row #10: 42 EUR/ 3 = 14 EUR ; row #20: 42 EUR / 3 = 14 EUR ; row #30: 42 EUR / 3 = 14 EUR ."
  },
  "advanced/document-amounts/amounts-distribution/index.html": {
    "href": "advanced/document-amounts/amounts-distribution/index.html",
    "title": "Amounts distribution | ERP.net Tech Docs",
    "keywords": "Amounts distribution After the additional sum is calculated (see Amounts calculation ), the result is not saved directly in the document, but it is distributed through the document rows ( more precisely - through those rows which the additional amount is applied to - the ones with nonzero weight, see Rows weighting ) and this distribution is saved in the document. So after the amount is calculated and distributed, if the user needs to see the total value of the additional amount, he has to sum up all the values from its distribution. This is easier than saving the total additional amount in the document, because often the distributed to a specific row amount is needed (for example - to see the VAT distributed to a specific product or the transport distributed to a specific product, so that we can add this amount to its value). If we save the total additional amount in the document, in these cases the user will have to distribute the amounts at the moment, which is not very effective. The article (and the subarticles) descirbes the methods for distributing the amounts throught the rows. Also, a procedure for amount distribution is described when, because of roundings, the amount cannot be precisely distributed, and other specific cases. Common principle of distribution The distribution principle is defined in the additional amount definition (by Distributed By field). There are three basic methods by quantity (see Amount distribution by quantity ), by amount (see Amount distribution by amount and by product definition (see Amount distribution by product definition ). Every method expects that a proportion of the amount distributed by the rows should be defined so the distribution to be executed. So if we have n rows on which we have to distribute additional amount, for every row a weight is defined - [ k1 ], [ k2 ] ... [ kn ]. In the common case, these are different coefficients than those described in rows weighting (but in some specific cases the coefficients from rows weighting may participate in the calculation of the distribution weights). So if the amount of these coefficients is [ S ] (i.e. [ S ] = [ k1 ] + [ k2 ] + ... + [ kn ]) and this amount is not equal to 0, than the i -row the proportion is [ ki ]/[ S ]: [distribution to row i ] = ROUND([amount] * [ ki ] / [ S ], [Round Scale]), where Round Scale is property of the additional amount definition. This is a standart distribution alogorithm. Specific cases are when [ S ] is 0 . Usually, in those cases the additional amount is distributed evenly through the row, using the following formula: [row i distribution] = ROUND([amount] / [rows count], [Round Scale]), but in some cases there are some more specific calculations (for example,when the amount is distributed by amount or by product definition and the additional amount is percent). Sometimes the additional amount may not be able to be distributed exactly through the rows. In these cases, an attempt is made to allocate the balance throught the rows which the amount is distributed to. Normally, it is impossible to distribute equal part of the balance to all rows (otherwise there will be no balance). So the balance is distributed throught the first several rows. Also, in this balance distribution we cannot distribute less than: [minimal balance distribution on a row] = 1 / 10[Round Scale]. Example 1: If we have 12 rows and the amount of 9.13 EUR to distribute with the following weights: [ k1 ] = [ k2 ] = ... = [ k10 ] = 1 , and [ k11 ] = [ k12 ] = 0 . So 9.13 EUR is distributed on the first 10 rows and, at first, we apply the formula to get the the distribution of 9.13 EUR / 10 ~ 0.91 EUR (assuming we have Round Scale = 2). In this case, we distribute only 10 * 0.91 = 9.10 EUR and the amount left ( 0.03 EUR) have to be distributed through the first 10 rows. As we cannot distribute less than 1 / 102 = 0.01 EUR, so only the first three rows are increase by 0.01 EUR. This is how the final distribution is achieved: on the first three rows the amount of 0.92 EUR is distributed; on the next seven rows the amount of 0.91 EUR is distributed; the last two rows no amount is distributed. If the round scale is more than 2 there is a chance part of the amount to be lost. For example, if the additional amount is 10 EUR and it is distributed equally throught 3 rows and the round scale is 3. In this case for every row the amount of ROUND(3.333333333333333, 3) = 3.333 EUR is distributed. When we save a document like this, the numbers after the second digit after the decimal point will be cut. So in the database we will have 3.33 EUR for each row. So the total amount will be 9.99 EUR and 0.01 EUR will be lost. For further information on how the distibuted amount is calculated by each method, see the following articles: Amount distribution by amount Amount distribution by product definition Amount distribution by quantity"
  },
  "advanced/document-amounts/determination-and-recording.html": {
    "href": "advanced/document-amounts/determination-and-recording.html",
    "title": "Additional amounts determination and recording | ERP.net Tech Docs",
    "keywords": "Additional amounts determination and recording These amounts are recorded in the Аdditional Amounts panel, which can be found in the following documents: Sales orders Invoice orders Invoices purchase orders Purchase invoices Transfer orders Transactions The input/primary data is entered in the Additional Amounts panel, where it is used for calculating the amount and determining its impact on the document. This calculation is executed every time the document is saved and consists of 2 stages: Amounts determination. Stage 1 amounts distribution through the affected documents. That distribution is saved in the document in which it is entered, no matter if the amount affects only the current document or more. The amount is determined by entering an exact value or by indicating that the amount is calculated as a percent of the base document amount or other additional amounts. This data is entered by adding the amount to a document in its Additional Amounts panel. Then, it is used to calculate the real value. For further information see Amounts calculation . After the amount value is calculated, it is not saved in the document. First, it is distributed through the affected documents. This is necessary because we often need to determine what part of the additional amount is distributed to a specific row (for example, the value of the additional amount VAT for a specific sales order row). The algorithm is explained in details in Amounts distribution . There may be cases when an additional amount is entered in one document, but it affects others as well. Take the thansport of deliveries from outside the country as an example. In this case, the original purchase invoice for the delivery of goods has arrived and it is entered in ERP.net . The purchase invoice is released before the purchase invoice for the transport arrives. The transport is entered as an additional amount so it can be included in the product's costs. As it cannot be entered in the original purchase invoice (because the document state is Released and the transport is not actually part of it), the transport is entered in another document and it should be distributed into the original purchase invoice (so its amount is included in the original purchase invoice goods costs). Therefore, we are able to indicate additional - referenced documents, where we distribute the current amount. This mechanism is described in Referenced documents . No matter if an amount is entered in a document or referenced in others, once it is calculated and distributed, we will need to see its real value . It is meant to show how the amount affects the business activities of the documents. Thus, the amount distributions should be summed from all documents it is distributed in."
  },
  "advanced/document-amounts/index.html": {
    "href": "advanced/document-amounts/index.html",
    "title": "Additional amounts | ERP.net Tech Docs",
    "keywords": "Additional amounts The additional amounts are a mechanism for reporting financial amounts in documents that are not contained by the document rows and/or do not represent measurement of the main purpose of the document. The main purpose is written in the document rows or in the document header. For example: product price or product cost (goods or services), which is sold or bought; enterprise company asset price or cost (fixed, financial or rental); value/amount of monetary transaction (transfer, payment or obligation). The amounts listed above are base amounts in documents and they are NOT additional. The document amounts are not proper to be reported along with the main document purpose or they are secondary effect of the main document purpose. These are some examples: VAT (and other taxes) - taxes, like VAT, are not products which the enterprise company is selling, producing or supplying; bеcause of this the taxes are usually reported as additional amounts in the documents; VAT deviation - this is special amount used for equalization of the VAT in the store sales (because of specific roundings); this amount is addition because it is used to obtain the legal rate of the VAT. taxes (as customs) - the same principals as in the taxes are applied; discounts - some types of customer discounts are represented as additional amounts; they are entered as additional amounts when the discount cannot be entered in a specific document row or there are no active promotions or bonus programs, which control this discount; increases and decreases - the same principle is applied as in discounts; if the increases and/or decreases cannot be defined in the rows or as part of a sale instrument such as promotional programs or bonus packages, than they are entered as additional amounts; commissions (and other internal mechanisms for payments or money accounting) - commissions and similar can be entered as additional amounts too; if they are used as additional amounts, they can represent a percent of the document amount and the result can be used for recording internal company performance indicators or personal employees indicators. Amounts calculation Amounts distribution"
  },
  "advanced/document-amounts/referenced-documents.html": {
    "href": "advanced/document-amounts/referenced-documents.html",
    "title": "Referenced documents | ERP.net Tech Docs",
    "keywords": "Referenced documents There are cases when we enter an additional amount in a document and calculate it, distributing it not only to the rows of the current document, but in others as well. For example, if there is a purchase invoice for goods transported to our location and this transport has to be paid, then it can be delivered later than the original purchase invoice (which is already Released and possibly Completed) and we have to enter the transport (as additional amount) in a separate document. Even if the purchase invoice is not late, it can also be necessary to enter it in a separate document - for example, if the transport is performed by a company, different from the one of the goods supplier. So, there is an additional amount transport in one purchase invoice and it will be distributed to the rows of other documents (already Released or Completed), so its value can be added to the goods cost in Logistics . For such cases, the additional amount is calculated through and distributed by documents different from the ones in which we enter it. This is performed in the Document Amount Referenced Documents panel where for each additional amount of the current document 0 or more documents can be entered. These documents are usually from the same system type as the current one (i.e. in invoices, we enter invoices, in sales orders - sales orders) or at least support additional amounts. The amount is calculated and distributed by these exact documents (if it was originally entered in the listed documents). Thus, for every additional amount, it can be defined to which documents it is related: if there is no information for the additional amount in the Document Amount Referenced Documents panel - the amount is distributed only in the current document and no other documents; if there are listed documents in the Document Amount Referenced Documents panel - the amount is distributed in the listed documents and no other documents. This makes it possible to enter additional amounts in the current document, which is distributed only in other documents. Note Respectively, this requires listing the current document as 'Referenced' if such distribution is necessary. Example 1 describes the standard case for referenced document usage - transport for purchased goods. For more information about the calculation and distribution formulas, see Amounts calculation and Amounts distribution . Example 1: Purchase invoice #1 has three rows: #10 with amount of 50 EUR , #20 with amount of 80 EUR and #30 with amount of 140 EUR . Second purchase invoice #2 is entered with no rows - only additional amount with Input Amount of 38 EUR . The user enters purchase invoice #1 in the Document Amount Referenced Documents panel purchase invoice #2 is not listed there). The amount is distributed among the three rows from #1, but the distribution is only entered in purchase invoice #1. This is the resulting distribution, assuming that the transport is distributed by amount and is rounded up to the second digit: row #10, purchase invoice #1: 7.04 EUR ; row #20, purchase invoice #1: 11.26 EUR ; row #30, purchase invoice #1: 19.70 EUR ; Example 2: There is sales order #1 at the end of last year. It has two rows: #10 with amount of 100 EUR and #20 with amount of 80 EUR . In this sales order, the user has missed to enter holidays discounts - additional amount 'Christmas discount’ ; (Default Percent: -3% ; Base On Lines: True ; Distributed By: Amount ; Round Scale: 2 ). It is not appropriate to edit the sales order since it comes from the previous fiscal year. Now, in the Easter Holidays, a sales order for the same customer is entered separately. The user enters the discount missed from the first sales order (‘Christmas Discount’ in sales order #2 is distributed only in sales order #1 - this is indicated in the Document Amount Referenced Documents panel). In sales order #2, the user enters a new discount for the Easter Holidays (Default Percent: -2% ; Base On Lines: True ; Distributed By: Amount ; Round Scale: 2 ). This additional amount is applied only to the current document and it is not entered in the Document Amount Referenced Documents panel. Also in sales order #2, a special bonus for the customer is agreed, which decreases 10% of the amounts from both sales order #1 and #2. This becomes an additional amount ‘Reorder Bonus’ and has the following properties - Default Percent: -10% , Base On Lines: True , the amount is based on ‘Christmas Discount’ and ‘Easter Discount’ also, Distributed By: Amount , Round Scale: 2 . So for the last additional amount from the Document Amount Referenced Documents panel, both sales orders are listed. If the rows in sales order #2 are: row #10 with amount of 35 EUR , row #20 with amount of 75 EUR and row #30 with amount 40 EUR , the three additional amounts in sales order #2 are calculated and distributed (the distributions are only entered in sales order #2): the amount of [Christmas Discount] is -5.40 EUR and it is distributed as follows: row #10, Sales Order #1: -3 EUR ; row #20, Sales Order #1: -2.40 EUR . the amount of [Easter Discount] is -3 EUR and it is distributed as follows: row #10, Sales Order #2: -0.70 EUR ; row #20, Sales Order #2: -1.50 EUR ; row #30, Sales Order #2: -0.80 EUR . the amount of [Reorder Bonus] is -32.16 EUR and it is distributed as follows: row #10, Sales Order #1: -9.70 EUR ; row #20, Sales Order #1: -7.76 EUR ; row #10, Sales Order #2: -3.43 EUR ; row #20, Sales Order #2: -7.35 EUR ; row #30, Sales Order #2: -3.92 EUR ."
  },
  "advanced/document-amounts/rows-weighting.html": {
    "href": "advanced/document-amounts/rows-weighting.html",
    "title": "Rows weighting | ERP.net Tech Docs",
    "keywords": "Rows weighting In many cases, the line amounts from the document rows play a major role in the additional amounts calculation. Either the value of the amount is defined by the row amounts (VAT or customs), or the distribution of the amount through the row depends on the line amounts. However, there are cases when not all rows participate equally in the distribution . For example, it is possible for some products in an invoice to be exempt from income tax (VAT). This leads to not all document rows participating in the VAT calculation. The calculated amount will be distributed only among the ones that have participated. Similar is the case with the 'Customs additional amount’ in purchase invoices, where a customs fee is due for particular products. There is a mechanism allowing the indication of some rows as more important than others - users can set weights, coefficients, or in some cases percentages for each document row. It is available in the Document Line Amounts panel, also known as *Amounts Distribution By Rows'. Here, the coefficient of the specific row is entered in the Line Percent field. These specific parameters may only be entered for additional amounts marked as distributed by product definition (see Amounts distribution ). In this panel, weights are entered in two ways: manually, when the document is created setting them as default values in the product definition Note If there are no weights for additional amount in the panel, then it is considered that all weights are equal to 100% . Below, brief descriptions and examples for the different input methods are explained. For more information on the role of weights/coefficients in the calculation and distribution, see Amounts calculation and Amounts distribution . Weights & coefficients in the product definitions Sometimes, weights of specific services are known before documents are created. For example, when customs taxes are paid for goods on import, some of the products have taxes and others do not. For many, taxes are defined by law and they are a constant percent of the product value. Users have to enter their weight for the additional amount 'Customs'. Then, once the documents are entered in ERP.net, when a product is selected in a document row, its weight is copied from the product definition into the Document Line Amount panel. Users can change the default weights of the products. Example 1: There is an additional amount Customs with the following properties: Distributed by: Product Definition ; Default percent: 100% . A user enters a purchase invoice with four rows: #10 with amount of 44 EUR , #20 with amount of 56 EUR , #30 with amount of 24 EUR and #40 with amount of 71 EUR . In row #10, there is a product with default weight for additional amount ‘Customs’ of 5% and in row #30, there is a product with default weight of 25% . These are the coefficients/weights for each row: row #10: weight = 0.05 ; row #20: weight = 0.00 ; row #30: weight = 0.25 ; row #40: weight = 0.00 ; The 'Customs' amount is 8.20 EUR and it is distributed through the rows as 2.20 EUR : 0 EUR : 6 EUR : 0 EUR Check out Amounts calculation and Amounts distribution for more information. Weights & coefficients in the document In certain cases, weights of the products for specific additional amounts are not known in advance. For example, they may depend on a document parameter and rely on the deal type of the sales order. Regardless of whether VAT is applicable or not and whether the document row has different deal types, users will have to enter the weights/coefficients in the specific document along with deal type. Products do not have percentages in their definitions in advance. Example 2: There is an additional amount ‘Specific VAT’, which is distributed by product definition and has a default percentage of 20% . A user enters a sales order with four rows = #10 with amount of 44 EUR , #20 with amount of 56 EUR , #30 with amount of 24 EUR and #40 with amount of 71 EUR . Rows #10 and #20 are exempt from VAT, while the others have 20% VAT. The user manually sets the following percentages ( 100% on rows #30 and #40): row #10: weight = 0.00 ; row #20: weight = 0.00 ; row #30: weight = 1.00 ; row #40: weight = 1.00 . The Specific VAT is 19 EUR Amounts calculation and it is distributed through the rows as 0 EUR : 0 EUR : 4.80 EUR : 14.20 EUR . Example 3: The following example describes a case where data is absent from the Document Line Amount panel: There is an additional amount VAT with a default percentage of 20% . Since it is not distributed by the product definitions in the Document Line Amount panel, there is no data. In this case, no weights/coefficients are used for calculating and distributing the VAT amount. It is considered that all document rows have 100% VAT so we can have easier calculation formulas."
  },
  "advanced/document-amounts/usage.html": {
    "href": "advanced/document-amounts/usage.html",
    "title": "Additional amounts usage | ERP.net Tech Docs",
    "keywords": "Additional amounts usage Additional amounts are used for different reasons - adding amounts to the main business activity in the document or reporting secondary measurements for the business or outside activities. Calculating the amount to pay Some additional amounts serve to calculate the amount to pay for the document. This is marked in the additional amount definition by adding a check to the Add To Customer field. Usually, these are amounts like VAT, VAT deviation, discounts, increases, decreases. For more information, see Amount to pay . Calculating goods cost Likewise, additional amounts may be used to add value to the goods cost in the logistics . For example, if transport is entered as an additional amount, when goods are purchased, the transport value will be added to the purchase price. When a stock transfer from one store to another is executed and it includes transport cost added to the issued products, the value of this transport should be added to the products cost before they are received in the second store. Adding transport to the purchase price or the store cost is done in the receiving store orders or store transactions. Then, when a row in the sub-document is created, the value of this row is increased by the distribution in the current row amount of the transport. The same procedure is applied to all additional amounts marked as part of the store cost calculation. This is the Add To Line field in the definition of the additional amount. Calculating outside activities Additional amounts may also be used to report external activities for the enterprise company. For example, if a salesman in a company receives commissions or other additions to their salaries equal to a percent of the turnover they achieve, then the commision may be entered as an additional amount in the sales order, which is a percent of the amount to pay ."
  },
  "advanced/document-flow/creating-duplicate.html": {
    "href": "advanced/document-flow/creating-duplicate.html",
    "title": "Creating a duplicate document and a new document from current | ERP.net Tech Docs",
    "keywords": "Creating a duplicate document and a new document from current The current article describes the principles and some specifics in creating a duplicate of an existing document. Different usages of the algorithm are also presented. Basic principles А duplicate of a given document is a new document which contains identical business data as the original one, meaning that all substantial and meaningful information is copied from the original. There is some exception for technical details, such as internal identification numbers - primary keys, IDs of reference links between different parts of one document, and more. This is the common algorithm for creating a duplicate: A new document is created with the same document type. Inside its headers, the substantial data from the original is copied. a. the substantial data from the original document header is copied to the new document header; b. in each of the headers of the new document, only the* substantial * data from the original headers is copied. In the duplicate, new rows are created for each original row, where substantial data is copied. If the original document has rows of the rows (a row having dependent records in different parts of the document) - for each main row, its duplicate in the new document is fixed; for each sub-row of the main row, a new sub-row in the duplicate is created. Only substantial data is copied from the original sub-row. If the original has rows of the rows of the rows , the same procedure is applied until the original document structure is copied. The new duplicate document must contain the same number of records (headers, rows, rows of rows) and structure as the original. Document rows are considered standard rows which most documents have, but properties and additional amounts also play a role. If a specific document header has its own properties, they are considered document rows. The records in the Document Amount Referenced Documents panel are considered rows of rows (rows of the additional amounts). The records in Document Line amounts are considered rows of the standard document rows. For now, attached files are not copied when creating a duplicate of a document. Example 1: There is a purchase invoice with a document header and a specific header, two additional amounts, and four rows. For the first row values, three properties are specified. The last row has value in only one property. The second and third row do not have properties. The properties of the purchase invoice rows are considered rows of rows within the document. When creating a duplicate of this purchase invoice, a new invoice is created, which also has one document header and one specific document header, two additional amounts, and four document rows. For the document rows, there are the following records: row 1 - 3 properties; row 2 - no properties; row 3 - no properties; row 4 - 1 property. Each record in the new document copies the substantial data from its corresponding record in the original purchase invoice. Other examples for rows of rows are: Depreciation plan line fixed value are rows of depreciation plan lines Payment slip lines are rows of payment slip amounts Operations are rows of work order items The voucher rows and their specific properties playing the role of their sub-rows. This is the common method for copying substantial data from the original records to the duplicate records: values in fields which are primary key or referent ID of a link to an upper record in the current document hierarchy, are not copied; the original values are kept since they are created during the creation of the duplicate; for fields processed specifically, the value from the original record is not copied and the specific logic for filling the duplicate record is followed; for the rest of the fields, the value from the original record is copied with no change in the corresponding field for the duplicate. Example 2: In the first example, when copying data from original to duplicate records, the following fields are skipped: in the document header: the value of the Id field as well as fields processed specifically; in the specific header of the purchase invoice: values of fields PurchaseInvoiceId and DocumentId; in additional amounts: values of fields DocumentAmountId and DocumentId; in purchase invoice lines: values of fields PurchaseInvoiceLineId and PurchaseInvoiceId; in purchase invoice lines user properties: values of fields PurchaseInvoiceId and EntityItemId. Cases of specific data copying The current section describes specific fields processing during data copying. Document headers If the document is a master document on its own, then in the MasterDocumentId field of the duplicate document, the original Id is filled. If this is not the case - MasterDocumentId is copied from the original document. In DocumentDate, the current date is filled in and DocumentVersion is set to '1'. EnterpriseCompanyId and EnterpriseCompanyLocationId house the enterprise company and location currently used by the user. CreationTime is filled in with the current date and time while CreationUser is set to the current user. State field is set to New and ReadOnly and Void are set to false. If the original document is voided, DocumentNo of the duplicate record takes the number of the original document. Otherwise, DocumentNo is null. The fields UserStatusId, AssignedToUserId, VoidTime, VoidUser, VoidReason, AccessKeyId and ParentDocumentId are always empty. Document headers and rows of a voucher If the DefaultReferencedDocumentId in the original document is the same as the Id, then in the duplicate document this field is filled with the Id of the duplicate document. The same logic is applied for ReferencedDocumentId field in the Voucher's rows. Payment slip amounts IsPartyPayment is always set to true. Transactions rows The fields LineBaseCost, LineDocumentCost, LineProductCost and LineStoreCost are always set to 0. Ingredients When creating duplicates of the Work order rows with ingredients, there are some specifics which are not exactly related to the fields, but to how they fit in the document hierarchy: if the WorkOrderItemId field in the material record is filled in, then it is considered a sub-record of the work order item record from the work order document, the Id of which is the value of WorkOrderItemId. These records are considered rows of the work order items rows; if the WorkOrderItemId field is null, then the record is directly considered a document row. Such records are rows only of the document header and not of other rows. The duplicate creation algorithm usage The algorithm for creating a duplicate works as follows: Duplicate creation is a function of the document form; the number of the original document is kept as are the date and the parent document (no matter the specifics of copying the data from the document headers). Creating new from current is a function of the document form; the document number and the parent document are not kept and the document date is the current date (as in the specific behaviour). Creating correction is a function of the document form; a duplicate of the current document is created and in its header, the field AdjustingDocumentId is filled with the Id of the original document; all other scalar fields in the duplicate are reset. Creating a copy of the sales order is a generation procedure in the sales order which produces a copy of the parent sales order; the standard duplicate creation is used and in the header of the duplicate, the standard logic of document creation is applied."
  },
  "advanced/document-flow/deterministic-generations.html": {
    "href": "advanced/document-flow/deterministic-generations.html",
    "title": "Deterministic generations | ERP.net Tech Docs",
    "keywords": "Deterministic generations Not all generations support generating and adjusting (patching) a transitional document. Since the adjustment (patch) procedure supports matching the lines primarily by line No. , the generation should guarantee to always generate the same line numbers, given the same starting document. In other words, if we execute the generation several times for the same document, the same resulting line numbers will be generated. This can be guaranteed if the generation generates the sub-document(s) using data only from the source (parent) document and does not look outside it. Common external data, that can make a generation non-deterministic include: Using date or time Using available quantities Using data from the definitions of related objects Actually, generations sometimes use outside data and are still considered deterministic . The main driving factor is whether the outside data influences the resulting line numbers. If the generation uses outside data, but still maintains generating the same line numbers, it is still considered deterministic for the purposes of document generation. Most commonly, deterministic generations simply: Generate exactly one line for each parent line. Use the line number from the parent line to set the line number of the generated line (e.g. they do not use auto-numbering). For example, let's have the following sales order: sales order line 10: Product1 Qty=15 sales order line 20: Product2 Qty=25 Let's have two generations, that use this input to create a store order: Generation A Generates the store order using strictly the data from the sales order and generates: store order line 10 : Product1 Qty=15 store order line 20 : Product2 Qty=25 Generation A is deterministic and can support adjusting transitional documents. Generation B The generation uses the current available quantities to split the lines of the sales order, based on the availability of the different lots. This generation creates: store order line 10 : Product1 Lot11 Qty=8 store order line 20 : Product1 Lot12 Qty=7 store order line 30 : Product2 Lot21 Qty=25 Generation B obviously cannot be used to adjust (patch) the generated document, because the line numbers of the generated document will vary, based on the current availability. Generation B is non-deterministic Adjustment procedure When a transitional document is generated, if later the document needs to be adjusted (to be in-line with its parent), an adjustment document is created. The adjustment document is a document, which contains changes . It is a peer document in the document tree and is usually hidden. The adjustment document is used to adjust (patch) the main document. The adjustment is executed upon setting the adjustment document status. After the adjustment, the main document is updated to reflect the changes brought by the adjustment document. Generating adjustment documents When a generation, which supports adjusting transitional documents, is executed, it checks the sub-documents. If it founds documents, that can be adjusted (patched), it automatically generates changes-only document(s). The generations usually determine the changes in the following way: If quantity, amount or other scalar attribute is updated, a changes line is generated, containing the numeric difference between the scalars. If notes, dates or other non-scalar attribute is updated, a changes line is generated, containing the new values for the non-scalars. Rule 1 and 2 can be combined. E.g. a changes line can combine both scalar and non-scalar changes. The main difference is, that scalars are updated with difference value, while non-scalars are updated with last value."
  },
  "advanced/document-flow/fulfillment.html": {
    "href": "advanced/document-flow/fulfillment.html",
    "title": "Document fulfillment | ERP.net Tech Docs",
    "keywords": "Document fulfillment Description Fulfillment is related to the document generation. Fulfillment makes sure that all quantities and amounts from the parent document are transferred to the sub-document. Differences in quantities and amounts between the parent and the sub-document require fulfillment. Documents in ERP.net usually require complete fulfillment before their state can be set to Completed. Fulfillment documents A document is fulfilled with another document. For example: Shipment order is fulfilled by creating a shipment . Invoice order is fulfilled by creating an invoice . ...and so on. As can be seen in the example, different document entity types usually come (at least) in pairs - orders and execution pairs of entity types. Actually, more and more entity types come in triples - requisition, order and transaction; but that is a different discussion. Note Order documents naturally require fulfillment, which is recorded as execution documents. Discrepancies in quantities and amounts between the parent and the sub-document(s) Quantities and amounts in a sub-document may not always represent an exact execution of the parent document. Why there are differences between the parent and the sub-document? Differences can arise for many reasons: Partial execution. For example, we shipped goods partially. In this case, the shipment does not completely fulfill the shipment order. Partial payment by customer. Adjustments to the parent document, because of processing errors. Adjustments to the parent document, by customer request. Adjustments to the sub-document. etc. All these cases require fulfillment before the document state can be set to Completed. Fulfillment tracking Fulfillment tracking is the process of calculating what remains to be fulfilled and how it is divided in the terms of detail lines. For example, a sales order from a customer requests shipment of 10 oranges. We shipped 8 oranges and 2 tangerines. Did we fulfill the sales order? The system tracks the fulfillment of a document, using several tracking techniques: Natural matching Parent line Fulfillment table Natural matching Natural matching matches the parent and the sub-documents, based on natural attribute values. Note Natural attributes are attributes, representing real-world things. This is in contrast with artificial attributes, which are required by the inner workings of the software system. In the example above, natural matching will compare the values of: Product Product variant Lot Serial number So, let’s review the previous example in the light of natural matching. sales order: line 1: oranges, 10 kg shipment: line 1: oranges, 8 kg line 2: tangerines, 2 kg Natural matching will not qualify the shipment of tangerines as execution of the sale of oranges, because it is a different product. Even if the customer agrees to accept the tangerines, we cannot represent this in the system. Another example. The customer might order specific lot of the product, but they are ready to accept another lot: sales order: 10 oranges, lot 202 shipment: 10 oranges, lot 203 This shipment satisfies the customer in the real world. However, using natural tracking, this will be considered a severe difference. The system will propose reversal of the shipment of lot 203 and shipment again of lot 202. Obviously, this is problematic and might confuse the users. Even more problematic, and more real-world example if two or more lines of the sales order contain oranges. In this case, natural matching simply does not work well. The benefit of natural matching is that it does not require special (artificial) tracking attributes or tables. However, it does not work well for some real-world scenarios. Natural matching is used in document generations, created in the earlier stages of ERP.net, but is mostly abandoned in newer developments. Parent line Parent line is widely used algorithm in ERP.net for keeping track of the execution. The idea is simple: The sub-document keeps reference to the parent line, which is being executed. For example: Sales order: line 1: oranges, 10 kg line 2: apples, 2 pcs shipment: line 1: oranges, 8 kg, parent line = 1 line 2: tangerines, 2 kg, parent line = 1 line 3: pears, 2 pcs, parent line = 2 Here, we can see that, although we sent tangerines, they replace the oranges. And we sent exactly the missing quantity. And we sent pears, instead of apples. Note The measurement unit of the sub-document line should be the same as the parent line. Of course, all this has to be arranged with the customer. The important thing is that, once arranged with the customer, we have to represent in it in the system. parent line system allows that. Fulfillment table As good as parent line algorithm is, it cannot be used in all places. There are cases, where it might simply be impossible or very hard to match all sub-document lines using only parent line. For example, in the WMS, suppose we have the following: Warehouse requisition: line 1: despatch oranges, 10 pcs line 2: despatch apples, 2 pcs In the optimization phase, the WMS has created the following plan: Warehouse order: line 1: pick oranges, 30 pcs (because there are also other orders and all will be sorted out on the packing table) line 2: pick apples, 2 pcs line 3: move everything to packing table 3. Obviously, we have a problem here establishing a direct relationship with the parent document. The solution is to use Fulfillment table. The fulfillment table is like a notebook, in which we record how much of the quantity has already been created for the sub-document. This allows the system to create complicated sub-documents, without tracking the direct relationship of the created lines with the parent lines. In this example, after creating the warehouse order, the fulfillment table will contain: Warehouse requisition XXX, execution of line 1: Qty:10 Warehouse requisition XXX, execution of line 2: Qty:2 The fulfillment table simply contains the executed quantities, without any regard of how they are executed. It does not contain any reference to the sub-document(s). The system tracks the execution, without specifically deciphering the sub-document(s) contents. The fulfillment table algorithm allows the application of complex algorithms for execution. These algorithms do not need to represent the parent document lines 1:1 with the sub-document lines and hence have the freedom to employ complex optimization techniques."
  },
  "advanced/document-flow/generation.html": {
    "href": "advanced/document-flow/generation.html",
    "title": "Document generation | ERP.net Tech Docs",
    "keywords": "Document generation Description Document generation is a key part of the document flow in the system and is widely used to automate such flows. It provides for the automatic generation of inheriting documents from a parent document. Generation is a special case of direct order fulfillment , when there is only one source document. It usually creates a single target but can often make multiple documents. When many instances are generated, it is because of different values of some key attribute(s) in the different lines of the source document. Automating the document generation Having just a single document as a source allows for easy document generation. One instance can create multiple and different types of target documents under different conditions and events. The definition of each document type includes a special sub-entity type called workflow routes . These routes specify procedures, conditions and events for the automatic generation of inheriting documents. Each document type can host many workflow routes . They either start automatically or require a user initiation. Together, the routes for the different document types form a general network graph called document flow . Properties of a document generation route Each document generation route contains the following properties: Generation events Events that trigger the document route. The most often used event is usually the one changing the document state . State The system state of the source document which will trigger the route. When a user changes this state, the system initiates all routes marked with any intermediate states. For example, if a document has a Planned state changed to Released state, a route specified for the intermediate Firm Planned state will be started. User state When not blank, it specifies that the route will be started only when the final user state of the source document matches the specified user state. Contrary to system states, when changing this state, routes for the intermediate user states are not initiated. Source enterprise company If left blank, the route will be valid for all enterprise companies. When not blank, the route will be run only for documents in the specified enterprise company. Generation procedure The procedure which will be used to generate the target document. Properties of a document generation procedure Generation procedures are fixed procedures provided by the system. When defining a document route, the user is allowed to choose such a procedure from a fixed list. Each generation procedure is defined in this documentation using the following attributes: Procedure code - The unique procedure code used for identification purposes. It has the following structure: Subsystem code 3-5 characters which uniquely identify the sub-system of the source document. Module code 2 digits that uniquely identify the module within the sub-system of the source document. Procedure code 2 digits which specify the consecutive number of the procedure within the module For example, ‘ CRM0103 ’ specifies a procedure in the ‘CRM’ sub-system, 01-Sales module, procedure #3. Name Name of the generation procedure. Obsolete Specifies whether the generation procedure is still active in the latest version of the system. Old generations are no-longer supported and are marked as ‘Obsolete’. Source document entity type Specifies the entity type of the source document, which defines the general type of the document, for example sales order . The generation procedure can be used only for documents with specified entity type. There can be many user-defined document types within a single entity type. Target document entity type The entity type of the target document. The generation procedure can generate only documents with a specified entity type. Each document type can specify different user-defined document types only within this specified type. Description Detailed description and business case when the generation procedure is used."
  },
  "advanced/document-flow/generation-procedures.html": {
    "href": "advanced/document-flow/generation-procedures.html",
    "title": "Generation procedures | ERP.net Tech Docs",
    "keywords": "Generation procedures Generation procedures are automated procedures which generate documents from other documents. They are the basis for the document flow. Generation procedures are the arrows in the document flow diagrams. Setup In order to start generating documents, the generation procedures need to be configured. The configuration is performed in the document type entity, in the document type routes child entity. Each document type route is a configuration for a single generation procedure. Generation procedures lifetime stages The current topic describes the stages of the lifetime of a generation procedure: NEW - in development, cannot be used ACTIVE - the generation could be actively used by the users AGEING - triggers a warning, can be silenced. OBSOLETE – triggers a warning e or an error and has to be replaced by an active generation procedure. DEAD – does not work, throws an error, or is permanently deleted. Details When creating a NEW generation procedure if it replaces a generation procedure that is currently in use, the old generation is marked as obsolete and it enters the lifetime stage AGEING. In those cases, the AGEING generation procedures, which later become OBSOLETE have to be replaced with the ACTIVE procedures that have been released, because they maintain the contemporary business logic, methods of computing and have a better and faster performance. The transition does not have to be made immediately after the release of the new version but it has to be performed before the generation procedure enters the stage DEAD i.e. before its date of suspension . For every generation procedure that is marked as obsolete, is scheduled a date of suspension on which date the generation procedure will be discontinued and could no longer be used. The date is added in the obsolete procedure's name e.g. 'To be deleted: 9.2021'. As a result of this date, are defined three periods in which the software will inform users accordingly: AGEING - From ([date of suspension] - 3 years) to (date of suspension] - 1 year) – a pop-up (balloon) message will be displayed informing the user that it is using an obsolete generation. These messages’ only purpose is to inform the users and they won’t interrupt/stop their operating with the system. The messages will be logged into the information messages navigator. The messages will stop popping up if for the particular line of the document type's routes the field Allow Obsolete Generation is check-marked. OBSOLETE - From ([date of suspension] - 1 year) to ([date of suspension]) If the field Allow Obsolete Generation is NOT check-marked - an error in a modal window will pop up during the execution of the obsolete generation procedure. The error will inform the users that they are using an obsolete procedure and the generation of the sub-document will be interrupted . The error will stop popping up if for the particular line of the document type’s routes the field Allow Obsolete Generation is check-marked. If the field Allow Obsolete Generation IS check-marked - a pop-up (balloon) message will be displayed informing the user that it is using an obsolete generation. These messages' only purpose is to inform the users and they won’t interrupt/stop their operating with the system. The messages will be logged into the Information Messages navigator. While using this generation, the popping up of this message could no longer be avoided . DEAD - From [date of suspension] onwards - generation ceases to operate and enters the lifetime stage DEAD. An error that can not be avoided will be thrown. With the release of the new main version after the date of suspension, the obsolete generation procedure is to be deleted and it will no longer appear in the drop-down lists."
  },
  "advanced/document-flow/index.html": {
    "href": "advanced/document-flow/index.html",
    "title": "Document flow | ERP.net Tech Docs",
    "keywords": "Document flow Description The sequence of documents in a process forms a document flow. Just a sequence of documents is a rare occurrence, so documents in a process are more likely to be in a hierarchy. Documents in ERP.net often have sub-documents . Most of the time, they are automatically generated or created by some fulfillment function . However, manually entering a sub-document is also allowed and sometimes encouraged. Documents, their sub-documents, the sub-documents of the sub-documents, etc. form a sequence, or hierarchy. The document flow design, therefore, is one of the most important aspects of implementing ERP.net for a target enterprise. The designed is achieved with the help of specific document routes built for each document type. Temporary"
  },
  "advanced/document-flow/parent-document-relationship-type.html": {
    "href": "advanced/document-flow/parent-document-relationship-type.html",
    "title": "Parent document relationship type | ERP.net Tech Docs",
    "keywords": "Parent document relationship type When a document has a parent document, there are constraints, which determine which states are allowed. The applicable states depend on the relation between the parent document and the child document. The relationship is contained in the parent document relationship type attribute. Its possible values are: Sub-task - the child document is a sub-task that must be completed to complete the parent document Next task - the child document is not related to the next task and the parent document can be completed without waiting for the child document to be completed. For example, the sales order-store order relationship is usually of Sub task type because the store order must be completed before the sales order can. In contrast, the offer-sales order relationship is usually of Next task type because the work on the offer can be completed once the sales order is created. There is no need to complete the sales order first. The allowed child document states depends on the relationship type and the parent document state. The following table summarizes the allowed states: Relationship type Parent state Allowed child states Sub-task New New Sub-task Planned New, Planned Sub-task Firm Planned New, Planned, Firm Planned Sub-task Released New, Planned, Firm Planned, Released, Completed, Closed Sub-task Completed Completed, Closed Sub-task Closed Closed Next task New New Next task Planned New, Planned Next task Firm Planned New, Planned, Firm Planned Next task Released New, Planned, Firm Planned, Released, Completed, Closed Next task Completed New, Planned, Firm Planned, Released, Completed, Closed Next task Closed New, Planned, Firm Planned, Released, Completed, Closed"
  },
  "advanced/document-flow/transitional-documents.html": {
    "href": "advanced/document-flow/transitional-documents.html",
    "title": "Transitional documents | ERP.net Tech Docs",
    "keywords": "Transitional documents Transitional documents are documents, which are automatically maintained to always contain the most current information from the parent document. They are automatically generated first and then, on each change in the parent document, are adjusted with the latest changes. Transitional documents, by default, are hidden from the document flow. Since they are totally automated and not user-created, they are usually of no interest to the user. They are used just to keep the document flow contiguous, but are hidden to keep it clean. Not all generations can create transitional documents. Only deterministic generations can create such documents. The main purpose of the transitional documents is to decrease the number of sub-documents in case there are often changes in the data from which sub-documents are created by the document fulfillment system and lots of sub-documents are created. Transitional document setup To set up a document type as transitional: Go to the document type definition and select 'transitional document'. To generate documents of this type, use only generations that support transitional document generation. Example 1: When creating payment orders by sales order payment plan (see the Sales order payment plan article) there are preconditions for great multiplication of the number of sub-documents. For example, if the sales order has a payment plan with three payments - 40 EUR , 50 EUR , 10 EUR - then initially three payment orders will be created (with no invoice data) for each scheduled playment. When the amount of 60 EUR from the sales order is invoiced, two additional payment orders are created - one for -40 EUR and one for -20 EUR for planned payments № 1 and № 2 , which have no invoice data, and two more payment orders for 40 EUR and 20 EUR for planned payments № 1 и № 2 with invoice data. So the sub-documents are now seven. When the user release more invoices, more payment orders will be created. If an invoice is voided - even more payment orders will be created so the collective state of the sub-documents is reached when the voided invoice is no longer reported. So the transitional documents are meаnt to decrease the sub-documents number in such cases, and the changes are applied as corrections on already existing sub-documents (see Adjustment documents . This is performed only if the existing documents are Released. If they have document state higher than Released (see Document states , new documents are created for the discrepancies that occur. In such а case, we call these sub-documents transitional . If a document is transitional is a property of the document type definition. Activating this property is available only when all active procedures which create the current document allow transitional document and are set to create а Released document. Thus, at the first sub-document creation, the sub-documents will have Released document state and the next document changes can be applied as corrections. Thereby, not only the sub-documents number is smaller, and the user does not have to process them (no need to change their state, to edit/correct them so they can reach the values in the parent document, to void additional documents and etc.). This is some kind of automatic processing of these documents by the system. The user has to work only on the parent document. This is where the name of these documents came from - transitional - as these documents do not need direct processing by the user. Example 2: There is a sales order for 100 pcs . It creates transitional store order. The first store order has 100 pcs . When we correct the parent sales order so the quantity is 70 pcs , there are the following two cases: the first is when the primary store order has 100 pcs and it is not Releаsed, but Firm Planned (this is possible if its state is returned to Firm Planned before the sales order correction or when the store order is created before its type is set to transitional). In this case, as there is no released document to correct, so a new Store Order is created with -30 pcs . Now there are two documents; But if the primary store order is Released (the usual case), then the discrepancy of -30 pcs is applied as a document correction and the quantity in the primary store order is now 70 pcs . Thereby, the sub-document is only one, as the discrepancy documents are not independent documents, they are applied to the primary document as corrections. Example 3 (continue of Example 1 ): There is a sales order with a payment plan for 3 payments - 40 EUR , 50 EUR , and 10 EUR . The payment orders are set as transitional documents. Initially, there are no invoices on this sales order so there are three released payment orders: payment № 1 , 40 EUR , no invoice data; payment № 2 , 50 EUR , no invoice data; payment № 3 , 10 EUR , no invoice data. Then invoice # 1 is created based on this sales order for 60 EUR . So the first two payments have to be corrected. The first should have invoice data, the second should have 20 EUR with invoice data, and the rest 30 EUR do not have invoice data yet. So for the additional four payment orders from Example 1 , created to cover the discrepancies, the first two payment orders containing -40 EUR and -20 EUR are applied as corrections of the already existing payment orders for planned payments № 1 and № 2 , with no invoice data. And the second two orders with invoice data are created as new Released documents as there are no released payment orders with invoice data yet. So now the payment orders are: payment № 1 , 0 EUR , no invoice data; payment № 1 , 40 EUR , invoice #1; payment № 2 , 30 EUR , no invoice data; payment № 2 , 20 EUR , invoice #1; payment № 3 , 10 EUR , no invoice data; If after that invoice #1 is edited to 35 EUR (or voided and created again), then the invoice amount may cover only part of the first payment and this will cause discrepancies/changes in the first four payments. As the payment orders are transitional, instead of creating four new documents, the existing payment orders will be adjusted: payment № 1 , 5 EUR , no invoice data; payment № 1 , 35 EUR , invoice #1; payment № 2 , 50 EUR , no invoice data; payment № 2 , 0 EUR , invoice #1; payment № 3 , 10 EUR , no invoice data; The previous example shows that there are cases when the sub-documents have zero-values in the scalar value fields. This is equal to removing the sub-documents (i.e. it does not order/execute anything anymore). The fact that the sub-documents are not voided or erased completely is useful as in a following action they may be used to be adjusted again with zero-values (thereby they are recovered as active documents)."
  },
  "advanced/index.html": {
    "href": "advanced/index.html",
    "title": "Advanced section | ERP.net Tech Docs",
    "keywords": "Advanced section This section contains information for advanced concepts, systems and deep dive in the security. It is intended primarily for advanced ERP implementation consultants. Advanced systems Document flow - document-related concepts and services. Document amounts Custom attributes - user-defined data attributes. Calculated attributes - user-defined calculations. User business rules - user-defined and system business rules. String interpolation Data objects - data object extensibility systems. Jobs Advanced concepts Master / Detail attributes Object / Relational mapping Aggregates Scheduled document events"
  },
  "advanced/jobs/index.html": {
    "href": "advanced/jobs/index.html",
    "title": "Jobs | ERP.net Tech Docs",
    "keywords": "Jobs Jobs is a system in ERP.net, which automatically runs processes. The types of processes, which are run include document state changing, executing scheduled events, or similar. The jobs are run in non-busy hours without requiring any user interaction. How to create and configure a job In most cases, in order to create a job, you have to simply create a new record with the desired job type in the Job navigator. Most parameters of the jobs have a default value and can operate without additional adjustments. An example is the J30903 Document print images - Delete old document print images jobs, which has only one parameter - Print Images Retention Months field Enterprise Company's definition, which has a default value of \"60 months\". However, there are jobs that are jobs that are performing more complicated processes and is not logical to be executed for all records in the database. They require configuring additional settings. Such an example is Document state change job . The parameters and therefore the required settings of each job are described in its documentation. Job scheduling Jobs can be started automatically by the jobs execution system following a predefined schedule. Note Currently, only an On Idle auto-start schedule is available. On idle jobs will be started in non-busy hours, subject upon availability of resources. A job is using the On Idle auto-start schedule when the Run On Idle option is activated in its definition. The jobs execution system will be started only if the following requirements are met: The time of the day is between 22:00 and 03:00. The current server sessions are less than 5. The last time the job's procedure is completed is more than 12 hours from now. The procedure is not currently working There is no manually stated jobs that are currently running Then the conditions described above are met and then the jobs execution system will start a special long-running procedure called 'System Jobs'. The procedure can be monitored as every other long-running procedure in procedures navigator in ERP.net or the procedures tab in the server manager. The jobs execution system will create a list of pending jobs and will start executing them sequentially. The list is made on the base of the active jobs defined in the databases. Each job runs a maximum of 5 minutes and then it is cancelled by the job runner. Every job can run up to 30 minutes which make a total of 6 times X 5 minutes runs, then it breaks the loop of pending jobs. If the job is interrupted before it's work is finished it must be started again during the 30 minutes period. If there are more records that have to be processed after the 30 minutes have elapsed, the job will start again on the next day. Execution log Each job execution is logged in Information Messages . The log contains information about the starting time, ending time, the processed records and the errors that have occurred during the processing (if possible and if any). Example: Process: Job J30777 Finish Store Transactions Message: Succeeded: 259; Failed: 0 LOG: [10:00:10] Total: 259 [10:04:42] Succeeded: 259 [10:04:42] Failed: 0 Available jobs J30632 Deletе old notifications J30724 Run scheduled events J30777 Document state change J30903 Deletе old document print images"
  },
  "advanced/jobs/J30632.html": {
    "href": "advanced/jobs/J30632.html",
    "title": "J30632 Deletе old notifications | ERP.net Tech Docs",
    "keywords": "J30632 Deletе old notifications Code J30632 Entity Communities.Notifications Entity Job type name Deletе old notifications Parameters - Description The system job deletes all old notifications, whose CreationTimeUtc is older than 32 days:(CreationTimeUtc - Now()) > 32 days First to process Notification.CreationTimeUtc (ASC) Records per iteration 10 000 Version Introduced: 2020.1 **For more information about the Jobs documentation template and a short explanation of each column, see topic @template-description-jobs**"
  },
  "advanced/jobs/J30724.html": {
    "href": "advanced/jobs/J30724.html",
    "title": "J30724 Run scheduled events | ERP.net Tech Docs",
    "keywords": "J30724 Run scheduled events Code J30724 Entity General.ScheduledDocumentEvents Entity Job Type Name Run Scheduled Events Parameters ScheduledDocumentEvent.Processed = False2. ScheduledDocumentEvent.Cancelled = False Description The system job executes all scheduled document events which are not cancelled. First to Process ScheduledDocumentEvent.CreationDate (ASC) Records per Iteration 1 Version Introduced: 2020.1 **For more information about the Jobs documentation template and a short explanation of each column, see topic @template-description-jobs**"
  },
  "advanced/jobs/J30777.html": {
    "href": "advanced/jobs/J30777.html",
    "title": "J30777 Document state change | ERP.net Tech Docs",
    "keywords": "J30777 Document state change Code J30777 Entity General.Documents Entity Job Type Name Document State Change Parameters Job.DocumentJob.Condition// Note that in 2020.1 in the condition can be used only the fields from the Documents table. Description The Document State Change job is used to change the state of the desired set of documents. For each job of this type must be created a record in Document Jobs ! This record contains information about the state which has to be set, the new user state (optional), and the conditions which define the set of documents that are going to be processed. First To Process - Records Per Iteration 1 Version 2020.1 IMPORTANT NOTES about the configurations in Document Jobs : The Document Type field is NOT a filter for the job. If you set a specific document type it does not mean that the job will be executed only for documents with this document type or even entity. The only filters which are evaluated to determine the processed documents are the filters in the Conditions field. The Conditions field is the only field that is taken into account to determine which documents will be processed. If there are NO conditions, the system will try to process all documents into the database! In Conditions we have to choose and specify the right combination of criteria which will filter the desired set of documents among all documents in the system. Commonly used filters would be: Document.Void = false - the job will exclude voided documents. Document.Entity Name - the job will be executed for all documents of this entity e.g. sales order. Document.Document Type - the job will be executed for all documents of this document type/s. Document.State - the job will be executed for all documents with this document state. Document.User State - the job will be executed for all documents with this user state. Document.Document Date >= and Document.Document Date >= - the job will be executed for all documents with document date in this period. Currently, the only conditions which are taken into account are the filters from the Document panel. **For more information about the jobs documentation template and a short explanation of each column, see topic @template-description-jobs**"
  },
  "advanced/jobs/J30903.html": {
    "href": "advanced/jobs/J30903.html",
    "title": "J30903 Deletе old document print images | ERP.net Tech Docs",
    "keywords": "J30903 Deletе old document print images Code J30903 Entity General.DocumentPrintImages Entity Job Type Name Deletе Old Document Print Images Parameters DocumentPrintImage.DocumentPrints.Document.EnterpriseCompany.PrintImagesRetentionMonths Description The system job deletes all old document print images, whose retention period has expired. A retention period is considered as expired when the period between the print time of the document print image and today is larger than the period set in the Print Images Retention Months field Enterprise Company's definition. The default value for the Print Images Retention Months field is 60 months but this period can be adjusted according to the particular company's needs. First to Process DocumentPrintImage.DocumentPrints.PrintTime (ASC) Records per Iteration 1000 Version Introduced: 2020.1 Note The job will NOT delete the information from the Document Prints panel/table. The information about when and by whom the document has been printed will continue to be available. The job deletes only the document print image a.k.a the visual representation of the document that has been printed. **For more information about the Jobs documentation template and a short explanation of each column, see topic @template-description-jobs**"
  },
  "advanced/jobs/template.html": {
    "href": "advanced/jobs/template.html",
    "title": "Jobs documentation template | ERP.net Tech Docs",
    "keywords": "Jobs documentation template Each job has a documentation topic, which includes a standardized table which contains detailed information about the job. The standardized table allows us to organize data in a structured way and helps the reader to quickly navigate through the info. The table columns and content explained Template Column Name Template Column Description Code Unique job code. Always starts with J and continues with a digit number. Entity The entity which records are being processed by the job. Job Type Name Unique job type name. Parameters The fields used as parameters by the job. Their values serve as conditions in order to be determined the set of entity records that are going to be processed by the job. Description An explanation of what the job actually does. First to Process Specifies the condition/s (if any) by which the job determines which records have to be processed first. Records per Iteration The count of records that are included in a single iteration of the job.If we are cancelling a manually started job, the job will be aborted after the iteration is finished. Version A list with all versions in which the job has been somehow changed. Usually contains two types of records: 'Introduced: 2xxx.x' - the version since which the job type is available; 'Updated: 2xxx.x ' - the version in which the job has been changed plus a short description of the changes. There could be non or multiple records of this type."
  },
  "advanced/string-interpolation/examples/constant.html": {
    "href": "advanced/string-interpolation/examples/constant.html",
    "title": "Constant expression examples | ERP.net Tech Docs",
    "keywords": "Constant expression examples Plain string Input 'This is a simple string.' Will result to the same output, because string interpolation not applicable. The input doesn't meet the syntax requirements. Output 'This is a simple string.' Expression with escaped curly braces Input '{{This is a simple string.}}' '\\{This is a simple string.\\}' Will create a Constant Expression which results to an output same as the input. Output '{This is a simple string.}'"
  },
  "advanced/string-interpolation/examples/data-member.html": {
    "href": "advanced/string-interpolation/examples/data-member.html",
    "title": "Data member expression examples | ERP.net Tech Docs",
    "keywords": "Data member expression examples Same level data member reference Input 'The document Id is {DocumentId}.' Output 'The document Id is 929bdc15-79d8-4a1f-9467-c237f040939d.' Breakdown 'The document Id is ' {DocumentId} Evaluates to \"929bdc15-79d8-4a1f-9467-c237f040939d\" '.' Assuming the domain object has a data member DocumentId which equals to '929bdc15-79d8-4a1f-9467-c237f040939d'. Referencing data members deeper Input 'The customer is {Customer.Party.PartyName} and its number is {Customer.Number}.' Output 'The customer is John Doe and its number is C12345.' Breakdown 'The customer is ' {Customer.Party.PartyName} Follows the reference path: Customer .Party .PartyName Evaluates to 'John Doe ' and its number is ' {Customer.Number} Follows the reference path: Customer .Number Evaluates to 'C12345' '.' Assuming the domain object has: data member Customer with data members Party.PartyName equals to 'John Doe' and Number equals to 'C12345'. Including a format specifier Input \"The customer is {Customer.Party.PartyName:de}.\" Output \"The customer is John Doe.\" Breakdown 'The customer is ' {Customer.Party.PartyName:de} Follows the reference path: Customer .Party .PartyName Evaluates to MultilanguageString object Format specifier found :de . Apply it. Returns 'Max Mustermann' '.' #Error# Not existing reference Input 'The customer is {Customer.Name}.' Output 'The customer is #Error: Attribute 'Name' not found#.' Breakdown 'The customer is ' {Customer.Name} Follows the reference path: Customer .Name --> Fail. Reference does not exist. Returns error. '.'"
  },
  "advanced/string-interpolation/examples/entity.html": {
    "href": "advanced/string-interpolation/examples/entity.html",
    "title": "Entity expression examples | ERP.net Tech Docs",
    "keywords": "Entity expression examples Acquiring an entity object and referencing its data member Input 'Hi, {Public_Users(a08baf52-de7a-4a39-a567-c6d7e2ab1dc8).Name}, welcome to our forum!' Output 'Hi, John Doe, welcome to our forum!' Breakdown 'Hi, ' {Public_Users(a08baf52-de7a-4a39-a567-c6d7e2ab1dc8).Name} Acquires an object of type User from the Public_Users entity with the provided Id . Follows the reference path: .Name Evaluates to 'John Doe' ', welcome to our forum!' Acquiring an entity object and deep referencing its data member, including a format specifier Input 'The parent group of this product is <{General_Products_Products(1908c05a-790a-42be-a8d8-e850798b5530).ProductGroup.Parent.Name:en}>.' Output 'The parent group of this product is <Materials>.' Breakdown 'The parent group of this product is ' {General_Products_Products(1908c05a-790a-42be-a8d8-e850798b5530).ProductGroup.Parent.Name:en} Acquires an object of type Product from the General_Products_Products entity with the provided Id . Follows the reference path: .ProductGroup .Parent .Name Evaluates to MultilanguageString object Format specifier found :en . Apply it. Returns \"Materials\" '>.' #Error# Not existing entity Input 'Not_Existing_Entity(4ab5e1ee-c613-4f6c-aa02-eb478c99bc80)' Output \"#Error: Entity 'Not_Existing_Entity' not found#\" Breakdown 'Not_Existing_Entity(4ab5e1ee-c613-4f6c-aa02-eb478c99bc80)' Acquires an object from the Not_Existing_Entity entity with the provided Id --> Fail. Entity does not exist Returns error. #Error# Not existing entity object Id Input 'Public_Users(ba8469d7-4854-4ff1-a5ac-a0a60414b061)' Output '#Error: Entity object 'ba8469d7-4854-4ff1-a5ac-a0a60414b061' not found#' Breakdown 'Public_Users(ba8469d7-4854-4ff1-a5ac-a0a60414b061)' Acquires an object of type User from the Public_Users entity with the provided Id --> Fail. Could not find an object with such an Id. Returns error."
  },
  "advanced/string-interpolation/examples/index.html": {
    "href": "advanced/string-interpolation/examples/index.html",
    "title": "Examples | ERP.net Tech Docs",
    "keywords": "Examples Below are some examples of string interpolation, grouped into different types of interpolation expressions. Each example contains an input and its corresponding ouput after the string interpolation is applied. Constant expression examples Data member expression examples Entity expression examples System variable expression examples"
  },
  "advanced/string-interpolation/examples/system-variable.html": {
    "href": "advanced/string-interpolation/examples/system-variable.html",
    "title": "System variable expression examples | ERP.net Tech Docs",
    "keywords": "System variable expression examples Interpolation of a globally resolved system variable Input 'Now is {$datetimeutc} (UTC)' Output 'Current database name is 01.01.2021 15:00:00 (UTC)' Breakdown 'Now is ' {$datetimeutc} Evaluates to \"01.01.2021 15:00:00' . '(UTC) Externally resolved system variable Input 'Current database name is {$dbname}' Output \"Current database name is E1_PROD\" Breakdown 'Current database name is' {$dbname} Evaluates to 'E1_PROD' via an external resolver. Acquiring a data member from a system variable and applying a format specifier Input 'Current company location is {$enterprisecompanylocation.LocationName:en}.' Output 'Current company location is London, UK.' Breakdown 'Current company location is ' {$enterprisecompanylocation.LocationName:en} Resolves the system variable $enterprisecompanylocation to a CompanyLocation object type. Follows the reference path: .LocationName Evaluates to MultilanguageString object Format specifier found :en . Apply it. Returns \"London, UK' \".\" #Error# Not existing system variable Input 'Yesterday was {$yesterday}.' Output 'Yesterday was #Error: System Variable '$yesterday' not found#.' Breakdown 'Yesterday was' {$yesterday} Resolves the system variable $yesterday --> Fail. Such a system variable does not exist. Returns error. '.' #Error# Not existing reference Input 'My name is {$user.RealName}.' Output 'My name is #Error: Attribute 'RealName' not found#.' Breakdown `'My name is'' {$user.RealName} Resolves the system variable $user to a User object type. Follows the reference path: .RealName --> Fail. Reference does not exist. Returns error. '.'"
  },
  "advanced/string-interpolation/expression-types/constant.html": {
    "href": "advanced/string-interpolation/expression-types/constant.html",
    "title": "Constant expressions | ERP.net Tech Docs",
    "keywords": "Constant expressions This kind of expressions doesn't perform any evaluation (i.e. no interpolation) and will produce an output same as the input. // Input 'test' // Output 'test' // Input 'Good morning!' // Output 'Good morning!' Multi-line input is also supported. The \\n sequence is interpreted as a new line. // Input 'line1\\nline2' // Output @'line1 line2' // Input 'line1\\n\\nline3' // Output @'line1 line3' It's also possible to escape the control characters for beginning and end of an interpolation expression { , } . Either by doubling {{ , }} , or by using the escape character \\{ , \\} . // Input '{{This one is escaped}}' // Output '{This one is escaped}' // Input '\\{This one also\\}' // Output '{This one also}' Note More details and examples are available in the examples section ."
  },
  "advanced/string-interpolation/expression-types/data-member.html": {
    "href": "advanced/string-interpolation/expression-types/data-member.html",
    "title": "DataMember expressions | ERP.net Tech Docs",
    "keywords": "DataMember expressions Acquires a data member according to the object's context by the passed reference . // Input '{DocumentId}' // Output '6d954d04-105b-4277-ad2c-6a9a80076a63' // Input *Note the (two-level) reference path - (1)Customer.(2)Id '{Customer.Id}' // Output '54feef7d-c397-44f1-8c23-580a62dd93f6' // Input *Note the (three-level) reference path - (1)Customer.(2)Party.(3)PartyName '{Customer.Party.PartyName}' // Output 'John Doe' // Input (Customer.SalesPerson evaluates to null) '{Customer.SalesPerson}' // Output: '' The evaluation fails if the resolved data member doesn't exist. The output will contain an error message. In contrast, if the data member is null, the expression will evaluate to an empty string. // Input (There is no 'Name' data member in Customer) '{Customer.Name}' // Output '#Error: Attribute 'Name' not found#'. // Input (Typo error) '{Customr.Id}' // Output '#Error: Attribute 'Customr.Id' not found#'. Note More details and examples are available in the examples section ."
  },
  "advanced/string-interpolation/expression-types/entity.html": {
    "href": "advanced/string-interpolation/expression-types/entity.html",
    "title": "Entity expressions | ERP.net Tech Docs",
    "keywords": "Entity expressions Resolves an object by its entity name and Id . // Input (the passed id exists) '{Public_Users(7af30531-d15d-4004-a4bb-21052299f549).Name}' // Output: 'John Doe' // Input (the passed id exists) '{General_Products_Products(4282f8c5-2ba8-4adc-b112-c9f5ca2675f2).Name}' // Output 'Product X' If the entity name or the Id does not exist, the evaluation fails and the output will contain an error message. // Input '{General_Product(2fa67d60-be11-41ec-beac-976e666ece4f)}' // Output '#Error: Entity 'General_Product' not found#' // Input (the passed id does NOT exist) '{General_Products_Products(1cbbe47c-2f54-4fcf-be46-7eb7c5a139e8)}' // Output '#Error: Entity object '1cbbe47c-2f54-4fcf-be46-7eb7c5a139e8' not found#' Also the error handling when passing not valid reference still apply. The evaluation will return an error. // Input '{Public_Users(7af30531-d15d-4004-a4bb-21052299f549).FullName}' // Output '#Error: Attribute 'FullName' not found#' Note More details and examples are available in the examples section ."
  },
  "advanced/string-interpolation/expression-types/index.html": {
    "href": "advanced/string-interpolation/expression-types/index.html",
    "title": "Interpolation expression types | ERP.net Tech Docs",
    "keywords": "Interpolation expression types As mentioned, the whole string, subject to interpolation, is treated as a set of multiple discrete expressions. Each one is evaluated and the resulting value replaces its corresponding expression definition into the input string. There are several types of interpolation expressions, depending on the type of acquired data and the way is obtained. Currently ERP.net supports the ones below. Constant expressions DataMember expressions Entity expressions System variable expressions"
  },
  "advanced/string-interpolation/expression-types/system-variable.html": {
    "href": "advanced/string-interpolation/expression-types/system-variable.html",
    "title": "System variable expressions | ERP.net Tech Docs",
    "keywords": "System variable expressions They are case InsENSitiVE and always start with the $ character, providing additional kind of data, not related with a specific object or its state. For example, if we need to get the current date, we can do it directly via the system variable $date . // Input '{$date}' // Output '01.01.2021' // Input '{$datetimeutc}' // Output '01.01.2021 15:00:00' // Input '{$rooturl}' // Output 'db.myerp.net' // Input '{$user.Name}' // Output 'John Doe' // Input '{$user.Name}' // Output 'John Doe' Note See System variables for more information and all supported system variables. If a system variable exists, but is null, the expression will evaluate to an empty string. // Input '{$role.Name}' // Output '' In contrast, if a system variable doesn't exist or its further reference is not valid, the evaluation will return an error. // Input '{$yesterday}' // Output '#Error: System Variable '$yesterday' not found#' // Input (FullName does not exist) '{$role.FullName}' // Output '#Error: Attribute 'FullName' not found#' Note More details and examples are available in the examples section ."
  },
  "advanced/string-interpolation/format-specifiers.html": {
    "href": "advanced/string-interpolation/format-specifiers.html",
    "title": "Format specifiers | ERP.net Tech Docs",
    "keywords": "Format specifiers Format specifiers are used to state the desired format when formatting object values. In ERP.net they can be used, for example, as a second parameter for the calculated attribute operator FORMATSTRING or in the formatting string (‘:FormatSpecifier’) when referencing domain attributes in the SENDMAIL action (‘{DomainAttribute:FormatSpecifier}’). There are two main types of format specifiers - standard .Net format specifiers (Numeric, Date - Time,..) and custom format specifiers (Multilanguge string, Custom property). Standard .Net format specifiers The standard .Net format specifiers are supported. The list below contains the most frequently used .Net format specifiers. For a complete list and more information, please look at the official .Net documentation site. Numeric format specifiers 'C', 'c' - abbreviation of Currency. Converts a number to a string that represents a currency amount. Can be used with a precision specifier that indicates the desired number of digits after the decimal point. The decimal symbol separator and the currency symbol depend on the local regional settings. Returns: 123.4656 ('C') → $123.46 123.4656 ('C3') → $123.466 'D', 'd' -abbreviation of Decimal. Converts a number to a string of decimal digits (0-9), prefixed by a minus sign if the number is negative. Can be used with a precision specifier that indicates the desired number of digits after the decimal point. This format is supported only for integral types. Returns:1234 ('D') → 1234 -1234 ('D6') → -001234 'N', 'n' - abbreviation of Number. Converts a number to a string. Can be used with a precision specifier that indicates the desired number of digits after the decimal point. The decimal symbol separator depends on the local regional settings. Returns 123.4656 (N) → 123.47 123.4656 (N3) → 123.466 'P', 'p' - abbreviation of Percent. Multiplies a number by 100 and converts it to a string that represents a percentage. The precision specifier indicates the desired number of decimal places. The decimal symbol separator depends on the local regional settings. Returns 0.488869 (P) → 48.89% 0.488869 (P3) → 48.887% Date and time format strings Standard date and time format specifiers can be used alone (standard date and time format string) or in a combination (custom format string) in order to define the text representation of a date and time value. A standard date and time format string uses a single format specifier to define the text representation of a date and time value. Any date and time format string that contains more than one character, including white space, is interpreted as a custom date and time format string. Standard date and time format strings: 'D', 'd' - Short date pattern. The returned format depends on the pattern set for Short date in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10.5.2019 'D' - Long date pattern. The returned format depends on the pattern set for Long date in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 'f' - Full date/time pattern (short time). The returned format depends on the pattern set for Long date and Short time in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 5:18 'F' - Full date/time pattern (long time).. The returned format depends on the pattern set for Long date and Short time in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 5:18:39 'M', 'm' - Month/day pattern. The returned format depends on the current culture set in the local regional settings. Returns: 2019-05-10 15:18:39.013 → May 10 'u' - Universal sortable date/time pattern. Returns: 2019-05-10 15:18:39.013 → 2019-05-10 15:18:39Z 'U' - Universal full date/time pattern. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 5:18:39 Custom format strings: 'd' - The day of the month, from 1 through 31. 'M' - The month, from 1 through 12. 'y' - The year, from 0 to 99. 'h' - The hour, using a 12-hour clock from 1 to 12. 'H' - The hour, using a 24-hour clock from 00 to 23. 'm' - The minute, from 0 through 59. 's' - The second, from 0 through 59. 'f' - The tenths of a second in a date and time value. '%' - Defines the following character as a custom '/' - Тhe current's culture date seperator. '' - The escape character. 'string', 'string' - Literal string delimiter. Examples: 2019-05-10 15:18:39.013 ('dd MM yyyy hh:mm:ss.fff')→ 10 05 2019 03:18:39.013 2019-05-10 15:18:39.013 ('yyyy MM dd hh:mm:ss.fff')→ 2019 05 10 03:18:39.013 2019-05-10 15:18:39.013 ('dd M yyyy hh:mm:ss.fff')→ 10 5 2019 03:18 2019-05-10 15:18:39.013 ('dd MMM yyyy hh:mm')→ 10 May 2019 03:18 2019-05-10 15:18:39.013 ('dd/MM/yyyy hh:mm')→ 10.05.2019 03:18 2019-05-10 15:18:39.013 ('dd/MM/yyyy hh:mm')→ 10/05/2019 03:18 2019-05-10 15:18:39.013 (dd-MM-yyyy hh:mm)→ 10-05-2019 03:18 2019-05-10 15:18:39.013 ('dd MM yyyy hh:mm 'h'')→ 10 05 2019 03:18 h Custom format specifiers There are also custom format specifiers that are created especially for ERP.net. They are different for the different data types and are described below. Multilanguge string 'C', 'CURRENT' - returns the string of the current value. 'D', 'DUMP' - returns the content of the multilanguage string in the format: EN= DE= 'T', 'TRANSLITERATED' - returns transliteration to the current language. format specifiers for a particular language - returns the translation of the specified language. If there is no transliteration set for this language, returns an empty string. Note: The format specifiers for a particular language are supported since EnterpriseOne version 2019.1. Language format specifiers: -'EN' - English 'BG' - Bulgarian 'CS' - Czech 'FR' - French 'DE' - German 'EL' - Greek 'HU' - Hungarian 'IT' - Italian 'MK' - Macedonian 'PL' - Polish 'PT' - Portuguese 'RO' - Romanian 'RU' - Russian 'SR' - Serbian 'ES' - Spanish Custom property 'VD' - abbreviation of Value/Description, returns: : 'V' - abbreviation of Value, returns: 'VDI' - abbreviation of Value/Description/Id, returns: : ( ) 'D' - abbreviation of Description, returns:"
  },
  "advanced/string-interpolation/index.html": {
    "href": "advanced/string-interpolation/index.html",
    "title": "String interpolation | ERP.net Tech Docs",
    "keywords": "String interpolation String interpolation is a process in which an input string is broken down into expressions (a.k.a. interpolation expressions). ERP.net tries to evaluate each interpolation expression and finally replaces each one with its string representation. String interpolation is available for each object. Abstract Below is a pseudo-example of how the string interpolation works: In the following input: 'Where there’s {EXPRESSION1}, there’s {EXPRESSION2}.'. {EXPRESSION1} and {EXPRESSION2} will be replaced with their string representations - smoke and fire . Finally, the interpolated string is presented to the output: 'Where there’s smoke, there’s fire.'. Let's try a real world example: Input: Now is {$date}. My name is {$user.Name}. Note {$date} and {$user.Name} . They are real expressions. Output: Now is 4.10.2021 17:49:55. My name is John Doe. Example More advanced examples for a string interpolation: // Input \"The following string was interpolated on {$date:ddd}\" // Output (interpolated) \"The following string was interpolated on 21-09-27\" // Input \"https://myservice.com?database={$dbname}&id={Id}\" // Output (interpolated) \"https://myservice.com?database=mydbname&id=39acf964-4e92-4d35-846e-c8a38efff02d\" Also, it's possible to interpolate far more complex ones: // Input @\"Hello, {Public_Users(d30f16c9-a07a-41ca-9d63-e15c3e4db6b4).Name:en}! My name is {$user.Name:en} and I work as a {$role.Name} in {$enterprisecompany.Company.Name:en}.\" // Output (interpolated) @\"Hello, John Doe! My name is Jane Doe and I work as a Manager in ABC Company Ltd.\" Note More examples are available in the separate examples section. Syntax The overall syntax for one interpolation expression is: {<$>reference<(args)><.subref><:fmt>} where: The curly braces { , } define the start and the end of the interpolation expression. $ - specifies that the expression is a System Variable . ref ( required ) - the identifier to the context of the interpolation expression. (args) - additional arguments must be passed when evaluating a Entity expressions. E.g. an Id . .subref - required when ref referes to an object, but a data member is needed. E.g. Customer.Party.PartyName , where Customer is the context (i.e. the ref ) and the .Party.PartyName is the path to the data member - the subreference. In short, .subref defines a path that will be followed after evaluation of ref . :fmt - format specifier. Further formatting of the evaluated value. E.g. Customer.Party.PartyName:en will format the resulting PartyName MultiFormatString according to particular language, referenced with en (English). Warning If an interpolation expression could not be evaluated because of incorrect syntax or wrong (not existing) reference, the evaluation will fail and will return an error. E.g. {Customer.Number} will produce \"C12345\", but {Customer.Numer} (note the typo) will output \"#Error: Attribute 'Customer.Number' not found#\". Format specifiers If the interpolation expression evaluates to an object, it's possible for future customization of the value to a desired format. Typically the target format depends on the concrete object type, e.g. for Number type the C format specifier acts as number to currency string conversion, but if the object type is MultilanguageString the format specifier will return the string of the current value. Note See Format specifiers for more information about the supported format specifiers and how to use them."
  },
  "advanced/string-interpolation/system-variables.html": {
    "href": "advanced/string-interpolation/system-variables.html",
    "title": "System variables | ERP.net Tech Docs",
    "keywords": "System variables The system variables are an essential part of ERP.net string interpolation. They provide additional kind of data, not related with a specific object or its state. For example, if we need to get the current date, we can do it directly via the system variable $date . Each system variable starts with the $ character that identifies it as such and must be surrounded with curly braces { } . E.g. {$date} is a legitimate system variable \"selector\" (a.k.a. expression) which will evaluate to the current date. There are system variables, which value depends on a specific context - e.g. the current Transaction or a specific Application . Therefore, they are evaluated via an externally provided Resolver . In the table below are listed all supported system variables, their return type and the resolvers from which they are supported. Warning If a system variable doesn't exist, it won't be evaluated and its expression will be returned untouched. E.g. {$non-existing-variable} will evalaute to the same thing- {$non-existing-variable} . In contrast, existing system variables, but having a null value, will evaluate to an empty string . System Variable Type Description Resolver $date DateTime Server system date Globally $time DateTime Server system time Globally $datetime DateTime Server system date and time Globally $datetimeutc DateTime Server system date and time in UTC Globally $rooturl string Current database URL Windows Client $dbname string Database name Windows Client $repository string The repository name of which the object is part of Windows Client $entity string The entity name of which the object is part of Windows Client $idlist string Comma separated list with Id s (serialized Guid ) of the current context. E.g. the selected rows in a Navigator Form Windows Client $enterprisecompany EnterpriseCompany The Enterprise Company in the current (transaction) context Windows Client $enterprisecompanylocation CompanyLocation The Enterprise Company Location in the current (transaction) context Windows Client $user User User instance to the current user Windows Client $role Role Role instance of the current user's role Windows Client $language string The language name (UI Culture) of the current user Windows Client"
  },
  "advanced/user-business-rules/action-types/fail.html": {
    "href": "advanced/user-business-rules/action-types/fail.html",
    "title": "FAIL | ERP.net Tech Docs",
    "keywords": "FAIL It's typically used to include additional validations in the system, which are currently not implemented. The FAIL syntax is simple - the current business rule will throw an error. Users are also able to set the error text as a constant. The constant may be entered as first parameter type and value. For example: ActionNo: 1 ; Action Type: FAIL; Parameter1 Type: Constant ; Parameter1 Value: 'error message text' ."
  },
  "advanced/user-business-rules/action-types/index.html": {
    "href": "advanced/user-business-rules/action-types/index.html",
    "title": "Action types | ERP.net Tech Docs",
    "keywords": "Action types The following types of actions are available when creating user business rules: FAIL NOTIFYUSER SENDMAIL SETVALUE WARNING"
  },
  "advanced/user-business-rules/action-types/notifyuser.html": {
    "href": "advanced/user-business-rules/action-types/notifyuser.html",
    "title": "NOTIFYUSER | ERP.net Tech Docs",
    "keywords": "NOTIFYUSER Name NOTIFYUSER Description Used for creating notifications with a specific text for the object for which the business rule has been triggered, which are later going to be sent to the users that were indicated in the rule by the Notifications system. More specifically, the action creates a record in the Notifications table for each of the users specified in Parameter1 (if there are more than one), whereUserId = the Id of the user in Parameter1 ValueSubject = Parameter2 ValueNotificationClass = Parameter3 Value, if emty - set a default value which is 'BR' + '_ ' + 'UserBusinessRule.Code' e.g. 'BR_0005'.DataObject = the extensible data object of the aggregate root of the entity for which the rule has been triggered. For more info, see Aggregates and Extensible Data Objects . If there are not explicitly created notification settings for the class specified in Parameter3, the notification will only be sent as an in-app notification. IMPORTANT: The NOTIFYUSER action is not compatible with all events . For more info, see the Compatible Events Chart below. Parameter 1 - The user/users for which the notification is going to be created. We can set either the UserId or the User's login. If there are more than one recipients they can be entered in a comma-separated list, but the list must contain only UserIds (Id1,Id2,...IdN) or only user's logins (Login1,Login2,...LoginN). Parameter 1 Type Guid, String, List Parameter 2 - The text which is going to be displayed in the notification. Parameter 2 Type String // usually used in combination with the formatted string parameter type. Parameter 3 (optional) - The class which will be set for the notification. If the parameter is not explicitly set will be used a default value. The default value is 'BR' + '_' + 'UserBusinessRule.Code' e.g. 'BR_0005'.For more information about Classes , see Notifications . Parameter 3 Type String Example see the Example section below Version Introduced in: 2020.1 Compatible events chart The NOTIFYUSER action is not compatible with all events . For more info, look into the following chart. Event Type Compatibility with NOTIFYUSER Client Commit (e.g. CLIENTCOMMIT, AGGREGATECLIENTCOMMIT) compatible Document Events - (e.g. STATECHANGING, STATECHANGED, VOIDING) compatible Commit (e.g. COMMIT) not compatible// NOTIFYUSER will create a notification but it will not be displayed to the user in real time. The notification will be displayed at the next login into the program. Front-End (e.g ATTRIBUTECHANGING, ATTRIBUTECHANGED) not compatible// NOTIFYUSER will not create a notification. Example А business rule that creates a notification for the sales person, when one of their sales orders has been released. Repository Crm.Sales.SalesOrders Events Event Type Event Parameter Execution Priority Change of State RELEASED Normal Actions Action No Action Type Parameter1 Type Parameter1 Value Parameter2 Type Parameter2 Value Parameter3 Type Parameter3 Value 1 NOTIFYUSER Attribute SalesPersonId Formatted String sales order {DocumentNo} has been released. Constant Sales_Person_SOReleased"
  },
  "advanced/user-business-rules/action-types/sendmail.html": {
    "href": "advanced/user-business-rules/action-types/sendmail.html",
    "title": "SENDMAIL | ERP.net Tech Docs",
    "keywords": "SENDMAIL Name SENDMAIL Description Used for sending notification emails using Business rules . The email can be sent to more than one recipients and the email's subject and body can be customized according to the particular business reason needs (for more info see the 'Subject and body customization' section below). The address from which the emails are sent is the e-mail address that is set in the From E-mail Address For System Notifications field in the ERP.net application server settings. Note that the SENDMAIL action is performed asynchronously. I.e. it is performed every time when the Event happens (and the conditions are met) and it does not matter whether the event has finished successfully or not. This means that if we have a [SENDMAIL] ( https://docs.erp.net/tech/advanced/user-business-rules/action-types/sendmail.html ) business rule that is triggered when we are saving a product, for example - an email will be sent every time when a product saving is initiated and even if during the saving is thrown an error, the email is going to be sent regardless that action has failed. IMPORTANT: The Sendmail action is not compatible with all events . For more info, see the Compatible Events Chart below. Parameter 1 [TO] - the email address/es to which the mail is going to be sent. If there are more than one recipients they can be entered in a comma-separated list (email1,email2...,emailN). Parameter 1 Type Constant, Attribute (the attribute's type must be String) Parameter 2 [SUBJECT] - The line with the subject of the email. Parameter 2 Type Constant, Attribute (the attribute's type must be String) Parameter 3 [BODY] - The content of the body of the email. Supports multi-line, for more info see the 'Subject and Body Customization' section below. Parameter 3 Type Constant, Attribute (the attribute's type must be String) Example see the end of the article Introduced In Version 2019.1 Note: Currently, the parameters of the business rules can include up to 256 symbols. Compatible events chart The SENDMAIL action is not compatible with all events . For more info look into the following chart. Event Type Compatibility with SENDMAIL Client Commit (e.g. CLIENTCOMMIT, AGGREGATECLIENTCOMMIT) compatible Document Events - (e.g. STATECHANGING, STATECHANGED, VOIDING) compatible Commit (e.g. COMMIT) compatible but not recommended - if possible, use CLIENTCOMMIT instead Front-End (e.g ATTRIBUTECHANGING, ATTRIBUTECHANGED) not compatible, the server will not send an email Subject and body customization The text in the parameters for Subject and Body can be customized according to the specific needs. For added convenience, we've made a couple of implementations in order to provide more formatting capabilities and to facilitate the action as a whole. escape charts The following escape chars are handled: \\n - newline - supported in the Body \\r\\n - also new line - supported in the Body { - insert opening curly bracket '{' in output. - supported in both the Subject and the Body } - insert closing curly bracket '}' in output. - supported in both the Subject and the Body HTML tags - supported in the Body The body could be also formatted using HTML. In order for the text to be recognized as HTML, the body has to contain the tag . The place of the tag is irrelevant, if the tag is placed somewhere in the body's text it is considered that the whole text is written in HTML. use of domain attributes in text - supported in both the Subject and the Body In the text of both parameters for Subject and Body, we can now reach and use the domain attributes' values (system domain attributes and calculated attributes). They are calculated for the particular entity record for which the rule is executed. In order for the domain attribute to be property recognized by the system, it needs to be surrounded with curly brackets '{...}'. Currently are supported the following options: \\1. Attributes: {DocumentDate}. \\2. References: {Customer}. \\3. Reference path: {Customer.Party.PartyName}. Note that Child Collections are not supported. Domain attributes formatting - supported in both the Subject and the Body The domain attribute values can be formatted with the standard .Net format specifiers and the system-specific attributes. For more information, see Format specifiers . Example А business rule that sends an email with an order confirmation to the customer and the sales manager when a sales order has been released. Repository Crm.Sales.SalesOrders Events Event Type Event Parameter Execution Priority Change of State RELEASED Normal Actions Action No Action Type Parameter1 Type Parameter1 Value Parameter2 Type Parameter2 Value Parameter3 Type Parameter3 Value 1 SENDMAIL Constant salesmanager@mail.com,customer@gmail.com Constant Order No{DocumentNo} has been confirmed Constant <p>Dear Customer,</p><p><b> Your order has been confirmed! </b></p><br/><p><h3>SUMMARY</h3></p><p>Order Number: <i>{DocumentNo}</i></p><p>Order Date: <i>{DocumentDate:dd-MM-yyyy}</i></p><p>Shipping Address: <i>{ShipToPartyContactMechanism. ContactMechanism.Name}</i></p><p>Delivery Date: <i>{RequiredDeliveryDate:dd-MM-yyyy}</i></p><p>Order Total: <i>{#CalculatedAttributeTotalSalesOrderAmount:C}</i></p><p>Payment Method: <i>{PaymentType.Name}</i></p><br/><p>Please expect your parcel to arrive on the delivery date stated above at the address or at the office of the courier company.</p><br/><p>Kind Regards,</p><strong>{SalesPerson.Person.FirstName} {SalesPerson.Person.LastName}<strong/></html> A representation of the email which is going to be received by the recipients: Subject: 'Order No00329 has been confirmed' Body: 'Dear Customer, Your order has been confirmed! SUMMARY Order Number: 00329 Order Date: 10-05-2019 Shipping Address: 21 Lombard St Delivery Date: 12-05-2019 Order Total: $14.82 Payment Method: Cash on Delivery Please expect your parcel on the delivery date stated above at the address or at the office of the courier company. Kind Regards, John Smith '"
  },
  "advanced/user-business-rules/action-types/setvalue.html": {
    "href": "advanced/user-business-rules/action-types/setvalue.html",
    "title": "SETVALUE | ERP.net Tech Docs",
    "keywords": "SETVALUE The SETVALUE action is used to update information or data in the system implicitly. When all conditions of the business rules are met and the specified event has happened, then the SETVALUE action updates the value of the specified attribute available for the repository (including the custom properties for the particular entity). The SETVALUE action requires the following parameters: Parameter 1 - the value which is updated (set). Currently, the available parameter type is Attribute. So, in Parameter 1 value the user enters the name of the attribute, which value has to be modified. Parameter 2 - the value which is set in Parameter 1. Currently, the available parameter types are Attribute and Constant. If the parameter type is Attribute, in parameter value the name of the attribute is selected. The selected attribute value would be used to be set as value of parameter 1. If the parameter type is Constant, then in parameter value a constant value has to be entered and every time the user business rule is execute, the parameter 1 attribute would be set to the constant value. The format of the different type of constants is described here: Parameter type CONST . Example: Repository Crm.Sales.SalesOrders Events Event Type Event Parameter Execution Priority Change of State RELEASING Normal Actions Action No Action Type Parameter1 Type Parameter1 Value Parameter2 Type Parameter2 Value 1 SETVALUE Attribute Notes Constant 'Approved'"
  },
  "advanced/user-business-rules/action-types/warning.html": {
    "href": "advanced/user-business-rules/action-types/warning.html",
    "title": "WARNING | ERP.net Tech Docs",
    "keywords": "WARNING Typically used to show a non-blocking message. It may be useful when you want to show a reminder, instead of stopping the transaction with an error using a FAIL business rule. The WARNING syntax is simple - the message that will be shown is set as a first parameter for the WARNING action. Example: ActionNo: 1 ; Action Type: WARNING; Parameter1 Type: Constant ; Parameter1 Value: 'warning message text' ."
  },
  "advanced/user-business-rules/business-rules/code.html": {
    "href": "advanced/user-business-rules/business-rules/code.html",
    "title": "R31067 Code (Code) | ERP.net Tech Docs",
    "keywords": "R31067 Code (Code) Code R31067 Entity UserBusinessRule Name Code(Code) Attribute Code Layer Back-End Events Commit Priority Normal Modify NO Applicable Legislations ALL // no condition needed Action Validate that: UserBusinessRule.UserBusinessRuleCode meets the following requirements: Code validation (Strict) Description The User Business Rule Code field of the user business rule must meet certain validation rules as well as all Code fields. The rules are described in Code validation (Strict) Message Use the message from R29431 MaintenanceType - Code (Code) Version Introduced: 2020.1 Revocable NO"
  },
  "advanced/user-business-rules/business-rules/index.html": {
    "href": "advanced/user-business-rules/business-rules/index.html",
    "title": "| ERP.net Tech Docs",
    "keywords": "Valid icon format Script text max length Code (Code)"
  },
  "advanced/user-business-rules/business-rules/script-text-max-length.html": {
    "href": "advanced/user-business-rules/business-rules/script-text-max-length.html",
    "title": "R28545 Script text max length | ERP.net Tech Docs",
    "keywords": "R28545 Script text max length Code R28545 Entity UserBusinessRule Name ScriptTextMaxLength Attribute ScriptText Layer Back-End Events Commit Priority Normal Modify NO Action Validate that: ScriptText.Length() <= 10000 Description The limit of the script which can be entered in a user business rule is 10000 characters. This validation is required for protective purposes. Message The Script text attribute exceeds its limit of 10000 characters. Please, shorten the text in the Script text attribute. Introduced In Version 2018.1 Revocable NO"
  },
  "advanced/user-business-rules/business-rules/valid-icon-format.html": {
    "href": "advanced/user-business-rules/business-rules/valid-icon-format.html",
    "title": "R28043 Valid icon format | ERP.net Tech Docs",
    "keywords": "R28043 Valid icon format Code R28043 Entity UserBusinessRule Name ValidIconFormat Attribute Icon Layer Back-End Events Commit Priority Normal Modify Normal Action Validate that: UserBusinessRule.Icon.File.Extension == \".JPG\" UserBusinessRule.Icon.File.Extension ==\".PNG\" UserBusinessRule.Icon.File.Extension ==\".SVG\" UserBusinessRule.Icon.File.Extession == \".ICO\" Description There are certain recommendations for the right format of the icon image. Valid file formats are .JPG, .PNG, .SVG, .ICO. All other formats are not allowed. Message \"The icon must be .JPG,.PNG, .SVG or .ICO. Please, use only images of those types.\" Introduced In Version 2018.2 Revocable NO"
  },
  "advanced/user-business-rules/events/aggregate-client-commit.html": {
    "href": "advanced/user-business-rules/events/aggregate-client-commit.html",
    "title": "AGGREGATE CLIENT COMMIT | ERP.net Tech Docs",
    "keywords": "AGGREGATE CLIENT COMMIT Event summary Name AGGREGATECLIENTCOMMIT Layer Back-End Description Occurs for the aggregate root when saving a change of an aggregate object, but only when the change is made by a client application. If the change is made by the server, the event will not be triggered. Version Introduced: 2019.1, Updated:- The Aggregate client commit event is introduced in version 2019.1 and is a variation of the CLIENT COMMIT event. It allows triggering user business rules for objects which are an aggregate root, not only when there is a change for the object itself, but also when some of its referent objects are edited . For more information about the aggregate's root, see Aggregates . Let's take a look at the following structure which is one single aggregate in ERP.net : a sales order (which is the aggregate's root) the Sales Order lines of this sales order the distributed amounts for each of these Sales Order lines the document amounts of this sales order the payment plan of this sales order In the example above, the CLIENT COMMIT event would occur for the sales order only if the sales order object itself has changed. While the aggregate client commit will occur for the sales order if any of the objects in the aggregate has changed. For example, changing just a single sales order line (without changing the sales order itself) would still trigger the Sales Order Aggregate event. In summary, a user business rule with an aggregate client commit event will be triggered when: the saving is performed by a client application; as the repository of the user business rule is an entity which is an aggregate root; there is a change for the aggregate root or for some of its constituent objects."
  },
  "advanced/user-business-rules/events/business-rules/index.html": {
    "href": "advanced/user-business-rules/events/business-rules/index.html",
    "title": "| ERP.net Tech Docs",
    "keywords": "R30055 Is repository aggregate root"
  },
  "advanced/user-business-rules/events/business-rules/is-repository-aggregate-root.html": {
    "href": "advanced/user-business-rules/events/business-rules/is-repository-aggregate-root.html",
    "title": "R30055 Is repository aggregate root | ERP.net Tech Docs",
    "keywords": "R30055 Is repository aggregate root Code R30055 Entity UserBusinessRuleEvent Name IsRepositoryAggregateRoot Attribute EventType Layer Back-End Events COMMIT Priority Normal Modify NO Applicabale legislation ALL // no condition needed Action If (EventType == AGGREGATECLIENTCOMMIT), validate that GetAggregateRoot(UserBusinessRule.RepositoryName.Entity) = null Description The Aggregate Client Commit is used for triggering user business rules for objects which are an aggregate root, not only when there is a change for the object itself, but also when it is edited by some of its referent objects. For this reason such rules can only be specified for repositories which are aggregate roots. For more information about the Aggregate Client Commit event, see AGGREGATE CLIENT COMMIT . Message The Event Type field in the event of user business rule with code '{UserBusinessRule.Code}' has an invalid value. Aggregate client commit event type could be used only for repositories that are a root of the aggregate. The aggregate root of the currently specified repository is '{UserBusinessRule.RepositoryName.Entity.AggregateRoot.EntityName}'. Version Introduced: in implementation Updated: - Revocable NO"
  },
  "advanced/user-business-rules/events/client-commit.html": {
    "href": "advanced/user-business-rules/events/client-commit.html",
    "title": "Client commit | ERP.net Tech Docs",
    "keywords": "Client commit Event summary Name CLIENTCOMMIT Layer Back-End Description Occurs when saving a change of the object, when the change is made by a client application. If the change is made by the server, the event will not be triggered. Version Introduced: 2019.1 Updated: - Thе event is a variation of commit and similar to it - it occurs for the particular object of the repository of the user business rule when an object change is saved. The difference is that it is triggered only when the saving is initiated by a client application, such as the ERP.net Windows Client. If the object is modified by the ERP.net server, then this event is not triggered. This could be used if, for example, we want the business rule to be executed when a user is manually saving a document, but the system is currently saving the document after its creation with a generation procedure."
  },
  "advanced/user-business-rules/events/commit.html": {
    "href": "advanced/user-business-rules/events/commit.html",
    "title": "COMMIT | ERP.net Tech Docs",
    "keywords": "COMMIT Event summary Name COMMIT Layer Back-End Description Occurs when saving a change of the object. Version Introduced: 2017.1 Updated: - Occurs when data is saved into the database. It is used for all kinds of data types - definitions, documents and more. Every time an object change is saved, the rule is activated (if it meets the conditions). The COMMIT event may be used, for example, to validate that all the necessary data of a product is entered. If not - throw an error (by using FAIL action) and do not save the product in the database until the entered data is correct."
  },
  "advanced/user-business-rules/events/index.html": {
    "href": "advanced/user-business-rules/events/index.html",
    "title": "User Business Rules - Events | ERP.net Tech Docs",
    "keywords": "User Business Rules - Events AGGREGATE CLIENT COMMIT CLIENT COMMIT COMMIT STATECHANGED STATECHANGING Business rules VOIDING"
  },
  "advanced/user-business-rules/events/statechanged.html": {
    "href": "advanced/user-business-rules/events/statechanged.html",
    "title": "STATECHANGED | ERP.net Tech Docs",
    "keywords": "STATECHANGED Event summary Name STATECHANGED Layer Back-End Description Occurs when the document state is changed. The state is specified in the 'Parameter' field. Possible parameter values are 'PLANNED', 'FIRMPLANNED', 'RELEASED', 'COMPLETED' and 'CLOSED'. Version Introduced: 2017.1 Updated: - This event will occur AFTER the change of the Document state but BEFORE that change has actually been saved. If there is, for example, a FAIL action set on STATECHANGED event, the rule will be triggered after all rules and validation registered on STATECHANGING are performed but before the document is saved into the database. In this case, when the conditions are met and the rule fails - the state of the document will not be successfully changed and it will remain in its previous state. Another example of a use case for this event is when we want to check if the availability of the product would be over 100 PCS when we receive a batch of goods. We would want to use the STATECHANGED event so the quantities of the current store transaction are included in the calculation. The event always goes with an event parameter. Possible values are: PLANNED FIRMPLANNED RELEASED COMPLETED CLOSED"
  },
  "advanced/user-business-rules/events/statechanging.html": {
    "href": "advanced/user-business-rules/events/statechanging.html",
    "title": "STATECHANGING | ERP.net Tech Docs",
    "keywords": "STATECHANGING Event summary Name STATECHANGING Layer Back-End Description Occurs during the document state change. The state is specified in the 'Parameter' field. Possible parameter values are 'PLANNING', 'FIRMPLANNING', 'RELEASING', 'COMPLETING' and 'CLOSING'.** Version Introduced: 2017.1 Updated: - This event happens during the change (before). If there is, for example, a FAIL action set on the STATECHANGING event, if the rule is activated, the state of the document would not be successfully changed. It would remain in its previous state. It is very important to set the event correctly. The event happens in the data which is set in the repository of the business rule. When we set the STATECHANGING event in a user business rule with repository 'General.Products.Products', this rule would never be activated because the products do not support the event. If a rule has a repository with document lines, for example 'Crm.Invoicing.InvoiceLines', this event would not be appropriate and would not activate the rule either. This is because the document lines do not support the change of state event; this event is supported by documents (their headers). The event always goes with an event parameter. Possible values are: PLANNING FIRMPLANNING RELEASING COMPLETING CLOSING"
  },
  "advanced/user-business-rules/events/voiding.html": {
    "href": "advanced/user-business-rules/events/voiding.html",
    "title": "VOIDING | ERP.net Tech Docs",
    "keywords": "VOIDING Event summary Name VOIDING Layer Back-End Description Occurs during the voiding of a document. Version Introduced: 2019.1 Updated: - The VOIDING event is introduced in version 2019.1. It is recommended only when the business rule's repository is a document header - Crm.Sales.SalesOrders, Logistics.Inventory.StoreOrders... The VOIDING event may be used to prohibit voiding (by using FAIL action) when certain conditions are met or not met. For example, the rule may throw an error when voiding a Sales order that has already been FIRMPLANNED ."
  },
  "advanced/user-business-rules/examples/credit-limit-override.html": {
    "href": "advanced/user-business-rules/examples/credit-limit-override.html",
    "title": "Allow a credit limit override when a client pays in cash | ERP.net Tech Docs",
    "keywords": "Allow a credit limit override when a client pays in cash If we know when the 'system type' from 'payment type' (sales order document) is set as 'in cash', we can use that information to create a Business rule that inserts a check mark in the field Credit Limit Override . We can get that information using this calculated attribute, which returns True or False. To allow a credit limit override when a client pays in cash, we can create a Business Rule with the following data: Repository Crm.Sales.SalesOrders | Events |:----- Event Type Event Parameter ExecutionPriority Change of State RELEASING Normal |Conditions |:----- Condition No Attribute Name Comparison Type Value 1 #IsInCash = True |Actions |:----- Action No Action Type Parameter1 Type Parameter1 Value Parameter2 Type Parameter1 Value 1 SETVALUE Attribute CreditLimitOverride Constant True Note '#IsInCash' is a Calculated attribute . For more information, see Check if the system type of payment type in the sales order is 'In cash' ."
  },
  "advanced/user-business-rules/examples/index.html": {
    "href": "advanced/user-business-rules/examples/index.html",
    "title": "User Business Rules - Examples | ERP.net Tech Docs",
    "keywords": "User Business Rules - Examples Allow a credit limit override when a client pays in cash How to set DeliveryTerms in purchase invoice How to start a business rule only on first releasing Whole quantity validation Temporary Action types ADDDAYS Additional amounts Additional amounts determination and recording AGGREGATE CLIENT COMMIT Allow a credit limit override when a client pays in cash Amount to pay AND Calculate standart price per lot based on the ingredients and the operations in the recipe Calculating cost for returned products Calculating cost for transferred products Calculating cost when returning rented assets Case Management Check if the current user has authorization Client commit COMMIT CONCAT CONST Constant expression examples Creating a duplicate document and a new document from current Default tracking levels Deferred payments options Determine line amount in sales orders Determine line discount Determine product price Display format DIVIDE Document fulfillment Document generation Document print images Document states ERP.net Financials Examples Examples Extensible Data Objects-EDO FAIL File manager GETOBJVALUE GT How to check if a custom property has values? How to check if a list has values? How to determine the party type of a party? How to get attribute value from list? How to use a customer as a company? J30903 Deletе old document print images Jobs documentation template Lots LTE Master / Detail attributes Material requirements planning Minimal sales quantity Module codes More specific cases of setting the transaction timestamp Multi-company support in ERP instances Multi-language support MULTIPLY Non agreed services and materials NOTIFYUSER Operators Original cost calculation Parties concepts Price types Pricing Product Dimensions Product groups Projected available balance Promotional packages Q & A R28545 Script text max length R30055 Is repository aggregate root Referenced documents ROUND Rows weighting Sales order payment plan Sales order row types SELECT SENDMAIL Service Setting transaction timestamp by store orders Setting transaction timestamp in reconciliations Setting transaction timestamp on transaction release SETVALUE Social interactions STATECHANGED STATECHANGING Store order rows execution algorithm System permissions System variable expression examples TOLOWER Track changes Transitional documents User Business Rules - Events Variable (dynamic) measurement ratios VOIDING Welcome to the ERP.net Technical Documentation ..."
  },
  "advanced/user-business-rules/examples/set-deliveryterms.html": {
    "href": "advanced/user-business-rules/examples/set-deliveryterms.html",
    "title": "How to set DeliveryTerms in purchase invoice? | ERP.net Tech Docs",
    "keywords": "How to set DeliveryTerms in purchase invoice? The DeliveryTerms is enum type so it is accessed specifically. The values of the codes are as follows: Member name Value Description ExWorks 0 ExWorks value. Stored as 'EXW'. FrancoCarrier 1 FrancoCarrier value. Stored as 'FCA'. FreeAlongsideShip 2 FreeAlongsideShip value. Stored as 'FAS'. FreeOnBoard 3 FreeOnBoard value. Stored as 'FOB'. CostAndFreightCF 4 CostAndFreightCF value. Stored as 'CFR'. CostInsuranceAndFreight 5 CostInsuranceAndFreight value. Stored as 'CIF'. CarriagePaidTo 6 CarriagePaidTo value. Stored as 'CPT'. CarriageAndInsurancePaidTo 7 CarriageAndInsurancePaidTo value. Stored as 'CIP'. DeliveredAtPlace 8 DeliveredAtPlace value. Stored as 'DAP'. DeliveredAtTerminal 9 DeliveredAtTerminal value. Stored as 'DAT'. DeliveredDutyPaid 10 DeliveredDutyPaid value. Stored as 'DDP'. If there is a need to set a value in the purchase invoice in the DeliveryTerms field, the action of the user business rule must set a casted value from a calculated attribute in the DeliveryTermsCode attribute. The calculated attribute must cast an integer to type 'Aloe.ERP.net.Model.Finance.Intrastat.DeliveryTerms'. For example - if the user wants to set SeliveryTermsCode on 'FOB' automatically, the user business rule must contain an action: 1 SETVALUE ATTRIB:DeliveryTermsCode ATTRIB:#CA And the #CA should have an integer value, casted to 'Aloe.ERP.net.Model.Finance.Intrastat.DeliveryTerms', for example: 10 CAST CONST:3 CONST:Aloe.ERP.net.Model.Finance.Intrastat.DeliveryTerms Having this business rule set up, when the event happens, it would set the delivery terms of the purchase invoice to 'FOB'."
  },
  "advanced/user-business-rules/examples/start-business-rule.html": {
    "href": "advanced/user-business-rules/examples/start-business-rule.html",
    "title": "How to start a business rule only on first releasing? | ERP.net Tech Docs",
    "keywords": "How to start a business rule only on first releasing? Sometimes a business case may require a certain business rule to be executed only on first releasing of the document. The calculated attributes are a tool, which when triggered performs their calculation in real time. This means that if we use a calculated attribute as a condition for a business rule, the condition may be fulfilled today, but not after a certain period of time. Let’s imagine that we use a business rule to allow releasing a sales order only if the lots used in its lines have not expired. The condition is fulfilled at the moment of the first releasing and the goods are delivered to the customer. But what if the released state of the sales order is reselected after a month, because of an adjustment of the document notes? The rule will be executed again and the adjustment may be impossible because some of the lots could have expired until this time. But in this case, the expiration of the lots is no longer important for us. To avoid such cases, we can set a business rule that will be triggered only when we are releasing the document for the first time, even though the business rules do not support a first releasing event parameter currently. We can create a calculated attribute (with a name 'IsFirstReleasing', for example) that check whether the releasing is first or not and returns 'true' or 'false'. For more information about the syntax of such attribute, see Check whether the releasing of the document is first or not? . We can later use this attribute as a Business rule condition '#IsFirstReleasing = true' which means the rule will be triggered only when the document is released for the first time and not when the released state is reselected."
  },
  "advanced/user-business-rules/examples/whole-quantity-validation.html": {
    "href": "advanced/user-business-rules/examples/whole-quantity-validation.html",
    "title": "Whole quantity validation | ERP.net Tech Docs",
    "keywords": "Whole quantity validation If the business requires whole numbers only, user defined business rule may be set to check the users work. For example - a validation of the sales order lines may be applied with the following data: Repository: Crm.Sales.SalesOrderLines Events - COMMIT Action - FAIL + Parameter1Type = Constant + Parameter1 Value = \"You have entered decimal number as a quantity. Please, check the data entered in the Sales order lines and try again!\" Conditions: check if the calculated attribute from the example in here is equal to 'false' When this user business rule is activated and if the user tries to release a sales order with the following lines: line 10 - product A - Quantity 5.05 line 20 - product B - Quantity 5.00 The system would return an error with the text we entered in the action of the user business rule - 'You have entered decimal number as a quantity. Please, check the data entered in the sales order lines and try again!' With this user business rule activated, and if the sales order has the following lines: line 10 - product A - Quantity 5.00 line 20 - product B - Quantity 5.00 The release of the document would be possible."
  },
  "advanced/user-business-rules/index.html": {
    "href": "advanced/user-business-rules/index.html",
    "title": "User business rules | ERP.net Tech Docs",
    "keywords": "User business rules These are business rules which a user defines on his own. They may be used to provide some kind of validation which is not available in the system business rules or to create working logic which is not currently available in the software. They may be registered on different layers - BackEnd and/or FrontEnd. The BackEnd means that the user business rule is processed on the server. A FrontEnd user business rule is processed in the client application. The user business rules consist of the following information: 'where?', 'when', and on 'what conditions?' something ('what?') should happen. They have the following information: Code - unique code of the rule; Name - the name of the user business rule; Repository Name - the name of the repository for which the business rule is defined. For example - invoices or invoice lines. Its value may be selected from a dropdown list and the value contains the path to the selected value, dot separated. For example: if the user needs to create user business rule so he can use it in the invoices forms or in the invoices navigators, the repository should be 'Crm.Invoicing.Invoices'. If the rule is created to be used in the invoice lines, then the repository should be 'Crm.Invoicing.InvoiceLines'; Notes - notes, comments, short information on the user business rules usage, purpose and more; IsActive - the user business rule may be activated and deactivated; Layer - currently this is unavailable. All user business rules are registered in the BackEnd layer. The events which need to happen for the user business rule to be activated are described in the User business rules - Events panel. It consists of the following information: Event type - the event for which to register the user business rule; Event parameter - registration parameter. The meaning of this parameter is determined by the type of the event; Execution priority - execution priority. Lowes values indicate earlier priorities. Possible values are: 30-Early, 50-Normal; 70-Late; Layer - currently this is unavailable. All events are events of the BackEnd layer. The conditions which have to be met when the event happen so the rule to be processed are entered as follows: Condition No - consecutive number of the condition, unique within the user business rule. Attribute name - the name of the attribute which will be validated in the condition. Comparison type - what is the comparison type. The available options are: =, !=, >=, <=, Like, IsNull, Value - the constant value to which the value of attribute (specified in the Attribute name) is compared to. So the condition is met when the value of the specified attribute and the specified value compose a true statement with the selected comparison type. For example, IsActive = True or Quantity < 100.0 and more. Note If there is more than one condition, the rule will be applied when all conditions are true. The actions which may be executed by the rule contain the following information: Action No - consecutive number of the action, unique within the user business rule; Action type - specifies the type of action to be performed by the rule. Possible values are: SETVALUE and FAIL . Parameter1 type, Parameter2 type, Parameter3 type - the type of the parameter specifies how to obtain the parameter value; Parameter1 value, Parameter2 value, Parameter3 value - the actual value of the parameter. Temporary Action types Advanced section AGGREGATE CLIENT COMMIT Allow a credit limit override when a client pays in cash Client commit COMMIT FAIL FormattedString How to set DeliveryTerms in purchase invoice? How to start a business rule only on first releasing? How to use business rules to set a value into a custom property? NOTIFYUSER Parameter types Q & A R28043 Valid icon format R28545 Script text max length R31067 Code (Code) SENDMAIL SETVALUE STATECHANGED STATECHANGING User Business Rules - Events User Business Rules - Examples VOIDING WARNING Whole quantity validation"
  },
  "advanced/user-business-rules/parameter-types/formattedstring.html": {
    "href": "advanced/user-business-rules/parameter-types/formattedstring.html",
    "title": "FormattedString | ERP.net Tech Docs",
    "keywords": "FormattedString Formatted string is a parameter type of the User Business Rules actions which is introduced in version 2020.1. This parameter represents a text which supports multi-line, variable interpolation, and variable formatting. It's typically used with the NOTIFYUSER businesses rule action. The functionalities which can be used in the value of the formatted string parameter are: escape charts The following are handled: \\n - newline - supported in the Body<br> \\r\\n - also new line - supported in the Body<br> \\{ - insert opening curly bracket '{' in output.<br> \\} - insert closing curly bracket '}' in output. <br> variable interpolation This allows specifying variables into a string using placeholders which when executed are replaced with their corresponding values. In the perspective of ERP.net those variables are the domain attributes - both system domain attributes and calculated attributes. When called the domain attribute value is calculated for the particular entity record for which the rule is executed. In order to specify a placeholder, a.k.a call a domain attribute in text, we must specify the domain attribute name in curly brackets '{...}'. Currently, the following options are supported: a. Attributes: {DocumentDate}, {#CalsulatedAttribute1}, {@CustomProperty1}. b. References: {Customer}. c. Reference path: {Customer.Party.PartyName}. Note that Child Collections are not supported. variable formatting The value of the domain attributes which is going to be loaded in the text can be formatted using format specifiers : {DocumentDate:dd-MM-yyyy}. Example: Using formatted string, this text Your web store has e new order!\\r\\n\\n\\{SUMMARY\\} \\nNumber: {DocumentNo}\\nOrder date: {DocumentDate:dd-MM-yyyy}\\nShipping address: {ShipToPartyContactMechanism.ContactMechanism.Name}\\nOrder total: {#CalculatedAttributeTotalSalesOrderAmount:C} will be returned as: Your web store has e new order! {SUMMARY}<br> order number: 00329<br> order date: 10-05-2019<br> shipping address: 21 Lombard St<br> delivery date: 12-05-2019<br> order total: $14.82<br>"
  },
  "advanced/user-business-rules/parameter-types/index.html": {
    "href": "advanced/user-business-rules/parameter-types/index.html",
    "title": "Parameter types | ERP.net Tech Docs",
    "keywords": "Parameter types Parameter types specify how to obtain a parameter value: Constant - when used, indicates that the Value for this parameter type would be a constant every time the rule is activated; Attribute - the value of the system or user-defined attribute; Reference - reference to another object; usually used with the attribute parameter type as a second parameter - and the attributes would be attributes of the referenced object and not of the current repository; ChildList - detailed objects, related to the current master object. FormattedString - A text which supports multi-line, variable interpolation, and variable formatting."
  },
  "advanced/user-business-rules/Q&A/index.html": {
    "href": "advanced/user-business-rules/Q&A/index.html",
    "title": "Q & A | ERP.net Tech Docs",
    "keywords": "Q & A How to use business rules to set a value into a custom property?"
  },
  "advanced/user-business-rules/Q&A/set-value-into-custom-property.html": {
    "href": "advanced/user-business-rules/Q&A/set-value-into-custom-property.html",
    "title": "How to use business rules to set a value into a custom property? | ERP.net Tech Docs",
    "keywords": "How to use business rules to set a value into a custom property? We can use business rules to set values into different fields, including custom properties action types . Currently, if we want to set a value into a custom property, we can either copy/get that value from another custom property or use an attribute/field/ constant whose data type is String. Example 1 - the value is copied from another Custom Property's value: If we want to copy a value from a specific Custom Property and set it as a value for another Custom Property in a sales order document, for example, then we can create a user business rule with the following data: Repository |:---- Crm.Sales.SalesOrders Events |:---- Event type Event parameter Execution priority Change of State RELEASING Normal Actions |:---- Action No Action type Parameter1 type Parameter1 value Parameter2 type Parameter2 value 1 SETVALUE Attribute @Property1 Attribute @Property2 Note Both Custom Property's Value and Custom Property's Description are copied. Note In this case, there are no limitations if the Custom Properties in which we set the value to inherit its allowed values from another entity or Custom Property. The only condition is the setting in both Custom Properties to be compatible according to the principles described in the topic Inheriting and copying custom properties . Example 2 - set a specific value that is not copied from another Custom Property's value: If we want to set a specific value (that is not copied from another Custom Property's value) for a Custom Property in a sales order document, then we can create a user business rule with the following data: Repository |:---- Crm.Sales.SalesOrders Events |:---- Event type Event parameter Execution priority Change of State RELEASING Normal Actions |:---- Action No Action type Parameter1 type Parameter1 value Parameter2 type Parameter2 value 1 SETVALUE Attribute @PropertyCode Constant 'StringValue01 Note Using this method, we can only set the Custom Property's Value and not its description. An exception is made when we are setting a value that is defined as a Property Allowed value. For more info, see the section below. Note Parameter2 Type is not limited to a Constant. We could use the attribute type as well and load the value from another system attribute or a calculated attribute . Note, however, that the value must be from a string type. If it is not, you can cast or convert it using a calculated attribute for the user business rule. But what if the custom property has allowed values, and we want to set one of them? This functionality is supported even when the custom property has allowed values, and we want to set one of them as a value of the particular property, but only if the property does not inherit its allowed values from another entity. When custom properties inherit their values from another custom property or their values are manually defined in the 'Property Allowed Values' panel - if one of these values is set by a business rule , it will be recognized as an allowed value for this property. In this case, the Allowed Value's description will be inherited as well."
  },
  "concepts/documents/adjustments.html": {
    "href": "concepts/documents/adjustments.html",
    "title": "Adjustments documents | ERP.net Tech Docs",
    "keywords": "Adjustments documents Using adjustment documents is a system to adjust released documents. As the released document states that the execution of the document has already started, therefore the released documents are read-only (see Document States ). So when there is a need to change such a document, the usual way of editing it is not available and a specific system is needed. The adjustment documents are separate documents trough which a released document can be edited. They contain the main document that they are making corrections on. So one released document may have more than one correction. The adjustment documents are allowed two ( Document states ) - New and Corrective . The Corrective state is specific only for the adjustment documents and it is not allowed at the rest of the documents. When the document state is switched from New to Corrective, the changes in the adjustment document are applied to the main released document. Then the field \"Adjustment number\" is filled in with the consecutive number of the correction. The adjustment documents contain only the changes which has to be applied. For example, if there is a released issuing Transaction with 10 PCS and it turns out that now only 8 PCS are issued, in this case, an adjustment issuing Transaction is executed with the quantity of -2 PCS . Thus, it can be considered that the adjustment document is the difference between the current values in the released document and the values, which have to be achieved after the correction. So the current data in every released document are a result of the original data (the document content when released for the first time) and the data added by all adjustment documents. This mechanism is preferred over the direct redaction of the released documents because of easier tracking of the separated corrections that are executed (tracking of these changes is important). For example, in the previous example with the transactions, the user may easily see that the quantity has been decreased by 2 PCS by the adjustment document. Otherwise, the user would have to compare the consecutive versions of the main document which may be a complicated and uncomfortable task, especially with large documents. Also, this mechanism allows the adjustment documents to be used for adjustment of Transitional documents and sub-documents. Adjustment document application The mechanism, when an adjustment document (when the document state is switched to Corrective) is applied on the main released document, is as follows: For each record in the adjustment document its corresponding record in the main document is searched. Matching the records is as follows: ​ a. if the record is in the adjustment document header, than the corresponding record is in the header of the main document; ​ b. if the record is in a row in the adjustment document then the record from the same row table in the main document is searched. The record should have the same natural key as the adjustment record; as natural key usually the document row number is used or another field (if there is no row number); for example, if in the adjustment document there is a row with number 30 , then in the main document a row in the same table and with the same number 30 is searched. If no corresponding record is found in the main document (this is possible only if the current record is in the rows of the adjustment document), then the adjustment record is simply added to the corresponding table in the main document with no changes in it; If a corresponding record is found in the main document, then the system reviews all the fields in the correction record and the following applies to each field: ​ a. if the field is a key field (see the article about Key and Scalar-Valued Fields), then it is checked if it has the same value in the main document and in the adjustment document; if there is a difference, the adjustment is rolled back, and the user is notified by an error message; ​ b. if the field is scalar-valued (see the article about Key and Scalar-Valued Fields), then the value of the adjustment record is added to the value of the main record; ​ c. if the field is neither key nor scalar-valued , then the value of the main record is replaced by the value of the adjustment record. Thus, in the adjustment document, only the changes in the main document are marked. I.e. the user can decrease or increase the value of a scalar-valued field (quantity or amount) or change/replace the value of a field that is neither key nor scalar-valued. Note Key fields cannot be adjusted by adjustment documents! Also if the adjustment document has no record corresponding to a record in the main document, then the original document will not be changed after the correction takes place. For example, if in the main document there is a row with a number 30 , and in the adjustment document there is no such row, then row 30 from the main document will remain unchanged after the correction. What can be done by adjustment documents? Can adjust values of non-key fields (the scalar-valued fields are adjusted by adding the value in the adjustment document, and the rest of the fields are adjusted by replacing the value with the one from the adjustment document); New records can be added in row tables; All scalar-valued fields in a row can be reset (so the row will no longer affect the document behavior). What cannot be done by adjustment documents? A value of a key field cannot be changed; A row cannot be deleted. Special types of adjustment documents There are some special types of adjustment documents in ERP.net, which are prepared by the system and the user does not have to fill the scalar values in them. Such types are the Nullify corrections . They are accessible in all documents and are used to adjust all scalar-valued fields so they become 0 . By this correction, the document no longer \"has value\" (i.e. it does not order or fulfill any quantities or amounts). This is an alternative to document voidance. For the Receiving orders there two special types of adjustments - Correction according to stored quantities and Correction according to invoiced quantity . The first type automatically calculates the necessary correction so the quantities in the Receiving Order become equal to the quantities from the current Receiving Order which are receipts in the store. This correction is used to eliminate the difference between the Receiving Order and its Transactions. The second type is used to equalize the quantities in the Receiving Order as they are in the Purchase invoices, created for the current Receiving order."
  },
  "concepts/documents/display.html": {
    "href": "concepts/documents/display.html",
    "title": "Display and search document and line numbers | ERP.net Tech Docs",
    "keywords": "Display and search document and line numbers 1. Displaying document and line numbers a) The general format for displaying document and line numbers is: < DocTypeCode > : < DocNumber > : < LineNumber > - < DocTypeName > For example, let's have the following: The document type is ‘Sales order’, with code ‘SO’ The document number is ‘00503’ The line number is 120 (the line numbers are integers) This will be represented as: SO:00503:120 - Sales order b) If we have to display only a document number (without line number), the format is the following: < DocTypeCode > : < DocNumber > - < DocTypeName > Now, let's have the following: The document type is ‘Sales order’, with code ‘SO’ The document number is ‘00503’ This will be represented as: SO:00503 - Sales order 2. Sorting lists of documents and line numbers When a list containing document and line numbers is sorted, the order is the following: First, sort lexicographically by \"DocTypeCode\" Then, sort lexicographically by \"DocNumber\" Then, sort numerically by \"LineNumber\" (if applicable) 3. Searching through document and line numbers When a user wants to find a document or a specific document line, they enter a search term. The following rules apply: a) Generally, a search is processed in the same format as the display text < DocTypeSearchTerm > : < DocNumberSearchTerm > : < LineNumberSearchTerm > For example, searching for ‘SO:00503:120’ will find and match ‘O:00503:120’ and nothing else. This is a non-wildcard search and is the fastest search. It is usually used when a value is pasted in a user application. b) Some of the search terms might be missing We can search for ‘SO:00503’ and this will match all lines from ‘SO:00503’, e.g. ‘SO:00503:10’, ‘SO:00503:20’, etc. If the search contains only one search term and does not contain colon (':'), it will be performed over the document number! Searching for '00503' will find 'SO:00503'. But searching for 'SO' will NOT match 'SO:00503', because 'SO' would not be found among the document numbers (unless there is a document with the number 'SO'). c) Some of the search terms might contain a wildcard symbol (%) The \"DocTypeSearchTerm\" and \"DocNumberSearchTerm\" can contain the wildcard symbol and it will perform a wildcard search. However, the \"LineNumberSearchTerm\" cannot contain wildcard symbol and will not perform a wildcard search. The system wildcard symbol is '%'. In the user applications, the generally accepted symbol is ' ' (space). 4. Examples System search term User Application Visualization Description S%:%503 'S : 503' • Document types, starting with 'S'. • Document Numbers, finishing with '503' SO:%503 'SO: 503' • Document type with code 'SO'. • Document Numbers, finishing with '503' SO:%503:10 'SO: 503:10' • Document type with code 'SO'. • Document Numbers, finishing with '503'. • Line Number 10 (line numbers do not support wildcard search) ::10 '::10' • All lines in all documents, with line number = 10 SO::10 'SO::10' • Document type with code 'SO'. • All lines, with line number = 10 :%503% ': 503 ' • All documents, with numbers, containing '503'. This could be specified simpler, as in the following example: %503% ' 503 ' Because there are no colons (':'), the search term is applied to the document number. • All documents, with number, containing '503'. Note: If you want to search by document type only, append a colon at the end of the search string, as in the following example: SO: 'SO:' • All documents (and lines) for document type with code = 'SO' SO:: 'SO::' (same as above). • All documents (and lines) for document type with code = 'SO' When searching in large databases, DO NOT put a wildcard symbol in front of the document number. Search for '0047858%' instead of '%47858%'. In a user application, search for '0047858' instead of ' 47858'. The difference in speed might be substantial. Performance tests have shown 0.2 sec for '0047858%', against 120 sec for '%47858%' in a database with 50 million documents. This recommendation is only for the document number. The document type code can contain wildcard symbols in any position and this does not affect performance."
  },
  "concepts/documents/index.html": {
    "href": "concepts/documents/index.html",
    "title": "Documents | ERP.net Tech Docs",
    "keywords": "Documents Description Documents are one of the three main categories of entities in ERP.net. They represent things that have occurred or will occur. The main categories are: Documents - facts; things that occur: Sales orders, invoices, purchase orders, etc. Definitions - they represent real-world objects; things that (generally) do not change: Customers, Products, Stores, etc. Settings - system-related; data about the way the system works: Document types, Document routes, Form views, etc. The most important attributes All documents derive from a base entity type called Document and share similar attributes. This is a non-extensive list of the more important attributes: Enterprise company - the company that created the document. Company location - the company location where the document was created. Document date - the date the document was constituted. If it was created electronically, then this is the system date of creation. When it is created outside the system and entered post-factum, the attribute contains the date of actual creation. Document type - a user-defined document type for classification of the documents. Also defines print-out forms, document flow and other rules. Document number - a unique number within the sequence, defined in Document type. Usually created by the system, but can also be set up to accept manual entry or import from external sources. State - each document in the system has a current state at any given moment. It affects how the document influences the system and whether it is updateable. Currency directory - the primary directory for currency rates which will be used for currency conversions throughout the document. Further reading: States Display and choose Adjustments Advanced topics: Document flow Document amounts"
  },
  "concepts/documents/states.html": {
    "href": "concepts/documents/states.html",
    "title": "Document states | ERP.net Tech Docs",
    "keywords": "Document states Description The documents in the system have a current STATE. This state determines the effect on the system and whether the document can be updated. The allowed states of the document are: New - the document is entered and saved in the system but does not affect (on planning, availability, etc.) Planned - the document is planned automatically by the system to occur at some point in the future Firm Planned - the document is planned to occur at some point in the future by a user. Firm Planned status is automatically set by the system if a user edits a Planned document. Released - the document is released for execution. The responsible party starts to execute it. Completed - the activities of the document are finished. Sometimes this state is also referred to as \"Finished\". Closed - the document is verified and no more changes are expected in it. Document editing rules Whether a document can be edited by a user depends on its state: New - the document can be edited freely. Planned - the document can be edited, but if you save the changes, the state will automatically change to Firm Planned (see below). Firm Planned - the document can be edited. Released - the document can no longer be edited, but an adjustment document can be created and applied (see heading below). Completed - the document cannot be changed, but its state can be returned to Released. Closed - the document cannot be changed, but its state can be returned to Completed. Planned documents reflect a plan, created automatically by the system. On the next planning run, planned documents are usually erased or voided (actually the system tries to erase them, but if they use sequence generators, they can only be voided, not erased). The Firm Planned state helps avoid the voiding. When a user makes changes to Planned document, the system changes the state automatically to Firm Planned in order to protect the user changes before the next planning run. Note Planned sub-documents are also erased or voided when a parent document state changes. This behavior is system defined and cannot be changed. Planned documents can only be protected from voiding by making them Firm Planned. Rules for changing document state Changing the document state usually goes straight, from New to Closed. However, sometimes it might be needed to revert back to the previous state. The following table shows when this is allowed: Old State New State Allowed Planned New Allowed Firm Planned Planned Allowed Released Firm Planned Not Allowed Completed Released Allowed Closed Completed Allowed There is a borderline at the Released state - once reached, the state cannot be reverted. The document can only be voided. Adjustment documents Adjustment documents are documents, which adjust other documents. Adjustments can be made only on documents, which are in the Released or Completed states. Adjustment documents can change only primary measurement values. They are usually used to increase or decrease quantities and/or amounts of released documents. Adjustment documents are separate documents, but when applied to a main document, they change its internal values. If an adjusted document is opened on the screen, it will look like it always has been adjusted. The previous versions of the document are securely stored and can be revealed by the document history. The adjustment documents come in effect (e.g. change the main document) when their state is changed to the special \"Adjustment state\". As these documents are only used to adjust other documents, they cannot have parent and/or child documents. Planning only Some documents are created specifically only for planning purposes. They are not intended to be ever released. There is a special flag, which signals this intention to the system, called \"Planning Only\". When this flag is set, the system would allow only New and Planned states for the document. No upper states would be allowed by the system. Usually, the document is later voided by its creator (when the plan changes or actual execution is about to begin). User-defined document statuses Each document type can contain user-defined sub-statuses to the system states. For example, one can define the following user statuses for a document type, called \"Direct Production Order\": Document Type(user defined) Document State(system defined) User Status(user defined) Exit Status(Yes/No) Document Type(user defined) Document State(system defined) User Status(user defined) Exit Status(Yes/No) Direct Production Order New Direct Production Order Planned Direct Production Order Firm Planned For Processing Direct Production Order Firm Planned Needs Check Direct Production Order Firm Planned Needs Approval Direct Production Order Firm Planned Approved Yes Direct Production Order Released Started Direct Production Order Released Tested Yes Direct Production Order Completed Direct Production Order Closed Each system state can have as many user statuses, as needed. As shown in the table above, one of the user statuses within each system state can be defined as Exit Status. The Exit Status is required to be reached to move to the next system state. In the example above, in order to release a direct production order, the Firm Planned/Approved state must first be set. This creates a control point for moving ahead of the state. Note The exit User status-es are usually secured, so that only the authorized users can set them."
  },
  "concepts/erp-instances.html": {
    "href": "concepts/erp-instances.html",
    "title": "ERP Instances | ERP.net Tech Docs",
    "keywords": "ERP Instances The ERP.net service is a hosted ERP service. Accessing the data is done through ERP Instances. When you sign up at erp.net , you can create and manage a new ERP Instance. An ERP Instance is a tenant in the hosting environment. It is multi-company, e.g. it allows managing multiple related legal entities (companies) in one instance. You don't need to create separate instances for each managed company. Each ERP Instance has a unique name. The instance can be accessed at: https://<<instance_name>>.my.erp.net For example, the demonstration database, DEMODB, is located at: https://demodb.my.erp.net"
  },
  "concepts/index.html": {
    "href": "concepts/index.html",
    "title": "Business logic concepts | ERP.net Tech Docs",
    "keywords": "Business logic concepts This section contains concepts, applicable to all modules."
  },
  "concepts/multi-company.html": {
    "href": "concepts/multi-company.html",
    "title": "Multi-company support in ERP instances | ERP.net Tech Docs",
    "keywords": "Multi-company support in ERP instances ERP.net allows a single ERP instance (database) to contain multiple companies. The different own companies, stored in the database are called 'Enterprise companies'. Many data objects (definitions, settings and documents) have an enterprise company attribute. When filled, it specifies that the data is specific to one of the enterprise companies. When the attribute is left blank, the data is valid for all enterprise companies. Some data objects have a required enterprise company attribute. In this case, the data is always specific to one enterprise company. For example, all documents have a required enterprise company attribute. For example, lets have the following accounts in our chart of accounts: 60201 - Expenses, general 60209 - Other expenses (specific to \"Company X\", one of the companies, managed in the database) This can be defined as follows: Account Enterprise Company 60201 60209 Company X In much the same way, the products and many other definitions can be defined to belong to only a single enterprise company or to all enterprise companies. Note There is no way to define a data object to belong to several enterprise companies. It is either one or all."
  },
  "concepts/multi-language.html": {
    "href": "concepts/multi-language.html",
    "title": "Multi-language support | ERP.net Tech Docs",
    "keywords": "Multi-language support Description Many string attributes in ERP.net support saving the data in multiple languages. These attributes are called Multi-language Strings. For example, the product name of a product can be entered in many languages simultaneously. When visualizing the data, the correct language version of the string is displayed automatically by the system, depending on the current user language. Note For reports, the report designer can specify whether to use the current user language or always use a fixed language. For example, for a Portuguese invoice, one would require that the labels and data are always displayed in Portuguese. Entering data in multiple languages The client applications of ERP.net usually allow the following abilities regarding multi-language strings: Enter the string in many languages Transliterate a string from one language to another (or all) Translate a string from one language to another (or all) When entering translations for a multi-language string, the client application usually displays a table with cells for each language translation, similar to this: Language Value EN: Toothpaste DE: Zahnpasta Depending on the client application, translation can sometimes also be automated. Some client applications support using an online service, like Google Translate to automatically translate a string to other languages. Translation is better suited to Description and Notes attributes. Transliteration Transliteration is the process of translating one language version of a string to another, based on the sounding of the string. Transliteration works great for person and company names and addresses. It allows branch offices to work in their local language and reports can still be shown in the corporate language. For example, the Russian word \"Иван\" would be transliterated in English as \"Ivan\". Transliteration works in two ways - manual and automatic. Manual transliteration \"Manual\" transliteration is actually automatic, but is initiated manually while editing the different language versions of a multi-language string. While editing multi-language string, the client application usually provides a function button, which transliterates the current language version to other languages. Automatic transliteration Automatic transliteration occurs when the system needs to display some a multi-language string in some language, but that specific language translation is not saved in the database. For example, suppose one employee works in a branch office in Russia and enters \"Иван\" as a person first name. The database saves only the Russian language version. Then another employee at a UK location requests to see the first name of the same person. The system would automatically transliterate the string and display it as \"Ivan\". Note Transliteration works optimally between Latin and Cyrillic."
  },
  "concepts/parties-concepts.html": {
    "href": "concepts/parties-concepts.html",
    "title": "Parties concepts | ERP.net Tech Docs",
    "keywords": "Parties concepts Description Parties in ERP.net are one of the most widely used definition. Generally, a party is a participant in any business relations or transaction. Examples of parties include: Business customers Consumer customers Employees in our or external companies Contacts Dealers Company locations Departments etc... Basic party types Parties do not exist by their own. They are always created as another object. Most parties are created as Person or Company. In object terms, it means that Person and Company inherit Party. The Party itself is called to be of type Person or Company. Note Parties cannot be directly created. They are always instantiated as some sub-type, like Person or Company. This diagram shows the relationship between Party, Person and Company: Party attributes inheritance The fact, that Person and Company inherit Party also means, that all attributes of Party are also attributes of Person and Company. For example, a Party has an Area attribute. So, all Person and Company objects would also have an \"Area\" attribute. The opposite is not true. E.g. Person and Company objects have attributes, which are specific to them and are not general Party attributes. For example: Party has Parent Party and Area attributes, which are inherited by Company and Person. But person's \"First name\" and \"Last name\" are specific only to persons. Neither companies nor generally parties have \"First name\". Relationships with other entity types Although parties do not exist on their own, they can participate in relationships. For example, a Customer or Supplier contract are objects, which can have a relationship with a Party. Relationship with Party means, that an actual customer contract object would relate to either a Person or a Company. This is shown on the following diagram: Note Customer (contract), Supplier (contract) and Dealership (contract) are actually called simply Customer, Supplier and Dealer in ERP.net. Note The diagram shows, that one Party object can participate in relationships with many Customer contract objects. In fact, however, the current implementation of ERP.net allows many Customer contracts per Party, but only one for each enterprise company. This means, that one party can have only a single customer contract with any given enterprise company. To clarify the above diagrams, lets provide an example. Suppose we have: A customer, which is a company, called \"ABC\" A supplier, which is a person, named \"John\" This will be represented with the following objects: Party (ABC) Company (ABC), which inherits Party (ABC) Customer (ABC), which points to Party (ABC) Party (John) Person (John), which inherits from Party (John) Supplier (John), which points to Party (John) If we query the system with a query, that can be stated as \"Show me ALL parties\", the result will be: Party (ABC) Party (John) If we query with \"Show me ALL customers\", the result will be: Customer (ABC) Party hierachy The basic party types are Person and Company, but there are some more party types. Among them are Department and Division. By using all the party types, the data about parties can be nicely organized. Particularly handy is the ability to hierarchically structure the parties. Having the departments and divisions as parties allows flexible representation of the different corporate hierarchies. For example, let's have Corporation A structured in the following way: Corporation A Division 1 Sales Department Marketing Department Division 2 Sales Department Marketing Department Global Marketing Department Global Accounting Department The flexible party hierarchy also allows structuring even different companies in a corporation: Corporation B Company A Consumer Electronics Division Sales Department Business Consulting Division Sales Department Accounting Department Company B Sales Department Accounting Department Corporate Financials Department Note Because our own enterprise companies Multi-Company are also companies (which are parties), party hierarchy can be used for organizing both our own corporate structure and the corporate structure of our business partners. Party relationships Party relationships organize the formal and informal relationships between different parties. Using party relationships, information, such as the following can be easily represented: Peter works for Company A Peter is a friend of George Steven is married to Susan since 8/3/2011 John worked for Company B from 1/1/2010 till 3/5/2015 The above information is represented in a table in the following way: From Party Relationship Type To Party From Date To Date Notes Peter works for Company A Peter is friend with George Steven is husband of Susan 8/3/2011 John works for Company B 1/1/2010 3/5/2015 Obviously, From Date and To Date represent the dates when the relationship was established and terminated."
  },
  "includes/erpnet.html": {
    "href": "includes/erpnet.html",
    "title": "| ERP.net Tech Docs",
    "keywords": "ERP.net"
  },
  "includes/name.html": {
    "href": "includes/name.html",
    "title": "| ERP.net Tech Docs",
    "keywords": "ERP.net"
  },
  "includes/webclient.html": {
    "href": "includes/webclient.html",
    "title": "| ERP.net Tech Docs",
    "keywords": "Web Client"
  },
  "includes/webclientfull.html": {
    "href": "includes/webclientfull.html",
    "title": "| ERP.net Tech Docs",
    "keywords": "ERP.net Web Client"
  },
  "includes/winclient.html": {
    "href": "includes/winclient.html",
    "title": "| ERP.net Tech Docs",
    "keywords": "Windows Client"
  },
  "includes/winclientfull.html": {
    "href": "includes/winclientfull.html",
    "title": "| ERP.net Tech Docs",
    "keywords": "ERP.net Windows Desktop Client"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to the ERP.net Technical Documentation | ERP.net Tech Docs",
    "keywords": "Welcome to the ERP.net Technical Documentation The Technical Documentation documents the business logic of ERP.net. It is targeted towards implementation consultants and power users. Learn more Concepts - general concepts, which apply to all modules. Functionality - documentation of the business functions. Advanced - documentation of advanced systems. Other documentations Data model - reference information about the entities, business rules, generations, etc. Developer documentation - information for developers."
  },
  "modules/applications/data-warehouse/index.html": {
    "href": "modules/applications/data-warehouse/index.html",
    "title": "Data warehouse | ERP.net Tech Docs",
    "keywords": "Data warehouse Data warehouse is a large storage of data coming from a wide range of company sources and used to guide management decisions. It helps in reporting and data analysis and is considered a core component of business intelligence. Currently, in the ERP.net platform, the following tools are implemented: data measures , grouped into data measure groups. data values , entered in for the different measures. Data measure groups are accompanying attributes, allowing data to be ordered by the users and structured in a hierarchy. Data measures are declared for a period . The period may be a day, month or year. It defines the allowed spread: a +/- percent by which the goal could be missed but still considered achieved. Data value is actually a fact. It represents the real value of a data measure for a specified date. Usually, this is the first day of the period of the data measure. It also holds a target value and an actual value. Data values support enterprise companies (for more information, see Multi-company ). Together, Data measures and Data values support custom properties . Values may be entered on a daily, monthly or yearly basis by the user, an application or other. They may also be entered by multiple sources at the same time. Data warehouse is after that used in the ERP.net BI. An external BI also may be used. Further reference: Data measure groups business rules"
  },
  "modules/applications/enterprise-asset-management/index.html": {
    "href": "modules/applications/enterprise-asset-management/index.html",
    "title": "Enterprise asset management | ERP.net Tech Docs",
    "keywords": "Enterprise asset management Description From Wikipedia: Enterprise asset management (EAM) involves the maintenance management of an organization’s physical assets throughout each asset's lifecycle. EAM is used to plan, optimize, execute, and track the needed maintenance activities with the associated priorities, skills, materials, tools, and information. This covers the design, construction, commissioning, operations, maintenance and decommissioning or replacement of plant, equipment and facilities. You can learn more at: https://en.wikipedia.org/wiki/Enterprise_asset_management In ERP.net, the EAM deals with the maintenance and locations of the company assets. In the following sections, we will describe the different entity types, comprising the EAM data model. Maintenance types When planning the required maintenance for an asset, there are different types of maintenance that can be required. For example, if we have a car, we can plan: Insurance renewal - once per year Oil change - each 20,000 km Gearbox check - every 5 years OR 100,000 km Each of the above maintenances represents a different maintenance type . In an enterprise, there might be many different types of assets. Each type of asset requires different maintenance types. Some maintenance types might be applicable for multiple asset types and others - unique for specific asset types. There might be many maintenance types and they need to be organized. That is why, there is the hierarchical organization, called Maintenance type groups . Asset types In an enterprise, there might be many assets, which need to be managed. However, the different types of assets need different kinds of management. For this reason, we can define different asset types . Example asset types: Car Heavy truck Aircraft Building Street lamp Computer Asset type - tracked parameters For each asset type, we can track different parameters. For example: Car Mileage (in km) Heavy truck Mileage (in km) Cycles Airplane Flight hours Cycles The tracked parameters are used to track the usage and wearing out of the asset and hence plan the desired maintenance. Asset type - maintenance mypes For each asset type, we define what kind of maintenance is needed for the assets of that type. Also, we can define a default schedule. For example: Car Insurance - Every 12 months Oil - Every 15,000 km Gearbox Heavy truck Insurance - Every 12 months Oil - Every 30,000 km Gearbox Refrigerating compartment check etc. Aircraft A-Check - Every 200 cycles B-Check - Every 6 months C-Check - Every 20 months D-Check - Every 80 months Note You can see here that although both cars and heavy trucks need oil change, the required mileage is different. In practice, every car and truck might have even different mileage requirements. Service centers When planning the maintenance of the assets, the different maintenances are executed by different service centers . Then, each maintenance schedule for an asset is assigned to a different service center. The service center might be an authorized service center for the asset. But it might also be an employee(s), executing the desired maintenance. Managed assets Finally, we can define every asset, the maintenance of which will be managed by the application. The asset can be defined in other parts of the ERP - as fixed asset, as vehicle (in Fleet management), etc. Defining the asset in the EAM application as managed asset , allows its maintenance to be managed. Example managed assets: Car Peugeot 508, Y2016, Reg.No. CC0303PM Car Jeep Grand Cherokee, Y2017, Reg.No.YY0202PS Mobile Station 5011, Address:...etc. Because there might be many managed assets, they are organized in a hierarchy of managed asset groups . Managed assets - maintenance schedules When an asset is defined as specific asset type , it inherits some default maintenance schedules. However, each asset might be of different age and wear and might have unique maintenance needs. Hence, the specific maintenance schedules of each specific managed asset are defined in Managed asset maintenance schedules . For example: Car Peugeot 508, Y2016, Reg.No. CC0303PM Insurance - Every 12 months Oil - Every 18,000 km Car Jeep Grand Cherokee, Y2017, Reg.No.YY0202PS Insurance - Every 12 months Oil - Every 20,000 km Managed assets - scheduled maintenances The maintenance schedules define the general plan for maintenance. However, we have to schedule each specific maintenance as well. The scheduling might be for different reasons: The time limit after the last maintenance was reached (by date). The mileage for the next maintenance was reached (by tracked parameter). The asset was purchased second hand and one initial maintenance should be scheduled after up to 20 days (manually planned). Each of the above represents a Managed asset maintenance schedules . They can be both manually entered or automatically planned. Note Emergency repair is not planned hence it is not scheduled maintenance. Emergency repairs are directly processed through Maintenance orders (which will be shortly presented). Managed assets - locations The EAM module allows the tracking of asset assignments to different company locations and responsible persons. Assets can also be re-assigned multiple times (even within a month). Note Asset assignment can be used to determine the cost centers to which the depreciation will be distributed. Asset locations contains data about each assignment: Date of assignment Company location Responsible person Notes - for more precise location or other notes. Maintenance orders The maintenance order document is the final data piece in the EAM data model. It represents one concrete appointment for a specific type of maintenance(s) for one (or many) specific asset(s). It is created by the maintenance planner to denote the actual appointment with the service center. The statuses of the maintenance order correspond to the progress of the maintenance: Firm Planned - the maintenance is appointed with the service center for specific time and date. Released - the maintenance has started (used mostly for maintenances which are performed in-house) Completed - the maintenance was performed. Maintenance orders can create other sub-documents to represent the actual work (like service orders) or the materials requested and used (store order / store transaction), etc. Maintenance order - lines One maintenance order can appoint at once the maintenance of many managed assets. Each maintenance type for each asset is represented with one maintenance order line ."
  },
  "modules/applications/overview.html": {
    "href": "modules/applications/overview.html",
    "title": "ERP.net Integrated applications | ERP.net Tech Docs",
    "keywords": "ERP.net Integrated applications ERP.net contains various built-in applications."
  },
  "modules/applications/service/index.html": {
    "href": "modules/applications/service/index.html",
    "title": "Service | ERP.net Tech Docs",
    "keywords": "Service"
  },
  "modules/applications/service/non-agreed-services-and-materials.html": {
    "href": "modules/applications/service/non-agreed-services-and-materials.html",
    "title": "Non agreed services and materials | ERP.net Tech Docs",
    "keywords": "Non agreed services and materials When a service activity creates store order, in order to invoice the used materials and the services which are performed, the sales orders have to include the non-agreed quantities of the materials and the services. The rest of the materials and services are covered by the guarantee, which is agreed in the service agreements. The current topic describes the calculation of the non agreed services and materials based on the data in a service activity. The agreed services and materials are listed in the service agreements, in the ServiceAgreementService and ServiceAgreementMaterial tables. After that the quantities which are listed in there are distributed through the service activities. When a service activity is released, what part of the agreed quantities has not been used by the previous service activities is calculated and the result (the remaining quantities) is distributed in the current document (only if the remaining quantities are not greater than the used quantities recorded in the current document). The distributed quantities are recorded in the Distributed Service Agreement Materials and Distributed Service Agreement Services tables. After all, the non-agreed materials and services are calculated by subtracting the quantities from those tables from the quantities in the current service activity. Non agreed materials For each Material line in the current service activity all records from Distributed Service Agreement Materials table which correspond the current line are derived. The amounts from the Agreed Quantity column are summed up (converted to the measurement unit of the material in the service activity line; the values in Agreed Quantity column are in measurement unit of the service agreement) and the sum is subtracted from the quantity in the current line (only if the sum is not greater than the quantity in the current line). This is the calculation: [**non-agreed material quantity**] = if [**Service Activity Material Quantity**] >= [**sum of distributed service agreement materials**] then [**Service Activity Material Quantity**] - [**sum of distributed service agreement materials**] else **0** Example 1: There is a service activity with three lines with materials: line #10, Material #1, 10PCS ; line #20, Material #2, 13PCS ; line #30, Material #3, 40PCS . Distributed Service Agreement Materials table has the following data: line #20 from the Service Activity, line #70 from Service Agreement #00007, 4PCS ; line #20 from the Service Activity, line #30 from Service Agreement #00019, 11PCS ; line #30 from the Service Activity, line #10 from Service Agreement #00007, 48KG . Thus, for line #10 from the Service Activity the distributed quantity is 0PCS , for line #20 from the Service Activity the distributed quantity is 15PCS , and if Material #3 has the following dimension: 3KG = 1PCS, than for line #30 the sum is 16 PCS. Thus, the non agreed quantities are calculated s follows: for line #10: [non agreed quantity of the material] = 10PCS - 0PCS = 10PCS; for line #20: [non agreed quantity of the material] = 0PCS (because 13PCS < 15PCS); for line #30: [non agreed quantity of the material] = 40PCS - 16PCS = 24PCS; Non agreed services The services are not invoices directly as they are not products, so to invoice them the information in service invoicing from the service definition is used. So, for each service activity line with service and for each record in service invoicing the following quantity of the product from the service invoicing records, is calculated: [**quantity to invoice**] = [**Service Activity Service Quantity**] * [**ServiceInvoicing.QuantityOfProduct**] / [**ServiceInvoicing.QuantityOfService**] The distributed quantities from the service agreements which correspond the current service line are subtracted from the described above quantity to invoice . But this is performed in two stages as in the service agreements there are two methods to describe agreements for services - one is to agree on a certain number of the service , and the second is to agree on certain number from the product from the service invoicing . Thus the non-agreed quantity of a specific product which invoices a specific service (i.e. a product listed in the Service Invoicing table of the service definition), happens by the following two formulas: At first, what quantity is not agreed by service agreements is calculated. This happens as all distributed quantities for the specified line listed in the Distributed Service Agreement Services table (but only records which are on specific service agreements where the service attribute is selected and service product attribute is null) are subtracted from the quantity from the Service Activity line. The following temporary value is calculated: [**preliminary quantity 1**] = if [**Service Activity Service Quantity**] >= [**sum of distributed service agreement services**] then [**Service Activity Service Quantity**] - [**sum of distributed service agreement services**] else **0** Using this preliminary quantity 1 for each product in service invoicing in the service definition a preliminary quantity for invoice is calculated: [**preliminary quantity** **2**] = [**preliminary quantity** **1**] * [**ServiceInvoicing.QuantityOfProduct**] / [**ServiceInvoicing.QuantityOfService**] And at the end, from the sum of distributed service agreement services which are for the same product and for which we have calculated the preliminary quantity, the calculated preliminary quantity 2 is subtracted. But only for quantities which are based on Service Agreements lines and which have empty service attribute and not null product attribute. Also, the distributed quantities are always converted to the measurement unit which is selected in the Service Invoicing record (as the measurement unit in the service agreement may be different). So: [**non agreed quantity of a product for invoicing**] = if [**preliminary quantity** **2**] >= [**sum of the distributed quantities of the product from Service Agreements**] then [**preliminary quantity** **2**] - [**sum of the distributed quantities of the product from Service Agreements**] else **0** Example 2: Lets have Service #1 with the following Service Invoicing data: 1 PCS of Service = 2 PCS of Product #1; 2 PCS of Service = 3 PCS of Product #2. And for Service #2, the invoicing products are: 1 PCS of Service= 4 PCS of Product #1; 1 PCS of Service= 10 PCS of Product #3. There is Service Activity with the following services: line #10, Service #1, 6PCS ; line #20, Service #2, 8PCS . Distributed Service Agreement Services table contains the following: line #10 of the Service Activity, line #40 (with Service #1) from Service Agreement #00023, 2PCS ; line #20 of the Service Activity, line #50 with Service #2) from Service Agreement #00023, 3PCS ; line #20 of the Service Activity, line #30 (with Service Product #3) from Service Agreement #00037, 78KG . So the first preliminary quantity is calculated as follows: for line #10: [preliminary quantity 1] = 6PCS - 2PCS = 4PCS ; for line #20: [preliminary quantity 1] = 8PCS - 3PCS = 5PCS . Then the preliminary quantity for invoicing is: for line #10 and Product #1: [preliminary quantity 2] = 4PCS * 2PCS / 1PCS = 8PCS ; for line #10 and Product #2: [preliminary quantity 2] = 4PCS * 3PCS / 2PCS = 6PCS ; for line #20 and Product #1: [preliminary quantity 2] = 5PCS * 4PCS / 1PCS = 20PCS ; for line #20 and Product #3: [preliminary quantity 2] = 5PCS * 10PCS / 1PCS = 50PCS . And at the end, if the dimensions of Product #3 are 3KG = 1PCS, the final calculations are: for line #10 and Product #1: [non agreed quantity] = 8PCS - 0PCS = 8PCS ; for line #10 and Product #2: [non agreed quantity] = 6PCS - 0PCS = 6PCS ; for line #20 and Product #1: [non agreed quantity] = 20PCS - 0PCS = 20PCS ; for line #20 and Product #3: [non agreed quantity] = 50PCS - 26PCS = 34PCS ."
  },
  "modules/community/case-management.html": {
    "href": "modules/community/case-management.html",
    "title": "Case Management | ERP.net Tech Docs",
    "keywords": "Case Management This module deals with the management of cases. It resembles both ticket management (like ZenDesk) and case management (like Jira and FogBugz). Currently under development."
  },
  "modules/community/digital-marketplace.html": {
    "href": "modules/community/digital-marketplace.html",
    "title": "Digital marketplace | ERP.net Tech Docs",
    "keywords": "Digital marketplace A digital marketplace is where developers publish apps for the end-users. When an app is activated (installed) on a user device, it is granted certain permissions to access the device resources. The marketplace can, but not necessarily, include functionality for downloading and embedding the app on the device. It resembles the way iOS and Android provide apps and other content with access to your phone. The main entities are: Marketplace - where developers publish and end-users obtain (install) apps. Each marketplace operates only for a single device type (class). Marketplace app - a third-party app listed on a marketplace and published by an app developer. It manifests a set of permissions which might require functioning. An app can have multiple media resources attached to it. They can be used to display media to the end-user. Marketplace app permission - permission which an app might require. There are pre-installed permissions required before installation. Some permissions might be post-install and optional. Each app permission is of Marketplace Permission Type. Marketplace app review - a review and star rating coming from a user who has installed the app. Uses the Social Interactions module for comments and reactions. Marketplace app license type - a type of license which can be provided for an installed instance of an app. Some license types allow only a 0 or 1 license qty, while others allow multiple licenses (for example, for any maximum limit of the license). Marketplace permission type - permission which can be granted to an installed application. Each permission type has a permission key - a unique string identifying the permission. User device - a device under the user's control. It can be a phone, computer, database, service, user account (in a social network) or anything else which allows secure access for apps to its resources. User device app - an app from a marketplace installed and granted permission to access a device. User device app permission - permission granted to a specific app for a specific user device. User device app license - a license granted to a user using an app on the device. The app can request its license data through an API call. It is up to the app to limit its usage, based on license information. App developer - a developer account. This is a third-party organization developing applications for a marketplace. Each marketplace has a different set of approved app developers. App developer users - user accounts which have access to an App Developer account. Users can be admins, developers (editing app resources) and moderators (interacting with app users). The user (and his role) can be for the whole developer account, or just for a single app."
  },
  "modules/community/index.html": {
    "href": "modules/community/index.html",
    "title": "Community | ERP.net Tech Docs",
    "keywords": "Community Community management is the management of the community of a company. This includes all sites, forums, ticketing and support systems, etc. as well as social interaction between all internal and external users. Case Management Digital marketplace Social interactions"
  },
  "modules/community/social-interactions/index.html": {
    "href": "modules/community/social-interactions/index.html",
    "title": "Social interactions | ERP.net Tech Docs",
    "keywords": "Social interactions This module represents the social interactions between internal and external users, just like in social networks like Facebook. The users join social groups . Each social post is made in a group. There is no personal space like in Facebook. Each post can contain social comments , replies and reactions . These can also be attached to any data object in the system. Notifications are special data records that contain information about a single notification for a user. Notification settings allow users to specify which notifications they want to receive. They can also specify whether the notifications should be sent in-app, by mail or by sms. For more information, refer to: Notification settings Notifications Social comments Social group members Social groups Social posts Social reactions"
  },
  "modules/community/social-interactions/notifications/index.html": {
    "href": "modules/community/social-interactions/notifications/index.html",
    "title": "Notifications | ERP.net Tech Docs",
    "keywords": "Notifications Notification is a single notification of one user for one event. The event can contain multiple references to objects, definitions, etc. Although notification is an entity in the Social interactions module, a notification can be raised by any module in the system. Notifications CAN specify a data object. If they do, the notification is related to the data object. However, this attribute is not required and can be null. Notifications contain URLs. If a user clicks on the notification, the specified URL will be opened. Each notification has a class which specifies the type of the notification: NT_SOC_REPLY - there was a reply to my post or comment NT_SOC_MENTION - I was mentioned in a post or comment NT_SOC_NEW_POST - new post in a group, in which I am member NT_WM_QTY_BELOW_MIN - in Warehouse management , when the qty in a tracked bin falls below the minimum When a notification is displayed to a user, it is marked as read . This does not guarantee that the user has read or understood it. Note The UI in some apps might require the user to actually click on the notification in order to mark it as read."
  },
  "modules/community/social-interactions/notifications/settings.html": {
    "href": "modules/community/social-interactions/notifications/settings.html",
    "title": "Notification settings | ERP.net Tech Docs",
    "keywords": "Notification settings These settings allow users to specify which notifications they want to receive. They can also specify whether the notifications should be sent in-app, by mail or by sms. A setting is for a single user, for a single notification class. Only whole notification classes can be set up. Currently, there is no support for muting specific notification types. A setting determines whether the user should receive: Notification - these are the in-app notifications . Email - the user should receive email on their primary email. Sms - the user should receive SMS on their primary phone number. For more information about notification types and classes, see Notifications ."
  },
  "modules/community/social-interactions/social-comments.html": {
    "href": "modules/community/social-interactions/social-comments.html",
    "title": "Social comments | ERP.net Tech Docs",
    "keywords": "Social comments This represents a comment to a data object within the system. Social posts are data objects. This is the most common object to which comments can be added. Besides social posts, there are other objects which are frequent targets by comments: Marketplace products Documents Definitions Settings However, comments can be added to any data object within the system. Important attributes: Data object - the data object being commented. Reply to comment - the comment to which the current comment replies. If empty, the comment is a root comment to the data object. Тhe Data object always points to the root data object being commented (it does not point to a data object for a comment). Comment text - comment contents in clear text. [!NОТЕ] It is planned that text will be allowed to contain some mark-down constructs in the future. Creation time Utc - automatically set by the server to the time of initial creation of the comment."
  },
  "modules/community/social-interactions/social-group-members.html": {
    "href": "modules/community/social-interactions/social-group-members.html",
    "title": "Social group members | ERP.net Tech Docs",
    "keywords": "Social group members This entity represents one membership of a user in a group. Important attributes: Join time Utc - automatically set by the server."
  },
  "modules/community/social-interactions/social-groups.html": {
    "href": "modules/community/social-interactions/social-groups.html",
    "title": "Social groups | ERP.net Tech Docs",
    "keywords": "Social groups The social groups are the primary areas (circles) where social interactions occur. Social groups have resemblance to Facebook groups. Unlike FB groups, social posts are always grouped. There is no personal space, unless a personal group is defined. Important attributes: Code - this is the unique code of the group. It is also used as a slug which forms part of the URL for the group, posts, etc. Name - the universal name of the group."
  },
  "modules/community/social-interactions/social-posts.html": {
    "href": "modules/community/social-interactions/social-posts.html",
    "title": "Social posts | ERP.net Tech Docs",
    "keywords": "Social posts This represents a single social post. It resembles a Facebook post. Important attributes: Post text - this is a single-language text, containing the contents of the post in clear text. Note It is planned that the text will be allowed to contain some mark-down constructs in the future. Creation time Utc - automatically set by the server to the time of the initial creation of the post. Last interaction Utc - set by the server. The last interaction time with the post, including comments, replies, and likes. Тhis is updated each time a related comment, reply or reaction is added/updated."
  },
  "modules/community/social-interactions/social-reactions.html": {
    "href": "modules/community/social-interactions/social-reactions.html",
    "title": "Social reactions | ERP.net Tech Docs",
    "keywords": "Social reactions Social reactions represent user reactions to social content. They resemble Facebook reactions. Important attributes: Data object - the root data object. A reaction can be attached to the data object itself, or to a comment of the data object. In any case, the data object contains the root data object, just like the comments. Social comment - when not null, it contains a comment to the same Data Object to which the reaction is attached. Reaction type - one of: LIKE LOVE HAHA WOW SAD ANGRY Creation time Utc - automatically set by the server to the time of initial creation of the reaction."
  },
  "modules/crm/contacts/index.html": {
    "href": "modules/crm/contacts/index.html",
    "title": "CRM Contacts and tasks | ERP.net Tech Docs",
    "keywords": "CRM Contacts and tasks The Contacts and tasks module is used to manage parties and calendars. When used as part of the sales process, they can initiate the sales process flow: Activity → Opportunity → Offer → Sales order → Invoice order → Invoice Activities The activities are like calendar appointments on steroids. Activities Have related party reference, allowing to sort activities by party. Allow attachments of files. Support questionaries (through the use of user defined data attributes) And much more. Activities can be used to automatically create sales opportunities in the Presales module."
  },
  "modules/crm/crm-common/crm-common-concepts/determine-line-discount.html": {
    "href": "modules/crm/crm-common/crm-common-concepts/determine-line-discount.html",
    "title": "Determine line discount | ERP.net Tech Docs",
    "keywords": "Determine line discount When trying to determine a line discount, we have to specify some required conditions: Product Date Quantity List of customers and some not required: Enterprise company - Only in the specified Enterprise Company Enterprise company location - Only in the specified Enterprise Company location Price list - self-explanatory Distribution channel - self-explanatory Current line discount - The current discount should not be changed if it satisfies the conditions and has the same priority as the determined top discount. ERP.net filters all discounts that match these criteria. When a discount is defined with a blank value for the Customer, the discount applies to all customers. The same goes for Customer Type, Product, From Date To Date, MinQuantity, MaxQuantity, Enterprise Company, Price List, etc. Generally, the algorithm is the following: ERP.net filters the discounts. Among the remaining discounts, the one with the highest priority is selected. If there is more than one price within the same highest priority, the newer one is selected (the one with later From Date). If a current line discount is provided and it satisfies the conditions and has the same priority as the selected one, then the current line discount is selected. So, after the selection process, one and only one discount is selected and applied to the document line. Filtering conditions Discount From Date is empty or <= required Date Discount To Date is empty or >= required Date Discount Product is empty or equal to required Product Discount Min Quantity is empty or <= required Quantity Discount Max Quantity is empty or >= required Quantity Discount Customer is empty or it is in the required list of customers Discount Product Group is empty, the same as the product group or parent of the product group Discount Distribution Channel is empty or equal to required Distribution channel Discount Price List is empty or valid for the required Date The discount Target group is empty or at least one of the customers is a member of the target group Discount Customer type is empty or it is in the list of customer types, derived from the required customer’s list"
  },
  "modules/crm/crm-common/crm-common-concepts/determine-product-price.html": {
    "href": "modules/crm/crm-common/crm-common-concepts/determine-product-price.html",
    "title": "Determine product price | ERP.net Tech Docs",
    "keywords": "Determine product price When trying to determine a product price, we have to specify some required conditions: Product Quantity QuantityUnit Date and some not required: Customer Ship to customer Enterprise company - Only in the specified enterprised company Enterprise company location - Only in the specified enterprise company location Distribution channel - self-explanatory Price list - self-explanatory Current product price - The current product price should not be changed if it satisfies the conditions and has the same priority as the determined top price. ERP.net filters all product prices for the given product that match these criteria. When a product price is defined with a blank value for the customer, the product price applies to all customers. The same goes for Ship To Customer, From Date, Thru Date and all not required parameters from the list above. Generally, the algorithm is the following: ERP.net filters the product prices. Each of the selected product prices is checked if min and max’s quantities are respectively less and greater than the provided quantity. The price ist of the product price is checked for validity according to the date. If Ship To Customer is provided, its party is considered a Target Party, else the customer's party is taken. If the product price has a target group specified, the target party should be a member of that group or null. Among the remaining product prices, the top priority price is selected considering the lowest Price Type's Ordinal Pos, the highest Priority and the newer From Date. If a Current Product Price is provided and it satisfies the conditions and has the same priority as the selected one, then the current product price is selected. So, after the selection process, one and only one product price is selected and applied to the document line. Filtering conditions From Date is empty or <= required Date Thru Date is empty or >= required Date Product is equal to required Product Customer is empty or it is equal to the required Customer Ship To Customer is empty or it is equal to the required Ship To Customer Min Quantity is empty or <= required Quantity Max Quantity is empty or >= required Quantity Enterprise Company is empty or equal to required Enterprise Company Enterprise Company Location is empty or equal to required Enterprise Company Location Distribution Channel is empty or equal to the required Distribution channel Price List is empty or valid for the required Date The target group is empty or the ship to the customer or the customer is a member of the target group"
  },
  "modules/crm/crm-common/crm-common-concepts/index.html": {
    "href": "modules/crm/crm-common/crm-common-concepts/index.html",
    "title": "| ERP.net Tech Docs",
    "keywords": ""
  },
  "modules/crm/crm-common/crm-common-concepts/pricing.html": {
    "href": "modules/crm/crm-common/crm-common-concepts/pricing.html",
    "title": "Pricing | ERP.net Tech Docs",
    "keywords": "Pricing Description When a user enters a sales order (or similar document), the system automatically assigns the appropriate sales price. Selecting the correct price is the main topic of the pricing. Product prices in reality Each product can have multiple prices associated with it. For example, Product A can have 3 standard prices: 50.00 USD - open price, for everyone who asks 48.00 USD - for regular customers 45.00 USD - for special customers Additionally, Product A can have a special price for some customers: 44.00 USD for Customer X 43.50 USD for Customer Y Also, there might be a discount campaign: 42.00 USD for everyone, from 1/1/2021 till 2/2/2021 Entering product prices in ERP.net The following table shows how we can define the prices from the above example in ERP.net. Product Customer Price List From Date To Date Priority Price Product A - - - - 1 50.00 Product A - Regular - - 2 48.00 Product A - Special - - 2 45.00 Product A Customer X - - - 3 44.00 Product A Customer Y - - - 3 43.50 Product - - 1/1/2021 2/2/2021 5 42.00 How ERP.net determines the correct price The most important thing to note is the priority attribute. The higher the priority, the more likely the price will be selected. After the user specifies the customer, date and product, ERP.net filters all prices, that match these criteria. When a price is defined with a blank value for the customer the price applies to all customers. The same goes for Price List, From Date To Date, etc. Only the Product attribute is required, it cannot be blank. If it could be blank, this means, that we can define the same price for ALL products. Generally, the algorithm is the following: ERP.net filters the prices, based on Product, Customer, Price List and all other conditional attributes. Among the remaining prices, the one with the highest priority is selected. If there is more than one price within the same highest priority, the newer one is selected (the one with later From Date). So, after the selection process, one and only one price is selected and applied to the sales document. More conditional filtering attributes ERP.net employs many more conditional attributes, which allow fine-grained tuning of the product pricing strategy. All conditional attributes work in the same basic way as described above. The following additional conditional attributes further filter down the prices: Enterprise company - for sales only in the specified ERP.net Min quantity - for sales quantities above (or equal to) the specified Max quantity - for sales quantities below (or equal to) the specified Target group - for customers in the target group Ship to customer - self-explanatory Distribution channel - self-explanatory Customer type - self-explanatory Specifying the price The price is specified using the following attributes: Price - the decimal part of the price Currency - the currency of the price Quantity - the quantity for which the price is specified Quantity measurement unit - the measurement unit in which the quantity is specified Examples: 5.00 USD for 1 pcs 10.00 EUR for 3 packs"
  },
  "modules/crm/crm-common/index.html": {
    "href": "modules/crm/crm-common/index.html",
    "title": "| ERP.net Tech Docs",
    "keywords": ""
  },
  "modules/crm/index.html": {
    "href": "modules/crm/index.html",
    "title": "Customer relationship management (CRM) subsystem | ERP.net Tech Docs",
    "keywords": "Customer relationship management (CRM) subsystem The CRM subsystem in ERP.net is used to manage customer relationships and other front-office activities of a company. General concepts and processes The main process in the CRM subsystem is: Activity → Opportunity → Offer → Sales order → Invoice order → Invoice Activity - generic activity, related to a party. Includes support for calendar appointments, reminders, questionnaires, etc. Can be used to represent appointments, scheduled meetings, visits, contracts and just about any generic document. Opportunity - sales opportunity, with expected revenue and probability. It does not have detail line items. Offer - sales offer (quote), with line items. It allows optional selection of some of the items, which the customer has accepted. Sales order - sales order from the customer. The main sales document. All documents before it are optional. The sales order initiates the logistics and financial processes, related to the sale. Invoice order - an order to issue an invoice. This is an internal document, which is used to track the invoices, which we have to issue. Invoice - legal and financial document, finalizing the sales process. Note The above diagram shows only the CRM part of the whole process. The full process involves many different modules of the ERP system. Modules There are many modules in the CRM subsystem. They are used to manage the different aspects of the CRM processes: Contacts and tasks - calendar appointments, party definitions, etc. Pre-sales - Opportunities management, quotation, etc. Sales - Sales orders, customers, etc. Invoicing - Invoicing process management, invoices and BI. POS - Manage point-of-sale activities in physical stores. Marketing - Marketing campaigns, activities, distribution channels, etc. Distribution - field sales, sales person targets management, etc. Pricing - price lists management. Product Configuration - create products based on specs for job shops (made-to-order and engineer-to-order environments). Products - manage products master data - products and product measurements, codes, variants, channel, pictures, groups, etc."
  },
  "modules/crm/invoicing/index.html": {
    "href": "modules/crm/invoicing/index.html",
    "title": "Invoicing - Invoicing process management, invoices and BI. | ERP.net Tech Docs",
    "keywords": "Invoicing - Invoicing process management, invoices and BI."
  },
  "modules/crm/invoicing/invoicing-concepts/determine-payment-due-date-in-invoices.html": {
    "href": "modules/crm/invoicing/invoicing-concepts/determine-payment-due-date-in-invoices.html",
    "title": "Determine payment due date in invoices | ERP.net Tech Docs",
    "keywords": "Determine payment due date in invoices Invoices in ERP.net are entered manually or they are created based on invoice orders. Determine payment due date when entering an invoice manually In this case the Payment Due Date is determined in the standard way - based on the data in the invoice customer definition. This is a default value and it can be changed by the user. Example 1: The user enters an invoice with a document date 15 Mar 2020 . The customer definition says that its Default Payment Term Days is 7 days . Then the Payment Due Date in the invoice is 22 Mar 2020 . Determine payment due date when entering an invoice based on invoice orders There is a Payment Due Date in the invoice orders. When the user enters Invoices based on invoice orders, the Payment Due Date is copied from the invoice order or from the Document Date of the invoice order (depending on which date is greater). This is also valid in the cases when the invoice is created with today's date. In this case the payment term is kept (as days count) as it is in the invoice order. Example 2: There is a sales order with Document Date 02 Nov 2020 and Payment Due Date 09 Nov 2020 (so the payment term is 7 days ). These dates are copied to the invoice order from the sales order. Then in the client definition the Default Payment Term Days is changed from 7 days to 14 days. The user creates invoice with Document Date 22 Nov 2020 . The Payment Due Date in the invoice is 29 Nov 2020 (i.e. keeping the term from the Invoice Order), in spite of the difference in the terms according to the customer's definition. Example 3: The same case as in Example 2 , except for the Document Date of the invoice order. In the current example it is 11 Nov 2020 (this is possible if the invoice order is generated from shipments). Then when creating the invoice. Payment Due Date is considered to be 11 Nov 2020 (the greater date), which means that the payment term is actually 0 days (the difference between the document date and the effective payment due date). I.e. when entering an Invoice with Document Date 22 Nov 2020 , its Payment Due Date is 22 Nov 2020 . Payment Due Date in theiInvoice depends of how the Payment Due Date and the Document Date in the invoice o rder are determined. Determine the Payment Due Date and the Document Date in the invoice orders They are usually generated on sales orders and copy their term and date. There are two general document flows that create invoice orders: sales orders => invoice orders These are orders directly created from sales orders. They include products that cannot be shipped. These are also orders for sales orders for sales returns. sales orders => shipment orders => shipments => invoice orders These are orders for products and services that have to be shipped first. When directly creating invoice orders from the sales orders, Document Date and Payment Due Date are copied from the sales order. The second document flow contains different mechanisms. Here, the document date in the invoice order is copied from the shipment and the Payment Due Date is determined by a more complicated algorithm. This is because the shipment does not have information for the payment term and it is provided by the sales orders which the shipment is based on. The sales orders may be more than one. Then the Payment Due Date in the invoice order is determined by the earliest Payment Due Date in the sales orders (i.e. the smallest date) and if this term is later than the Document Date of the invoice order (copied from the shipment), then the Payment Due Date is saved. If the Payment Due Date is before the Document Date - then the Document Date is saved as a Payment Due Date ."
  },
  "modules/crm/invoicing/invoicing-concepts/determine-unit-price-and-line-amount-in-invoice-orders.html": {
    "href": "modules/crm/invoicing/invoicing-concepts/determine-unit-price-and-line-amount-in-invoice-orders.html",
    "title": "Determine unit price and line amount in invoice orders | ERP.net Tech Docs",
    "keywords": "Determine unit price and line amount in invoice orders The invoice orders and their lines are created to generate invoice documents with the aid of particular Sales Order lines are invoiced. For this reason, every Invoice Order lines points to and fulfils exactly one Sales order line. In some cases though, when the parent document is a Shipment, for example, the Unit price and Line amount could not be copied directly from the parent document. They could not be copied from the sales order as well, because the line might be broken down (by lots for example) during the goods issue and the Line amount will not be the same. Therefore those amounts must be calculated. Calculation Initially, when the invoice order and its lines are created, the Quantity is copied from the parent documents line, the Unit price and the discounts are copied from the parent Sales Order line. The quantity and unit price values are used for the calculation of the Line amount . The algorithm is as follows : [LineAmount] = Round( [Quantity] * [Unit price] * (1 - [Line Standard Discount Percent] ) * (1 - [Line Custom Discount Percent] )) *The Line amount is rounded up to the second digit. Example: SalesOrderLine1 : Quantity = 3 PCS , UnitPrice = 2.5694 EUR, LineStandardDiscountPercent = 0.00 %, LineCustomDiscountPercent = 25.00 %, LineAmount = 5.78 EUR ShipmentLine1 : Quantity = 2 PCS ShipmentLine2 : Quantity = 1 PCS InvoiceOrderLine1 : Quantity = 2 PCS, UnitPrice = 2.5694 EUR, LineStandardDiscountPercent = 0.00 %, LineCustomDiscountPercent = 25.00 %, LineAmount = 2 2.5694 (0.75) = 3.8541 ~ 3.85 EUR InvoiceOrderLine 2 : Quantity = 1 PCS, UnitPrice = 2.5694 EUR, LineStandardDiscountPercent = 0.00 %, LineCustomDiscountPercent = 25.00 %, LineAmount = 1 2.5694 (0.75) = 1.92705 ~ 1.93 EUR Then when saving the document the Discrepancy System (for more information see Discrepancy System ) initializes а depletion of the rounded Line amount which leads to a recalculation of the Unit price: [Unit price] = Round( [LineAmount] / (1 - [Line Standard Discount Percent] ) / (1 - [Line Custom Discount Percent] ) / [Quantity] ) *The unit price is rounded up to the fifth digit. Example: InvoiceOrderLine1 : Quantity = 2 PCS, LineAmount = 3.85 EUR, LineStandardDiscountPercent = 0.00 %, LineCustomDiscountPercent = 25.00 %, UnitPrice = 3.85 / 0.75 / 2 = 2.5666666... ~ 2.56667 EUR InvoiceOrderLine2 : Quantity = 1 PCS, LineAmount = 1.93 EUR, LineStandardDiscountPercent = 0.00 %, LineCustomDiscountPercent = 25.00 %, UnitPrice = 1.93 / 0.75 / 1 = 2.57333333... ~ 2.57333 EUR"
  },
  "modules/crm/invoicing/invoicing-concepts/index.html": {
    "href": "modules/crm/invoicing/invoicing-concepts/index.html",
    "title": "| ERP.net Tech Docs",
    "keywords": ""
  },
  "modules/crm/marketing/bonus-programs/index.html": {
    "href": "modules/crm/marketing/bonus-programs/index.html",
    "title": "Bonus programs | ERP.net Tech Docs",
    "keywords": "Bonus programs Bonus programs are a tool that automates including a bonus product or a discount on the sales order when the document meets certain conditions. Using bonus program automation reduces the chances that a mistake is made. For example, if the business model requires using a lot of bonuses, there is a high probability an employee would forget to include a free product or a discount, but using bonus programs ensures that if all conditions are met, the customer receives the bonus. Bonus programs define bonuses and conditions, which specify when the bonuses should be applied to the sales order. Conditions for the particular bonus programs are set in the ‘condition’ fields and are verified for the whole sales order. Bonus program conditions: Description: Active That’s the main condition if the bonus must be applied. The other conditions are verified only for active bonus programs. Priority from 1 (the lowest) to 5 (the highest) of the bonus program compared to the other bonus programs. Condition Customer Specifies that the bonus program must be applied only for the customer that is set in the field. If ‘Condition Customer = NULL’, then it’s applied for all customers. Condition Customer Filter XML Sets a custom filter for clients. The bonus program is only applied if the customer meets the specified criteria. Currently, only criteria from the related ’Customers’ and ‘Parties’ tables are supported. The filter can contain custom properties. Condition Ship To Customer Specifies that the bonus program must be applied only when shipping to the customer that is set in the field. If ‘Condition Customer = NULL’, then it’s applied to all customer’s company locations. Condition Ship To Customer Filter XML The bonus applies only when shipping to a customer that meets the specified criteria. Currently, only criteria from the related ’Customers’ and ‘Parties’ tables are supported. The filter can contain custom properties. Condition Product If there is no value in the field, then all other conditions must be evaluated for the whole sale order. Otherwise, the bonus only applies to the lines that contain the product. If the bonus program is valid for more than one product, then another condition product could be added in the panel 'Bonus program products'. Condition Product Group The bonus program only applies to products from the specific group or its subgroups. Currently, the condition for the product group can’t be used with conditions for Min and Max quantity. That’s because if the base measurement units of the products in the group are different, there is no way the right calculation is made and the bonus program won’t be applied Condition Min Quantity Specifies a condition for the minimum quantity of the condition product in the base measurement unit. If there is no condition product, then a minimum quantity can not be set for the current bonus program. If the condition products are more than one, then all of them have to use the same base measurement unit. Otherwise, there is no way the right calculation to be made and the bonus program won’t be applied. Condition Max Quantity Specifies a condition for the maximum quantity of the condition product in the base measurement unit. If there is no condition product, then a maximum quantity can not be set for the current bonus program. If the condition products are more than one, then all of them have to use the same base measurement unit. Otherwise, there is no way the right calculation to be made and the bonus program won’t be applied. Condition Min Amount Specifies a condition for the minimum sum of amounts of the sales order lines, for which the bonus is valid. Condition Max Amount Specifies a condition for the maximum sum of amounts of the sales order lines, for which the bonus is valid. Condition Document Currency The bonus program only applies if the document currency is the same as the currency in this field. Condition Document Currency is also required if any of the amount conditions are set. Condition From Date Starting date (inclusive) from which the bonus program is valid. Condition To Date End date (inclusive) to which the bonus program is valid. Condition Target Group Specifies that the bonus program only applies for the customers from the specified target group. Condition Distribution Channel Specifies that the bonus program only applies when the specified distribution channel is used in the document. Condition Distribution Channel Filter XML The bonus only applies when the distribution channel in the document meets the specified criteria. Note When forming the maximum and minimum quantity of products purchased with the particular sales order, the system sums a total quantity of all purchased products defined in the bonus program. For example, if a bonus program is valid for two products - product A and product B and the condition for minimum quantity is 5 pieces, the bonus program will be applied no matter what is the ratio between those two products (2 pcs of product A and 3 pcs of product B, 1 pcs of A and 4 of B, 0 pcs of A and 5 of B …). Currently, two types of bonuses are supported: Product – Аdds a sales order line with a free product. Works as follows: If all conditions are met, a new line with the bonus product is created. The quantity in the line is determined by the values of the bonus program fields For Each and Bonus Product Quantity . For Example: if there is a bonus program with a product 'Pencil', which is offered as a gift for each 10 ordered books, then if in the sale order there are 30 notebooks, a bonus row with 3 pencils will be created. The line amount is '0.00'. In the line field Bonus program there is information about the name of the bonus program that is currently applied . Discount – Calculates a percentage discount for a specific sales order line. Works as follows: To all lines that meet the conditions, standard discount applies, which is defined in the bonus program. Bonus programs do not apply to lines with zero quantity. A bonus type is required for each bonus program. Both bonus types can not be used simultaneously. Data fields: Description: Bonus Action Specifies the type of the bonus – a product or a discount. Bonus Product The product that the customer receives for free, if the conditions of the bonus program are met. The field is required when there is value in Bonus Product. Bonus Product Quantity The quantity of the bonus product. The field is required if there is a value in Bonus Product. Bonus Product Quantity Unit The measurement unit of the bonus quantity of the product. The field is required if there is a value in Bonus Product. For Each Specifies an amount of the condition product, for which the bonus quantity is applied every time. For example, if we want to use the common form of sales promotion 'Buy X get Y for free' we should set the 'X' quantity in the field 'For Each'. This way if the customer buys 2 Х quantity, then will receive 2 Y bonus. Bonus Line Discount Percent The percent discount that is going to be applied in the rows."
  },
  "modules/crm/marketing/index.html": {
    "href": "modules/crm/marketing/index.html",
    "title": "| ERP.net Tech Docs",
    "keywords": ""
  },
  "modules/crm/presales/index.html": {
    "href": "modules/crm/presales/index.html",
    "title": "CRM Presales | ERP.net Tech Docs",
    "keywords": "CRM Presales The presales module is used to manage the presales process. Deals (Opportunities) Activity → Opportunity → Offer → Sales order → Invoice order → Invoice The deals in the Crm.Presales.Deals Entity are used to manage sales opportunities to new or existing customers. Note Deal is synonymous to opportunity. The deals: Have appointed sales representative, managing the deal. Do not have line items. They are used to manage deals, which are still not clear enough to detail at this level. Have a percentage probability of success . The percentage is set by the sales representative, based on their own judgement. Have expected sales revenue . Have expected close date . Based on the data above, the team leaders and sales managers have instant and clear visibility over the sales processes. The deals are usually initially created based on General.Contacts.Activities Entity . However, once a deal is created, it can be used to create many more sub-activities to manage related tasks. Offers (quotes) Activity → Opportunity → Offer → Sales order → Invoice order → Invoice The deals documents can be easily transformed into Offers (quotes), which contain detailed line items. Entries in the Crm.Presales.Offers Entity allows the customer to be presented with optional items. After approving some or all of the optional items, the offer can generate Crm.Sales.SalesOrders Entity in the Sales module."
  },
  "modules/crm/sales/index.html": {
    "href": "modules/crm/sales/index.html",
    "title": "CRM Sales module | ERP.net Tech Docs",
    "keywords": "CRM Sales module Activity → Opportunity → Offer → Sales order → Invoice order → Invoice The sales module is used to manage the preparing and issuing of sales orders and the related master data."
  },
  "modules/crm/sales/price-types.html": {
    "href": "modules/crm/sales/price-types.html",
    "title": "Price types | ERP.net Tech Docs",
    "keywords": "Price types Price types are used to set additional priority conditions for the prices. 5 is the highest priority level that can be selected in the Priority field of the price. To add an additional higher priority, a price type must be defined and selected as a price type of the price. Priorities among the different price types are set by filling a number in the ordinal position field in the definition of the price type – the lower the number, the higher the priority. Price types add additional priority under the following algorithm: If a price has a defined price type, this price will be with the highest priority among other prices - no matter their level of priority. If more than one price has a defined price type, the price with the price type that has the lowest ordinal position will be with the highest priority. If more than one price has a defined price type and their price types have equal ordinal positions, the price with the highest priority will be selected."
  },
  "modules/crm/sales/pricing.html": {
    "href": "modules/crm/sales/pricing.html",
    "title": "Pricing | ERP.net Tech Docs",
    "keywords": "Pricing Description When a user enters a sales order (or similar document), the system automatically assigns the appropriate sales price. Selecting the correct price is the main topic of the pricing. Product prices in reality Each product can have multiple prices associated with it. For example, product A can have 3 standard prices: 50.00 USD - open price, for everyone who asks. This price is defined as Standard. 48.00 USD - for regular customers 45.00 USD - for special customers Additionally, product A can have a special price for some customers: 44.00 USD for Customer X 43.50 USD for Customer Y Also, there might be a discount campaign: 42.00 USD for everyone, from 1/1/2021 till 2/2/2021. This price is defined as Promotion and it should be with higher priority than the Standard price. Entering product prices in ERP.net The following table shows how we can define the prices from the above example in ERP.net. Product Customer Price list From date To date Price type Priority Price Product A Standard 1 50.00 Product A Regular 2 48.00 Product A Special 2 45.00 Product A Customer X 3 44.00 Product A Customer Y 3 43.50 Product A 1/1/2021 2/2/2021 Promotion 5 42.00 How ERP.net determines the correct price The most important thing to note is the Price type field. The price type with the lowest Ordinal position is with highest priority. If the Price type field has a blank value, the first thing that is taken into consideration is the Priority field of the price. The higher the priority, the more likely the price will be selected. After the user specifies the customer, date and product, ERP.net filters all prices, that match this criteria. When a price is defined with blank value for Customer, the price is applicable to all customers. The same goes for Price list, From date, To date, etc. Only the Product field is required, it cannot be blank. If it could be blank, this means, that we can define the same price for ALL products. Generally, the algorithm is the following: ERP.net filters the prices, based on Product, Customer, Price list and all other conditional fields. If among the remaining prices, there are prices with defined price type, the one that has a price type with the lowest Ordinal position is selected * If there is more than one price within the same lowest Ordinal position, the one with the highest priority is selected If among the remaining prices, there are no prices with defined price type, the one with the highest priority is selected * If there is more than one price within the same highest priority, the newer one is selected (the one with later From date) So, after the selection process, one and only one price is selected and applied to the sales document. More conditional filtering fields ERP.net employs many more conditional fields, which allow fine-grained tuning of the product pricing strategy. All conditional fields work in the same basic way as described above. The following additional conditional fields further filter down the prices: Enterprise Company - for sales only in the specified enterprise company Min Quantity - for sales quantities above (or equal to) the specified Max Quantity - for sales quantities below (or equal to) the specified Target Group - for customers in the target group Ship To Customer - self explanatory Distribution Channel - self explanatory Customer Type - self explanatory Specifying the price The price is specified using the following fields: Price - the decimal part of the price Currency - the currency of the price Quantity - the quantity for which the price is specified Quantity Measurement Unit - the measurement unit in which the quantity is specified Examples: 5.00 USD for 1 pcs 10.00 EUR for 3 packs"
  },
  "modules/crm/sales/promotional-packages/index.html": {
    "href": "modules/crm/sales/promotional-packages/index.html",
    "title": "Promotional packages | ERP.net Tech Docs",
    "keywords": "Promotional packages Promotional packages are packages of products, which can be added into the sales orders. After they are added, the products from the package appear as sales order lines and their quantity is multiple of the number of the sold packages. If a line is added from a promotional package, then the name of the promotional package is filled in the line field Promotional package . A promotional package can be applied for a sales order only if it fulfills the conditions of the package such as Starting date, End date, Customer, Enterprise company, Price list and others. Promotional package fields Description Valid from date Starting date from which the promotional package is valid. Valid to date End date (inclusive) to which the promotional package is valid. Valid for price list Price list for which the promotional package is valid. Valid for customer Customer for which the promotional package is valid. Valid for target group Target group for which the promotional package is valid. Valid For Customer Filter XML Sets a custom filter for clients. The promotional package only applies if the customer fulfills this condition. Valid for Ship to customer Ship to customer for which the promotional package is valid. Valid for Ship to customer Filter XML The promotional package only applies if the customer, which is supplied, fulfills this condition. Valid for Distribution channel Distribution channel, for which the promotional package is valid. Valid for Distribution channel Filter XML The promotional package only applies if the distribution channel in the sales order fulfills this condition. Promotional package lines Promotional package's lines represent the products that are part of the particular package. Quantity and Standard discount percent adjust are required for each line. Promotional package line fields Description Line Number Line number Product Id Product code Quantity Product quantity Unit Price When filled sets the unit price of the product. Unit Price CurrencySpecifies the currency of the unit price Standard discount Percent Adjust Specifies the amount of change (in percentage points) of the standard discount. Standard discount Adjust Or Replace Specifies the type of change of the standard discount. Possible values: • Add – adds the percent set into the field ‘Standard Discount Percent Adjust’ to the already existing trade discount in the sales order lines: Standard Discount = Standard Discount + adjust, where ‘adjust’ is the value in the field ‘Standard Discount Percent Adjust’. • Replace – Saves the percent of the field ‘Standard Discount Percent Adjust’ in the standard discount for the line: Standard Discount = adjust • Mark Down – Applies after the standard discount and is calculated as follows: Standard Discount = 1 - (1 – Standard Discount) * (1 - adjust)"
  },
  "modules/crm/sales/sales-concepts/amount-to-pay.html": {
    "href": "modules/crm/sales/sales-concepts/amount-to-pay.html",
    "title": "Amount to pay | ERP.net Tech Docs",
    "keywords": "Amount to pay Amount to pay is part of the sales orders and invoices. It is the final amount that the customer has to pay on the current document (sales order or invoice). It is calculated as the sum of the row amounts and all additional amounts in the current document which has checked in the Add To Customer attribute in their definitions. Example 1: There is an invoice with two rows: Row #10 - Product 1 , LineAmount: 2 PCS x 12 EUR = 24 EUR Row #20 - Product 2 , LineAmount: 3 PCS x 7 EUR = 21 EUR The document has an additional amount paid by the customer: VAT, Amount Percent: 20% of the line amount of the rows = 0.2 x 45 EUR = 9 EUR So the Amount To Pay is: 54 EUR = 24 EUR + 21 EUR +9 EUR. Relation To Tax Base And VAT (Invoices) In most cases, the amount to pay matches the sum of tax base and VAT, like in Example 1 , but a difference is possible. It is possible if there are Additional Amounts that are paid by the customer but are not set as base amounts for VAT additional amount. Example 2 : There is an invoice with a line amount of 45 EUR and two Additional Amounts which are paid by the customer: VAT, amount: 20% of 45 EUR = 9 EUR Penalty Interest - not a VAT base amount, Amount: 20 EUR So the Aount To Pay is 74 EUR while the sum of Tax Base and VAT is 54 EUR . Example 3 : The additional amount VAT (special cases) is set that its base amount type is Tax Base , Add To Customer and Base On Lines are True . Tax Base is not paid by the customer. There is an invoice with two rows: Row #10 - Product 1 , LineAmount: 2 PCS x 12 EUR = 24 EUR Row #20 - Product 2 , LineAmount: 3 PCS x 7 EUR = 21 EUR and Additional Amounts as follows: Tax Base , Amount: 30 EUR VAT , Amount Percent 20% of 30 EUR = 6 EUR In this case, the Amount To Pay is 45 EUR while the sum of Base Tax and VAT is 36 EUR ."
  },
  "modules/crm/sales/sales-concepts/deferred-payments-options.html": {
    "href": "modules/crm/sales/sales-concepts/deferred-payments-options.html",
    "title": "Deferred payments options | ERP.net Tech Docs",
    "keywords": "Deferred payments options Some companies may apply the sales policy of selling with deferred payment. And sometimes there are additional requirements needed to be met, so the deferred payment is allowed. In ERP.net, there is an option to set a minimal total amount on a sales order in order to use deferred payments. The minimal amount may be set for each Enterprise company separately in the specified currency. If a sales order is set with a minimal deferred payment amount, there are certain system validations that ERP.net requires. The first option for the user is to have a sales order with amount to pay greater than the sales order minimal deferred payment amount. If this is not true, the current sales order may be processed if: there are no payment plans; the Payment Due Date is not greater than the document date; the payment type system type is in cash or card."
  },
  "modules/crm/sales/sales-concepts/determine-line-amount-in-sales-orders.html": {
    "href": "modules/crm/sales/sales-concepts/determine-line-amount-in-sales-orders.html",
    "title": "Determine line amount in sales orders | ERP.net Tech Docs",
    "keywords": "Determine line amount in sales orders The line amount in a sales order is formed by the following fields: Quantity , Unit Price , Line Standard Discount Percent and Line Custom Discount Percent . The fields Unit Price , Line Standard Discount Percent and Line Custom Discount Percent represent the trade conditions in the row. They may be managed/filled as a nomenclature - as product prices, discounts, bonus programs and promotions. The formula of the field line amount is rounded up to the second digit and is as follows: [LineAmount] = Round( [Quantity] * [Unit Price] * (1 - [Line Standard Discount Percent] ) * (1 - [Line Custom Discount Percent] )) Example 1 : In the row there is quantity 7 PCS and unit price 0.15472 EUR and no discounts, then the line amount is: [Line Amount] = Round( 7 * 0.15472 * (1 - 0) * (1 - 0)) = Round( 1.08304 ) = 1.08 . Example 2 : In the row there is quantity 27 PCS and unit price 0.15472 EUR , the discounts are 19% and 7% , then the line amount is: [Line Amount] = Round( 27 * 0.15472 * (1 - 0.19 ) * (1 - 0.07 )) = Round( 1.08304 ) = 1.08 . There are also other row amount types which meaning and calculation are different than those of amount saved in the field LineAmount. For more information, see Amount to pay ."
  },
  "modules/crm/sales/sales-concepts/determine-payment-account-in-sales-order.html": {
    "href": "modules/crm/sales/sales-concepts/determine-payment-account-in-sales-order.html",
    "title": "Determine payment account in sales order | ERP.net Tech Docs",
    "keywords": "Determine payment account in sales order The algorithm The algorithm for the determination of the payment account in the sales order is the following: SalesOrder.PaymentAccount is set to one of the following (in order of their precedence): If the ShipToCustomer.DefaultPaymentType = SalesOrder.PaymentType AND the ShipToCustomer.PaymentAccount is not null => it is taken. If the Customer.DefaultPaymentType = SalesOrder.PaymentType AND the Customer.PaymentAccount is not null => it is taken. If the PaymentType.DefaultPaymentAccount is not null => it is taken. No changes are applied. The rationale, expected setup and usage Initially, the user chooses a customer. The payment type and the payment account of the customer would be copied to the sales order. Note It is important, that the customers' payment type IS set to some non-null value! The following events happen: The user selects a customer. The payment type of the customer is loaded in the sales order. Since the payment type of the sales order is the same as the customers, the customer’s payment account is copied to the sales order. If however, the user chooses a different payment type, the default account of this new payment type is selected. For example, the customer usually pays cash and has a cash payment account specified. But now he chose to pay by credit card. In this case, the system loads the payment account of the 'Credit Card' payment type. The event order is the following: The user selects a customer The payment type of the customer is loaded in the sales order. The user selects different payment types. Since the payment type of the sales order is no longer the same as the customers', the payment account of the sales order is now copied from the definition of the payment type."
  },
  "modules/crm/sales/sales-concepts/index.html": {
    "href": "modules/crm/sales/sales-concepts/index.html",
    "title": "| ERP.net Tech Docs",
    "keywords": ""
  },
  "modules/crm/sales/sales-concepts/minimal-sales-price.html": {
    "href": "modules/crm/sales/sales-concepts/minimal-sales-price.html",
    "title": "Minimal sales price | ERP.net Tech Docs",
    "keywords": "Minimal sales price There are two ways to set a minimal sales price of a product: In the product definition. It is a price for one standard lot and in the costing currency of the product. The minimum is enforced upon releasing a sales order. If not set, this means that there is no minimum sales price enforcement. In the product distribution channel definition. It is also a price for one standard lot and in costing currency of the product. It describes the minimum sales price of this product through the current channel. If it is set in the product definition, the restriction takes place in every sales order. If it is set in the product distribution channel, then it validates the sales order release, only if the distribution channel is selected in the document header. If there are two minimal sales prices for a product - one in its definition and one set by the product distribution channel, then the more restrictive price is taken into account. Note The minimal price constraint does not take effect when the user enters a sales return. The restriction is not directly applied to the unit price in the sales order. As the unit price in the sales order lines does not reflect discounts, the restriction calculates the final unit price through the line amount and is applied to the calculated results. Example 1 : Product A has a minimal sales price of 9.00 EUR . The product costing currency is EUR and standard lot size base is 1 PCS. There is a sales order with the following line: Line No = 10 , Product = Product A , Unit Price = 9.20 EUR , Line Custom Discount Percent = 5% ; Quantity Base = 3 PCS ; Line Amount = 26.22 EUR . When the user tries to release the sales order, he will receive an error message, that the unit price is less than the minimum unit price of the product. This is because the unit price with the calculated discount is as follows: [Line Amount] / [Quantity Base] = 26.22 EUR / 3 PCS = 8.74 EUR . In this case, because of the custom discount the user has entered, the unit price of the product goes under the minimum sales price of the product. Example 2 : Let’s use the product from Example 1 . The product is also part of the distribution channel DC#1 . Product A also has a minimal sales price defined in the product distribution channel of 9.40 EUR . The user enters a sales order with the DC#1 set in its header and the following line: Line No = 10 , Product = Product A , Unit Price = 9.20 EUR , Quantity Base = 1 PCS . In this case, the sales order release will also return an error because of a minimum sales price violation. This is because the more restrictive minimal sales price is taken into account and it is 9.40 EUR . In this case, if the product is sold through the DC#1 distribution channel and it cannot be sold for less than 9.40 EUR per unit."
  },
  "modules/crm/sales/sales-concepts/minimal-sales-quantity.html": {
    "href": "modules/crm/sales/sales-concepts/minimal-sales-quantity.html",
    "title": "Minimal sales quantity | ERP.net Tech Docs",
    "keywords": "Minimal sales quantity There are two ways to set a minimal sales quantity of a product: In the product definition. It is a minimal base quantity that has to be specified in any sale. The minimum is enforced upon releasing a sales order. If not set, this means that there is no minimum sales quantity enforcement. In the product distribution channel definition. It is also a base quantity that has to be specified in any sale. It describes the minimal sales quantity of this product through the current channel. If it is set in the product definition, the restriction takes place in every sales order. If it is set in the product distribution channel, then it validates the sales order release, only if the distribution channel is selected in the document header. If there are two minimal sales quantities for a product - one in its definition and one set by the product distribution channel, then the more restrictive one is taken into account. [!NNOTE] : The minimal quantity constraint does not take effect when the user enters a sales return. The restriction is applied on the Quantity Base field in the Sales Order Lines. When such restriction exists it is applied to the calculated quantity in the base measurement unit. The restriction also calculates the total quantity base of the product in the Sales Order Lines, meaning that if the user enters the product in more than one line and the >total quantity base covers the minimal sales quantity base, then the user would be able to release the sales order. Example 1: Product A has a minimal sales quantity base of 3 PCS . The product base measurement unit is PCS . It is declared that 1 KG of Product A is equal to 2 PCS . In the product definition a minimal sales quantity base of 3.00 . There is a sales order with the following line: Line No = 10 , Product = Product A , Quantity = 1.40 KG , Quantity Base = 2.80 PCS . When the user tries to release the sales order, he will receive an error message, that the quantity in the current document lines is less than the minimal sales quantity. Example 2: If in the sales order from Example 1 the user adds 3 more lines as follows: Line No = 20 , Product = Product B , Quantity = 10 KG , Quantity Base = 10 KG . Line No = 30 , Product = Product C , Quantity = 3 PCS , Quantity Base = 3 PCS . Line No = 40 , Product = Product A , Quantity = 0.20 pcs , Quantity Base = 0.20 PCS . In this case, the user will be able to release the sales order because Line No 10 and Line 40 has a total quantity base of 3.00 PCS , which covers the minimal sales quantity base restriction, defined in the product definition. Example 3: Product P is part of distribution channel DC#1 . Its base measurement unit is PCS . Product P has a minimal sales quantity base in its definition of 3.00 PCS . Product P also has a minimal sales quantity base defined in the product distribution channel of 2.80 PCS. The user enters a sales order with the DC#1 set in its header and the following line: Line No = 10 , Product = Product P , Quantity = 2.90 PCS , Quantity Base = 2.90 PCS . In this case, the sales order release will also return an error because of a minimal quantity violation. This is because the more restrictive minimal sales quantity (the one in the product definition) is taken into account."
  },
  "modules/crm/sales/sales-concepts/sales-order-row-types.html": {
    "href": "modules/crm/sales/sales-concepts/sales-order-row-types.html",
    "title": "Sales order row types | ERP.net Tech Docs",
    "keywords": "Sales order row types The classification of the Sales Order rows describes three main row types - Normal sale, Sales return and Neutral operation. The row type is important for some generation procedures from sales order. Types The row type is defined by the signs of the quantity value and the amount in it. These criteria are chosen because it is most common and natural. For example, it is possible to define if a Sales Order row is for stock return or not by the values in the Return For Sales Order Line field in the lines or the header field - ReturnForSalesOrder. But it is also possible for the user to enter a sales order for stock to directly return negative values in the quantity and/or amount fields without using tools such as ReturnForSalesOrderLine or ReturnForSalesOrder. Thus, the signs of the values in the Quantity and Line Amount fields are the most common and natural criterion to determine the row type. Thus, according to the signs of the quantity and the amount, there are three main types of Sales Order rows: normal sale - rows with quantity > 0 or amount > 0; sales return - rows with quantity < 0 or amount < 0; neutral operation - rows with quantity == 0 and amount == 0. Why defining row type is important? The types, listed above, are used in the generation procedures of store orders and shipment orders from sales orders and the row type is important. For example, if the row type is sales return, then if the product is shippable or not doesn’t matter - the store orders and invoicing orders are generated always directly from the sales order. If the row type is a normal sale - then if the product is shippable or not is important and it defines if shipment order has to be created or store order and invoice order directly from the sales order. The rows with neutral operation do not participate in these generation procedures as for a row with zero quantity and zero amount there is no point of creating nor store orders, nor invoice orders. Row data validations and rules To avoid ambiguity when defining the type of a Sales Order row, certain restrictions are required when entering data in the sales orders. For example, quantity < 0 is not allowed with amount > 0 in one row as this row would be normal sale and return sale at the same time, which would lead to double Store Orders and Invoice Orders generation for the current row. These are all restrictions in the data in the sales orders, related to the row types definition: the quantity and the amount in the row must be with the same signs (for example, one is > 0 and the second is < 0); if the quantity and the amount in the row are positive then the ReturnForSalesOrderLine, ReturnForInvoiceLine and HistoricalUnitCost must be null; the header fields \"ReturnForSalesOrder and ReturnForInvoice must be also null; if one of the quantities or the amount in the row is negative and the product is not stocked then the HistoricUnitCost must be null; if one of the quantities or the amount in the row is negative and the product is stocked, then exactly one of the fields must have value - ReturnForSalesOrderLine and HistoricUnitCost. These restrictions are also required because they maintain the overall validity of the data in the sales order according to the business logic of the fields being part of the constraints. Validation is not only applied when the data is entered in the row, it may also appear and during the execution of a generation procedure."
  },
  "modules/crm/sales/sales-concepts/vat-deviation.html": {
    "href": "modules/crm/sales/sales-concepts/vat-deviation.html",
    "title": "VAT Deviation | ERP.net Tech Docs",
    "keywords": "VAT Deviation VAT Deviation is a term used in sales orders and invoices. It is used in POS/store sales and their sales invoices. VAT deviation is the difference between the amount of the document that is obtained, when value added tax is calculated on the total amount of the document (which is the standard method of calculation in ERP.net) and the amount that is obtained when value added tax is charged on each Unit price in the document separately (which is the case for Store sales). Usage VAT Deviation is used in store sales and their sales invoices when in those documents the VAT and/or discounts are not applied directly to the line amounts. Then the total amount of payment that ERP.net will calculate (value [Standard Amount] ) may differ, usually by a few cents, from the amount the client actually pays (value [POS Amount] ). In these cases, VAT deviation is calculated as an additional amount in the Sales order / Invoice that is paid by the customer and serves as an adjustment to the standard ERP.net way of calculating a payment amount. The additional VAT deviation can be used for accounting purposes as well, in order to make a transition between the standard amounts and the POS amounts. Calculation If we denote the value of the two amounts of the document by [POS Amount] and [Standard Amount] then the formula would be: [VAT Deviation] = [POS Amount] - [Standard Amount] . The difference between [POS Amount] and the [Standard amount] is that when calculating the [POS Amount] VAT is applied to the line amount for each line separately (taking into consideration the standard and specific discounts and then rounding off the result to a second decimal sign before calculating the amount of the line). Whereas while calculating [Standard Amount] the value added tax is applied to the entire amount of all lines (the rounding is performed on the total amount). [POS Amount] and [Standard Amount] are calculated as follows: [Standard Amount] = Round ( [Line Amount_Line1] + [Line Amount_Line2] + ... + [Line Amount_LineN] ) * (1 + [VAT Rate] )) [POS Amount] = [POS Line Amount_Line1] + [POS Line Amount_Line2] + ... + [POS Line Amount_LineN] , where Line1, Line2, ... LineN are all lines in the Sales / Invoice (the formula of the Line Amount is described it the topic Determine Line Amount in Sales Orders ), and the POS Amount for each line is calculated as follows: [POS Line Amount] = Round ( [Quantity] * [POS Unit Price], [POS Unit Price] = Round ( [Unit Price] * [1 - [Standard Discount] ) * (1 - [Custom Discount] ) * (1 + [VAT Rate] )). The rounding made to a second decimal place. It is also considered that all percentages - [VAT rate], [Standard Discount] and [Custom Discount] - are fractional numbers between 0 and 1. Example: Let's have a sales order with two lines: in the first one we have 7 pcs with a Unit Price - 7.37 (without VAT) and in the second one we have 0.354 kg with a Unit Price of 3.58 (VAT excluded). The VAT rate is 20% (i.e. [VAT rate] = 0.2). So we can calculate that: [LineAmount_Line1] = Round ( 7 * 7.37 ) = 51.59 ; [LineAmount_Line2] = Round ( 0.354 * 3.58 ) = Round ( 1.26732 ) = 1.27 ; [Standard Amount] = Round (( 51.59 + 1.27 ) * ( 1 + 0.2 )) = Round ( 63.432 ) = 63.43 ; [POS Unit Price_Line1] = Round ( 7.37 * (1 + 0.2 )) = Round ( 8.844 ) = 8.84 ; [POS Unit Price_Line2] = Round ( 3.58 * (1 + 0.2 )) = Round ( 4.296 ) = 4.30 ; [POS Line Amount_Line1] = Round ( 7 * 8.84 ) = 61.88 ; [POS Line Amount_Line2] = Round ( 0.354 * 4.30 ) = Round ( 1.5222 ) = 1.52 ; [POS Amount] = 61.88 + 1.52 = 63.40 ; [VAT Deviation] = 63.40 - 63.43 = -0.03 ."
  },
  "modules/crm/sales/sales-order-payment-plan.html": {
    "href": "modules/crm/sales/sales-order-payment-plan.html",
    "title": "Sales order payment plan | ERP.net Tech Docs",
    "keywords": "Sales order payment plan This topic describes the essence of the sales order payment plans, the method of calculating the instalments, and the algorithm for creating payment requests under a plan. Sales order payment plans The sales order payment plan determines how the amount of the given sales order is paid (with how many instalments and their individual amounts). For each instalment, there are two main attributes - a method for determining the amount and a method for determining the due dates (the payment term ). Methods for determining the amount (specified by the Amount Percent , Amount and Remainder fields): an indication of a fixed amount that does not depend on other factors; the amount of the instalment is a percentage of the total amount of the transaction; the amount is the remainder that is not covered by the other instalments. It is mandatory that in every plan there must be exactly one instalment marked as a Remainder (usually this is the last instalment in the plan). It is necessary to have such an instalment because it 'picks up' all of the small inaccuracies and differences of rounding (if there are other instalments whose amounts are determined by a percentage). It can also 'pick up' the changes in the total amount happening due to changes in the terms of trade in the invoices (see Example 3 below). There are two main fields with values that need to be determined in order to define the payment term - Payment Due Start Date (a.k.a Execution Date ) and Payment Due Date . Payment Due Start Date (a.k.a Execution Date ) is the date when the payment becomes due/executable and payment due date is the last day of the payment term. Due date form methods according to which the payment term is calculated: Specify the date explicitly: the payment due start date is determined by adding 'Payment term days' to the 'Explicit payment due date' and the due date is 'Explicit execution date' added with 'Execution term, days'; Use sales order due date: Due start date/Execution date and Payment due date are copied directly from the sales order header fields *Payment Due Start Date ' and Payment Due Date ; Use sales order date: the dates are calculated using the sales order document date added with the number of days entered in 'Execution term, days' (for the calculation of the payment start due date) or 'Payment Term days' (for the calculation of the due date); Use invoice due date: Due start date/Execution date and Payment due date are copied directly from the invoice header fields Payment Due Start Date and Payment Due Date ; Use invoice date: the dates are calculated using the invoice document date added with the number of days entered in 'Execution term, days' (for the calculation of the payment start due date) or 'Payment term days' (for the calculation of the due date); The last two methods use the delivery invoice dates. If they are not yet issued, then the dates are calculated according to the values inserted in the Sales Order header. If there is no indicated payment plan for the particular sales order at all, then it is considered that there is a plan that consists of only one instalment. This instalment is not numbered (see the Create payment orders section below) and is for total amount to pay of the sales order. In a 'service' instalment the method of determining the payment term depends on whether the Payment orders for the invoiced amounts will be created from the sales order or not (this depends on the setting of the Payment order generation procedure). If the payment orders for invoiced amounts will be generated from the sales order, then for the 'Due date form Method' the 'Use invoice due date' method is used, otherwise the 'Use Sales order Due date' method is used. Determining the total payment amount In order to determine the amount of each instalment, it is first necessary to determine what is the total / final amount that has to be paid for this transaction. This is done using the data from several documents - the Sales order with which the transaction is reflected and all Invoices for this sale (both for the advance and for delivery). For this purpose, two types of Amounts are calculated separately – Sales order amounts and Invoice amounts, which are then summed to obtain the final amount. Invoice amounts are the Amounts to pay (see topic Amount to pay ) of the delivery invoices. And the sales orders amounts are the paid advances and the remaining part of the Amount to pay (see topic Amount to pay ) of the sales order, which is not covered by an advance or delivery. To determine the last amount (the remaining part of the amount to pay of the sales order), the following formula is used: [remaining part] = [Amount to Pay of the Sales order] - [advances paid] - [invoiced part of the Sales order] The invoiced part is calculated by determining how much of the Amount to pay of the sales order is covered by the delivery invoices. This is done for each line of invoices in two alternative methods: through the Covered amount field of the Invoice lines; or through the quantities in the Invoice lines (this is used for the lines in which the Covered Amount is not filled in). Finally, the results of all lines of delivery invoices for current sales order are summed into [invoiced part of the Sales order] . It does not matter what the final amount to pay for the invoice is. The reason why the final amount to pay of the invoice is not to be considered is that there may be a change in the trading conditions (prices, discounts, etc.). This should not change the ratio - what part of the sales order is covered by this invoice. The first method is based on how much of the basе of the sales order (the Line Amount field of the Sales Order line) is covered by the value of the Sales Order Amount field in the line of the invoice. This relationship determines what part of the Sales Order line has been invoiced. For example, if the Sales Order lines is for 100.00 BGN and we have 20.00 BGN VAT (ie the amount to pay of the sales order is 120.00 BGN) and there is one Invoice line in which the covered sales order amount is 70.00 BGN, then the invoiced part of the sales order line is 120.00 * 70.00 / 100.00 = 84.00 BGN . The second method works on the same principle, but the relationship is made between the quantities of the Sales order line and the Invoice line. For example, if in the Sales Order line there is aqQuantity = 10 pcs with a total Amount to pay = 90.00 BGN and there is only one Invoice line for quantity = 7 pcs then the invoiced part of the Sales Order line is 90.00 BGN * 7 pc / 10 pc = 63.00 BGN . If there also is an advance deduction in the invoice, this deduction is also subtracted from the invoiced part (because advances are aggregated in [advances paid] ). If in the example described above there is an advance deduction of 15.00 BGN in the Invoice, then the invoiced part of the Sales order is (90.00 BGN * 7 pcs / 10pcs) – 15.00 BGN = 48.00 BGN . Example 1: There is a sales order with quantity = 10 pcs for a total Amount to pay of 90.00 BGN , there already is a paid advance of 15.00 BGN and two delivery Invoices (in which the field*'Sales Order Amount* is not filled in): one for quantity = 3 pcs in which we deduct the advance and therefore we have an amount to pay of the invoice 12.00 BGN = (27.00 BGN – 15.00 BGN) ; one for quantity = 4 pcs , in which trade conditions are changed and so we have an amount to pay of the invoice 41.00 BGN (instead of the expected 36.00 BGN ). The result is: [invoiced part of Sales order] = (90.00 BGN * 3 pss / 10 pcs) + (90.00 BGN * 4 pcs / 10 pcs) – 15.00 BGN = 48.00 BGN ; [remaining part] = 90.00 BGN – 15.00 BGN – 48.00 BGN = 27.00 BGN ; Thus, we receive two Invoice Amounts – 12.00 BGN and 41.00 BGN - and two Sales order amounts – 15.00 BGN (advance) and 27.00 BGN . The final payment amount is: [total Amount to pay] = 12.00 BGN + 41.00 BGN + 15.00 BGN + 27.00 BGN = 95.00 BGN In principle, (and from Example 1 ) we see that the total Amount to pay practically is the amount to pay of the sales order summed with the increases/decreases that occurred due to a change in the terms of trade in the invoices. The reason behind the using of such a breakdown of individual (smaller) amounts in the calculation is to avoid a (technical) complex analysis of how exactly the trade terms of the Invoices have changed and how this changes and affects the total amount. Also, these individual amounts help with the creation of Payment orders. Determination of the instalments amounts The instalments are calculated by computing the total amount to pay and applying the method of determining the instalment amount. Here are two examples: Example 2: There is a sales order with a total amount to pay 95.00 BGN . For this sales order, there is a payment plan with three instalments: the first for 33.30 % , the second for 33.70 % and the third is marked as a ' Remainder '. Thus, we get the following instalments: [Instalment 1] = 95.00 BGN * 33.30 % = 31.635 ~ 31.64 BGN ; [Instalment 2] = 95.00 BGN * 33.70 % = 32.015 ~ 32.02 BGN; [Instalment 3] = 95.00 BGN - 31.64 BGN - 32.02 BGN = 31.34 BGN ; Example 2 shows that when using a percent-based instalment and we have a change (increase/decrease) in the Amount to pay because of changing the terms of trade in the invoices, this change is evenly distributed among the instalments. It also illustrates the usefulness of the 'Remainder' instalment. If it was, instead, 33.00 %, then the total amount of the three instalments (after determining the percentages after the rounding) would be 95.05 BGN and not 95.00 BGN! Example 3: There is a sales order with a total amount to pay 95.00 BGN . For this sales order, there is a payment plan with three instalments: the first for an exact amount of 30.00 BGN , the second for an exact amount of 40.00 BGN and the third is marked as a 'remainder'. Thus, we get the following instalments: [Instalment 1] = 30.00 BGN (fixed amounts do not change); [Instalment 2] = 40.00 BGN (fixed amounts do not change); [Instalment 3] = 95.00 BGN – 30.00 BGN – 40.00 BGN = 25.00 BGN ; This example illustrates the other benefits of the 'Remainder' instalment. When there are only fixed amounts in the previous instalments and there is change of the trade terms in the invoices, then this change is reflected in the last instalment. Create payment orders When we create payment orders by a sales order payment plan, first we have to determine the amount (as described above) and the due dates for any of the plan instalments. Thereafter, individual sales order and invoices amounts (those from which the total amount is formed) are determined. We make an additional breakdown of the instalments and the instalments are exhausted in the order of creation of the individual amounts. Example 4: Let's use the situation of Example 1 and the payment plan of Example 3 . We get the following breakdown: 15.00 BGN - from [instalment 1] and because of the advance amount of the Sales order; 12.00 BGN - from [instalment 1] and because of the amount of the first Invoice; 3.00 BGN - from [instalment 1] and because of the amount of the second invoice; 38.00 BGN - from [instalment 2] and because of the amount of the second invoice; 2.00 BGN - from [instalment 2] and because of the remaining part amount of the sales order; 25.00 BGN - from [instalment 3] and because of the remaining part amount of the sales order. More examples of payment orders generated by sales order payment plans there are in topic Transitional documents . [!NOTE:] In the usual case, the sales and invoice amounts will match the instalments amounts, in fact, the resulting breakdown will match the payment plan (none of the >instalments will be 'broken down'). Then, for each Amount the resulting breakdown can create a separate Payment order. Whether it will be created or not depends on the settings of the generation procedure. If in the Settings it is indicated that the Payment orders have to be created for the invoiced amounts, then for the relevant Invoice amounts (these are amounts of 12.00 BGN, 3.00 BGN and 38.00 BGN from the example above) separate Payment orders will be created. Otherwise, no Payment orders are going to be created for those amounts. The same is valid for the non-invoiced amounts (amounts 15.00 BGN, 2.00 BGN and 25.00 BGN from above) with the only difference that the setting of the generation procedure has another name. The due start date ( Amount.DueStartdate ) and the due date ( Amount.Duedate )are the determined dates for the current instalment (from which the amount has been broken down) according to its method. The fields for reference invoice data ( 'Invoice amount', 'Referent invoice document type', ' Referent invoice number', etc. ... ) are filled in depending on whether the amount of the breakdown has been calculated according to the sales order or invoice amount. The Party ( Amount.Party ) in the payment order is inherited from the customer and the location party is inherited from the Ship To Customer field in the sales order. The instalment number ( Amount.InstallmentNumber ) in the Payment order is filled in according to the corresponding field in the instalment from which the amount has been broken down. If the instalment is 'service' (i.e. no payment plan has been entered in the sales order), then the field for the instalment number in the payment order remains blank. The payment account ( Amount.PaymentAccount ) and the payment type ( Amount.PaymentType ) in the payment order are inherited from the corresponding instalment from the plan. If they are not filled in in the instalment or the instalment is 'service' then they are inherited from the Sales Order header. Additionally, if the payment type is not filled in both places but the amount is an invoice amount and payment type is filled in in the invoice, then it is inherited from the invoice. The document notes ( Amount.DocumentNotes ) in the Payment order are a combination of the document notes of the parent document and the notes of the corresponding in the plan. If both are filled in – then they are concatenated, separated by a space (or a new line). And if only one of them is filled in – it is the only one that is inherited."
  },
  "modules/financials/cost-accounting/add-production-function.html": {
    "href": "modules/financials/cost-accounting/add-production-function.html",
    "title": "Add production function | ERP.net Tech Docs",
    "keywords": "Add production function This function is used in the Cost distribution document. When used, it adds the production from the specified period and store to the document. How does it work? The function selects all store transaction lines, filtered by the following conditions: They are part of a document which is at least Released and non-voided. They are part of a document with the same enterprise company as the one of the cost distribution document. They are part of a store transaction with a store equal to the one in the cost distribution header (if specified); if the store of the cost distribution header is empty, then the current filter is not applied. The store transaction's movement type is \"Receipt\"; Their Transaction Timestamp is in the period specified in the document header. Their quantity base is not 0. The ParentStoreOrderLine is not null. The store order specified in the ParentStoreOrderLine field has output order as a parent document. When the set of store transaction lines is ready, it is loaded in the Outputs panel of the cost distribution document. The fields in the panel are filled as follows: Line No - unique, consecutive line number. The field is AutoNumber; Cost Object - the id of the store transaction line; Weight Coefficient - the function sets the Line Base Cost Corrections as a coefficient. The line base cost corrections equals the sum of [LineBaseCost] (in the current store transaction line) and the sum of [BaseCostAdjustment] of all cost correction lines which are non-voided and at least released and referring the current store transaction lines. When the data is filled in the cost distribution outputs table, the Cost distribution document is saved."
  },
  "modules/financials/cost-accounting/calculate-distribution-function.html": {
    "href": "modules/financials/cost-accounting/calculate-distribution-function.html",
    "title": "Calculate distribution function | ERP.net Tech Docs",
    "keywords": "Calculate distribution function The function is used in the Cost distribution document. When used, it calculates the distributed amounts for each output and for each cost type and fills the Results table with the calculations. How does it work? The function performs the following steps: Calculate the sum of the weight coefficients of all outputs. For each output and for each cost type the distributed amount is calculated by the following algorithm: at first, it is assumed that a proportion of the distributed cost amounts is defined, so the distribution is executed. If we have n outputs which we have to distribute cost amounts on, for every row (a row is a combination of output and cost type) a weight is defined - [k 1 ] , [k 2 ] ... [k n ] . So if the amount of the coefficients is [S] (i.e. [S] = [k 1 ] + [k 2 ] + ... + [k n ] ) and this amount is not equal to 0, than the i -row the proportion is [k i ]/[S] : [distribution to row i ] = ROUND([cost type amount] [k i ] / [S] , 2); This is a standard distribution algorithm. Specific cases are when [S] is 0 . Usually, in those cases the cost amount is distributed evenly through the row, using the following formula: [row i distribution] = ROUND([cost type amount] / [rows count], 2); Sometimes the cost amount may not be able to be distributed exactly through the rows. In these cases, an attempt is made to allocate the balance through the rows which the amount is distributed to. Normally, it is impossible to distribute an equal part of the balance to all rows (otherwise there will be no balance). So the balance is distributed by the first several rows starting with the row with the largest amount. Also, in this balance distribution we cannot distribute less than: [minimal balance distribution on a row] = 1 / 10 [Round Scale] . (the round scale for line amounts is always 2 (currently), so we cannot distribute cost amount of less than 1/10 2 = 0.01) In the Results table, the results of step 2 are saved and for each combination of output and cost type, a new row is added. Example 1 Let's say there is a cost distribution document with two cost types with the following data: Cost Type: CT1 ; Distributed Cost Amount: 100 ; Cost Type: CT2 ; Distributed Cost Amount: 500 ; In the Outputs table, the following rows are present: LineNo: 10 ; Cost Object: StoreTransactionLine1 ; Weight Coefficient: 15.00 ; LineNo: 20 ; Cost Object: StoreTransactionLine2 ; Weight Coefficient: 13.00 ; LineNo: 30 ; Cost Object: StoreTransactionLine3 ; Weight Coefficient: 10.11 ; LineNo: 40 ; Cost Object: StoreTransactionLine4 ; Weight Coefficient: -0.50 ; LineNo: 50 ; Cost Object: StoreTransactionLine5 ; Weight Coefficient: 29.99 . So [S] in the example is: 15.00 + 13.00 + 10.11 + -0.50 + 29.99 = 67.60 . When the calculate distribution function is started, the results table is filled with the following data: OutputLineNo = 10 ; Cost Type: CT1 ; Distributed Amount Base: 22.19 ; DistributedAmountBase = ROUND([k Output[LineNo=10] ] / [S] * [Cost Type Amount] ; 2) = ROUND(15.00 / 67.60 * 100; 2) = 22.19; OutputLineNo = 20 ; Cost Type: CT1 ; Distributed Amount Base: 19.23 ; Calculation steps: DistributedAmountBase = ROUND(13.00 / 67.60 * 100 ; 2) = 19.23; OutputLineNo = 30 ; Cost Type: CT1 ; Distributed Amount Base: 14.96 ; Calculation steps: DistributedAmountBase = ROUND(10.11 / 67.60 * 100 ; 2) = 14.96; OutputLineNo = 40 ; Cost Type: CT1 ; Distributed Amount Base: -0.74 ; Calculation steps: DistributedAmountBase = ROUND(-0.50 / 67.60 * 100 ; 2) = -1.09; OutputLineNo = 50 ; Cost Type: CT1 ; Distributed Amount Base: 44.36 ; Calculation steps: DistributedAmountBase = ROUND(29.99 / 67.60 * 100 ; 2) = 44.36; OutputLineNo = 10 ; Cost Type: CT2 ; Distributed Amount Base: 110.95 ; Calculation steps: DistributedAmountBase = ROUND(15.00 / 67.60 * 500 ; 2) = 110; OutputLineNo = 20 ; Cost Type: CT2 ; Distributed Amount Base: 96.15 ; Calculation steps: DistributedAmountBase = ROUND(13.00 / 67.60 * 500 ; 2) = 96.15; OutputLineNo = 30 ; Cost Type: CT2 ; Distributed Amount Base: 74.78 ; Calculation steps: DistributedAmountBase = ROUND(10.11 / 67.60 * 500 ; 2) = 74.78; OutputLineNo = 40 ; Cost Type: CT2 ; Distributed Amount Base: -3.70 ; Calculation steps: DistributedAmountBase = ROUND(-0.50 / 67.60 * 500 ; 2) = -3.70; OutputLineNo = 50 ; Cost Type: CT2 ; Distributed Amount Base: 221.82 ; Calculation steps: DistributedAmountBase = ROUND(29.99 / 67.60 * 500 ; 2) = 221.82. Example 2 Let's see an example where the sum of the DistributedAmountBase of a cost type is not the cost type distributed cost amount. A cost distribution document is present with one cost type CT1 with amount of 100.93 . In the Outputs table, the following rows are present: LineNo: 10 ; Cost Object: StoreTransactionLine1 ; Weight Coefficient: 15.11 ; LineNo: 20 ; Cost Object: StoreTransactionLine2 ; Weight Coefficient: 0.00 ; LineNo: 30 ; Cost Object: StoreTransactionLine3 ; Weight Coefficient: 10.00 ; LineNo: 40 ; Cost Object: StoreTransactionLine4 ; Weight Coefficient: 20.00 ; LineNo: 50 ; Cost Object: StoreTransactionLine5 ; Weight Coefficient: 15.11 . So the [S] in the examples is 15.11 + 0 + 10 + 20 + 15.11 = 60.22 . When the calculate distribution function is started, the results table is filled with the following data: OutputLineNo = 10 ; Cost Type: CT1 ; Distributed Amount Base: 25.32 ; DistributedAmountBase = ROUND([k Output[LineNo=10] ] / [S] * [Cost Type Amount] ; 2) = ROUND(15.11 / 66.22 * 100.93; 2) = 25.32; OutputLineNo = 20 ; Cost Type: CT1 ; Distributed Amount Base: 0.00 ; Calculation steps: DistributedAmountBase = ROUND(0.00 / 66.22 * 100.93 ; 2) = 0.00; OutputLineNo = 30 ; Cost Type: CT1 ; Distributed Amount Base: 16.76 ; Calculation steps: DistributedAmountBase = ROUND(10.00 / 66.22 * 100.93 ; 2) = 16.76; OutputLineNo = 40 ; Cost Type: CT1 ; Distributed Amount Base: 33.52 ; Calculation steps: DistributedAmountBase = ROUND(20.00 / 66.22 * 100.93 ; 2) = 33.52; OutputLineNo = 50 ; Cost Type: CT1 ; Distributed Amount Base: 25.32 ; Calculation steps: DistributedAmountBase = ROUND(15.11 / 66.22 * 100.93 ; 2) = 25.32; Now the DistributedAmountBase sum is 22.32 + 0.00 + 16.76 + 33.52 + 22.32 = 100.92 and there is difference of 0.01 between the distributed cost amount of the CT1 as it is 100.93 . The difference of 0.01 meets the requirement of [minimal balance distribution on a row] = 1 / 10 [2] =0.01. The balance distribution amount is 0.01 and it should be distributed on the row with largest amount, the row with the Output [LineNo=40] . The final Results now would be as follows: OutputLineNo = 10 ; Cost Type: CT1 ; Distributed Amount Base: 25.32 ; OutputLineNo = 20 ; Cost Type: CT1 ; Distributed Amount Base: 0.00 ; OutputLineNo = 30 ; Cost Type: CT1 ; Distributed Amount Base: 16.76 ; OutputLineNo = 40 ; Cost Type: CT1 ; Distributed Amount Base: 33.53 ; (the balance is distributed here) OutputLineNo = 50 ; Cost Type: CT1 ; Distributed Amount Base: 25.32 . Note If the balance distribution amount in Example 2 was 0.02, it would be distributed on OutputLineNo = 40 and OutputLineNo = 10 as these are the first two largest >amounts through the rows."
  },
  "modules/financials/cost-accounting/cost-distribution.html": {
    "href": "modules/financials/cost-accounting/cost-distribution.html",
    "title": "Cost distribution | ERP.net Tech Docs",
    "keywords": "Cost distribution The cost distribution document is used to distribute costs. Users may enter one or more cost types and their amounts. The cost distribution may be performed manually or automatically by using the integrated functions. How to use the document? At first, the user has to enter the dates and (if necessary) store, where they are distributing costs. The period of the cost distribution is specified in the cost distribution table by the following fields: Start Date - starting date of the period for which the current document distributes costs. The field cannot be empty and it is entered manually by the user. End Date - end date of the period for which the current document distributes costs. The field cannot be empty and it is entered manually by the user. Store - specifies the store in which the cost is distributed. In the distribution cost types table, the user enters the cost types and their amounts. Note The cost type amounts are entered in enterprise company base currency! The Distributed Cost Amount field accepts decimal values. Then, the user has to enter/load the outputs on which they are distributing the specified amounts and cost types. This is performed in the outputs table. The fields are: Line No - this is the consecutive line number in the document, unique within the document. Cost Object - the ID of the cost object for which costs will be distributed. The domain of the cost object is determined by the distribution document type. Weight Coefficient - the field is mandatory. This is a weight coefficient for the cost distribution on the current row. Manual data entering in the outputs table is not available. The document has a function which automatically loads the outputs for the specified period (and store, if entered). For more information see Add production function . After the production is filled in the document, the cost distribution calculation may be performed manually or automatically. The table cost distribution results contains the amounts calculated for distribution on the outputs data. In the results table, there are the following fields: Output Id - the distribution output over which we are distributing the cost (the amount in the current row); Cost Type - the cost type for which the distribution in the current row is calculated; Distributed Amount Base - the amount (in base currency) of the distributed cost. The amount is calculated for the combination of output and cost type. The data in the results table has a function that calculates distributed amounts on each output. The amount is the total amount (distributed to the current output) of all cost types which are set for distribution. For more information, see Calculate Distribution Function ."
  },
  "modules/financials/cost-accounting/index.html": {
    "href": "modules/financials/cost-accounting/index.html",
    "title": "Cost Accounting | ERP.net Tech Docs",
    "keywords": "Cost Accounting Add production function Calculate distribution function Cost distribution Distribution business rules Distribution generation procedures"
  },
  "modules/financials/excise/excise-product-categories.html": {
    "href": "modules/financials/excise/excise-product-categories.html",
    "title": "Excise product categories | ERP.net Tech Docs",
    "keywords": "Excise product categories EU Excise product categories Excise Product Categories Excise Product Category code Manufactured tobacco products T Beer B Wine and fermented beverages other than wine and beer W Intermediate products I Ethyl alcohol and spirits S Energy products E https://ec.europa.eu/taxation_customs/dds2/seed/help/seedhpep.jsp?callbackuri=CBU-3&Lang=en"
  },
  "modules/financials/excise/excise-products.html": {
    "href": "modules/financials/excise/excise-products.html",
    "title": "Excise products | ERP.net Tech Docs",
    "keywords": "Excise products EU Excise products Excise Products Excise Product Code Cigarettes T200 Cigars and cigarillos T300 Fine-cut tobacco for the rolling of cigarettes T400 Other smoking tobacco T500 Beer B000 Still wine and still fermented beverages other than wine and beer W200 Sparkling wine and sparkling fermented beverages other than wine and beer W300 Alcohol - intermediate products I000 Spirituous beverages S200 Ethyl alcohol S300 Partially denatured alcohol S400 Other products containing ethyl alcohol S500 Vegetable and animal oils (energy products) Products falling within CN codes 1507 to 1518, if these are intended for use as heating fuel or motor fuel E200 Mineral oils (energy products) Products failing within CN codes 2707 10, 2707 20, 2707 30, and 2707 50 E300 Leaded petrol E410 Unleaded petrol E420 Gasoil, unmarked E430 Gasoil, marked E440 Kerosene, unmarked E450 Kerosene, marked E460 Heavy fuel oil E470 Products failing within CN codes 2710 11 21, 2710 11 25, 2710 19 29 in bulk commercial movements E480 Products failing within CN codes 2710 11 to 2710 19 69, not specified above E490 Liquefied petroleum gases and other gaseous hydrocarbons (LPG) E500 Saturated acyclic hydrocarbons E600 Cyclic hydrocarbons E700 Methanol (methyl alcohol) E800 Mixture of acyclic hydrocarbons - \"FAMAE\" E910 Mixture of acyclic hydrocarbons - others E920 https://ec.europa.eu/taxation_customs/dds2/seed/help/seedhpep.jsp?callbackuri=CBU-3&Lang=en"
  },
  "modules/financials/excise/index.html": {
    "href": "modules/financials/excise/index.html",
    "title": "Excise | ERP.net Tech Docs",
    "keywords": "Excise Excise product categories Excise products"
  },
  "modules/financials/fixed-assets/depreciation-methods/depreciation-functions.html": {
    "href": "modules/financials/fixed-assets/depreciation-methods/depreciation-functions.html",
    "title": "Depreciation functions | ERP.net Tech Docs",
    "keywords": "Depreciation functions"
  },
  "modules/financials/fixed-assets/depreciation-methods/index.html": {
    "href": "modules/financials/fixed-assets/depreciation-methods/index.html",
    "title": "Depreciation methods | ERP.net Tech Docs",
    "keywords": "Depreciation methods Depreciation functions Period determination methods"
  },
  "modules/financials/fixed-assets/depreciation-methods/period-determination-methods.html": {
    "href": "modules/financials/fixed-assets/depreciation-methods/period-determination-methods.html",
    "title": "Period determination methods | ERP.net Tech Docs",
    "keywords": "Period determination methods From next month to last month From current month to last but one month By days Method of calculation First, the quota for each month is calculated: Month quota = Depreciable amount / Int(Month(Depreciation End Date - Depreciation Start Date -1)) For the first month: First month Depreciation = Month quota * ((Number of Days in First month - Depreciation Start Date)/Number of Days in First month) For every next month but last one: Depreciation = Month quota For the last month: Depreciation = Month quota - First month Depreciation Example: Asset with Useful life = 6 months and Depreciable amount = 120 Depreciation Plan = 14.01 - 14.07 Month quota = 120 / 6 months = 20 First month Depreciation = 20 * ((31-14)/31) = 10.97 For 2,3,4,5 and 6th month Depreciation = 20 Last month Depreciation = 20 - 10.97 = 9.03"
  },
  "modules/financials/fixed-assets/index.html": {
    "href": "modules/financials/fixed-assets/index.html",
    "title": "Fixed assets | ERP.net Tech Docs",
    "keywords": "Fixed assets Depreciation methods"
  },
  "modules/financials/index.html": {
    "href": "modules/financials/index.html",
    "title": "| ERP.net Tech Docs",
    "keywords": "VAT Fixed assets Cost accounting Payments Excise"
  },
  "modules/financials/overview.html": {
    "href": "modules/financials/overview.html",
    "title": "ERP.net Financials | ERP.net Tech Docs",
    "keywords": "ERP.net Financials Accounting Cost Accounting Fixed Assets Intrastat Payments VAT"
  },
  "modules/financials/payments/advance-amounts-determination/advance-amount-calculation-algorithm.html": {
    "href": "modules/financials/payments/advance-amounts-determination/advance-amount-calculation-algorithm.html",
    "title": "Advance amount calculation algorithm | ERP.net Tech Docs",
    "keywords": "Advance amount calculation algorithm 1. Determination of the rows containing advances Advance amounts are considered the amounts from all rows where the party in the payment order is the same as the party in the payment transaction and the payment order has no value in the Referent Invoice Number field. The condition in the Referent Invoice Number field is appropriate for sales orders and purchase orders because there we expect that after the invoice or the purchase invoice is released, the payment orders are (re)generated with data from the invoice and the Referent Invoice Number field would be filled in. Note So the payment order with no Referent Invoice Number , created before the invoice and its payment releases, is a payment before the invoice release and is considered an advance. Example 1 : There is a payment transaction where the Party is Company 1 and it consists of 10 rows: row #10, Covered Amount = 20 BGN, Amount = 20 EUR, Payment Order = PO #1; row #20, Covered Amount = 38 BGN, Amount = 38 EUR, Payment Order = PO#2; row #30, Covered Amount = 50 BGN, Amount = 50 EUR, Payment Order = PO #3; row #40, Covered Amount = 20 BGN, Amount = 20 EUR, Payment Order = PO #4; row #50, Covered Amount = 35 BGN, Amount = 35 EUR, Payment Order = PO #5; row #60, Covered Amount = 30 BGN, Amount = 30 EUR, Payment Order = PO #6; row #70, Covered Amount = 25 BGN, Amount = 25 EUR, Payment Order = PO #7; row #80, Covered Amount = 40 EUR, Amount = 80 BGN, Payment Order = PO #8; row #90, Covered Amount = 25 EUR, Amount = 50 BGN, Payment Order = PO #9; row #100, Covered Amount = 20 EUR, Amount = 40 BGN, Payment Order = PO #9. For each of the nine payment orders the following data is available: PO #1: Party = Company 1, Reference Invoice Number = null; PO #2: Party = Company 1, Reference Invoice Number = null; PO #3: Party = Company 1, Reference Invoice Number = \"1100056\"; PO #4: Party = Company 1, Reference Invoice Number = \"10700149\"; PO #5: Party = Company 1, Reference Invoice Number = null; PO #6: Party = Company 1, Reference Invoice Number = null; PO #7: Party = Company 1, Reference Invoice Number = null; PO #8: Party = Company 2, Reference Invoice Number = null; PO #9: Party = Company 1, Reference Invoice Number = null; So from these 10 rows, the following rows would be separated - row #10, row #20, row #50, row #60, row #70, row #90 and row #100, and they will be used for the calculation of the advance amounts. 2. Grouping the rows The Payment Transaction rows, determined in step 1, are grouped by the fields ERP.net Location, Total Amount Currency and Ref Document from the referred payment orders. Thus, for each combination of values from these three fields, a group is formed from the Payment Transaction rows that meet this data. Example 2 : Let’s use the data from Example 1 and the payment orders has the following values in the ERP.net Location, Total Amount Currency and Ref Document values: PO #1, ERP.net Location = \"ERP.net Location 1\", Total Amount Currency = BGN, Ref Document = null; PO #2, ERP.net Location = \"ERP.net Location 1\", Total Amount Currency = BGN, Ref Document = null; PO #5, ERP.net Location = \"ERP.net Location 1\", Total Amount Currency = BGN, Ref Document = \"Sales Order 20001052\"; PO #6, ERP.net Location = \"ERP.net Location 1\", Total Amount Currency = BGN, Ref Document = \"Sales Order 20001052\"; PO #7, ERP.net Location = \"ERP.net Location 1\", Total Amount Currency = BGN, Ref Document = \"Sales Order 20001052\"; PO #8, ERP.net Location = \"ERP.net Location 1\", Total Amount Currency = EUR, Ref Document = \"Sales Order 20001052\"; Thus in these seven separated rows, three groups are formed: Group 1: row #10, row #20 (for \"ERP.net Location 1\", BGN and null ref document); Group 2: row #50, row #60, row #70 (for \"ERP.net Location 1\", BGN and \"Sales Order 20001052\" ref document); Group 3: row #90, row #100 (for \"ERP.net Location 1\", EUR and \"Sales Order 20001052\" ref document). 3. Determining the advance amount for each group For each group from step 2, an advance amount is calculated, which meets the parameter [Is Amount With VAT]. The amounts are summed up from all rows (the values in the Covered Order Amount field), where the Is Amount With VAT has the same value as the parameter [Is Amount With VAT]. When summing the amounts from the rows the following condition should be considered - if the direction of the payment order is different than the direction of the payment transaction, then the value in the Covered Order Amount field should be multiplied by -1 before adding it into the total. *** Example 3***: Let’s use the data from Example 1 and Example 2 and the [Is Amount With VAT] parameter is True and in all payment orders, the Is Amount With VAT field is True, except for PO #5 and PO #6. Also, the direction of the Transaction is Income and all payment orders are income, except for PO #1, PO #5 and PO #7, which direction is Expense . So for each group, the following calculations are performed: for Group 1: [advance amount] = -1 * 20 BGN + 38 BGN = 18 BGN; for Group 2: [advance amount] = 30 BGN + -1 * 25 BGN = 5 BGN (the amount from PO #5 is skipped as it does not meet the [Is Amount With VAT] parameter; for Group 3: [advance amount] = 0 EUR, as the payment orders from all rows do not meet the [Is Amount With VAT] parameter. In the end, the collection of advance amounts which meet the [Is Amount With VAT] parameter consists of two amounts - 18 BGN and 5 BGN (the last one with 0 EUR is skipped). Defining the remaining amount In the end, the values from the Amount fields in all group rows are summed up where the value in the Is Amount With VAT field is different from the [Is Amount With VAT] parameter. All these values are not included in the calculations in the previous step. They form the remaining amount. In the current calculation, the amount should be multiplied by -1 if the payment order direction differs from the payment transaction direction. Example 4 : Using the data from Example 1, Example 2 and Example 3 , the remaining amount is formed by the amounts from PO #5 and PO #9 as they do not meet the [Is Amount With VAT] parameter. So the result is: [remaining amount] = -1 * 35 BGN + 50 BGN + 40 BGN = 55 BGN."
  },
  "modules/financials/payments/advance-amounts-determination/index.html": {
    "href": "modules/financials/payments/advance-amounts-determination/index.html",
    "title": "Advance amounts determination | ERP.net Tech Docs",
    "keywords": "Advance amounts determination The current article describes the algorithm which defines what part of the amounts of a given payment is paid in advance. This algorithm is applicable both in income payments and expense payments so it can determine the advance amounts in both sales orders and purchase orders. Input algorithm data: Payment transactions which contains the advance amounts; [Is Amount With VAT] - a parameter that may be True or False and defines if the amounts include VAT or not. Output algorithm data: Collection of the advance amounts found in the payment transaction, which meets the parameter [Is Amount With VAT]; The total remaining advance amount does not meet the parameter [Is Amount With VAT]. The advance amounts are extracted from the payment yransaction rows and their calculation depends on the data in the payment orders which are referred to in the rows. The algorithm uses the following schema: Determine the rows containing advance amounts. Grouping the rows from step 1. For each group, a total amount is determined, which meets the [Is Amount With VAT] parameter, and this total amount is added to the collection of advance amounts. All rows (from all groups), which contain advance amounts and do not correspond to [Is Amount With VAT], are summed up and they define the remaining amount. For a more detailed explanation of the algorithm, see Advance amount calculation algorithm ."
  },
  "modules/financials/payments/index.html": {
    "href": "modules/financials/payments/index.html",
    "title": "| ERP.net Tech Docs",
    "keywords": ""
  },
  "modules/financials/VAT/defining-vat-and-base-for-vat-entries.html": {
    "href": "modules/financials/VAT/defining-vat-and-base-for-vat-entries.html",
    "title": "Defining VAT and base for VAT Entries | ERP.net Tech Docs",
    "keywords": "Defining VAT and base for VAT Entries The current article describes how the numeric values are defined - base and VAT, which are saved in the VAT Entries when this document is created automatically from other documents in ERP.net. Currently, the documents which create VAT Entries are: Invoices (they create records in the VAT sales ledger entries Sales ledger entries); Transactions (they create records in the VAT sales ledger entries) The calculations are performed in three stages: 1.Defining which document rows participate in the calculation. 2.Defining the deal types for each row. 3.Defining the base and the VAT for each deal type. 1. Defining the participating rows Which rows participate in the calculation of the base and the VAT is defined for each document individually. The set of rows also depends on that if the document creates VAT sales or purchases ledger entries. In invoices , all rows participate in the calculation. In purchase invoices which create VAT purchases ledger entries, all rows participate, too. In purchase invoices which create VAT sales ledger entries there are two cases: if the document header has value in the Sale Deal Type field, then all rows participate in the calculation; if the document header has no value in the Sales Deal Type field, then only the rows which have value in the Sale Line Deal Type field (this is the same field but in the document rows). In transactions , all rows participate in the calculation. 2. Defining the deal types For each row that participates in the calculation, unique identification of the deal type of the row must be defined. If for any of the rows this definition is impossible, the calculation process is interrupted and an error message is displayed. The deal type definition for a row depends on the document which it is part of and on that if the document creates VAT sales or purchases ledger entries. For invoice row - if the row has value in the Line Deal Type field, then the deal type is defined by this value. Otherwise, the value in the document header is used. For purchase invoice (which creates VAT purchases ledger entries) row - the principle is the same as in the Invoice rows - if the row has value in Line Deal Type field, the deal type is defined by this value, otherwise - the Deal Type from the document header is used. For purchase invoice (which creates VAT sales ledger entries) row - the same combination of corresponding fields from the rows and the document header is used, except the fields here are Sales Line Deal Type (in the rows) and Sales Deal Type (in the document header). In transactions, all rows use a specific property of the document flow - Deal Type field from table \"Transaction Entry Template\". There are no specified fields in the document rows and header for the Deal Type. 3. Defining base and VAT for each Deal Type All bases and VAT amounts are calculated only in base currency. For all deal types, defined in stage 2, two values are calculated - [base] and [VAT]. To calculate them for the current deal type the rows, which have such deal type defined in stage 2, are used. Example 1 : There is an Invoice with 7 rows: row #10, Line Deal Type = \"DealType1\", LineAmount = 32 EUR; row #20, Line Deal Type = \"DealType2\", LineAmount = 17 EUR; row #30, Line Deal Type = \"DealType3\", LineAmount = 41 EUR; row #40, Line Deal Type = \"DealType1\", LineAmount = 45 EUR; row #50, Line Deal Type = \"DealType3\", LineAmount = 55 EUR; row #60, Line Deal Type = \"DealType3\", LineAmount = 29 EUR; row #70, Line Deal Type = \"DealType1\", LineAmount = 24 EUR. Thus, in the previous stage for the rows three ideal types are defined - DealType1, DealTyope2 and DealType3. Thus, three bases and three VATs must be calculated - [DealType1:base], [DealType2:base], [DealType3:base], [DealType1:VAT], [DealType2:VAT], [DealType3:VAT]. To calculate base and VAT for DealType1 the data from row #10, row #40 and row #70 are used. For the base and VAT of DealType2 only row #20 is used, and for DealType3 - row #30, row #50 and row# 60. The VAT additional amount is set in the ERP.net definition (see Additional amounts ) of the current document. If the document does not contain the specified VAT additional amount (or there is no such in the ERP.net company definition), the calculation is interrupted by an error message. The distributed additional amount on the rows is used in the calculation of the VAT amounts. And to calculate the bases amounts - the distributed VAT additional amounts which are added to the base and also the line amounts (but only if in the VAT additional amount Base On Lines is true). The bases and VAT’s calculations are performed in three steps: The amounts for each deal type is formed. The rest of the VAT is processed. VAT, which is calculated/distributed incorrectly, is re-distributed. Step 1 For each deal type, two values are calculated - base and VAT. So a list of couples is formed, which has as many elements as deal types there are. This is processed only if the VAT in the document is distributed by the current document (it is possible to distribute on other documents - if so, this step is skipped; it is possible to distribute both on the current document and different documents - then this step is performed). If the step is skipped, then the list is empty. So, for each deal type all rows, which have the specified deal type, are summed up and from each row, the distributed VAT is extracted, the distributed amounts which are added to the Base also, and the line amounts if the VAT is based on lines. The value of [VAT] for the current deal type is the sum of the distributed VAT for all rows with this deal type. And the value of [base] is the sum of the distributed amounts which are added to the VAT base and the line amounts (if the VAT is based on lines). Example 2 : Let's use the Invoice from Example 1 . There is an additional amount VAT, which is 32.32 EUR and it is based on the line amounts and the second additional amount \"Loyal Customer Discount\". The discount amount is 40 EUR and the distribution of both additional amounts is as follows: row #10, distributed discount -7 EUR, distributed VAT 5 EUR; row #20, distributed discount -1 EUR, distributed VAT 1.12 EUR; row #30, distributed discount -14 EUR, distributed VAT 0 EUR; row #40, distributed discount 0 EUR, distributed VAT 9 EUR; row #50, distributed discount -11 EUR, distributed VAT 0 EUR; row #60, distributed discount -3 EUR, distributed VAT 5.2 EUR; row #70, distributed discount -4 EUR, distributed VAT 4 EUR. Also, the VAT amount is distributed not only on the current document but on another document row which has no other additional amounts and line amount of 40 EUR and the distributed VAT is 8 EUR. Then the following calculations for base and VAT for the different deal types of the current document are received: [DealType1: base] = 32 EUR + -7 EUR + 45 EUR + 0 EUR + 24 EUR + -4 EUR = 90 EUR; [DealType2: base] = 17 EUR + -1 EUR = 16 EUR; [DealType3: base] = 41 EUR + -14 EUR + 55 EUR + -11 EUR + 29 EUR + -3 EUR = 97 EUR; [DealType1: VAT] = 5 EUR + 9 EUR + 4 EUR = 18 EUR; [DealType2: VAT] = 1.12 EUR; [DealType3: VAT] = 0 EUR + 0 EUR + 5.2 EUR = 5.2 EUR; Step 2 If any of the following is true: the list of couples of values from Step 1 is empty (this is possible if the VAT is not distributed on the current document); or the VAT is distributed on other documents also or either not the whole VAT is used when forming the VAT amounts in step 1 or not the whole VAT base is used when forming the bases. then the creation of a new couple of values is necessary - base and VAT. The deal type for this couple is extracted from the deal type field in the document header (and if the document is Transaction - then it is extracted from the document flow). In the base and VAT for this deal type the remaining values from the base and VAT, which are not distributed in Step 1 from the other deal types, are recorded. Example 3 : Let's use the data from Example 2 and the Invoice has a deal type in its header - DealType4. The VAT in the document is 32.32 EUR, and [DealType1: VAT] + [DealType2: VAT] + [DealType3: VAT] = 24.32 EUR. So there are 8 EUR remaining. Also the total VAT base (from both documents) is 243 EUR, and [DealType1: base] + [DealType2: base] + [DealType3: base] = 203 EUR. So the remaining base is 40 EUR. So a new couple of values is formed for DealType4: [DealType4: base] = 40 EUR [DealType4: VAT] = 8 EUR Step 3 In the end, there is a newly formed list of couples of values - base and VAT - for several deal types. If one of those deal types does not support VAT and its calculated VAT in the list is not a zero, then a need for correction of those VATs and bases calculated by now appears. The correction is performed by resetting the VATs of all deal types, which VAT is distributed incorrectly in the documents, and these VATs are distributed amongst the other deal types, proportionally to their bases (if after this redistribution there is remaining amount because of roundings, then this small amount is distributed to the last deal type which supports VAT). Example 4 : Let’s use the data from the previous examples and DealType1, DealType2 and DealType4 support VAT, and DealType3 does not. So there is incorrectly distributed VAT of [DealType3:VAT] = 5.2 EUR. So the 5.25 EUR must be relocated to the rest of the deal types - the following correction is achieved: [DealType3: VAT] = 0 EUR; [DealType1: VAT] = 18 EUR + 5.2 EUR * 90 EUR / (90 EUR + 16 EUR + 40 EUR) = 21.21 EUR; [DealType2: VAT] = 1.12 EUR + 5.2 EUR * 16 EUR / (90 EUR + 16 EUR + 40 EUR) = 1.69 EUR; [DealType4: VAT] = 8 EUR + 5.2 EUR * 40 EUR / (90 EUR + 16 EUR + 40 EUR) = 9.42 EUR."
  },
  "modules/financials/VAT/index.html": {
    "href": "modules/financials/VAT/index.html",
    "title": "VAT | ERP.net Tech Docs",
    "keywords": "VAT Defining VAT and base for VAT Entries"
  },
  "modules/general/documents/document-print-images.html": {
    "href": "modules/general/documents/document-print-images.html",
    "title": "Document print images | ERP.net Tech Docs",
    "keywords": "Document print images Document print images contain the data of a printout of a document as it was obtained from the data source at the moment of printing. The data is used as a history in order to review the visual representation of the printed document. The Document print images would take the most space in customer databases. Therefore, it is good to delete obsolete records periodically. It is highly recommended that you set up a system job that will delete them automatically. For more information, see Deletе old document print images"
  },
  "modules/general/documents/index.html": {
    "href": "modules/general/documents/index.html",
    "title": "| ERP.net Tech Docs",
    "keywords": ""
  },
  "modules/general/folders.html": {
    "href": "modules/general/folders.html",
    "title": "File manager | ERP.net Tech Docs",
    "keywords": "File manager The File manager is where you can create and store folders with different files inside. It follows a hierarchical tree order, similar to the one found in Product groups . With the help of the ribbons, you are able to peek inside a complex structure without getting lost. Each folder can have an unlimited number of subfolders , the order of which is decided by pre-defined filters. Moreover, ERP.net allows important documents (such as contracts and statistics) to be embedded, from one to dozens at a time. You can view the contents of a folder if you right-click it and select the Definition command. There are also options to rename , remove , or create a new subfolder within the selected folder. The contents of the folder can be seen in the window that opens. You can create individual folders folders by right-clicking anywhere inside the Tree panel and selecting the New command. This triggers Edit Mode , where a window outside of the File Manager pops up and allows for the creation of the new forder. Parent Folder - whatever you select from the dropdown will make the new folder its subfolder. Folder Name - this is the name of the folder or subfolder. Notes - these are optional details characterising the new folder or subfolder. Before proceeding further, you need to save your current progress, thus completing the folder creation process. Storing files into folders allows for flexibility and security when working with sensitive documents. Currently, it is possible to embed a file only in the [New] window, where \"[New]\" is the folder's name. To do so, right-click inside the panel and select Insert new file -> Embedded File . You will need to select the documents from the location that you store them. Once uploaded, they become part of the folder and are subject to the management capabilities of the File Manager . The quickest way to open a file is by double-clicking it. Its contents will be revealed straight away. You can also see files in different viewing modes, ranging from extra large icons to tables with detailed rows."
  },
  "modules/general/index.html": {
    "href": "modules/general/index.html",
    "title": "| ERP.net Tech Docs",
    "keywords": ""
  },
  "modules/general/products/coding-systems.html": {
    "href": "modules/general/products/coding-systems.html",
    "title": "Coding systems | ERP.net Tech Docs",
    "keywords": "Coding systems Coding Systems group together multiple product codes according to different criteria. All product codes are grouped in coding systems. Product codes are codes other than the part numbers that bring meaning to the company such as supplier codes, customer codes, barcodes and more. A default measurement unit could also be specified in coding systems. If a product code relating to a coding system with a default measurement unit is selected, then this unit must load in the document instead of the product's default unit. For example, if in the products definition \"Measurement Unit = Pcs\" is set, and for this product there is also a product code that relates to a coding system with a \"Default Measurement Unit = Package\", then we expect the following behavior: When a product in the sales order is selected through product code via barcode, then: Product’s part number loads in the Product field in the particular sales order line; \"Quantity Unit = Package\", which corresponds to the default measurement unit in the coding system’s definition; \"Unit Price\" must be recalculated according to the product dimensions ."
  },
  "modules/general/products/index.html": {
    "href": "modules/general/products/index.html",
    "title": "Products | ERP.net Tech Docs",
    "keywords": "Products Products are goods which are the object of a company’s business activities. Products can be tangible or intangible. A tangible product is a physical object that can be perceived by touch such as a building, vehicle, gadget, or clothing. An intangible product is a product that can only be perceived indirectly such as services. In ERP.net, all product-specific data is kept in the product’s definition. Product’s definition includes the information required for specific business processes and other basic data that describes and categorizes the product, for example: product name; part number; product type; measurement unit; costing currency and others. Different panels can also be visualized in the product’s definition, allowing the user to have access to all of the product related information such as product dimensions , current stock holds, serial numbers, lots, product prices and others. All products are grouped in user defined product groups (e.g. goods, materials, services …) according to different criteria. For more information, see Product groups . Coding systems Product codes Product dimensions Product pictures Products - business rules Product types Serial numbers Variable (dynamic) measurement ratios"
  },
  "modules/general/products/product-codes.html": {
    "href": "modules/general/products/product-codes.html",
    "title": "Product codes | ERP.net Tech Docs",
    "keywords": "Product codes Product codes are mechanisms that allow products to be selected not by their part number (indicated in the product definition), but by alternative codes for this product. For example, using this mechanism, products are selected via barcode. Product codes are used for the creation of new codes for existing products in the database. All product codes are grouped in coding systems. This mechanism is applied in the lines of logistics documents. It is implemented through a special field for the product code in the table and is a foreign key to the product codes table. By selecting the number from the drop-down list box you actually select the product for which the code is set. The field is commonly used when the documents are created manually by the user. When the documents are created automatically by the system (through procedures, for example) values in this field are carried by parental documents to sub-documents (if set), but are not automatically filled by the system (if not set). There are certain relations between the fields Product , Product Code and Quantity Unit : If the field Product Code has a value or the value in the field is changed, then the value of the Quantity Unit is taken from the definition of coding system (if set) to which the code belongs; If the value in the field Product is changed, then the field Product Code must be empty, because the product is no longer selected through this mechanism."
  },
  "modules/general/products/product-dimensions/index.html": {
    "href": "modules/general/products/product-dimensions/index.html",
    "title": "Product Dimensions | ERP.net Tech Docs",
    "keywords": "Product Dimensions Product Dimensions are used for conversion between different units of measurement for the same quantity. In order to make this possible, product dimensions must be set for the products as a ratio between multiplier and divider to the base unit. The formula for calculation of quantity base in the documents lines is as follows: Quantity Base = Quantity * Product Dimension Dest Quantity / Product Dimension Source Quantity Required fields Description Quantity The quantity in the non-base unit. Source Quantity Unit The non-base unit for which the conversion ratio is specified. Dest Quantity The quantity in some of the base units. Dest Quantity Unit The measurement unit of the dest quantity. Should be one of the units of the base measurement category of the product. Measurement Category The measurement category of the source quantity unit. For each product, only one conversion ratio can be specified for a measurement category. Example: We need to load two pallets of a product. But we know that each pallet contains 15 pieces. So the total pieces that we need to load are 30. This means that if we want to automate this calculation, we need to insert the following information to create a conversion ratio in the product dimensions: Source Quantity - 1.00 Source Quantity Unit - Pallet Dest Quantity - 15.00 Dest Quantity Unit - Pcs Measurement Category - Complectation (e.g.)"
  },
  "modules/general/products/product-groups/index.html": {
    "href": "modules/general/products/product-groups/index.html",
    "title": "Product groups | ERP.net Tech Docs",
    "keywords": "Product groups Product groups form a hierarchical tree structure of the products. ERP.net allows multiple groups with different names and characteristics to be created. Each product group can contain an unlimited number of products which are grouped together according to different criteria. It is strongly recommended that products are grouped in a meaningful way, as they could inherit certain properties from the groups. Product groups could also facilitate the creation of the individual products. For example, in their definition, it could be set: Next part number – a part number to be auto assigned to the products created in the group or the sub-group; Default measurement unit - a measurement unit to be auto assigned to the products created in the group or the sub-group; Product name mask – specifies a mask for the name of the products created in the group or the sub-group. The function allows creation of more accurate names that follow a certain pattern. Product groups could also contain other important settings, such as 'Product group required properties', 'Principal recipes', 'Product supply', etc."
  },
  "modules/general/products/product-types/index.html": {
    "href": "modules/general/products/product-types/index.html",
    "title": "Product types | ERP.net Tech Docs",
    "keywords": "Product types Product types - business rules"
  },
  "modules/general/products/serial-numbers/index.html": {
    "href": "modules/general/products/serial-numbers/index.html",
    "title": "Serial numbers | ERP.net Tech Docs",
    "keywords": "Serial numbers Serial numbers are a way of identifying the different pieces of a product. They may be used for equipment, software, assets and more. With the Serial numbers the user can follow what happens with objects, which are otherwise identified by the system with one product definition (i.e. one Product_Id). The Serial numbers are also important for identification when providing guarantee and support. For example, in a sales order, the user may enter a row with three pieces which will have to be shipped separately (1 piece at a time). But (in the sales order) the user cannot mark which one of the three pieces is shipped first, which one is shipped second and etc. In the sales order, three Serial numbers are entered, but in the Shipments, the user may specify by Serial numbers which one is shipped each time and which Shipment exactly refers to it. Implementation The Serial numbers are recorded in a separate table where each record is an individual Serial number. Additional information is specified as Product, Lot (eventually), Availability (is the current piece blocked), Serial number card data and more. This way of implementation is preferred instead of the initial idea of defining number groups. In this implementation, the numbers in each group cannot be identified by something other than the symbols of their record. This is not very helpful because there are cases with fundamental differences between two Serial numbers which may be entered in one document row. For example, one of them may be blocked for future usage, and the second one - not. Other than that, visually, it looks better when the different Serial numbers are displayed in different document rows. This corresponds with the fact that we treat the products with different Serial numbers as different products. Also, the current implementation considerably eases the entering of Serial numbers by barcode scanner. Tracking of the current availability is easier as well as the tracking of the product with a specified serial number. Usage in documents Whether a product should be used with or without Serial numbers, is a property set in its definition - Is Serialized field. If a product is not serialized, Serial numbers are forbidden when working with this product. If it is serialized, than serial number usage is required in Transactions and Reconciliations, and in the other documents it is allowed , but not required. Usually, Serial numbers are entered in the transactions and reconciliations. In the previous documents (Receiving orders, Sales orders etc.) the user is able to enter a serial number but such kind of usage is rare. If the serial number is not entered, for example in the Receiving order, the user may enter just one row with the quantity of 10 PCS and breaking down this row to 10 separated rows with different Serial numbers and quantity of 1 PCS happens in the Transaction. The main way to break down one row to several with different Serial numbers happens through the Barcode commands panel for Store orders execution. Data entry validation The serial number is specified in the documents rows by selecting it from a dropdown list. When the value in this field changes, the following validations should be performed: if the row is a Transaction row or a Reconciliation row - then the value should be different than null only if the product is serialized; if the row is a different document row (not a Transaction or a Reconciliation) - then the value may (but not necessarily) be not-null only if the product is serialized. If it is not serialized, then null value is required; If there is a serial number in the row, then the quantity in the row must be 1, 0 or -1 and the measurement unit must be pieces ; if the entered value in the Serial Number field is different from null, then the product from the current row must be the same as the product in the serial number definition. Easy entry/selection Entering new Serial numbers and selecting an already entered one should be as easy as possible. For this purpose, when entering a serial number and in a dropdown list a number ( nonexistent in the database for the current product) is selected, then a record with this value is created in the database automatically. This will have the greatest effect when working with the Barcode commands panel. This panel has a working mode which creates new Serial numbers and it is available only when receiving goods in the store. If the user issues goods, they can choose only Serial numbers, which are already entered in the database. Also, there are modes for quick entering/selection of a list of Serial numbers. By them, the user may enter directly the numbers separated by commas (for example - \"KHC4500071, KHC4500072, KHC4500073, KHC4500074, KHC4500075, KHC4500076, KHC4500077\"), or they may set a range of numbers (in the previous example list, the user may enter just \"KHC4500071\" and \"KHC4500077\"). For more information about the Barcode panel's serial number modes, see Barcode Panel Modes and its subtopics. Availability And product tracking The products availability (both current and at a specified date) for serialized products is detailed to serial number level. The same is valid for the stock movements reports. By them, the user is able to track the movements of specified products and their Serial numbers. Such tracking is always executed by store documents (i.e. store movements) and if there comparing operations from specialized modules is required, then a link between the Transactions and the documents from the specified module is used (for example - links as [Parent Document] <-> [Sub-Document]). For example, in purchasing orders Serial numbers will rarely be entered (except for returns) and the Serial numbers will show up in the transactions. So if the user wants to see when a specified serial number is bought, then they would use stock movements and follow the link to the Purchasing orders (for example - through the parent document of the Store order). Also sее: Serial numbers business rules"
  },
  "modules/general/products/variable-dynamic-measurement-rations.html": {
    "href": "modules/general/products/variable-dynamic-measurement-rations.html",
    "title": "Variable (dynamic) measurement ratios | ERP.net Tech Docs",
    "keywords": "Variable (dynamic) measurement ratios Variable (dynamic) measurement ratios are a functionality that allows a compensation of stock differences. Stock differences occur if there are variances between the quantity in the base unit of measure and the quantity in the parallel unit of measure. Stock differences may, for example, be caused by natural weight variations in material withdrawals. The option ‘Allow variable measurement ratios’ is available in the product’s definition. When this option is checked, the base quantity could be edited in the receiving order and transaction’s lines. Thereby, the user has the opportunity to manually adjust the right base quantity in the particular situation. Otherwise, if in the product definition is not set that it is allowed to use variable measurement ratios , then the product dimensions must be followed properly while recalculating base quantity. Example: The client has ordered 1 pallet of a product. We know that one pallet theoretically weights 1000 kg and that information is set as a conversion ratio in the product dimensions . But we also know that this weight may vary, so the product is allowed to use Variable measurement ratios . The base quantity in the store transaction is calculated on a base of the conversion rate. But when the workers in the warehouse actually put the pallet on the scale it turns out that the pallet actually weights 1100 kg . In this case they can manually set the value for the base quantity. This will not only assure that the information in the system is correct, but also will allow the company to invoice the right amounts. Note When using Variable measurement ratios , there are certain prohibitions. For example, creating payment orders from sales orders involving products with this setting is not >allowed. The reason is, if those payment orders are created for uninvoiced amounts, the possible change of the quantity in the transaction and therefore in the invoice may cause >the generation of excess documents."
  },
  "modules/index.html": {
    "href": "modules/index.html",
    "title": "ERP.net Internal apps | ERP.net Tech Docs",
    "keywords": "ERP.net Internal apps The internal apps in ERP.net are divided in application groups. To learn more about the apps in a group, use the following list: Community Customer relationship management (CRM) subsystem Logistics Note Your ERP instance might contain external applications, which might not be documented here. External applications are tightly integrated in the User menu. Sometimes, external apps replicate the visuals of the internal apps and might be indistinguishable."
  },
  "modules/logistics/concepts/goods-cost/cost-correction/basic-algorithm-for-cost-correction-calculation.html": {
    "href": "modules/logistics/concepts/goods-cost/cost-correction/basic-algorithm-for-cost-correction-calculation.html",
    "title": "Basic algorithm for cost correction calculation | ERP.net Tech Docs",
    "keywords": "Basic algorithm for cost correction calculation This algorithm is applied to multiple records: either transaction rows or accumulated records for goods cost (most often opening a balance for а specified period). The algorithm has two stages: The records are ordered chronologically. The cost of the rows that do not include accumulated information is recalculated one by one. The cost of transaction rows in multiple records is recalculated instead of the accumulated data. The mismatch between the newly calculated and the current actual cost is saved in the document cost correction . With the release of cost correction , the costs in the transaction rows are updated. Multiple records are generated when all transaction operations for a period (as well as the opening balance at the start of the period) are loaded. It is of great importance for all transaction operations and opening balances to be loaded during the operation. Any of them missing may lead to incorrect cost correction (during stage 2 of the algorithm). Stage 1: Chronological sorting of the records The following criteria is used to order the records chronologically: In case two records share the same enterprise company, store, product , and lot (only if the product has a separate cost for each lot), the records with a shorter transaction timestamp are placed before the ones with a greater transaction timestamp . If the transaction timestamps are equal, the receipt goes before the issue operation. If the records have the same movement type , it is assumed that the operations have happened at the same time. If two records - part of a transfer or a production process - have opposite movement types , then an issue transaction is performed before a receipt transaction (only if the transaction timestamp of the issue transaction is smaller than or equal to the receipt transaction). Enterprise company, store, product , and lot do not affect the order here. The criteria above can’t provide thorough sorting of the records. That is why a topological sorting is applied. Any topological sorting may be used - more than one for a specific partial sorting. The result in the next stage is the same regardless of the sorting method used. Stage 2: Recalculating the sorted records When the records are ordered in the previous stage, the cost accumulated from the starting period (average) is calculated. Then, the cost of each record is recalculated. Finally, the recalculation of the next record begins (if there is one in the first place). The recalculation of the record cost is performed as follows: If the record is for accumulated data (opening balance), the record is not recalculated. If the record is an issue transaction, then the cost is calculated according to the average accumulated cost. If the record is a receipt transaction and is part of a transfer or a production process, then its cost is recalculated according to the algorithm from articles Calculating cost for produced products , Calculating cost for transferred products , and Calculating cost for returned products . If the record is a receipt transaction and is not part of a transfer or a production process, the record is not recalculated. Example 1: There are two stores and three products, the first two of which are provided by external suppliers. The third is internally produced. A recalculation of the cost for January 2020 is needed. This is the data for the first store. The second store has no movements recorded (including the current period): Store # 1 , Product # 1 , Opening Balance , before 01 Jan 2020 00:00, 10 PCS, total cost: 100 ; Store # 1 , Product # 2 , Opening Balance , before 01 Jan 2020 00:00, 10 PCS, total cost: 150 ; Store # 1 , Product # 1 , receipt transaction , Transaction Timestamp 05 Jan 2020 17:27 , 10 PCS, total cost: 140 ; Store # 1 , Product # 2 , receipt transaction , Transaction Timestamp 05 Jan 2020 17:27 , 10 PCS, total cost: 190 ; On 16 Jan 2020 , a certain quantity from the third product is manufactured and added in the other store: Store # 1 , Product # 1, issue transaction , Transaction Timestamp 16 Jan 2020 10:12 , 4 PCS, total cost: 48 ; Store # 1 , Product # 2, issue transaction , Transaction Timestamp 16 Jan 2020 10:25, 6 PCS, total cost: 102 ; Store # 2 , Product # 3 , receipt transaction, Transaction Timestamp 16 Jan 2020 14:47, 2 PCS, total cost: 150 . Then, on 19 Jan 2020 , part of the produced quantity is moved to the first store and the transport costs 7 : Store # 2 , Product # 3, issue transaction , Transaction Timestamp 19 Jan 2020 11:32, 1 PCS, total cost: 75 ; Store # 1 , Product # 3, receipt transaction , Transaction Timestamp 16 Jan 2020 11:50, 1 PCS, total cost: 82 . It turns out that there was a receipt transaction on 11 Jan 2020 which is not entered in the system on time: Store # 1 , Product # 1, receipt transaction , Transaction Timestamp 11 Jan 2020 13:44 , 5 PCS, total cost: 85 ; Store # 1 , Product # 2, receipt transaction , Transaction Timestamp 11 Jan 2020 13:44 , 6 PCS, total cost: 44 . The cost of all other store Transactions during this month is incorrect (except the first two receipts on 05 Jan 2020 ) and has to be recalculated. When executing the algorithm with the previous data, the following order of records will be completed after the first stage: Store # 1 , Product # 1, Opening Balance , before: 01 Jan 2020 00:00 ; Store # 1 , Product # 2, Opening Balance , before: 01 Jan 2020 00:00 ; Store # 1 , Product # 1, receipt transaction , Transaction Timestamp: 05 Jan 2020 17:27 ; Store # 1 , Product # 2, receipt transaction , Transaction Timestamp: 05 Jan 2020 17:27 ; Store # 1 , Product # 1, receipt transaction , Transaction Timestamp: 11 Jan 2020 13:44 ; Store # 1 , Product # 2, receipt transaction , Transaction Timestamp: 11 Jan 2020 13:44 ; Store # 1 , Product # 1, issue transaction , Transaction Timestamp: 16 Jan 2020 10:12 ; Store # 1 , , Product # 2, issue transaction , Transaction Timestamp: 16 Jan 2020 10:25 ; Store # 2 , Product # 3, receipt transaction , Transaction Timestamp: 16 Jan 2020 14:47 ; Store # 2 , Product # 3, issue transaction , Transaction Timestamp: 19 Jan 2020 11:32 ; Store # 1 , Product # 3, receipt transaction , Transaction Timestamp: 19 Jan 2020 11:50 . After the recalculation in the second stage for the last five transactions, the following actual costs will be calculated: Store # 1 , Product # 1, issue transaction , Transaction Timestamp: 16 Jan 2020 10:12 , recalculated cost: 52 ; Store # 1 , Product # 2, issue transaction , Transaction Timestamp: 16 Jan 2020 10:25 , recalculated cost: 96 ; Store # 2 , Product # 3, receipt transaction , Transaction Timestamp: 16 Jan 2020 14:47 , recalculated cost: 148 ; Store # 2 , Product # 3, issue transaction , Transaction Timestamp: 19 Jan 2020 11:32 , recalculated cost: 74 ; Store # 1 , Product # 3, receipt transaction , Transaction Timestamp: 19 Jan 2020 11:50 , recalculated cost: 81 . This means that in the cost correction document, 5 rows will be created, one for each of thе operations with cost changed, and the rows will save the mismatches: 52 - 48 = 4 , 96 - 102 = - 6 , 148 - 150 = - 2 , 74 - 75 = - 1 and 81 - 82 = - 1 ."
  },
  "modules/logistics/concepts/goods-cost/cost-correction/index.html": {
    "href": "modules/logistics/concepts/goods-cost/cost-correction/index.html",
    "title": "Cost correction | ERP.net Tech Docs",
    "keywords": "Cost correction The current article describes the calculation (and recalculation) of the actual cost . The article Original cost calculation describes how the original cost is calculated. Those calculations are accurate as long as the store transactions are entered in their original chronology. If the order is incorrect, so will be the cost. Example 1: There are two receipt transactions and one issuing transaction entered in the system: receipt , Timestamp: 05 Jan 2020 12:45, 4 PCS , total cost: 100 EUR ; receipt , Timestamp: 05 Jan 2020 17:27, 3 PCS , total cost: 75 EUR ; According to the original cost calculation for average cost, the issuing transaction should be: issue , Timestamp: 08 Jan 2020 11:29, 5PCS , total cost: 5 * (175/7) = 125 EUR ; There is another receipt transaction not entered on time. It happened on 07 Jan 2020 and was entered on 08 Jan 2020 : receipt , Timestamp: 07 Jan 2020 23:59, 3PCS , total cost: 105 EUR ; If the third receipt transaction is entered on time, then the unit cost on 08 Jan 2020 would be 280/10 = 28 , not 25 , as it was originally calculated in the issuing transaction. This is happening due to the late entering of the transaction in the system. The cost of the issuing transaction is incorrect and a recalculation is needed. The effect of the incorrect cost from example 1 may influence not only issuing transactions. If the issuing operation was about ingredient consumption from the Production module, for example, then the cost of the production output would be incorrect as well. This leads to incorrect cost when issuing the production output. If you don't enter the transactions in the system on time, there will be negative consequences. To correct them, there is a basic algorithm for cost correction calculation . This algorithm changes the costs as if they were entered on time. There is a document named cost correction, where the results from this calculation should be saved. Тhe rows of the document show how the cost is changed (base cost, product cost, store cost, and document cost) for each Transaction row affected. Cost corrections allow the original cost to be changed. In each transaction row the fields are as follows: [actual/corrected cost] = [original cost] + [adjustment cost] where: [original cost] = the product, store, document, and base cost saved in the transaction row; [adjustment cost] = the sum of all product, store, document, and base cost values saved in the rows of all the released, non-voided cost corrections referring to the current transaction row. For more specific information, see: Basic algorithm for cost correction calculation Models for maintaining the actual cost Specific procedures of cost corrections"
  },
  "modules/logistics/concepts/goods-cost/cost-correction/models-for-maintaining-the-actual-cost.html": {
    "href": "modules/logistics/concepts/goods-cost/cost-correction/models-for-maintaining-the-actual-cost.html",
    "title": "Models for maintaining the actual cost | ERP.net Tech Docs",
    "keywords": "Models for maintaining the actual cost There are two main models to keep the goods cost up-to-date. Right from the start, when we enter (and release) the transactions, the actual cost is recalculated. The costs of all existing store transactions affected by the current transaction are also calculated. This leads to a perfect situation where all transactions are correctly calculated no matter when they are entered in the system. In addition, the calculation is performed by the system and the user does not have to control it. The disadvantage of this model is the additional calculations for creating and releasing a transaction, especially when that transaction is old. This may lead to slow performance of the Logistics module. The corrections are created periodically by a user instead of immediately for each transaction. This model provides the easier daily creation of a transaction with a risk for incorrect costs not covered by cost correction (this happens only when store transactions are entered in a non-chronological manner). Dynamic cost correction Maintaining the actual cost at all times with the first model is accomplished by using two specific procedures for generating cost correction from every transaction. They have to be created when the transaction is released and the generation of the cost correction updating the cost of the current transaction is performed first. Thus, when the transaction is released, it will have its original cost, and the first generation will correct its values if necessary. We assume that the cost of all existing released transactions before the creation of the current transaction are correct (as the cost of the current transaction may be affected by them). Once the first generation corrects the cost of the newly entered transaction, the second generation corrects the cost of all other transactions that depend on the current transaction. Thus, after its release, the cost of all transactions in the system will be actual no matter the date they are entered. The older the transaction, the slower the performance of the two generation procedures will be (this means that more transactions will be affected by the current transaction). Periodical cost correction The second model for cost correction does not use automatic generation procedures for the cost corrections. Instead, the user manually enters documents for a specified period (month, quarter, etc.) and starts the basic algorithm for cost correction calculation for all transactions in the specified period. For example, if cost corrections are performed monthly, the user creates a new cost correction document and sets the period from the first date to the last date of the month. Then, he starts the function Recalculate the corrections for the period , which loads all store transactions where transaction timestamp is in the specified period. The function then adds the opening balances at the beginning of the period, and this data is executed by the basic algorithm for cost correction calculation . So, the actions of the user are limited to entering the start and end dates, starting the function and releasing the document. This is performed for past periods (i.e. not for the current month) for which there will be no more new transactions, and in which the cost corrections are already calculated and released. Otherwise, there may be incorrect cost in the current-period transactions. The recalculation of the cost of all transactions in a specified period may take more time than if the first model is used, but it eases the daily Transactions release significantly. Also, for periodical cost correction , a more appropriate execution time may be picked (for example, during the night)."
  },
  "modules/logistics/concepts/goods-cost/cost-correction/specific-procedures-of-cost-corrections.html": {
    "href": "modules/logistics/concepts/goods-cost/cost-correction/specific-procedures-of-cost-corrections.html",
    "title": "Specific procedures of cost corrections | ERP.net Tech Docs",
    "keywords": "Specific procedures of cost corrections Apart from the standard method of cost correction - loading the store transaction for a specified period (plus the opening balances) and filling in the rows for the correction by the basic algorithm for cost correction calculation , there are two more ways to create a cost correction document. They use generation procedures available in the transaction document. Cost correction generation procedure for the actual cost of the current transaction This generation procedure updates the cost of the store transactions in the current transaction document. For each row, the following actions are applied: Loading the actual cost by the current moment (i.e. this is the sum of the original cost from the transaction row and the addition cost in the row, generated by already created cost corrections). This is a sum [current cost] ; Then, the actual cost for the row is calculated - the sum [actual cost] as usual: a. if the transaction is issuing , the cost is calculated by the average accumulated cost; b. if the record is a receipt transaction and is part of a transfer or production process, its cost is recalculated according to the algorithm from articles Calculating cost for produced products , Calculating cost for returned products and Calculating cost for transferred products ; c. if the record is a receipt transaction and is not part of a transfer or production process, the original cost is considered the actual cost. To make valid calculations, the cost of all store transactions affecting the current transactions should be recalculated correctly. At the end, the difference [actual cost] - [current cost] is calculated. Provided that it is different than zero, a new row is added in the cost correction sub-document for the current transaction row, which contains the difference. Cost correction generation procedure for the current transaction results This generation procedure updates the costs of all transactions that depend on the current transaction rows. The following actions are executed: Loading all store transactions (with the opening balances if needed) which depend on the current document; Тhe basic algorithm for cost correction calculation is applied over the loaded set of records; For each store transaction from the set of records, the difference between the algorithm result and the actual cost valid before the creation of the current transaction, is calculated. If it is a non-zero result, a new row in the cost correction is added. Loading the records is performed iteratively. Before the first iteration, the following is created: [current set of records] = the transactions in the current Transaction document; [current Movement Type ] = Movement Type of the current transaction; [result] = [current set of records] + the opening balances for the current store of the current products from the transactions of the [current set of records] (the opening balances are for the Transaction timestamp date) Then, a cycle of iterations is performed, and for each iteration, the following is executed: if the [current Movement Type ] = receipt , a new set of records is loaded; [new set of records] = all transactions for the stores and the products (and the lots, if the product keeps separated cost for each lot) from the [current set of records] whоse Transaction Timestamp is greater than or equal to the Transaction Timestamp in the [current set of records] . If the [current Movement Type ]= issue and the [current set of records] has records that are part of a transfer/production process, then the [new set of records] is as follows: [new set of records] = all receipt transactions from the specified transfer/production processes, whose transaction timestamps are greater than or equal to the transaction timestamps in the [current set of records] . The result is updated and the current set of records becomes: [result] = [result] U [new set of records] (the opening balances are added for every new store which is part ot [new set of records] but is not part of [current set of records]) ; [current set of records] = [new set of records] . At the end, if [current Movement Type ] = receipt , then [current Movement Type ] is set to issue and if it was [current Movement Type ] = issue , [current Movement Type] is set to receipt . These iterations are performed until an iteration has a [new set of records] that is empty."
  },
  "modules/logistics/concepts/goods-cost/index.html": {
    "href": "modules/logistics/concepts/goods-cost/index.html",
    "title": "Goods Cost | ERP.net Tech Docs",
    "keywords": "Goods Cost Currently, the goods cost in ERP.net is calculated by the transactions documents. For each transaction the cost is defined either automatically when the document is released or by the parent document. This is determined by the Cost Source field. It has two possible values: ‘Store’ - this value sets out that the cost in the transaction is defined when releasing the document by the accumulated cost in the store. This is used when issuing transactions are executed. ‘Document’ - the cost is defined by the data in the transaction rows ( Unit Cost and Line Cost fields). This data is usually inherited by the parent document and used when receipt operations are executed (the only exception is when the receipt operation comes from ‘Reconciliation’ - then, the value in Cost Source is ‘Store’). ‘Store orders’ enable other modules to set goods cost. They contain not only the quantity but in specific cases, what the goods cost should be. This cost is copied to the transactions. The Cost Source is set to Document in the transactions executing the specific Store Order. This is how they participate in the cost definition. For each store transaction (i.e. transaction document) changing the cost, a specific Timestamp is saved. It indicates the time the operation starts influencing the cost. The field in the transaction rows is called transaction timestamp . Generally, the transactions should be entered in the system in the right chronology. Usually, the transaction timestamp is set either by the ‘transaction release’, or by the ‘store orders’ as follows: in the parent store order, a specific transaction timestamp is set. This value is inherited by the transaction that executes the ‘store order’'; if the parent store order has no transaction timestamp and the transaction has today's date or future date, then the transaction timestamp is set to current date and time; if the parent store order has no transaction timestamp and the transaction has past date, then the transaction timestamp is set to XX.XX.XXX 23:59:00, where XX.XX.XXXX is the document's date. If necessary, the transaction timestamp may be set manually by the user, although there are certain limitations. For example, if the quantity in the row is 0, the date in Document Date should be no different than the one in transaction timestamp . For more information, see the Setting transaction timestamp article. Cost types When the transactions are not entered in the system on time and damage the right chronology, this may generate incorrect costs. To fix this, ERP.net has developed a Cost correction system, recalculating the cost as if it was entered in the right chronological order. There are two types of goods costs: Original cost - defined right when entring the document. Depends on the entry order. Cost adjustment – for the definition of this cost, a special recalculation is used. It compensates the wrong chronology of the transactions. Cost currency In the transactions, the cost comes in four currencies: base cost, product cost, store cost, and document cost . For each row, the cost is calculated independently. The base currency comes from the Enterprise Company definition of the current transaction. Product currency is part of the product definition and if there is no currency, then the base cost is used. Store currency is in the store definition; if there is no currency - the base currency is used. The document currency is set in the Document Currency field. For each store transaction, the cost is calculated in all four currencies when defined automatically. For more specific information about cost calculations see the following articles: Cost correction Original cost calculation"
  },
  "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-inventory-reconciliation.html": {
    "href": "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-inventory-reconciliation.html",
    "title": "Calculating cost for inventory reconciliation | ERP.net Tech Docs",
    "keywords": "Calculating cost for inventory reconciliation The cost of the issue and receipt store transactions, which are the result of an inventory reconciliation, are calculated according to the current availabilities in the store, as on the date of the inventory reconciliation. Since some of the products may not be available, the calculation is performed according to the following algorithm: The current availability of the product on the date of the inventory reconciliation is calculated. If the current availability is different from 0, the average cost is taken. If the current availability is 0, the unit cost of the last issue store transaction is taken. If there is no previous issue store transaction, the standard cost is taken (from the product definition)."
  },
  "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-produced-products.html": {
    "href": "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-produced-products.html",
    "title": "Calculating cost for produced products | ERP.net Tech Docs",
    "keywords": "Calculating cost for produced products In the production process, some materials (issued from one or multiple stores) are transformed into a certain output (entered into the store). The cost of the issue transactions has to be transferred to the receipt transactions. This is similar to the transfer and return of goods (see Calculating cost for transferred products and Calculating cost for returned products ). However, the calculations are different. During production, the receipt store orders are generated by output orders. There are two stages for calculating the cost in the receipt store orders: Comparison between the rows in the consumption orders and the rows in the output orders. For each row in the output orders, that comparison defines which materials are used for the production of the product in the current row. For each row in the consumption orders, the cost of the issue transactions of the current row is distributed by its relevant output orders rows from stage 1. In the end, it is provided that on each output order row, the distributed amount comes only from the materials that are used for the produced products in the current row. This distributed amount is written as a specifically set cost in the receipt store order, which is generated by the output order. Stage 1: Comparison of the rows in the consumption and output orders Released, non-voided consumption orders and output orders that are sub-documents of a given work order are taken into account. For each row of an output order, the following is defined: what part of the materials is used to produce the specified row and from which consumption order rows the materials are taken. This data is saved in a Distributed material consumptions table (part of the output order data). The output orders may get materials only from consumption orders released before the output order. In other words, the release order for consumption and output orders defines how the quantities in their rows will be compared. When a user creates a new output order and releases it, the distributed materials are recalculated. This is true for corrections as well. For each output order row, the following is executed: All rows for released, non-voided consumption orders for the current work order item are filtered (their quantities need to be taken into account). The consumption orders are released before the current output order. From the quantities of the rows in step 1, quantities of materials distributed on the same work order item by output orders (released before the current one) are removed . From what's left of the materials, the necessary quantities for the current row of the output order are distributed . They are defined by the Recipe in the work order. For the current row, they cannot be distributed in bigger quantities than they are allowed to. Exception is made only for the last output orders from each work order item or for the output order rows marked as Finished . The rest of the materials are distributed on Finished rows. When releasing new consumption orders or voiding released consumption orders, these steps are executed again for each output order from the current work order. This keeps the distributions for these output orders up-to-date. Example 1 : There is a work order producing 3 PCS of a product. The materials are 9 PCS from Material #1 and 12 PCS from Material #2 . The materials are consumed in two stages: Consumption order CO#1 , which has 8 PCS from Material #1 and 8 PCS from Material #2 Consumption order CO#2 , which has 1 PCS from Material #1 and 4 PCS from Material #2 Both consumption orders are released and the first output order is created for 2 PCS of the work order item. When this output order is released, the following materials distribution is calculated: Product, CO#1 , Material #1 , 6 PCS ; Product, CO#1 , Material #2 , 8 PCS . Then, the user creates and releases an output order for the rest 1 PCS of the work order item. It distributes the following: Product, CO#1 , Material #1 , 2 PCS . Product, CO#2 , Material #1 , 1 PCS . Product, CO#2 , Material #2 , 4 PCS . In the current stage, it is possible that no issue/receipt store transactions have been released yet. Therefore, this distribution is used to reserve materials for work order items. When the store transactions begin, the cost of the issue transactions is transferred to the receipt transactions (Stage 2) using the already calculated distribution. Sometimes the remaining non-distributed materials from an output order are less than what is ordered by the recipe in the current output order. In this case, the output order is distributed in fewer than the technologically defined quantities. The remaining excess (if, of course, this is requested by following consumption orders) will be distributed to the last output order of the current work order item (or to a row marked as \"Finished\"). Let's take a look at such an example. Example 2 : We have the same work order as in Example 1 . First, CO#1 is released with 5 PCS of Material #1 and 6 PCS of Material #2 . Then, an output order is released for the 2 PCS of the work order item. According to the recipe, 6 PCS of Material #1 and 8 PCS of Material #2 should be distributed. By now, no consumption orders with such quantities have been released. As a result, the output order takes fewer quantities (from CO#1 ): Work order item, CO#1 , Material #1 , 5 PCS ; Work order item, CO#1 , Material #2 , 6 PCS . Then, CO#2 is released with the rest of the materials quantities - 4 PCS and 6 PCS , respectively. When the second output order is released for the remaining 1 PCS , more materials per unit will be distributed than in the first output order: Work order item, CO#2 , Material #1 , 4 PCS ; Work order item, CO#2 , Material #2 , 6 PCS . There are cases when non-distributed materials remain even after the release of the last output order on one work order. Usually, this happens if consumption orders are released after all output orders. As a final result, an output order with 0 quantity is released. Such output orders are called completing output orders and all remaining materials are distributed to them. Sometimes these orders are not only released, but come before the last output order with non-zero quantities. This is done when there are non-distributed materials, though the next output orders will not be released soon. The completing output orders (also known as intermediate ) \"collect\" all the remaining material quantities without having to release the next output order. The two examples above describe production processes where each material from a Work Order is assigned to exactly one work order item. There are materials which cannot be assigned to a specific work order item (the work order item field in the ingredients table is empty). Instead, the quantity of the material is distributed to all work order items in the current Work Order. This distribution may be achieved by two methods (different values in the Distribute By field): by Standard Price - the current Standard Price Per Lot of the products from the work order rows (the work order items) is used. The price is then multiplied by the quantities in the rows and the result becomes a coefficient for materials distribution; by Measurement - the quantities from the work order rows are used as coefficients. Each quantity is converted into a measurement category, which is specified in the material row. All products must have defined product dimensions for the specified category. After the coefficients are defined by one of the methods, the quantities from the consumption order are distributed to an output order as follows: All rows of released, non-voided Consumption Orders are filtered . The consumption orders are released before the current output order. The quantities from p.1 are decreased by the material quantities distributed to output orders which are released before the current one. The entire remaining materials quantity is distributed by the coefficients among all rows of the current output order. To define the coefficients, the quantities from the current output order are used. Note If all work order items have a Standard Price Per Lot of 0 (zero), the coefficients would also be 0. In that case, the cost of all materials from p.2 is distributed equally among the work order items. As a result, cost loss is avoided. Example 3 : There is a Work Order with 295 PCS of a given material, which is distributed by standard price among four work order items of the work order: Product #1 (standard price is 17 EUR), Product #2 (standard price is 9 EUR), Product #2 (standard price is 12 EUR), and Product #4 (standard price is 20 EUR). For each work order item, 2 PCS are produced. First, CO #1 is released for 189 PCS of the material. Then, OO #1 is released with the following: 2 PCS of Product #1 , 1 PCS of Product #2 and 1 PCS of Product #4 . The coefficients for distribution in the current output order are: 2 * 17 : 1 * 9 : 1 * 20 = 34 : 9 : 20. According to these coefficients, the following distribution is achieved: Product #1 , CO#1 , Material, 189 * 34 / (34 + 9 + 20) = 102 PCS ; Product #2 , CO#1 , Material, 189 * 9 / (34 + 9 + 20) = 27 PCS ; Product #3 , CO#1 , Material, 189 * 20 / (34 + 9 + 20) = 60 PCS . Then, a new CO #2 is released for the rest 106 PCS , and the last output order is released for the rest of the work order items. It has the following coefficients: 1 * 9 : 9 * 12 : 1 * 20 = 9 : 24 : 20. The distribution is calculated as follows: Product #2 , CO#2 , Material, 106 * 9 / (9 + 24 + 20) = 18 PCS ; Product #3 , CO#2 , Material, 106 * 24 / (9 + 24 + 20) = 48 PCS ; Product #4 , CO#2 , Material, 106 * 20 / (9 + 24 + 20) = 40 PCS . Stage 2: Issue transactions cost distribution Once Stage 1 is completed, the cost of the issue transactions is transferred to the receipt transactions. This operation can be explained with the quantity distribution of the materials from the consumption orders and the work order items from the output orders. The distributions are used to form proportions which help distribute the cost of the consumption order transactions among the output orders. This distribution is also saved in the \" Distributed Material consumptions \" table (in the output order document) and then it is used to set the cost of the receipt store transactions correctly. When new issue transactions appear from consumption orders, an update of the distributions in all output orders (from one work order) is executed again. The quantity distributions are complemented by the cost distributions. Let's examine this particular case: There is a row from a consumption order which contains 15 PCS , 5 PCS of which are distributed to one output order and the rest 10 go to another output order. If there are several store transactions to issue all 15 PCS at a cost of 371 EUR, then one-third of it is distributed to the first output order and the rest is distributed to the second one. A detailed example follows. Example 4 : There is a work order producing 3 PCS of a product. The materials are 9 PCS from Material #1 and 12 PCS of Material #2 . The materials are consumed in two stages: Consumption order CO#1 , which has 8 PCS from Material #1 and 8 PCS from Material #2 Consumption order CO#2 , which has 1 PCS from Material #1 and 4 PCS from Material #2 There is an output order for 2 PCS of the work order item with the following distribution: Product, CO#1 , Material #1 , 6 PCS ; Product, CO#1 , Material #2 , 8 PCS . The second output order is for 1 PCS from the work order item with the following distribution: Product, CO#1 , Material #1 , 2 PCS ; Product, CO#2 , Material #1 , 1 PCS ; Product, CO#2 , Material #2 , 4 PCS . If the issue cost is 40 EUR for Material #1 and 71 EUR for Material #2 from CO#1 and 7 EUR for Material #1 and 39 EUR for Material #2 from CO#2 , then a distribution is calculated where the quantity comparisons are filled with costs. The first output order has the following: Product, CO#1 , Material #1 , 6 PCS , 40 * 6 / 8 = 30 EUR ; Product, CO#1 , Material #2 , 8 PCS , 71 * 8 / 8 = 71 EUR . And the cost of the produced product from this output order is 30 + 71 = 101 EUR . For the second output order, there is the following: Product, CO#1 , Material #1 , 2 PCS , 40 * 2 / 8 = 10 EUR ; Product, CO#2 , Material #1 , 1 PCS , 7 * 1 / 1 = 7 EUR ; Product, CO#2 , Material #2 , 4 PCS , 39 * 4 / 4 = 39 EUR . And the total cost of the produced product is 10 + 7 + 39 = 56 EUR . Issue and receipt balance Similarly to store transfers and sales, there is a receipt limitation in the production - it cannot exceed the issue. Unlike store transfers and sales, the validation is a bit more complicated because the product in the issue transactions is different from the product in the receipt transactions. The materials are not the same as the produced product. As a result, the total quantities of issue and receipt transactions cannot be compared directly. The limitation is applied on all store transactions that are caused by a Work Order. For each transaction timestamp , the following is executed: All issues (the materials) are summed up with a transaction timestamp less than or equal to the current. By their receipts from the work order, it is defined what is the largest quantity that is available for production from these materials; All receipts (the produced products) are summed up with a transaction timestamp less than or equal to the current; A validation is performed to check if the maximum quantity of the product from p.1 is bigger than or equal to the receipt total from p2. For more information about the validation, see Receipt and issue balance validation in store transfers ."
  },
  "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-returned-products.html": {
    "href": "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-returned-products.html",
    "title": "Calculating cost for returned products | ERP.net Tech Docs",
    "keywords": "Calculating cost for returned products The current article describes how the product cost is formed when returning sold products. This is a receipt returning. This process is very similar to the product transferring (see Calculating cost for transferred products ). However, there’s а difference: instead of transferring the products from one store to another in the current enterprise company, the products are taken out of the store and given to the customer. After that, the customer returns them to the same store. So, the receipt cost (on each row) is defined by the following formula: [receipt cost] = proportional part of the [issue cost] A proportional part of the issue cost is required as not all products can be returned after being sold. The proportion is defined by the ratio between sold and returned quantity. Example 1: A customer buys 10 PCS on 05 Jan 2020 and a few days later returns 3 PCS . The issue transaction is: issue, Timestamp: 05 Jan 2020 11:14, 10 PCS , document cost: 90 . Then, in the receipt store order generated by the returning sale order, the following is saved: 3 PCS , document cost: 90 * 3 / 10 = 27 The data for the issue transactions is retrieved as follows: The value in Return for sales order line is taken into account - it connects us to the original line. For this line, the system finds all store orders rows referring to it. For each store order row, the respective non-voided executions are loaded (transactions rows) - the store transactions. The document cost is copied from the Line document cost field in the transactions rows. There are some specific cases when the calculations from the example described above are not possible. Here, it is necessary to enter the original sale orders lines in the rows of the returning sales order. Sometimes this is not possible and the original sales order does not exist in the system. If a company started working on ERP.net recently and the original sales order had happened before the shift to ERP.net, the Historical Unit Cost field from the returning sales order is used for the definition of the unit cost in the receipt transaction. The formula is as follows: [receipt cost] = [returned quantity] * [historical unit cost] Example 2: There is a product return from a customer for 3 PCS and the original sales order does not exist in ERP.net. The Historical Unit Cost field in the returning sales order has to be filled in. If its value is 8 , then the receipt store order will have the following: 3 PCS , document cost: 3 * 8 = 24 . Receipt and issue cost balance As with store transfers, when returning products, the quantity returned can’t be greater than the quantity sold. This is true for the original sale document and all the sales orders for the products returned. Every store transaction for the sales orders is gathered and for each transaction timestamp , validation is performed as in the store transfers: The costs from all issue transactions with transaction timestamp smaller or equal to the current are summed up; The costs from all receipt transactions with transaction timestamp smaller or equal to the current are summed up; The system checks if the issue total is greater or equal to the receipt total. For more details about this validation, see Receipt and issue balance validation in store transfers ."
  },
  "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-transferred-products.html": {
    "href": "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-transferred-products.html",
    "title": "Calculating cost for transferred products | ERP.net Tech Docs",
    "keywords": "Calculating cost for transferred products Store Transfers create two parallel sub-document flows - receipt and issue flow. The cost of the issue store transactions is calculated by the average cost in the store, while the one in the receipt store transactions - specifically by the store transfer. It is formed by the following two components: Issue cost (of the issued goods); Additional amounts in the store transfer, added to the products (representing increased goods cost e.g because of transport taxes). For each store transfer the following must be valid: [receipt cost] = [issue cost] + [ Additional amounts for cost] Each store transaction row is calculated separately (so [ Additional amounts for cost] is the additional amount distributed to the current row). These calculations are executed when the receipt store order is generated and the calculated cost is saved in the Line Cost field in the rows of the store order. So if the generated store order receipt follows the generation of the issue documents (orders and their executions, providing the issue cost), then the issue cost may be copied to the receipt orders. Example 1 : There is a store transfer with two rows - row #1 with Product 1 for 10 PCS and row #2 with Product 2 for 12 PCS . At first, there are two issue transactions: issue, Product 1 , Timestamp: 01 Dec 2020 13:50, 8 PCS , document cost: 88 ; issue, Product 2 , Timestamp: 01 Dec 2020 13:50, 6 PCS , document cost: 90 . Afterwards, store orders receipt will be created with the same quantities and set costs in the rows: row #10, Product 1, 8 PCS , line cost: 88 ; row #20, Product 2, 6 PCS , line cost: 90 . When executing this store order, the result is transactions receipt for 8 PCS and 6 PCS with cost of 88 and 90 , respectively. And when the rest of the transfer quantities are issued: issue, Product 1 , Timestamp: 07 Dec 2020 10:05, 2 PCS , document cost: 20 ; issue, Product 2 , Timestamp: 01 Dec 2020 10:05, 6 PCS , document cost: 102 . a new receipt store order will be created with rows as follows (the store transfer will try to create a new store order for the whole issued cost from the four issue transactions. However, a store order for the first two issues already exists, so the Discrepancy system will create new order only for the second issues): row #10, Product 1, 2 PCS , line cost: 20 ; row #20, Product 2, 6 PCS , line cost: 102 . When executing this store order, the receipt cost will be equal to the issue cost. The next example describes the calculations when there is an additional amount for the transport added to the goods cost. Continuation of Example 1: There is an additional transport amount of 66 (in document currency) distributed in the two rows as follows: 30 on the first row and 36 on the second row. These amounts will be added to the row costs in the generated store orders, proportionally to their quantities. So their rows become: Store Order # 1 , row # 10, Product 1, 8 PCS , row cost: 88 + 30 * (8 / 10) = 112 ; Store Order # 1 , row # 20, Product 2, 6 PCS , row cost: 90 + 36 * (6 / 12) = 108 ; Store Order # 1 , row # 10, Product 1, 2 PCS , row cost: 20 + 30 * (2 / 10) = 26 ; Store Order # 1 , row # 20, Product 2, 6 PCS , row cost: 102 + 36 * (6 / 12) = 120 ; The standard generation of store orders receipt from store transfers always creates a store order receipt for the exact quantity already issued by transactions. The user may change the quantities (only decreasing them - see the end of the current article) in the receipt documents or enter them manually (the cost in the receipt documents has to be proportional to the one calculated by the system). Example 1 (alternative case): If due to correction or manual work the receipt store order #1 is as follows: row # 10, Product 1, 5 PCS , row cost: 55 ; row # 20, Product 2, 4 PCS , row cost: 60 ; then, the rest of the cost – 33 for row #10 and 30 for row #20, will be added along with the quantities in the second receipt order: row # 10, Product 1, 5 PCS , row cost: 53 ; row # 20, Product 2, 8 PCS , row cost: 132 ; Issue and receipt cost balance In the examples above, it is possible to receive only less quantity than the issued - the rest will come later. The receipt value in a document cannot be more than the issued’s. It is not possible to receive more than the amount issued from the first store when transferring stocks. Although these cases are just theoretical, they may lead to incorrect cost (especially after cost correction , as discrepancies may appear). Example 2: In Store 1, where 5 PCS are available from a product, cost: 100 , and in Store 2, there are 10 PCS from the same products with the cost of 200 . A transfer from Store 2 to Store 1 for 3 PCS is executed. At first, 1 PCS is issued from Store 2, then immediately all 3 PCS are received. The total availability in both stores is 8 + 9 = 17 instead of 15 . There will also be an artificial cost increase. If this availability and cost condition is kept for some time, there may be incorrect cost calculations of the store transactions. Limitations for what is possible to be entered in the target store from a store transfer are required. They are applied when releasing or voiding the released transactions from the transfer. A limitation could be: For each transaction timestamp on all transactions of the current transfer, the following must be true: The sum of the issues up to this timestamp (including the timestamp) is larger or equal to the sum of the receipts up to this timestamp (including the timestamp). Example 3: If we use the store transfer of 3 PCS from Store 2 to Store 1 from Example 2 , the first issue is as follows: issue , Timestamp: 10 Dec 2020 17:04, 1 PCS , cost: 20 ; Now, the user is not able to make a transaction receipt for 3 PCS . The user is able to enter up to 1 PCS: in Store 1. receipt , Timestamp: 10 Dec 2020 17:27, 1 PCS, cost: 20 ; The user is not able to change the transaction timestamp to a value less than 10 Dec 2020 17:04 . After releasing the transaction receipt , the user is not able to void the issue transaction because on 10 Dec 2020 17:27 there will be a total issue of 0 PCS , which is less than the total receipt of 1PCS . For more information about the validation, see Receipt and issue balance validation in store transfers ."
  },
  "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-when-returning-rented-assets.html": {
    "href": "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-when-returning-rented-assets.html",
    "title": "Calculating cost when returning rented assets | ERP.net Tech Docs",
    "keywords": "Calculating cost when returning rented assets"
  },
  "modules/logistics/concepts/goods-cost/original-cost-calculation/index.html": {
    "href": "modules/logistics/concepts/goods-cost/original-cost-calculation/index.html",
    "title": "Original cost calculation | ERP.net Tech Docs",
    "keywords": "Original cost calculation This article describes how the original cost is defined for each store transaction (i.e., for each row of a transaction). There are two ways to define it: by average cost and by specifying the cost in the parent document. Which way will be used is determined by the business process (procurement, production, transfer, sale) the transaction is created for. It depends on other modules and their respective documents, which are the main documents in the transaction flow. The Cost source field defines which method is used. For more information, see Goods cost . Average cost It is used when the Cost source field is set to store. These are usually the issue transactions in the store. The only receipt transactions with this source are generated by Reconciliations. Тo define the cost of the current transaction, the following is performed: All valid store transactions are gathered. They are non-voided or (at least) released transactions and contain the same product, store and enterprise company which date to before the current transaction. The order of the transactions is defined by the transaction timestamp . If there are multiple transactions with the same transaction timestamp , the receipt transactions are ordered before the issue transactions. The unit cost is defined in all currencies (see Goods cost ) from p.1. The unit cost is multiplied by the quantity in the row and the result is saved as a cost in the current transaction (in all currencies). Example 1: For a specified product, store and enterprise company, there are transactions listed below. For issue transactions, the average cost method is used. In the beginning, there are two receipt transactions: receipt , Timestamp: 01 Dec 2020 12:45 , 4 PCS, total cost: 100 ; receipt , Timestamp: 01 Dec 2020 17:27 , 3 PCS, total cost: 61 . These two transactions define the unit cost as ( 100 + 61 ) / ( 4 + 3 ) = 23 . The result is used in the next issue transaction: issue , Timestamp: 03 Dec 2020, 11:29 , 5 PCS, total cost: 5 * 23 = 115 ; Then, there is a receipt transaction: receipt , Timestamp: 04 Dec 2020 15:33 , 6 PCS, total cost: 146 ; The average cost is ( 100 + 61 - 115 + 146 ) / ( 4 + 3 - 5 + 6 ) = 24 . This cost is used in the next issue transactions. Note that the first issue transaction happens at the same time as the receipt transaction, but the receipt transaction is considered before the issue transaction. Because of this, the cost of the issue transaction is affected: issue , Timestamp: 04 Dec 2020 15:33 , 2 PCS, total cost: 2 * 24 = 48 ; issue , Timestamp: 07 Dec 2020 09:54 , 1 PCS, total cost: 1 * 24 = 24 . This example illustrates a case where the product cost is not affected by the presence or absence of a lot. Even if different lots exist in the transactions, the cost is an average. There are products required to have individual costs for each lot (this is described in the product's definition). The principle above is then changed, and in p.1 we take into account transactions that also have a matching lot field. An empty value (no lot) is considered a valid/separate lot. Example 2: There is a receipt transaction with two lots (so there are two receipt store transactions): receipt , lot # 1 , Timestamp: 01 Dec 2020 13:15 , 10 PCS, total cost: 120 ; receipt , lot # 2 , Timestamp: 01 Dec 2020 12:15 , 8 PCS, total cost: 96 . The unit cost for both lots is 12 . Then come the following issue transactions: issue , lot # 1 , Timestamp: 01 Dec 2020 14:28 , 3 PCS, total cost: 3 * 12 = 36 . The next receipt transaction is only for lot # 1 : receipt , lot # 1 , Timestamp: 02 Dec 2020 10:30 , 7 PCS, total cost: 98 ; Now lot # 1 has a unit cost of ( 120 - 36 + 98 ) / ( 10 - 3 + 7 ) = 13 , while the second lot has a unit cost of 12 . issue , lot # 1 , Timestamp: 05 Dec 2020 17:20 , 4 PCS, total cost: 4 * 13 = 52 ; issue , lot # 2 , Timestamp: 05 Dec 2020 11:12 , 5 PCS, total cost: 5 * 12 = 60 . Specifying the cost explicitly This is used when the cost source is set to \"Document\". This is the source of all receipt transactions, except for the ones generated by Reconciliation. For each receipt transaction, the cost is calculated separately and according to a formula/calculation that is specific to the current business process. The method involves calculating a number in the document currency (the cost is in only one currency). Then, this number is converted into the rest of the cost currencies (see Goods cost ). A more complicated example is when the cost of the goods is defined by the issue transaction cost of other goods available in the same enterprise company. It is not required to receive the goods from the same store. When transferring goods from one store to another, the issue transaction has a standard average cost. However, the goods received in the second store have to be entered with a cost equal to the one from the first store issue (a greater cost may be set if there are transport or other expenses). The same principle is applied when returning sold goods from a client or receiving back a rented asset. Another example is the production, where the cost of the produced products is formed by the costs of the ingredients, salary expenses, and more. Further reading: Calculating cost for inventory reconciliation Calculating cost for produced products Calculating cost for returned products Calculating cost for transferred products Calculating cost when returning rented assets"
  },
  "modules/logistics/concepts/index.html": {
    "href": "modules/logistics/concepts/index.html",
    "title": "Common concepts | ERP.net Tech Docs",
    "keywords": "Common concepts Goods cost Lots issue Setting transaction timestamp"
  },
  "modules/logistics/concepts/lots-issue.html": {
    "href": "modules/logistics/concepts/lots-issue.html",
    "title": "Lots issue | ERP.net Tech Docs",
    "keywords": "Lots issue The current article describes the principles of lots issue when goods are issued from the store. Lots issue is actually the obligation to issue products from certain lots before others. The lots are prioritized and the priority is mandatory when goods are issued from the store (i.e. when store transactions are released). This priority is at least advisable when lots are entered before the store transaction documents (store orders, shipment orders, sales orders and more). The final goal is the lots selection in the document lines to be executed in the correct order. Example 1: In the document line, 10 Pcs of the product have to be sold/shipped/issued and the lot is not specified. The lot with the highest priority (let’s name it [Lot 1#] ) has 17 Pcs available. So following the principle of lots issue, the user has to select/be offered [Lot 1#] in the line. There are cases when the first lot does not have enough available quantity to fulfill the whole line quantity. Then, more than one lot has to be used. The quantity in the line has to be divided into several lines and in each line the lot has to be specified with its quantity. Again, the lots order defines their priority in the lots issue. Example 2: If there are 30 Pcs in the line and no lot is selected, and the three top priority lots - [Lot 1#] , [Lot 2#] , and [Lot 3#] - have available quantities of 17 , 8 , and 12Pcs , then the quantity in the line would be divided into the following lines: - [Lot #1],17 Pcs *; - [Lot #2],8 Pcs *; - [Lot #3],5 Pcs *. * These are the total quantities of each one of the three lots. The document may be saved in other forms, for example - the 17 Pcs of the first lot may be entered as 17 separated lines, each line with quantity of one [Lot #1]. This may be necessary if the product is serialized, each line must have a serial number specified, and the quantity has to be 1 . Actually, it can be said that there is always line breakdown. In еxample 1 there is trivial breakdown into only one lot [Lot #1] , 10 Pcs . Defining lots may appear in earlier documents that precede the store transactions - store orders, shipment orders, sales orders, etc. In this stage, specifying the lot is recommended. If lots are selected in such a document, they are passed to the next document and may be changed. In some cases, a change may not be recommended and following documents have to keep the selected lots (for example, the customer in the sales order requires to receive the lots which are specified in the sales order; then, those lots have to be issued from the store). Specifying lots in the store transactions is final and mandatory. If it has not happened in previous documents, it has to happen in the store transaction. The lots cannot be changed in following documents. Store transactions differ from the other documents with their limits according to the quantities which may be selected for each lot. In the store transactions, quantities are limited to the current stock holds. In other documents, there may be more precise restrictions - the “available to promise” (for specified lot). This is a method used to reserve lots. For example, if a sales order reserves the whole available quantity of one lot but there is no store transaction yet (so the current stock hold is unchanged), it would be wrong if another sales order called for quantities from the same lot. Selecting lots in a document line happens only if the line has no selected lots. If the lot is already specified and there are enough stock holds (with no assurance that the selected lot has the highest priority), only the quantity is validated. Such validation is applied in the store transactions, but it is possible to appear earlier (in preceding documents) so the user is warned earlier that he has to select another lot. Lots issue methods There are three main lots issuing methods - FIFO (First in, first out), FEFO (First expire, first out), LIFO (Last in, first out). They set the lots priorities. Each product uses a lots issuing method for itself. This is specified in the product definition. The product setting may be specified or null. If it is null, there is no sequence in the product's lots and there are no restrictions which lot should be selected (or the product does not use lots). In such cases, the lot is not mandatory even in the store transactions. The priority may be defined by sorting the lots by the date of their first receipt or by the date when they expire: for the FIFO method - the lots are sorted in an ascending order by the date of first receipt; for the FEFO method - the lots are sorted in an ascending order by their expiring dates (if no expiration date is specified, the null date is considered the largest date); for the LIFO method - the lots are sorted in a descending order by the date of first receipt. Example 3: There are 30 Pcs in a document line and lots of the product in the line have the following details (lot, available quantity/current stock hold, date of first receipt, expiry date): [Lot #1], 11 Pcs , 01.12.2021 , 05.01.2022 ; [Lot #2], 17 Pcs , 03.12.2021 , 03.01.2022 ; [Lot #3], 14 Pcs , 07.12.2021 , null . This document line is divided into two or three document lines with quantities from different lots depending on the lots issuing method of the product: when FIFO is selected: -[Lot #1],11 Pcs *; -[Lot #2],17 Pcs *; -[Lot #3],2 Pcs *. when FEFO is selected: -[Lot #2],17 Pcs *; -[Lot #1],11 Pcs *; -[Lot #3],2 Pcs *. when LIFO is selected: -[Lot #3],14 Pcs *; -[Lot #2],16 Pcs *. * Again, additional lines breakdown may be necessary if the product uses serial numbers or other information for the current transaction. If the quantity of Example 3 is 5 Pcs and not 30 Pcs, then no line breakdown would be necessary (to be more precise - the trivial breakdown into one line would happen) and the lot would just be selected in the line depending on which lots issuing method the product uses. When the current stock holds of the product have records for both quantity from a specific lot and quantity with no lot, then the no-lot records have the least priority (because, for example, they may be held for planned receipts which have not arrived yet, and the quantities are only available without being part of the current stock holds; in that case, it would be better if they were used as late as possible while the current stock holds with specified lots are exhausted first). So, for each lots issuing method, the priorities are defined as follows: FIFO: the records with lots whose receipt date has value - highest priority (sorted ascending by this date); the records with lots with null receipt date (they are considered to arrive in the store as late as possible); the records with no lots. FEFO: the records with lots whose expiry date has value - highest priority (sorted ascending by this date); the records with lots with null expiry date (they are considered to expire last); the records with no lots. LIFO: the records with lots with null receipt date - highest priority (they are considered to arrive in the store as late as possible); the records with lots whose receipt date has value (sorted descending by this date); the records with no lots. Lots issue ways Lots issue may be done in the following manners: - manually (through the interface - using a panel, list, others); - automatically (by starting a function by the user or a document event - state change). Manual lot issue In these cases, the system suggests to the user a list of lots sorted according to the lot issue method (by the date of first receipt or the expiry date). The user selects the lots and their quantities (his choice is limited to the available quantity). The most direct approach is the order (sorting) to be shown in the dropdown list of the lot attribute in the line. Thus, the user does the lots breakdown by selecting a lot, editing the quantity (if necessary) and adding a new line with the same product, where he/she can select the next lot and its quantity. In this case, only lots with available quantity are shown in the dropdown list. Another approach is the sorted list with available lots to be placed in a separated panel/screen. There are fields where the user can enter the quantity for each lot. Thus, the user sees the list and enters the whole breakdown of the line at once instead of entering it line by line. The panel/screen would contain only available lots. In both cases, it is useful for the lists to contain additional information: current stock holds, available quantity (for each lot), date of first receipt, expiry date (as date and duration), notes, etc. Automatic lot issue Automatic lot issue is executed by the system when the user starts it or when an event happens. The automatic lot issue uses the same sorted list of the lots as the manual lot issue. The difference is that the lots are always issued strictly in the order of the list. In the manual lot issue, the user has the option not to issue a specific lot and to skip its turn and use another lot. Calculation of the quantity in the last lot In the lot issue process, it is important to keep in mind that the quantities are entered in the measurement unit of the line. Every quantity fulfillment in the examples is done in the base measurement unit because the current stock holds and the available quantities are always shown in that unit. So, in the examples above, the Quantity Base attribute is used. To enter quantity in the Quantity field (where the measurement unit may differ from the base measurement unit of the product), the Product Dimensions would be used. The problem is that if product dimensions are used for all quantities in the breakdown of the line, the total Quantity might be different from the initial Quantity. This may lead to differences in the quantities in the child and the parent documents and as a result new documents may be created. Example 4: There is a document line with Quantity of 16 l and 30 kg Quantity Base (the product dimension is 1 l = 1.875 kg ). The three lots with highest priorities for this product ( [Lot #1] , [Lot #2] and [Lot #3] ) have current stock holds/available quantities of 10 kg , 10 kg , and 18 kg . In the breakdown of the initial document line, there would be 10 kg of each lot. If we apply the product dimension for each lot to see the quantity in liters, we would have the following: - [Lot #1] , Quantity Base = 10 kg , Quantity = 10 / 1.875 = 5.33333l ; - [Lot #2] , Quantity Base = 10 kg , Quantity = 10 / 1.875 = 5.33333l ; - [Lot #3] , Quantity Base = 10 kg , Quantity = 10 / 1.875 = 5.33333l ; But the total quantity would be 15.99999 l and not 16 l as expected. This problem is solved by using the remainder and not product dimensions for the last document line ( [initial quantity]-[already used quantity] ). This algorithm would make the breakdown of Example 4 as follows: - [Lot #1] , Quantity Base = 10 kg , Quantity = 10 / 1.875 = 5.33333l ; - [Lot #2] , Quantity Base = 10 kg , Quantity = 10 / 1.875 = 5.33333l ; - [Lot #3] , Quantity Base = 10 kg , Quantity = 16 - 5.33333 - 5.33333 = 5.33334 l . Example 5: The same approach for calculating the quantity in the last line from the breakdown is applied in cases of trivial breakdowns (when there is only one lot). Then, the only quantity in the breakdown is the last line. For example, if the line has Quantity of 2 l and Quantity Base of 0.66667 kg (3 l = 1 kg), and the first lot (with highest priority) has current stock holds/available quantity of 10 kg , then the only breakdown is not supposed to be multiplied by 3 to have the quantity in liters (as it would make 0.66667 * 3 = 2.00001 l). The calculation should be 2 - 0 = 2 l (this is the initial quantity minus the already used quantity - 0)."
  },
  "modules/logistics/concepts/setting-transaaction-timestamp/index.html": {
    "href": "modules/logistics/concepts/setting-transaaction-timestamp/index.html",
    "title": "Creating a duplicate document and a new document from current | ERP.net Tech Docs",
    "keywords": "Creating a duplicate document and a new document from current The current article describes the principles and some specifics in creating a duplicate of an existing document. Also different usages of the algorithm are presented. Basic principles Creating a duplicate of a given document is actually creating a new document which contains identical business data with the original one, meaning that in the duplicate all substantial and meaningful data is copied from the original document and there is an exception for some technical data (such as internal identification numbers - Primary Keys, IDs of reference links between different parts of one document and more). This is the common algorithm used when creating a duplicate of a given document: A new document is created with the same document type and in its headers the substantial data from the original document is copied: a. the substantial data from the original document header is copied to the new document header; b. in each of the specific headers in the new document only the substantial data from the corresponding specific headers of the original documents is copied. If the original document has rows - for each row a new row is created in the duplicate document and the substantial data from the original row is copied to the new one. If the original document has rows of the rows (i.e. a document row has dependent records in different part of the document) - for each main row from the original document its duplicate row in the new document is fixed and for each of its sub-rows of the main row a new sub-row in the duplicate document is created and from the original sub-row only the substantial data is copied. If the original document has rows of the rows of the rows , the same procedure is applied until the original document structure is covered. Thus, the new document - the duplicate - must contain the same number of records (headers, rows, rows of rows etc.) as the original document and these records must have the same structure as they are in the original document. As document rows are considered not only the standard rows which most of the documents have, but also the document properties and the Additional amounts . Also, if the specific document header has its own properties, then they are considered document rows. The records in ‘Document amount referenced documents’ panel are considered rows of rows (rows of the additional amounts). Also, the records in ‘Document line amounts’ are considered as such (they are rows of the standard document rows). Currently, the attached files are not copied when creating a duplicate of a document."
  },
  "modules/logistics/concepts/setting-transaaction-timestamp/transaction-stamp/index.html": {
    "href": "modules/logistics/concepts/setting-transaaction-timestamp/transaction-stamp/index.html",
    "title": "| ERP.net Tech Docs",
    "keywords": ""
  },
  "modules/logistics/concepts/setting-transaction-timestamp/index.html": {
    "href": "modules/logistics/concepts/setting-transaction-timestamp/index.html",
    "title": "Setting transaction timestamp | ERP.net Tech Docs",
    "keywords": "Setting transaction timestamp The current article describes the principles for defining a transaction timestamp in the transactions rows. A timestamp is essential for goods cost definition. It represents the exact moment when a specific transaction starts affecting the goods cost. For more information, see Goods cost and its sub-articles. Usually, transaction timestamps are set automatically with no need for user intervention. This is executed in two general ways: On transaction release, if there is no transaction timestamp, then it is set automatically by the date of the transaction and/or by the current date and time. When the automatic set of the timestamp in the transaction release does not set the correct date and time in accordance with to the business process, a transaction timestamp is defined in the store orders (or another document generating transactions, such as Reconciliations). Thus, another module which controls and executes the orders is available to set a specific transaction timestamp defined by its business logic. Users can change the transaction timestamp in one of two ways: By editing the store orders (their transaction timestamps will be copied to the executing transactions). By editing the transactions directly (before their release or afterwards by adjustment documents ). No matter how the timestamp is set, it has to comply with the following restrictions: if the quantity in the transaction row is different from 0, then the Document Date should match the date of the transaction timestamp . More detailed description of the logic behind the automatic set of the transaction timestamp may be found in the following articles: More specific cases of setting the transaction timestamp Setting transaction timestamp by store orders Setting transaction timestamp in reconciliations Setting transaction timestamp on transaction release"
  },
  "modules/logistics/concepts/setting-transaction-timestamp/more-specific-cases-of-setting-the-transaction-timestamp.html": {
    "href": "modules/logistics/concepts/setting-transaction-timestamp/more-specific-cases-of-setting-the-transaction-timestamp.html",
    "title": "More specific cases of setting the transaction timestamp | ERP.net Tech Docs",
    "keywords": "More specific cases of setting the transaction timestamp When generating cost transactions from receiving orders, there is a specific way of getting the transaction timestamps . It is wrong because of the irregular generation procedure: direct transaction creation from another module is not supposed to happen, as the other modules are not supposed to work with internal module operations. In this transaction generation, only the cost is filled in (all quantities are 0). It is the cost coming from the purchase invoices, for the quantities which are already entered in the store by the receiving order. To have correct time and date for the cost, the generated transaction should have a specific transaction timestamp equal to the transaction timestamp with which the quantities enter the store. If the cost is entered later, the products will turn out with zero cost. For examples and more detailed information about goods cost when purchasing, see Setting cost when purchasing goods ."
  },
  "modules/logistics/concepts/setting-transaction-timestamp/setting-transaction-timestamp-by-store-orders.html": {
    "href": "modules/logistics/concepts/setting-transaction-timestamp/setting-transaction-timestamp-by-store-orders.html",
    "title": "Setting transaction timestamp by store orders | ERP.net Tech Docs",
    "keywords": "Setting transaction timestamp by store orders Sometimes, the algorithm for automatic set of transaction timestamps on transaction release may not choose the best possible dates and times. This is usually because of the specific logic of the business process of ordering store transactions which are unknown to the Logistics module. It is possible to set transaction timestamps for the ordered transactions in the store orders. The module that contains the specific business logic helps setting better and more accurate times and dates in the store orders. When the orders are fulfilled, these transaction timestamps will be copied to the transactions and will remain unchanged on transaction release. The current article describes some specific cases which require setting the transaction timestamp by the store orders. In transitional store orders For more information about transitional documents, see Transitional documents . When a store order is transitional, all its rows are filled in with the creation date and time of the parent document. The logic here is as follows: If the store order is set to transitional, then it is considered that it will happen automatically along with the parent document. So, the transaction timestamps will inherit the creation date and time of the parent document. Example 1 : There is a work order where all documents except for the transactions (consumption orders, output orders and store orders) are transitional . On release, the store orders generate released transactions, i.e. the process is completely automatic. At first, the work order has the following technological ratio: producing 1 PCS of a product, the materials are 1 PCS of material #1 and 1 PCS of material #2 . On work order release, all sub-documents are created, and the materials are issued with a transaction timestamp of [19 Jan 2020 14:00:07] and the produced product has a transaction timestamp of [19 Jan 2020 14:00:09] . Also, because of the quick creation and release of all sub-documents, these are the transaction timestamp for creating the producing sub-documents (the consumption order is created on [19 Jan 2020 14:00:07] and the output order - on [19 Jan 2020 14:00:09] . Then, on 22 Jan 2020 the Work Order is adjusted and the quantity of the first material is changed from 1 PCS to 2 PCS . If in the transitional Store Orders the transaction timestamp fields are left blank, when releasing the new transaction for the additional 1 PCS of material #1 , its transaction timestamp would be [19 Jan 2020 23:59:00] because it was released later than its Document Date. In this case, we would have the following chronology: 1 PCS of material #1 , issue , 19 Jan 2020 14:00:07 ; 1 PCS of material #2 , issue , 19 Jan 2020 14:00:07 ; 1 PCS of produced product, receipt , 19 Jan 2020 14:00:09 ; 1 PCS of material #1 , issue , 19 Jan 2020 23:59:00 At 14:00:09 there will be a receipt of 1 PCS of the product for which 2 PCS of material #1 are needed. By now, only 1 PCS is issued (the other piece is issued later). This leads to failure in the issue and receipt balance validation (see Receipt and issue balance validation in store transfers and Calculating cost for produced products because of incorrect time of the last issue transaction. When the Store Orders are transitional, the transaction timestamp is equal to the time and date of creation of the parent document, so the last issue transaction will also have transaction timestamp [19 Jan 2020 14:00:07] and the problem with the issue/receipt balance would not appear again. In store orders created from completing output orders When completing output orders are generated from the work order document form, specific date and time are set as a transaction timestamp in the rows of the output order. For each row in the output order, the greatest or the last transaction timestamp of all timestamps marking the moment the production has entered the store, is set as a transaction timestamp (this is the maximum date and time in all receipt transaction rows created by the current work order row, which has quantity different from 0). After that, the transaction timestamp from the completing output order are passed to the store orders and copied to the transaction rows. The completing output orders actually distribute the cost of the materials which are not issued on time. As a standard, it is considered that later issues of materials are distributed to the last manufactured products. This is why the greatest transaction timestamp of all non-zero receipt transactions for the specified product is set as a transaction timestamp . In store orders created by consumption orders for material In the generation procedure of store orders by consumption orders, there is also a specific way of setting the transaction timestamp in the store orders rows. It appears only if the quantity in the specified row is negative and the greatest transaction timestamp from all material issue transactions in the generated store order is used as a transaction timestamp . The consumption order rows with negative quantities return unnecessary (exceeding) materials. This process has to be entered in the store with the same cost, as issued. If the material is issued in more than one transaction, the issue transaction preceding the return of the materials is unknown, so the last issue is used as a reference. In store orders created by shipment orders for products return This case is similar to the return of materials to the production. If the quantity of the current shipment order row is negative, the greatest transaction timestamp from the relevant store order row (of all issue transactions happening by now) is set as a transaction timestamp ."
  },
  "modules/logistics/concepts/setting-transaction-timestamp/setting-transaction-timestamp-in-reconciliations.html": {
    "href": "modules/logistics/concepts/setting-transaction-timestamp/setting-transaction-timestamp-in-reconciliations.html",
    "title": "Setting transaction timestamp in reconciliations | ERP.net Tech Docs",
    "keywords": "Setting transaction timestamp in reconciliations In Reconciliations, transaction timestamps which are about to be generated in the store transactions rows are calculated the same way as on Release. In the reconciliation document form, when the current availability of the products is calculated and stored in the rows, transaction timestamps are filled in as follows: If the Reconciliation has a present or future document date, then the transaction timestamp in the row has the current date and time. if the Reconciliation has a past document date, then the transaction timestamp is XX.XX.XXXX 23:59:00, where XX.XX.XXXX is the document date. The same principle is used for reconciliation release, in case there are rows with empty transaction timestamps . When the reconciliation creates transactions for discrepancies, the dates and times already set in the Reconciliation are copied to the newly created store transactions. Thus, the transaction timestamps in the transactions are defined by the current creation time or Reconciliation release and not by the current release time (of the store transaction)."
  },
  "modules/logistics/concepts/setting-transaction-timestamp/setting-transaction-timestamp-on-transaction-release.html": {
    "href": "modules/logistics/concepts/setting-transaction-timestamp/setting-transaction-timestamp-on-transaction-release.html",
    "title": "Setting transaction timestamp on transaction release | ERP.net Tech Docs",
    "keywords": "Setting transaction timestamp on transaction release On first release of the document, the transaction timestamp is set automatically in each transaction row that has no value. If the transaction has inherited some specific dates and times from the store orders or the user has entered them manually, these values will remain unchanged and the new dates and times will be set only in the rows with no values for transaction timestamp . When releasing the transaction, the values in the rows with no transaction timestamps are set according the following business rules: If the transaction's document date is today's date or a future date, the transaction timestamp for all rows is the current date and time. If the transaction's document date is in the past, then the transaction timestamp is XX.XX.XXXX 23:59:00, where XX.XX.XXXX is the document date. When a transaction is released with a past date, the time is set to 23:59:00 because it is unknown when exactly the transaction happened. It is assumed that it happened after all the other transactions which were released in time. In other words, late transactions are listed at the end of the selected date. If they are too late or cannot be ordered correctly among the other transactions from the same day, then the user may change the time manually - by adjustment documents . The time \"23:00:00\" follows the same principles because it helps the user manage late transactions from a given date more easily. For example, if it is necessary for a transaction to come after another one, the user should adjust it in the remaining minute of the current day. If the selected time was \"23:59:59:999\", that would not be possible."
  },
  "modules/logistics/concepts/standard-quantity-base.html": {
    "href": "modules/logistics/concepts/standard-quantity-base.html",
    "title": "Standard Quantity Base | ERP.net Tech Docs",
    "keywords": "Standard Quantity Base In Version 2018.2, we added a new dimension to measure the quantity in logistics documents - Standard Quantity Base (SQB). SQB represents the theoretical quantity in the base measurement unit according to the current dimensions of the product. The main objective is to improve algorithms for exhaustion and clear traceability of the execution of the ordered quantity. More details Quantity (Q) and Quantity Base (QB) were used for the exhaustion of the quantities between parent and generated (child) documents. Variable measurement ratios allowed the editing of QB. It no longer tracks the exhaustion between a parent and a child document. Example : PRODUCT (2 pcs = 1 kg standard) SALES ORDER (Q = 100 pcs, QB = 50 kg) STORE TRANSACTION (Q = 100 pcs, QB = 49 kg) The QB in the STORE TRANSACTION is 49 because that quantity has been measured in the store. QB in the SALES ORDER is 50 kg because this is the theoretical (standard) quantity in the base measurement unit. Although QB in the STORE TRANSACTION is 49 kg, the ordered quantity is fully exhausted. The example above shows that QB can no longer be used to monitor exhaustion, at least in the case of products with a variable ratio of units of measurement. This led to the need of adding a new measure - SQB (quantity in a standard unit of measure). SQB is the theoretical quantity in Base Measurement Unit which will be calculated if QB remains read-only, unchangeable by the user. Example : PRODUCT (2 pcs = 1 kg) SALES ORDER (Q = 100 pcs, QB = 50 kg, SQB = 50 kg) STORE TRANSACTION (Q = 100, QB = 49 kg (measured), SQB = 50 kg) Here, it is clear that if we use SQB, we can easily and accurately determine whether the document is exhausted or not. This made the SQB Metric the main generation procedure indicator as to deciding whether the quantity of the parent document is fully exhausted or not. It does not mean that Q and QB will no longer be taken into account. An exhaustion of Q and QB will continue to be performed - otherwise, the algorithms won’t be able to solve problems with rounding when we are partially executing the ordered quantity. The difference is that they will not determine whether a new child record must be created. For more information, see Metrics . SQB also allows for exhaustion monitoring and the unification not only of all generation procedures but also of all functional navigators. A record/line in functional navigators will be available for execution only if there is а remaining SQB that hasn’t been thoroughly fulfilled by the child documents. When using exhaustion by SQB, all functionalities will also work for non-VMR products while preserving resilience in terms of manual change in the measurement ratios. General SQB purposes In Conclusion, the new SQB dimension allows: QB exhaustion even when we are using VMR; QB and SQB exhaustion for non-VMR products; solving problems with rounding when we are partially executing the ordered quantity; clear traceability of how much of the ordered quantity is exhausted; implementation of the same algorithm for executing and exhausting quantities for all functional navigators."
  },
  "modules/logistics/index.html": {
    "href": "modules/logistics/index.html",
    "title": "Logistics | ERP.net Tech Docs",
    "keywords": "Logistics Common concepts Inventory Planning Procurement Warehouse management (WMS)"
  },
  "modules/logistics/inventory/execute-store-orders-function/index.html": {
    "href": "modules/logistics/inventory/execute-store-orders-function/index.html",
    "title": "Execute store orders function | ERP.net Tech Docs",
    "keywords": "Execute store orders function This function allows easier work with the barcode scanner and more functional methods for the execution of one store order row by more than one transaction row. This is useful in case the user operates with lots or serial numbers, etc. The function contains two main components: Store Orders panel Input Data panel Store Orders panel It loads the unfulfilled store order rows according to the filters in the navigator. The data includes the ordered quantity of the row, the executed part of that quantity and the remaining quantity (the unfulfilled part). This data is read-only except for the Input Quantity which is used for easier data entering. Input Data panel This panel is editable by the users. They enter information about what store transactions are executed in the current moment and do not mark the specific store orders that they are executing. This is defined automatically by the system. The data that is entered is Product, Lot, Serial Number, Quantity, Measurement Unit and Base Quantity . There are several methods to enter such information: Manually. This is the rarest method used. To be more precise, it is for editing information entered by any other method. Using the Input Quantity field in the Store Orders panel. When the user enters data in it, it automatically creates new row in the Input data panel with the entered quantity and the product, lot, serial number and measurement unit copied from the store order row , Also, the new row in the Input data panel is marked as reserved for the row in the store order rows panel. This method's purpose is to support the old method from the old execution navigator, where the user always enters the exact Store order row that he is executing. Using barcode scanner (or other system for control/counting/marking the stocks). This is considered as the standard way to enter data, where the user does not specify the store order row and only marks the store transaction. Distributing the executions The data entered in the Input data panel has to be distributed through the rows from the Store Orders panel. This is performed after each change in the Input data panel. The distribution is executed by store order rows execution algorithm and all calculations about the quantity are based on Base Quantity . The store order rows form the list [ORD] and the data in the Input data panel forms the list [EXC] . There is a small difference from the algorithm - rows from the Input data panel reserved to specific store order row, always execute this specified row. The algorithm is not allowed to distribute them to other rows. The purpose of this is to avoid a situation when the user enters quantity in Input Quantity field and it is distributed to another store order row (just because the algorithm considers it as with higher priority than the one that the user has chosen). So this gives the user the ability to mark specific rows for execution. The distributed quantities are illustrated as sub-rows of the store order rows. They contain data (quantity, lot, serial number and more) from the Input data panel which may be different than the data in the Store order row. Creating transaction In the end, when the user creates transaction, its rows are based on the distributed executions. For example, if a store order row has 4 distributed sub-rows of execution, then the Transaction has 4 rows with the information from the Input data panel and all those rows are executing the specific store order row. When the transaction is created, the data in the Input data panel is deleted and the navigator is ready to be used again."
  },
  "modules/logistics/inventory/execute-store-orders-function/store-order-rows-execution-algorithm.html": {
    "href": "modules/logistics/inventory/execute-store-orders-function/store-order-rows-execution-algorithm.html",
    "title": "Store order rows execution algorithm | ERP.net Tech Docs",
    "keywords": "Store order rows execution algorithm This algorithm is applied when there are many unfulfilled store orders or products going in and out of the store. The purpose is to create transactions, fulfilling the orders as correctly as possible. The idea behind the algorithm is that the system automatically defines which store orders should be fulfilled and what part of them - automatically, without user interference. This allows faster processing of the issue and receipt transactions, especially when the data (orders and products) volume is large. The starting data for the algorithm is two lists: list of unfulfilled store order rows - [ORD] . This list is usually a partial sample of all unfulfilled store orders in the database, e.g the orders from a certain customer/supplier or certain order. In [ORD] there are only the quantities which are unfulfilled, because if for a given store order row for 10 PCS there are released transactions with 7 PCS , then in [ORD] the quantity for this row would be 3 PCS . The rows completely fulfilled by transactions are not part of [ORD] ; List of store transactions - [FUL] , which contain data about products currently being moved in or out of the store. The data consist of Product, Lot, Serial Number and Quantity . Afterwards, data is saved in the newly created Transactions. The list [FUL] is usually the result of a control system (such as barcode scanner) which is placed at the entrance/exit of the store. Both lists must consist of the same type of operations - meaning [ORD] is a list of receipt store order rows and [FUL] is a list of receipt store order rows or if [ORD] contains only issue store order rows and [FUL] is a list of issue store order rows. If [ORD] and [FUL] contain both issue and receipt transactions, then the lists must be separated into two uniform parts and the algorithm will be applied on each part separately. Store orders execution algorithm The purpose of the algorithm is the distribution of all operations/quantities from [FUL] to the rows of [ORD] . It is possible that some operations are defined as fulfilment of one row from [ORD] . Besides, the quantities from one operation can be separated amongst more than one row. At first, the two lists are sorted. [FUL] is sorted according to the entering order of the operations. [ORD] is sorted by Document Date, Document Number and Line Number (this is standard sorting, but other types of sorting using data from CRM or SCM modules which has initialized the orders are also possible). These sortings set a kind of initial priority, which should be used for orders fulfilment. Then, the algorithm continues to 4 stages and at each operations/quantities from [FUL] are compared to [ORD] rows by defined criteria. At each stage the system goes through [FUL] (after it is sorted) and for each operation with quantity no equal to zero (the quantity may be 0 at a previous stage) the following actions are executed: Search for a row in [ORD] that matches the operation according to the current stage criteria. If there is no such row, the algorithm goes to step 7. If there is such a row, the algorithm continues to the next step. The part of the operation quantity this row fulfills is defined. At stage I, II and III the quantity is defined by comparison of the row quantities and the operations quantities. The smaller value is defined as quantity. Exception is stage IV where the algorithm takes the quantity in the operation. A new transaction row is created with the Product, Lot and Serial Number from the operation and the quantity defined in step 3. As a transaction timestamp in the transaction row, the current date and time is set. Also, the row from [ORD] , which is found in step 1, is marked in the transaction row. The row from step 1 and the operation are edited and their quantity is decreased by the quantity from step 3 (i.e. the algorithm updates what is left for fulfilment). If the remaining quantity in the operation is different than 0, all steps by now are repeated. Otherwise, the algorithm goes to the next step. The processing of the current operation is over and the algorithm goes to the next one. So for each operation the algorithm finds a store order row, fulfilling it, according to the current criteria, and this is repeated until the quantity in the operation is 0 or there are no store orders found (that match the operation). The criteria by which the store order row is found for a given operation is a comparison between the row and the operation by their values of Product, Lot and Serial number . Three types of comparison exist: Exact match means that the row and the operation have the same value. For example, exact lot match means that either the row and the operation have the same lot or both have no lot specified. Weakened match means that either the value is the same in both (row, operation) or one of them may be null. For example, weakened lot match returns match even if the operation has a lot and in the row there is no lot. Free match means that the algorithm does not take into account the values and always returns a match. At the different stages there are the following criteria for store order rows fulfilment: Stage I: Searching for a match by Product and by Lot and by Serial number . Also, it is required that the quantity in the row should be different than 0 (in this stage this should be true for each row in [ORD] ). Stage II: Searching for a match by Product and weakened match by Lot and by Serial number . Again, it is required that the quantities in the order rows are different than 0 (here, it is possible that zero quantity rows are found because of the update in stage I). Stage III: Searching for a match by Product , free match by Lot and by Serial number and non-zero quantities in the order rows. Stage IV: Searching for a match by Product and free match by Lot and by Serial number . The difference from stage III is that here the quantities in the rows can be zero. It becomes clear that in the first stage the algorithm tries to strictly comply with the product, lot and serial number, and during the next stages the algorithm weakens the criteria allowing violation of the lots and serial numbers from the store orders. At stage III over execution is still not allowed (because of the non-zero quantities criteria). The purpose of the last stage is to be used in cases when the user issues/receives more than what was ordered. So in the last stage the user is able to fulfill orders with zero quantities, combined with the way of defining the quantities of stage III - the over execution is allowed. If the quantities from [FUL] are not more than the quantities in [ORD] , then stage IV will not be reached at all. Also, in each stage the algorithm requires exact match by Product . This means that if in [FUL] there are products that are not listed in [ORD] , then they will remain even after stage IV. Those cases (by now) are not covered by the system and have to be managed by the user. Otherwise, after stage IV in all operations from [FUL] there would only be zero quantities. By this we reach the purpose that all quantities in [FUL] should be distributed to a row from [ORD] . Example 1: There are the following rows in [ORD] (serial numbers are null everywhere): row 10, Product #1, 4 PCS, Lot #ab17 row 20, Product #1, 3 PCS, Lot #ss54 row 30, Product #1, 2 PCS row 40, Product #1, 7 PCS, Lot #ts23 In [FUL] there is only one operation for Product #1, Lot#ab17 , with no serial number and quantity of 14 PCS . So in stage I the algorithm will cover row 10 by 4 PCS from the operation, at stage II the algorithm will cover row 30 and at stage III the algorithm will cover part of row 40 . This is how the lists [ORD] and [FUL] will look like at each stage: After stage I: | [ORD] | [FUL] | |:----|:----| row 10, Product #1, 0 PCS, lot #ab17 | Product #1, lot #ab17, 10 PCS row 20, Product #1, 3 PCS, lot #ss54 | row 30, Product #1, 2 PCS | row 40, Product #1, 7 PCS, lot #ts23 | After stage II: | [ORD] | [FUL] | |:----|:----| row 10, Product #1, 0 PCS, lot #ab17 | Product #1, lot #ab17, 8 PCS | row 20, Product #1, 3 PCS, lot #ss54 | row 30, Product #1, 0 PCS | row 40, Product #1, 7 PCS, lot #ts23 After stage III: | [ORD] | [FUL] | |:----|:----| row 10, Product #1, 0 PCS, lot #ab17 | Product #1, lot #ab17, 0 PCS | row 20, Product #1, 0 PCS, lot #ss54 | row 30, Product #1, 0 PCS | row 40, Product #1, 2 PCS, lot #ts23 | Example 2: If there are the same [ORD] and [FUL] except for the fact that the quantity in [FUL] is 18 PCS (i.e. 2 more than the orders). Then in stages I and II the fulfilments will be the same. At stage III row 40 will be fulfilled completely and at stage IV the remaining 2 PCS from [FUL] will cover row 10 and it will be over executed."
  },
  "modules/logistics/inventory/index.html": {
    "href": "modules/logistics/inventory/index.html",
    "title": "Inventory | ERP.net Tech Docs",
    "keywords": "Inventory Execute store orders function Lots Store orders Projected availability report Receipt and issue balance validation in store transfers"
  },
  "modules/logistics/inventory/lots/index.html": {
    "href": "modules/logistics/inventory/lots/index.html",
    "title": "Lots | ERP.net Tech Docs",
    "keywords": "Lots Warehouse lots contain one row for each specific product, status, production batch and other specific warehousing conditions. Lot status can block certain operations. Items in a lot are all of the same type and produced under the same conditions, intended to have uniform quality and characteristics. The lots characteristics are: Product - the product of the lot; Lot number Receipt store transaction - if the lot isn't created manually, this field stores the receipt store transaction which created the current lot; Status - the status of the warehouse lot may be one of the following: blocked for document (sales or service order); blocked for party; blocked for inspection; free to use; Blocked for party - non-null when the warehouse lot is blocked specifically for some party. Blocked for document - if non-null, contains the document for which the lot is blocked. License No - the license number for this lot. Null when license number is N/A or unknown. Purchase lot number - identification of the purchase lost with which the products from this store lot are received. E.g. the document number of the receiving order. Description; Expiry date; Receipt date - the date of the first receipt of products in this lot."
  },
  "modules/logistics/inventory/projected-availability-report.html": {
    "href": "modules/logistics/inventory/projected-availability-report.html",
    "title": "Projected availability report | ERP.net Tech Docs",
    "keywords": "Projected availability report This report is based on projected available balance and shows the inventory balance projected into the future. Fields This article describes the most important fields in the report: Document date - this is the planned release date of the store orders; On hand quantity base - the stock holds for today ; Planned quantity base - planned movement of the product (negative number when issuing, positive number when receiving). The result is calculated from non-voided, at least released store transactions, with transactions timestamps equal to the Document date field; Planned quantity base to date - planned movement of the product so far. It is basically the running total of the Planned quantity base field. The result is calculated from non-voided at least released store orders with planned release date equal to the Document date field; Projected available balance - this is the planned stock holds after the planned movements happen; Available to promise - the minimum quantity available for use in future issuing operations and which will not violate the current issue operations, already planned or done with this product. This data is calculated for a specified store and/or product."
  },
  "modules/logistics/inventory/receipt-and-issue-balance-validation-in-store-transfers.html": {
    "href": "modules/logistics/inventory/receipt-and-issue-balance-validation-in-store-transfers.html",
    "title": "Receipt and issue balance validation in store transfers | ERP.net Tech Docs",
    "keywords": "Receipt and issue balance validation in store transfers The current article describes the validation if the receipt does not exceed the issue in the product transfer. In this case a transfer may be any of the following actions: moving a product from one store to another store by a store transfer; products production (that it is considered that the materials are issued and transferred as a new product into another store); returning products by a customer (this is considered a transfer - the products are issued from one store and given to the customer and then they return\\transfer them to the same or other store); returning a rented asset which has been delivered to the customer (here the situation is similar to the returning of sold products except that the returning may happen or not, but after we delivered assets to the renters, we expect their return is mandatory when the rental contract expires). This validation is important so unrealistic situations can be avoided (for example - transactions with incorrect chronology) which may lead to incorrect goods cost. For more information on cost calculation, see Calculating cost for transferred products , Calculating cost for returned products , Calculating cost for produced products and Calculating cost when returning rented assets . Validation in transfer of one product Usually in store transfers one product is issued from one store and the same product is entered into the target store (the same record in the products nomenclature). The current article describes the validation in this usual type of transfer. Other transfers (such as production, where one product (or more) are issued from the first store and other products (or products) are entered into the target store) is not covered in the current article. The validation is applied on every issue and receipt transaction release (from the respective store). And the validation applies on every transfer row. All issue transactions and all receipt transactions, resulting from the current row, are summed up. At first, these operations are ordered. For every two store transactions - [transaction 1] and [transaction 2] , their chronological order has to be defined. This is executed as follows: If the transaction timestamps of [transaction 1] and [transaction 2] are different - the transaction with a smaller timestamp is before the other If the transaction timestamps are equal, but the movement type is not the same (issue or receipt) - then the issue transaction is before the receipt transaction. If the transaction timestamps are equal and both transactions are issued - then the transaction with a bigger quantity is placed before the other. If the transaction timestamps are equal and both transactions are receipts - then the transaction with less quantity is placed before the other. After the transactions are ordered chronologically, the costs are set to zero: [issue quantity total] = 0 and [receipt quantity total] = 0. Then, for every element of the ordered list with transactions, depending on its direction - issue or receipt - its base quantity is added to the respective total. Then, the system checks if [issue quantity total] < [receipt quantity total] is true. If it is true, the current operation (transaction release) is aborted and an error message appears. If it is false, then the system moves to the next element of the ordered list of transactions. If the Transaction Timestamps are equal in receipt transactions, the transactions are in quantity ascending order because the following case is possible: the first transaction is an issue transaction of 10 PCS at 12:42 , the next operation is a receipt transaction of 10 PCS at 13:17 and there are two more receipt transactions with equal Transaction Timestamps of 13:31 - one transaction for 3 PCS and one transaction for -3 PCS . The last two transactions may appear after correction of the receipt document of 10 PCS. So if the transactions are not in ascending order, it is possible to add the quantity of the transaction with quantity of 3 PCS first and in this moment the [issue quantity total] = 10 and [receipt quantity total] = 13 , which may mislead us for imbalance between issue and receipt transactions, no matter that the next transaction immediately fixes it. Under the same considerations, the issue transactions with equal Transaction Timestamps are in quantity descending order. It is possible to correct the first operation with -3 PCS and this correction will have the same Transaction Timestamp as the original transaction. Then if the -3 PCS transaction is first, there will be redundant/non-existing imbalance - [issue quantity total] = -3 and [receipt quantity total] = 0 . Validation in transfer of different products (production) In production there is a change in the algorithm above. As the products that are received in the target store (manufactured goods) are usually different from the ones that we issue from the first store, it is not appropriate to check directly if [issue quantity total] > [receipt quantity total] . Also, it is not appropriate to sum quantities of different materials/products in one total [issue quantity total] . This is the reason for the different calculation of the [issue quantity total] . Instead of summing the issue transactions in one [issue quantity total] , each material/product has its own total and the result is several totals. These totals and the quantities that are defined by the manufactured good recipes are used to calculate if enough materials are issued by the current moment. This quantity is added to the [issue quantity total] ."
  },
  "modules/logistics/inventory/store-orders/index.html": {
    "href": "modules/logistics/inventory/store-orders/index.html",
    "title": "Store orders | ERP.net Tech Docs",
    "keywords": "Store orders Concepts"
  },
  "modules/logistics/inventory/store-orders/store-orders-concepts/index.html": {
    "href": "modules/logistics/inventory/store-orders/store-orders-concepts/index.html",
    "title": "Concepts | ERP.net Tech Docs",
    "keywords": "Concepts Store orders - planning and due dates"
  },
  "modules/logistics/inventory/store-orders/store-orders-concepts/store-orders-planning-and-due-dates.html": {
    "href": "modules/logistics/inventory/store-orders/store-orders-concepts/store-orders-planning-and-due-dates.html",
    "title": "Store orders - planning and due dates | ERP.net Tech Docs",
    "keywords": "Store orders - planning and due dates The current article describes the purpose and usage of the planning and due dates in the store order headers - Planned Release date, Planned Completion date and Due date attributes. Planned release date The date specifies when, by plan, the execution of the store order should start. I.e. by plan on this date the first store transaction for the current store order should be released (if the store order is fulfilled at once, it would be the only store transaction). Planned completion date This is the date when, by plan, the execution of the store order should end. If can be considered as the date when the last store transaction for the current store order is released. But it would be more precise to say that this is the date when the last non-completed store transaction is completed , since the releasing of the store transaction does not guarantee that the process of execution of the store order is completed and the quantities and/or the costs may be modified by corrective documents to the released store transaction. Due date This is the end term for completion of the store order execution. The meaningful store order suggests the following to be true: Planned Release date =< Planned Completion date =< Due date. This still allows us to have different due dates and planned completion dates. For example, if we have the following dates: Planned release date = 2020/10/01 Planned completion date = 2020/10/05 Due date = 2020/10/08 It would mean that we plan to execute the order from 1th October to 5th October but the due date allows us a three days delay. This could happen if the execution plan is scheduled for this period (1th-5th October) because of purchase or production orders (because of resource optimisation, for example) but the due date is defined by another module (for example - by the delivery date to the customer). Thus, the planned release date and planned completion date are used because of the production and procurement plan while the Due date is because of other modules which generate Store orders and it is used for control of the deadline. Planned release date is essential for the available to promise calculation and the projected available balance . Thus, by the planning dates the user is able to define more precisely the information about when a specified quantity of a product is expected to be produced or delivered. For example, if a delivery of a large quantity of a product is expected but the delivery would be executed partially and not at once - several deliveries, so separated store orders could be created and each store order would define the different periods for each delivery stage. The advantage in this case is that the users would have more detailed information on when exactly the products are expected to be placed in the store. If we create one store order and the planned release date is the start of the first delivery, then the users would know that the whole quantity would be available at the first stage of the delivery. For more information, see Available to promise . How are the attributes filled in by generation procedures? Here we explain how the planning and due dates are filled in when the store order is generated by another document. For more precise information about the specific generation procedure Wiki should be referred to. When generated by sales order All generation procedures from sales orders define the planning and due dates in the store orders as follows: Due date = Required Delivery date; Planned Release date = Required Delivery date; Planned Completion date = Required Delivery date. Required Delivery date is found in the sales order lines or in the sales order header (if the lines have no value). When generated by transfer orders For receipt store orders the dates are filled in as follows: Due date = Default Due date in; Planned Release date = Default Due date in; Planned Completion date = Default Due date in. For issue store orders the dates are filled in as follows: Due date = Default Due date out; Planned Release Date = Default Due date out; Planned Completion Date = Default Due date out. Default Due date in and Default Due date out are found in the transfer order lines. When generated by shipment orders Here, the planning and Due dates are filled in as follows: Due date = Required Delivery date; Planned Release Date = Required Delivery date; Planned Completion date = Required Delivery date. Required Delivery date is found in the Shipment order header. When generated by shipments Here, the planning and Due dates are filled in as follows: Due date = if the largest Required Delivery date has value - this is the date, if not - the Document date; Planned Release date = if the largest Required Delivery date has value - this is the date, if not - the Document date; Planned Completion date = if the largest Required Delivery Date has value - this is the date, if not - the Document date. The largest Required Delivery date is the largest Required Delivery date from the Shipments headers and the line Required Delivery date from the Shipment lines. When generated by consumption orders When issuing store orders are generated, the dates are filled in as follows: Due date - if the cheduled Date Time attribute from the Consumption order line has value - this is the date, else - the date of the first release of the consumption order; Planned Release date - Scheduled Date Time; Planned Completion date - Scheduled Date Time. Scheduled Date Time is found in the Consumption Order lines. When generated by output orders When receiving store orders are generated, the dates are filled in as follows: Due date - Due date from the work order; Planned Release date - Release date from the work order; Planned Completion date - Due date from the work order. For each output order line, the Due date and the Release date from the work order are the dates of the work order selected in the output order line. When generated by receiving order All generation procedures of store order from receiving order fill the planning and Due dates as follows: Due date - today's date; Planned Release date - Planned Release date from the receiving order; Planned Completion date - Planned Delivery date from the receiving order. Planned Release date and Planned Delivery date from the Receiving order are attributes of the Receiving order header. When generated by service activity All generation procedures of store order from receiving order fill the planning and Due dates as follows: Due date - today's date; Planned Release date - null/empty value; Planned Completion date - null/empty value."
  },
  "modules/logistics/planning/available-to-promise/atp-algorithm.html": {
    "href": "modules/logistics/planning/available-to-promise/atp-algorithm.html",
    "title": "ATP Algorithm | ERP.net Tech Docs",
    "keywords": "ATP Algorithm The current stock holds are added to the unfulfilled store orders chronology. Thus, save for the physical availability, store orders which are not fulfilled, but planned to be on a specific date, are taken into account (the Planned Release Date field indicates this date). Besides physical availability, other already planned stock movements are taken into account. The calculated quantities for each date from the new chronology are reviewed and the smallest value is selected. This is the ATP quantity for the specified parameters. We use the smallest value. If on a date when we have the smallest value a greater value is entered as ATP quantity, and this quantity is used for a new issuing operation, it will not be enough for all ordered operations. The minimum quantity in the new chronology actually shows the greatest value we can use for the date specified as a parameter without violating other issuing store processes. Let’s apply that to the example from available to promise : After adding the physical availability to the chronology, we have: Date Physical availability Start quantity Receipt quantity Issue quantity End quantity 2021/10/01 8 3 - - 11 2021/10/03 8 - - 2 9 2021/10/04 8 - 16 4 21 2021/10/07 8 - - 8 13 2021/10/09 8 - - 7 6 2021/10/14 8 - 8 - 14 2021/10/16 8 - 4 9 9 2021/10/19 8 - - 2 7 Here is the graphical chart for the new chronology: After reviewing the value column (or following the lowest values in the graphical chart), you can see that the lowest value is 6 pcs . This is the available to promise quantity for 2021/10/01 . Total clculations (for a period) When calculating the ATP for a whole period (more than one date), the data gathering, as well as the combination of the chronology and the current stock holds, is executed the way we described earlier. After that, for every date in the period greater than or equal to the date specified as a parameter, the ATP is defined as follows: The minimum quantity value for the whole period is defined - let's call it min1 . Then, we pick the last (greatest) date for this value - date1 . For every date from the starting to date1 (including), the ATP is min1 . If there are dates in the chronology after date1 , the minimum quantity value for the period after date1 is min2 . The last date which has this value is date2 . From the date after date1 and before date2 (including), the ATP is min2 . This is repeated until all dates in the chronology are covered. The period we are making calculations for is divided into several sub-periods (at least one, and at most - equal to the number of dates in the chronology). In the first sub-period, there is a minimum value for the ATP. For each subsequent sub-period, the ATP is greater than the ATP for the previous sub-period. For example, let's have have the following chronology for the period between 01.10 and 06.10 , calculated after adding the current physical availability to the data from the unexecuted sore oders. Date Physical availability Start quantity Receipt quantity Issue quantity End quantity 2021/10/01 12 8 - - 20 2021/10/03 12 - 2 - 22 2021/10/08 12 - 5 - 27 2021/10/09 12 - 2 19 10 2021/10/12 12 - - 7 3 2021/10/15 12 - 28 6 25 2021/10/16 12 - - 7 18 2021/10/20 12 - 6 9 15 2021/10/21 12 - - 3 12 2021/10/24 12 - 24 5 31 2021/10/30 12 - - 6 25 2021/10/31 12 - - 5 20 After reviewing the chronology, we establish that the period from 2021/10/01 to 2021/10/06 is divided to three sub-periods: one from 2021/10/01 to 2021/10/14 , another from 2021/10/15 to 2021/10/23 and a third from 2021/10/24 to 2021/11/06 . For the first period, the minimum value (hence the ATP) is 3 pcs . For the second period, it is 12 pcs , and for the last period, the ATP is 20 pcs . These calculations are represented by a graphic: Modifications in the agorithm iplementation There are some specific changes in the ATP calculation for algorithm implementation. When using the unexecuted store orders chronology instead of starting with an opening balance for a defined period, the definition of the start quantity for the unexecuted stre oders is not really effective. All store movements - the unexecuted by now store orders - are used without limits for date and without calculation for the starting value. These movements calculate the ATP for sub-periods. To calculate the ATP for a specific date, we simply take into account the periods before this date and the minimum value from the last period. This method is effective enough. However, problems appear when we want to calculate the ATP for a date before all existing unexecuted store orders. There is no sore oders chronology for this date and as the opening balance is not calculated (it would be zero), the previously mentioned principle for ATP calculation cannot be applied. When the date for which we calculate the ATP is before the earliest unexecuted store orders,the following principle is applied: All unexecuted store orders after the specified date are taken into account, and the ATP is calculated according to their chronology. This is a value projected available balance . The current available physical quantity is calculated - value [ Current Stock Holds ] If there are future unexecuted store orders, (i.e., if [ projected available balance ] is not null), then: [ ATP ] = min([ projected available balance ], [ Current Stock Holds ]) Otherwise, [ ATP ] = [ Current Stock Holds ] For example, if the current physical availability is 10 pcs and there are the following unexecuted Store Orders: 2021/10/09 - 2 pcs , receipt; 2021/10/13 - 7 pcs , issue; 2021/10/16 - 6 pcs , receipt. the ATP for the dates from 2021/10/09 to 2021/10/15 (including) is 5 pcs . After this date, it is 11 pcs . If we have the same data from the previous example, but the issue for 2021/10/13 is 1 pcs , then the ATPs would be as follows: before 2021/10/09: 10 pcs (this is the smaller value from the current physical availability and the projected available balance after 2021/10/09 ); from 2021/10/09 to 2020/10/15 (including): 11 pcs ; from 2021/10/16 onward: 17 pcs ."
  },
  "modules/logistics/planning/available-to-promise/atp-reports.html": {
    "href": "modules/logistics/planning/available-to-promise/atp-reports.html",
    "title": "ATP Reports | ERP.net Tech Docs",
    "keywords": "ATP Reports In Version 2018.2, we introduced two new reports – Available to promise and Available to promise (by lots) . These reports show the quantities available to promise (ATP) (by product or by product lot) from a current or future date, but not only as a calculated number. The reports allow us to see the separate records for all planned movements and therefore the projected available balance (PAB) for the different dates. Using it, we can see which numbers are behind the value of (ATP) and how it is calculated for the different periods. Details The ATP available on a given date is the quantity that can be promised to orders scheduled for shipment (for more information, see topic Available to promise ) from that date to the date of the next planned movement. That is why the ATP in the reports is calculated from each scheduled date. In ERP.net, this is the planned release date of the store orders. The records represent the chronology of the unfulfilled parts of non-voided store orders, which has statuses from planned to released included. There is a separate record for each combination of date, product, enterprise company and store . In the available to promise (by lots) report, the records are also separated by a lot . The calculation of ATP is based not only on the data of the chronology of the store orders which are not executed , but also on the information of the current stock holds (see topic Available to promise ). However, for the particular product or store, there may not be any unfulfilled shipments or deliveries and therefore those records won’t exist in the reports. For this reason, the reports start with an auxiliary line with a fictive “From date” which is equal to 01.01.2000 and contains the information for the starting availability, i.e. the current availability . As mentioned above, the rest of the records represent the chronology of the store orders which are not executed . They contain information for: Movements base - The sum of the quantity of all planned stock movements (issue and receipt) on this date in base measurement unit. Movements to date base - A running total of the quantity of all planned stock movements (issue and receipt) until this date (inclusive) in base measurement unit. Projected availability - Projected Availability in base measurement unit on a particular date. A running total of the projected/expected available quantity calculated by adding supply or subtracting demand in chronological order in base measurement unit. The value includes all expected stock movements (issue and receipt) until this date (inclusive) and the current availability. ATP Base - Indicates the promissory amount in base unit valid from a specified date to the date of the next stock movement. This is the minimum quantity available for use for future issuing operations (sales, use in production, etc.), and which will not violate the planned issue operations."
  },
  "modules/logistics/planning/available-to-promise/index.html": {
    "href": "modules/logistics/planning/available-to-promise/index.html",
    "title": "Available to promise | ERP.net Tech Docs",
    "keywords": "Available to promise Description The available to promise (ATP) for a product and a date is the minimum quantity available for use in future issuing operations (sales, production, etc). It will not interfere with the issue operations, including this product, no matter if they are already planned, finished, or being executed just now. The calculation of the ATP is made by dates and it has meaning for the present or future dates. There is no use calculating it for past periods. Even more, the ATP algorithm , which is used for the calculation, is based on the fact that the ATP quantities are calculated for a date greater than or equal to today's date. This is because the current stock holds are used instead of their movements chronology. The parameters, data, and ATP algorithm used for the ATP calculation are shown below. We will try to calculate the ATP for a specific date. Then, there is a detailed example of an ATP calculation for a long period (more than one date). Parameters The main/required parameters are product , own company , and date . The ATP calculation is executed from the date and for the specified product and own company. Additional parameters can be set as store and lot . If a store is specified, the calculation will be executed only for this store. Otherwise, the data is collected from all stores (as though it is limited by the product, the own company, and the date). The lot specification is similar. Data For a standard ATP calculation, two types of data are used: 1. Current stock holds : It shows the availability of the product selected in the specified own company. If a store and a lot are provided, the data is filtered by them. 2. Chronology of the store orders which are not executed : It loads the chronology of the unfulfilled parts of non-voided store orders, with statuses ranging from \"Planned\" to \"Released\". The data is filtered by the parameters entered for a product, own company, store, and lot. The chronology is sorted by the Planned Release Date field. The data in this field is fundamental for ATP calculations. For example, let's assume that we have specified a product , own company , store and lot , and we want to calculate the ATP for date 2020/10/01 . The physical availability for this date is 13 pcs , and before that date there are two unfulfilled, released store orders - one for receiving 7 pcs with date 2020/09/28 and one for issuing 4 pcs with date 2020/09/29 . The documents after 2020/10/01 are as follows: 2020/10/03 - released issuing store order for 5 pcs , 3 pcs of which are fulfilled with a store transaction on the same date, so the unfulfilled quantity is 2 pcs; 2020/10/03 - released issuing store order for 5 pcs , which is fulfilled with a store transaction marked as single execution and contains 2 pcs from the same date, so the unfulfilled quantity is 0 pcs ; 2020/10/04 - planned receipt store order for 16 pcs , unfulfilled; 2020/10/04 - planned issuing store order for 4 pcs , unfulfilled; 2020/10/07 - planned issuing store order for 8 pcs , unfulfilled; 2020/10/09 - planned issuing store order for 7 pcs , unfulfilled; 2020/10/14 - planned receipt store order for 8 pcs , unfulfilled; 2020/10/16 - planned receipt store order for 4 pcs , unfulfilled; 2020/10/16 - planned issuing store order for 9 pcs , unfulfilled; 2020/10/19 - planned issuing store order for 2 pcs , unfulfilled; The current availability is 8 pcs . It is calculated by adding the two issuing store transactions with date 2020/10/03 to the availability from 2020/10/01 . The unfulfilled store orders chronology is as follows: Date Start quantity Receipt quantity Issue quantity End quantity 2020/10/01 3 - - 3 2020/10/03 - - 2 1 2020/10/04 - 16 4 13 2020/10/07 - - 8 5 2020/10/09 - - 7 -2 2020/10/14 - 8 - 6 2020/10/16 - 4 9 1 2020/10/19 - - 2 -1 The start quantity on 2020/10/01 is calculated by the two issuing store orders before 2020/10/01 . For the next dates, the unfulfilled store orders from the specific date are added. Further reading: ATP algorithm ATP Reports"
  },
  "modules/logistics/planning/index.html": {
    "href": "modules/logistics/planning/index.html",
    "title": "Planning | ERP.net Tech Docs",
    "keywords": "Planning Available to promise Material requirements planning Projected available balance"
  },
  "modules/logistics/planning/material-requirements-planning.html": {
    "href": "modules/logistics/planning/material-requirements-planning.html",
    "title": "Material requirements planning | ERP.net Tech Docs",
    "keywords": "Material requirements planning Material requirements planning (MRP) is a planning process designed to match supply with demand. MRP does this by creating supply (purchase/work/transfer) orders to meet or exceed the demand, according to the MRP parameters. Some information could be obtained from here: https://en.wikipedia.org/wiki/Material_requirements_planning The MRP process in ERP.net is an implementation which mostly follows the general theory. However, in order to use MRP, you need to do the ERP.net-specific setup. Document types and routes setup The document routes should be properly set-up. The main input parameter for MRP is demand . It is calculated based entirely on store orders with state Planned . Therefore, the document routes for sales orders, purchase orders, work orders, etc. should be adequately designed to generate store orders with a planned state. If a store order is generated solely for the purposes of MRP demand management, it can be set with the Planning_Only attribute. This attribute does not allow the setting of Firm Planned (or higher) states. Simplified description of a single MRP run When MRP is run for a warehouse (store), it does the following to each product: Calculates demand. Determines whether a supply action is needed. Determines the required quantity. Creates a purchase/work/transfer order for the desired quantity. When MRP is run for multiple warehouses (stores), the system tries to prioritize the supply order of the warehouses. This might not always be successful, especially in cases of circular supply orders. Terms There are many terms used in MRP. We will try to provide simple descriptions for some of them: Projected Available Balance (PAB) - An inventory balance projected into the future. It is the sum of on-hand inventory minus requirements plus scheduled receipts and planned orders. Planning Bucket - the smallest period whose demand and supply are planned as a single unit. In ERP.net, it is fixed as 1 day . In theory, it could be a day, week, month or some mixed system (for example, days in the near future, weeks in the far future, etc.). Planning Horizon - the period of time in the future for which demand is matched with supply. In ERP.net, it is currently fixed to 180 days . The Planning Buckets (also known as \"buckets\") exist only within the time frame specified by the Planning Horizon. When we say \"bucket\", it is a Planning Bucket in the future, but within the Planning Horizon . Time fences Time fences are boundaries between different periods in the planning horizon. From today to Demand Time Fence (DTF) - the time period in the (near) future for which actual demand is considered accurate, and forecasts - inaccurate. The planning process considers only demand. From DTF to Planning Time Fence (PTF) - the time period between the DTF and PTF for which it is unknown whether the demand or the forecast is more accurate. The planning process considers bigger either the demand or forecast for each bucket. After PTF - only the forecasts are considered accurate. The planning process considers only forecasts. Product supply definitions The MRP process is set-up through the product supply definitions. Each definition contains the planning parameters for one product and one warehouse (store). Every warehouse (store) needs to create a separate product supply definition for each product, which will be planned for this warehouse. The product supply definitions parametrize the when , how much , and how of the MRP planning system. Procurement type Procurement type specifies what to do when a supply order needs to be created. The options are: Buy - Create a purchase order Make - Create a work order Transfer - Create a transfer order Order policy The order policy specifies when the supply is not enough and a supply order needs to be created. The options are: MRP - a supply order is created for: any demand for a bucket OR if the Projected Available Balance for any bucket is less than the Planning Safety Stock . OPS - a supply order is created if the PAB for any bucket is less than the specified Order Point . OPT - a supply order is created if by the time of expected arrival of the ordered goods, the PAB is less than the specified Order Point . PRS - a supply order is created unconditionally on each order cycle. Planning Order Cycle Days specifies the number of days in the order cycle. Lot sizing method The lot sizing method specifies how much should be ordered. It is divided in two separate calculations: Algorithm calculations. Order modifiers The selected algorithm calculates some order quantity. Then, order modifiers adjust the quantity with minimum, maximum, and lot-size modifiers. The algorithms are: FOQ - Fixed Order Quantity - orders unconditionally what is specified in the Fixed Order Quantity. EOQ - Economic Order Quantity - orders the specified period in an efficient way, balancing between order-fixed and holding costs. For more information, see https://en.wikipedia.org/wiki/Economic_order_quantity . LFL - Lot For Lot - orders the calculated demand for the bucket. LFP - Lot For Period - orders the required quantity for the bucket but adds enough quantity for the specified period ahead. ROP - Reorder Point - orders up to the specified Planning Maximum Inventory . ROT - Reorder Point with Time Planning - orders up to the specified Planning Maximum Inventory but also adjusts the quantity with the expected usage for the time the goods are in transit."
  },
  "modules/logistics/planning/projected-available-balance.html": {
    "href": "modules/logistics/planning/projected-available-balance.html",
    "title": "Projected available balance | ERP.net Tech Docs",
    "keywords": "Projected available balance Description Projected available balance (PAB) shows the inventory balance projected into the future. It is the running sum of the current stock holds with scheduled receipts added, minus planned issue stock orders. The projected available balance is used in the calculation of the available to promise . The algorithm In the projected available balance, two kinds of data are used: Current stock holds - this is the quantity available placed in store today; Chronology of the store orders which are not executed - includes all store orders (or their unfilled parts) which are not completed yet. Note that if there are expected store receipts or issues for a past date which are still not executed, the algorithm assumes that they are being executed today . For example: Let's assume that today (2021/05/05) we have 10 pcs from product A in store S ; There is an expected delivery from 3 days ago (2021/05/02) for 8 pcs , which has not been executed yet; We have the following planned store movements: on 2021/05/07 , planned receipt of 15 pcs ; on 2021/05/09 , planned issue of 4 pcs ; on 2021/05/13 , planned receipt of 10 pcs ; on 2021/05/15 , planned issue of 7 pcs ; on 2021/05/15 , planned receipt of 2 pcs ; on 2021/05/20 , planned issue of 3 pcs ; With this data provided, we can calculate the following PAB: Date Start quantity Issue quantity Receipt quantity PAB 2021/05/05 10 - 8 18 2021/05/07 - - 15 33 2021/05/09 - 4 - 29 2021/05/13 - - 10 39 2021/05/15 - 7 2 34 2021/05/20 - 3 - 31 The PAB line can be seen on the following chart: All documents in ERP.net that may lead to store movements can be set to generate planned or firmed store orders - directly or through other documents. With this setting, the documents can be involved in the projected available balance and available to promise calculations."
  },
  "modules/logistics/procurement/automatic-lot-creation.html": {
    "href": "modules/logistics/procurement/automatic-lot-creation.html",
    "title": "Automatic lot creation | ERP.net Tech Docs",
    "keywords": "Automatic lot creation This function is used when the user wants to automatically create new lots when purchasing products. This is achievable by the product type definition and the Lot Auto Creation field. If checked, it specifies that lots are automatically created by the receiving orders with which the products are received. When such product is purchased, the following actions are performed for each purchase order row: if the Lot field has value, nothing happens; if the Lot field is empty, the system checks the value of the product type's definition Lot Auto Creation field (of the product of the current row): if it is false - nothing happens; if it is true - then an attempt to set a lot in the current row is performed: an already existing lot of the current product is searched, which has the number of the current document set in the Purchase Lot Number field; if such lot is found - it is filled in the current row; if no such lot is found - a new lot is created. New lot algorithm creation The new lot, created in the last step of the actions described above, is created as follows: the product from the purchase order row is set as 'Product' in the new lot definition; the 'Purchase Lot Description' from the purchase order header is set as 'Description' in the new lot definition; the Document Number of the current document is set as 'Purchase Lot Number' in the new lot definition; the 'Lot Number' of the new lot is formed by the biggest lot number (in alphabetic order) of the already existing ones (regardless of Product, Description or Purchase Lot Number), and this number is increased by 1; if there are no existing lots in the database '00001' is set."
  },
  "modules/logistics/procurement/index.html": {
    "href": "modules/logistics/procurement/index.html",
    "title": "Procurement | ERP.net Tech Docs",
    "keywords": "Procurement Automatic lot creation Setting cost when purchasing goods"
  },
  "modules/logistics/procurement/setting-cost-when-purchasing-goods.html": {
    "href": "modules/logistics/procurement/setting-cost-when-purchasing-goods.html",
    "title": "Setting cost when purchasing goods | ERP.net Tech Docs",
    "keywords": "Setting cost when purchasing goods In ERP.net goods are purchased in two stages: Stage one: recording the quantities. In this stage, only quantities are entered into the system - those which are actually received. This stage changes only the stock holds. In this stage also the user defines the lots. Stage two: recording the costs. This is done by separating store documents from the documents from stage one. This is because the cost is defined by the purchase invoices for the goods which do not always arrive along with the actual goods. The current article describes stage two. The documents that are part of both stages of the purchasing process are as follows: Receiving orders - These documents represent what we expect to receive and not what is actually received. Purchase invoices - created from or by receiving orders and contain the cost of the goods. This is the document sent by the supplier and the user enters it the way it is received; Store receipt orders - created from the receiving order and record the quantity that has to be entered in the store; Quantity transactions - created from or by the store orders . They contain the stocks that are entered into the store (they may be entered directly by a barcode scanner). These documents do not record the goods cost yet; Cost transactions - created from the receiving orders and record the cost, which is copied from the purchase invoice . They should get the exact lots and Transaction Timestamp from the quantity transactions . Stage one is represented by receiving order => store receipt orders => quantity transactions while the second stage is represented by receiving order => cost transactions and only after the purchase invoice is entered in the system. The cost is set only for the products which are received by the quantity transaction . I.e. if there is a receiving order with no quantity transaction then no cost transaction will be created. The cost is calculated when the quantities from the quantity transaction are multiplied by the unit cost, defined by the purchase invoice . So if there is no purchase invoice no cost transaction will be created. The unit cost for one row in the receiving order is defined as follows: All rows of released, non-voided purchase invoices for the current row from the receiving order are summed up. If there are no such rows, then the unit cost is 0 . For each row from p.1,an end cost is defined: [End Cost] = [Line Amount] + [sum of the distributed amounts for the current row] . Note Only additional amounts that are marked with Add To Line as True. Also, the additional amount may be entered by other purchase invoices (for example - transport purchase invoice). At the end the [End Cost] for all rows from p.1 are summed up, the quantities for those rows are summed up and the end cost is divided by those quantities. If the quantities are 0 then the unit cost is also 0 . Not: When summing up all end costs have to be converted to the currency of the receiving order , and all quantities have to be converted to the measurement unit of the receiving order row. Then, when creating cost transaction for a receiving order , for each row of the current receiving order the following calculations are made: All rows of released, non-voided cost transactions for the current row of the receiving order , are summed up; For each row from p.1, a new row in the transaction cost is created in which the quantity and the unit cost are 0 , the lot and the transaction timestamp are copied from p.1. and the cost is equal to the quantity of the row multiplied by the unit cost for the row in the receiving order . Example 1 : There is a Receiving Order #1 with two rows: row #10, Product A, 10 PCS ; row #20, Product B, 12 PCS ; The following quantity transactions are created: Transaction #1 for Receiving Order #1 row #10 , Product A,Lot 12B , 4 PCS , Transaction Timestamp = 15/10/2020 12:59; Transaction #1 for Receiving Order #1 row #20 , Product B,Lot 9A, 10 PCS , Transaction Timestamp = 15/10/2020 12:59; Transaction #2 for Receiving Order #1 row #10 , Product A,Lot 17B, 3 PCS , Transaction Timestamp = 17/10/2020 14:15; Transaction #2 for Receiving Order #1 row #20 , Product B,Lot 13A, 1 PCS , Transaction Timestamp = 17/10/2020 14:15. Also, there are two purchase invoices for Receiving order #1 and one purchase invoice for transport, which distributes an additional amount on the first two purchase invoices : Purchase Invoice #1 , for Receiving Order #1 row #10, 8 PCS, 64 EUR ; Purchase Invoice #1 , for Receiving Order #1 row #20, 13 PCS, 39 EUR ; Purchase Invoice #2 , for Receiving Order #1 row #10, 1 PCS, 10 EUR ; Purchase Invoice #3 with no rows and an additional amount of 44 EUR for transport which is distributed by the quantities. So the added amounts are 16 EUR, 26 EUR and 2 EUR ; In this case, the cost transactions on this delivery should be as follows: Product A, lot 12B, 0 PCS , Transaction Timestamp = 15/10/2020 12:59 , Line Cost = 4 PCS * ((64 EUR + 16 EUR + 10 EUR + 2 EUR) / (8 PCS + 1 PCS)) ~ 40.89 EUR ; Product B, lot 9A, 0 PCS , Transaction Timestamp = 15/10/2020 12:59 , Line Cost = 10 PCS * ((39 EUR + 26 EUR) / 13 PCS) = 50 EUR ; Product A, lot 17B, 0 PCS , Transaction Timestamp = 17/10/2020 14:15 , Line Cost = 4 PCS * ((64 EUR + 16 EUR + 10 EUR + 2 EUR) / (8 PCS + 1 PCS)) ~ 30.67 EUR ; Product B, lot 13A, 0 PCS , Transaction Timestamp = 17/10/2020 14:15 , Line Cost = 4 PCS * ((39 EUR + 26 EUR) / (16 PCS) = 5 EUR ;"
  },
  "modules/logistics/wms/how-it-works/warehouse-order-execution.html": {
    "href": "modules/logistics/wms/how-it-works/warehouse-order-execution.html",
    "title": "Warehouse order execution | ERP.net Tech Docs",
    "keywords": "Warehouse order execution Warehouse order execution can be done through the WMS mobile application. The warehouse order lines are loaded one by one and are executed by the worker using the execution Wizzard. The Wizard loads information about the task type, warehouse location, product and quantity of the executed line. The proposed warehouse location, product and quantity can be either confirmed or changed. When the line is completed, the execution is recorded as both warehouse transaction and warehouse order execution. The count of the records information in them depends on the task type. If task type is MOVE, then : two warehouse transactions - one with OUT direction and the the warehouse location specified during the line execution and one with IN direction and the To Warehouse Location specified in the warehouse order line one document fulfillment with completed fulfillment type and the quantity speficied during the line execution are created. If task type is RECEIVE, then : one warehouse transaction with IN direction and the the warehouse location specified during the line execution one document fulfillment with completed fulfillment type and the quantity speficied during the line execution are created. If task type is RECEIVE, then: one warehouse Transaction with OUT direction and the the warehouse location specified during the line execution one document Fulfillment with completed fulfillment type and the quantity speficied during the line execution are created."
  },
  "modules/logistics/wms/how-it-works/warehouse-policies.html": {
    "href": "modules/logistics/wms/how-it-works/warehouse-policies.html",
    "title": "Warehouse policies | ERP.net Tech Docs",
    "keywords": "Warehouse policies Warehouse policies is a hierarchical system for applying policies to warehouse operations. Policy kind Warehouse policies have diferent kinds/types which specify what the actual action of the policy is. The list of the policy kinds is system predifined. Applicability You set up each warehouse policy by defining the conditions where it applies, to which products and for how long. Each warehouse policy can apply to: Warehouse Zone and its sub-zones Product group and its sub-groups Product type Specific product From date To date NOTE: Some policies can be applied only at the warehouse level. Importance Policies have importance. When evaluating a policy, the setting with the highest importance is applied. For example, if a policy is applied to a root zone and to a sub-zone, the importance of the sub-zone setting determines which setting will be applied: If the sub-zone setting has higher priority, it will be applied. This can be used for hierarchical application of policies for zones. If the root zone setting has higher priority, it will be applied. This can be used for root zone (or even warehouse level) setting, which overrides the setting for specific zones. Importance is an integer value, allowing even negative numbers (for very low importance)."
  },
  "modules/logistics/wms/index.html": {
    "href": "modules/logistics/wms/index.html",
    "title": "Warehouse management | ERP.net Tech Docs",
    "keywords": "Warehouse management Warehouse management module follows the concepts of the Warehouse Management Systems WMS . The main objective for implementing a WMS is to optimize the efficiency of the warehouse operations in the managed warehouses . Managed warehouses are physical warehouses, which have managed operation. They exist outside of existing store definitions. ThesStores concept is used for the management of inventory levels and general ledger (accounting) entries. Managed Warehouses are sub-level, which is used to manage all warehouse activities, including: Picking Put-Away Counting Packing/Unpacking Inspection Robot interactions etc. Note One managed warehouse can encapsulate the storage and operations of multiple legal entities (Enterprise companies). While the existing \"Store\" concept is strictly bound to the enterprise company, the warehouse can accommodate goods of multiple entities. It can even be used to store goods from external companies. The most important part for achieving operational effectiveness is to properly organize the layout of the warehouses. Layout optimization is outside the scope of this document. Managed Warehouses are organized using Zones and Locations . Zones are sub-divisions of a warehouse. Note Zones are used to accommodate different storage needs, such as different temperature requirements or turnover rate of the products. The zones are further divided in Locations . Locations have name (like #1-8-20), which is used to uniquely identify them. Note Use warehouse management to increase efficiency by automating warehouse routing and identifying storage locations for your products. The two most basic documents of WMS are: Warehouse requisitions (W.R.) They contain outside requests for warehouse operations (usually inbound/outbound). Warehouse orders (W.O.) They are the internal plan for execution of W.R. They contain routes, locations, workers, etc. The basic operation flow of WMS is the following: The steps, noted in (parens) in the diagram are as follows: The outside module/department creates W.R. based on its needs. Inside the WMS, the team devises a plan for execution and stores it as a W.O. In the best-case scenario, the creation of WO is totally automated. The workers use their handheld devices to execute the order. Each step is recorded as both warehouse transaction and warehouse order execution. After the WO is fully executed, the warehouse requisition execution is updated. After the WR is fully executed, the external module/department updates its execution state. Typically, managed warehouse operations are executed using some sort of handheld device, which is used to scan bar-codes, NFC tags, etc. Push and Pull task management When a warehouse requisition document comes in, there are many ways we can plan how to fulfill it. The plan is represented by warehouse order documents. But how these Order documents are created? There are at least two main ways to organize the work. Pull system The Pull system is the easiest way to organize the execution. Under some circumstances, it can also be the most efficient. In the Pull system, each warehouse worker decides when to get (pull) work. Whenever they are ready, they request more work through their mobile app. Pros: Do not require a central planner. Effective for small orders, usually e-Commerce. Very easy to setup. Easy to maintain - no need to plan for workers missing, overloaded, etc. Efficient - workers achieve high efficiency without central planning (but might need more control). Cons: Not good for B2B, because large orders are better served with Push System. Without a central planner, worker control needs to be better controlled. Cannot implement complex order mixing, splitting or other complex work procedures. Push system Under the Push system, there is a central planner, who plans the work and pushes it to the workers. The Push system might be required in more complicated execution environments. Pros: A central planner can better allocate the worker and machine resources to fulfill the requisitions. In complicated execution, the Pull System might be inappropriate. Worker task management is taken away from the workers and controlled centrally. Cons: More expensive - require a central planner. The efficiency of the workers depends heavily on the planner. Choosing the right strategy There can be other organizations of the workflow within a warehouse. The ERP.net data model allows implementing almost any conceivable strategy, with the most prominent ones built-in. However, planning the execution can be externalized to custom apps and services. Applying AI/ML strategies for achieving better efficiency is a possible direction. Also, mixing robots with human workers might require using custom strategies."
  },
  "modules/logistics/wms/push-and-pull-task-management.html": {
    "href": "modules/logistics/wms/push-and-pull-task-management.html",
    "title": "Push and pull task management | ERP.net Tech Docs",
    "keywords": "Push and pull task management When a warehouse requisition document comes in, there are many ways we can plan how to fulfil it. The plan is represented by warehouse order documents. But how are these order documents created? There are at least two main ways to organize the work. Pull system The pull system is the easiest way to organize the execution. Under some circumstances, it can also be the most efficient. In the pull system, each warehouse worker decides when to get (pull) work. Whenever they are ready, they request more work through their mobile app. Pros: Do not require a central planner. Effective for small orders, usually e-commerce. Very easy to set up. Easy to maintain - no need to plan for workers missing, overloaded, etc. Efficient - workers achieve high efficiency without central planning (but might need more control). Cons: Not good for B2B, because large orders are better served with push system. Without a central planner, worker control needs to be better controlled. Cannot implement complex order mixing, splitting or other complex work procedures. Push system Under the push system, there is a central planner, who plans the work and pushes it to the workers. The push system might be required in more complicated execution environments. Pros: A central planner can better allocate the worker and machine resources to fulfil the requisitions. In complicated execution, the pull system might be inappropriate. Worker task management is taken away from the workers and controlled centrally. Cons: More expensive - require a central planner. The efficiency of the workers depends heavily on the planner. Choosing The right strategy There can be other organizations of the workflow within a warehouse. The ERP.net data model allows implementing almost any conceivable strategy, with the most prominent ones built-in. However, planning the execution can be externalized to custom apps and services. Applying AI/ML strategies for achieving better efficiency is a possible direction. Also, mixing robots with human workers might require using custom strategies."
  },
  "modules/logistics/wms/zone-based-routing.html": {
    "href": "modules/logistics/wms/zone-based-routing.html",
    "title": "Zone based routing | ERP.net Tech Docs",
    "keywords": "Zone based routing The basic idea With zone based routing, the rules for processing the goods are determined based on the zone, in which the goods are stored for each step. The zones are sequentially numbered, relative to their \"closeness\" to final shipping. For example: 1 IN -> 2 INSP -> 3 BULK -> 4 PICK -> 5 KIT -> 6 PACK -> 7 OUT RECEIVE ------------> --OPTIMIZE--> ----------------> DISPATCH The main processes in the warehouse - receive, optimize and dispatch, are ordered consecutively through the zone sequence. The receive process starts at the inbound docks and runs until goods are placed in bulk. The optimization process usually deals with replenishment of the picking zones, but can also be used for pre-kitting. The planning of the dispatch process works backwards - from the final step (the dispatch from the outbound docks) to the first step (usually picking). This is similar to how MRP/DRP works, but applied for WMS. Zone based routing and sequencing provides great flexibility in the route formation process, while keeping things simple and understandable for the process designers. It allows the process designers to focus separately on each zone, leaving the complex full routing formation to the system. Zone based routing allows programming of very complicated routes, while still keeping things simple and maintainable. How it works? For each zone, there are rules, which define how the goods will be processed, when they pass the zone. The rules for a zone are defined separately for each of the WMS processes - receive, dispatch and replenishment. The full route is the concatenation of all route steps for each consecutive zone. Hierarchical rules Since zones are hierarchical, for any given zone there might be multiple rules, coming from different levels of the hierarchy. All rules in the hierarchy are combined when creating the routing. Combining the rules is performed separately for each STEP NO within each zone. To determine the \"winning\" rule for each step, the RULE PRIORITY is used within all rules, which satisfy the RULE CONDITIONS. Start and finish of the process The receive process starts at the inbound dock and is planned through the zones, until there are no more steps. Usually, it finishes at the BULK zone. The dispatch process works in the opposite way - it first determines the quantities needed at the outbound docks, and than determines what previous steps could supply these quantities. The optimization process is a middle ground - it just runs for all zones, for which there is a definition for the optimization process. Movement between the zones When a rule has a MOVE task, it orders movement of the goods to another zone. The algorithm for determining the routing steps is then restarted for this new zone and so on until the goods reach their final destination and state. Rule and task conditions Rule conditions are evaluated when the routing is determined. They can be used to alter the routes based on conditions, which are known by the time the route is created. Rule conditions include such things as product group, zone characteristics, etc. Task conditions are evaluated later in the process and hence allow processing based on what is know in real time during the execution of the order. They are first copied to the warehouse order. Then, upon actual execution of the order, they are evaluated in real time. Task conditions can be based on runtime characteristics like quality inspection status, lot characteristics, etc."
  },
  "modules/logistics/wms/zones-and-locations.html": {
    "href": "modules/logistics/wms/zones-and-locations.html",
    "title": "Warehouse zones and locations | ERP.net Tech Docs",
    "keywords": "Warehouse zones and locations Warehouse zones are used to organize the different storage areas of the warehouse. Zone hierarchy The zones are organized in a hierarchy, where each zone can have sub-zones, which can have its own sub-zones and so on. For example: Picking Aisle P1 Rack P1.1 Shelf P1.1.1 Shelf P1.1.2 Shelf P1.1.3 Aisle P2 Refrigeration Aisle R1 Rack R1.1 Aisle R2 Carts Cart C1 Bulk Rack B1 Rack B2 Primary and sub-zones In the above example, Picking, Refrigeration, Carts and Bulk are primary zones . Aisle M1, Rack M1.1, etc. are called sub-zones . The primary zones have no parent zone. Sub-zones always have a parent zone. Locations The warehouse locations (sometimes called bins) are used for the actual storage of the goods. They are the leafs in the hierarchy and are structured under the warehouse zones. For example: Zone \"Shelf P1.1.3\" can contain 3 locations: P1.1.3-A P1.1.3-B P1.1.3-C"
  },
  "modules/production/index.html": {
    "href": "modules/production/index.html",
    "title": "ERP.net production | ERP.net Tech Docs",
    "keywords": "ERP.net production"
  },
  "modules/projects/index.html": {
    "href": "modules/projects/index.html",
    "title": "ERP.net Project management | ERP.net Tech Docs",
    "keywords": "ERP.net Project management"
  },
  "README.html": {
    "href": "README.html",
    "title": "Welcome to the ERP.net Technical Documentation | ERP.net Tech Docs",
    "keywords": "Welcome to the ERP.net Technical Documentation The documentation uses DocFX to build."
  },
  "reference/config-options-reference.html": {
    "href": "reference/config-options-reference.html",
    "title": "Config options reference | ERP.net Tech Docs",
    "keywords": "Config options reference The current article contains a list of configuration keys and their values: Key - AllowFirmPlannedParentForReleasedChild a.Action: When the key has value and this value is \"1\" the following is allows: released subdocuments of FirmPlanned document are allowed. b.The user sets it manually. Key - CheckForNonVoidedReferencingDocumentsDisabled a.Action: When the key has value and this value is \"1\", verification for references between the documents is not performed when a document is made void. In all other cases, the verification is performed. b.The user sets it manually. Key - CheckForOverexecutionDisabled a.Action: When the key has value and this value is \"1\", verification for over execution of the parent order documents is not performed. In all other cases, the verification is performed. b.The user sets it manually. Key - CheckForOverinvoicedQuantityInSalesOrderLinesDisabled a.Action: When the key has value and this value is \"1\", verification for invoicing greater quantity than the sold quantity is not performed. In all other cases, the verification is performed. b.The user sets it manually. Key - CheckForTransactionMovementTypeDifferentThanParentStoreOrderMovementTypeDisabled a.Action: When the key has value and this value is \"1\", verification that the movement type of the store transaction is the same as the movement type(s) of the parent store order(s) is not performed. In all other cases, the verification is performed. b.The user sets it manually. Key - Default language a.Action: Defines the default language of multi-language fields. For example: en - English, bg - Bulgarian. b.The user sets it manually. Key - Default_Enterprise_Company_Location_Id/XXX a.Action: Defines the default company location. XXX is the ID of the enterprise company. The value is the ID of the default company location. b.Set automatically by the system of the user. Key - Documents/OnlySaveNewVersionsToHistory a. This key is used for compatibility with older versions of the software. The old method of saving a document in the document history is to save the previous version before the current version is saved. The new method is to save the current version. b.Action: When the key has value and this value is \"1\", the new method is applied. In all other cases, the old method is applied. c.The user sets it manually. Key - DontCheckForNegativeUnitPrice a.Action: When the key has value and this value is \"1\", verification for negative values in the Unit Price field is not performed. In all other cases, the verification is performed. b.The user sets it manually. Key - Inv/CheckForNegativeAvailability a.Action: When the key has value \"1\", verification for negative stock balance is performed. The verification checks if the stock balance after the current operation would not become negative and also if the document date is not today's date, the validation checks for not negative stock balance for the dates in the transaction timestamps in the store transaction rows. If the key has an empty value (null) or its value is different than \"1\" the described validations are not performed. b.The user sets it manually. Key - InvoiceFiscalPrintChangeToState (DEPRECATED) a.Action: This key specifies the document state to which an invoice is switched to after the receipt is printed. The key value is the numeric value of the document states (0 = New, 10 = Planned, 20 = FirmPlanned, 30 = Released, 40 = Completed). In all other cases, the invoice is switched to Released state. b.The user sets it manually. Key - InvoiceFiscalPrintUseDistributedAmountsForUnitPrice a.Action: When the key has value and this value is \"1\", the unit price which is sent to the fiscal printer is calculated through the distributed amounts, which are added to the products. In all other cases, the unit price is calculated as follows: the unit price in the document line with VAT included and discounts in the row. b.The user sets it manually. Key - Last_Used_Enterprise_Company_Id a.Action: Defines the last used by the user enterprise company. The value is the id of the enterprise company. b.Set automatically by the system of the user. Key - Last_Used_Enterprise_Company_Location_Id/XXX a.Defines the last used by the user enterprise company location. The value is the id of the enterprise company location. b.Set automatically by the system of the user. Кеу - SalesOrderFiscalPrintChangeToState (DEPRECATED) a.Action: This key specifies the document state to which a sales order is switched to after the receipt is printed. The key value is the numeric value of the document states (0 = New, 10 = Planned, 20 = FirmPlanned, 30 = Released, 40 = Completed). In all other cases, the sales order is switched to Released state. b.The user sets it manually. Key - SalesOrderFiscalPrintUseDistributedAmountsForUnitPrice a.Action: When the key has value and this value is \"1\", the unit price which is sent to the fiscal printer is calculated through the distributed amounts, which are added to the products. In all other cases, the unit price is calculated as follows: the unit price in the sales order line with VAT included and discounts in the row. b.The user sets it manually. Key - SalesOrdersOverduePaymentOrdersCheckDisabled a.Action: When the key has value and this value is \"1\", on sales order document release overdue payment orders check is not performed. In all other cases, such check is performed. b.The user sets it manually. Key - SimpleFilterLayout a.Action: When the value of the key is \"1\", then the \"Use simple layout for filter panels\" option is check-marked and the visualization of the navigator filter panels for the specified user is in the format \"Field OR Value\". If the value of the key is \"0\", then the \"Use simple layout for filter panels\" option is not check-marked and the visualization of the navigator filter panels for the specified user is in the format \"Field: Value\". b.The user sets it manually through File tab → Settings → \"Use simple layout for filter panels\". But if the key is not configured for the particular user, then the system will use the default value. The default value depends on the system version: until Version 2019.1 - the default value is \"0\"; in Version 2019.1 and later - the default value is \"1\" Key - CheckInvoiceLinesQuantityUnitDisabled a.Action: When the key has value and this value is \"1\", when an invoice is released the validation if the measurement unit of the invoice line and the invoiced sales order line are the same is not performed. b.The user sets it manually. Key - AllowBaseAmountsFromThirdDocument a.Action: The action of the current key impacts how the additional amounts are distributed. If amount S and B are distributed on document D1 and amount S depends on amount B. When the current key has value and this value is \"1\" the calculation of the additional amounts is performed as follows: - Each B amount which is distributed on the rows of document D1 participates in the calculation of the base amount of amount S no matter which document defines the B amount. When the current key has a value different from \"1\" or the key does not exist: - Amount B participate in the base amount of S amount only if the B amount is defined by the same document as S amount in the referent document of S amount. The preferred document of S amount is the document on which rows S amount is distributed. b.The user sets it manually. Key - CreateReconciliationsByTimestamp a.Action: When this key has value and this value is \"1\", the function \"Add the available products\" in the reconciliation form and the manually added new rows would use the date of the transaction timestamp in the row, and not the date of the document, to calculate the stocks availability. The stocks availability may be looked at by one of the following methods: - Stock movements in the store by the document date; - Stock movements in the store by the date of the transaction timestamp. b.Usually, the \"i\" method is used to define stock availability (i.e. the quantities at a specified date), and method \"ii\" is used to define the stocks cost (at a specified time) c.The user sets it manually. Key - CostCorrectionsCalculateCostTransferDocumentsCostByDocumentCurrencyReevaluation a.Action: the current key regulates the recalculation of the products costs by the documents which transfer costs (store transfers, work orders, sales returns). When the key has value and this value is \"1\", the recalculation is performed as follows: all costs of the issue and receipt store documents are converted to the currency of the master document (the document which transfers the cost). If not, usually the base currency of the issue and receipt store documents is used for the recalculation. b.The user sets it manually. Key - ActiveLanguages a.Action: Displays the languages which are active in the current database. If there is no value, all languages are active (currently 15 languages are supported). b.Automatically by the form for editing the languages list, which opens from the Edit Languages menu. Key - CheckForTransactionInvalidLotDisabled a.Action: When this key has value and this value is \"1\", the validation for an invalid lot in the store transaction on document release is not performed. An invalid lot is a lot that is defined for a product, different than the product in the store transaction line. In all other cases, the validation is performed. b.The user sets it manually Key - VisualPasteDisabled - suspended a.Action: When this key has value and this value is \"1\", when rows are pasted in a grid they are pasted all at the same time (as it was in version 2.3). In all other cases when rows are pasted in a grid, they are pasted visually - row by row and field by field. Every value is searched between allowed values in drop-down lists. b.The user sets it manually Note This key is suspended in version 2019.1. In its place there are two new functions in forms and navigators: - Paste Rows - Paste Rows Without On-Screen Validation Key - RealTimeEventsDisabled a.When this key has value and this value is \"1\", ERP.net would not proceed connection with the server which sends real-time events. b.The user sets it manually Key - RealTimeEventsTimeoutSeconds a.Action: Sets the timeout period for waiting for a server response for real-time events, in seconds. If the server does not raise an event in the specified time, the client sends a new request. The value is a number between 5 and 240. If null, the timeout time is 240 seconds (4 minutes). b.The user sets it manually Key - Require strong passwords a.Action: When this key has value and this value is \"1\", strong password validation is performed. Strong password requirements are as follows: the password is at least 8 characters; the password contains characters from 3 out of 4 groups: small letters, capital letters, Nonalphanumeric characters, numbers; the password does not contain the username; the password does not contain \"123\", \"1234\", \"12345\", \"123456\". b.The user sets it manually Key - DisableAccountKeyPropertyDotCheck a.Action: When this key has value and this value is \"1\", when an item key is formed in the accounting voucher rows the validation for no '.' (dot) in the values of the key custom, properties are not performed. For the normal working process of the system, it is important no dots to be part of the values of the key custom properties because the dot is a system character used for item key compilation. b.The user sets it manually Key - AllowPlannedDocumentStateInClient a.Action: When this key has value and this value is \"1\", the document state menu would contain Planned state. In all other cases, the user would not be able to select the Planned state on any document. b.The user sets it manually Key - DisableProductCopyPropertiesFromOtherProduct a.Action: When this key has value and this value is \"1\", the Product configurator feature for copying the values to custom properties from the custom property which values are products is deactivated. b.The user sets it manually Key - PaymentTransactionFiscalPrintChangeToState (DEPRECATED) a.This key specifies the document state to which a payment transaction is switched to after the receipt is printed. The key value is the numeric value of the document states (0 = New, 10 = Planned, 20 = FirmPlanned, 30 = Released, 40 = Completed). In all other cases, the payment transaction is switched to Released state. b.The user sets it manually. Key - Crm/Sales/SalesOrders/ShowFillLotsInLines a.Action: When this key has value and this value is \"1\", the sales order function \"Fill lots in lines\" is activated. b.The user sets it manually. Key - General/Contacts/LoadCalendarForLimitedTime a.Action: When this key has value and this value is \"1\", the calendar in the Activities navigator loads data only for the displayed period (+/- 1 month) when the user scrolls through the calendar. b.The user sets it manually. Key - DisableDocumentRecalculationOnIdle a.Action: When this key has value and this value is \"1\", in the document forms the recalculation of additional amounts, bonus programs, payment plans and etc in real-time would not be performed (Application.Idle event). In such cases, the document would be recalculated only before the COMMIT event and not in real-time while the user enters the b.data in the document form. The method referred by the current key is \"Document.Recalculate\" which performs different actions in the different entities. c.The user sets it manually. Key - DisableParentDocumentReset a.Action: When this key has value and this value is \"1\", on document state change the parent document state is not reset. b.The user sets it manually. Key - RevokedBusinessRules a.Action: When this key has value, the validation and the action of the business rules, which codes are specified as a key value, is not performed. The codes of the business rules must be listed comma-separated (for example 27407, 26881 ..). Since version 2018.2, business rules' codes must be set with their full code including \"R\" (eg R27408, R26881 ...). If the key value is changed, the client application requires a restart. b.The user sets it manually. Key - DisableQueryingForSaveOnClose a.Action: When this key has value and this value is \"1\", on closing of a form which is not saved, if there is a change in any table of the form, no information message for saving or undo of the changes appears. b.The user sets it manually. Key - UseLegacyLoadForLotsIssue a.Action: When this key has value and this value is \"1\", for the calculation of the quantity \"Available to promise by lots\" is used the method that was developed before Version 2018.2. In all other cases, is used the current for Version 2018.2 method which is advisable and has a better performance. b.The user sets it manually. Key - ReservedLicenses (not implemented/ cancelled) Key - EnableCreateGroupForUser a.Action: When this key has value and this value is \"1\" or \"true\" (case-insensitive), when creating a new user into the database a new group with the user’s name will be created automatically as well. b.The user sets it manually. c.The key is introduced in version: - 2019.1 (in implementation) Note Before version 2019.1 a new user group was created automatically every time when a new user is created and this behaviour could not be disabled. Since version 2019.1 the behaviour is disabled by default and could be activated manually using the current registry key. Key - DocumentVersioningSystem a.Action: When the value of this key is \"VH\" the system will use the \"old\" document versioning system. If the key's value is \"TC\" the system will not create records using the \"old\" document versioning system and will instead use the Track changes system. The minimum level that is going to be tracked when the \"TC\" option is activated is \"Track Changes Level 3\". If for the particular document entity is chosen a specific level, then this level will be applied only if it is a higher level than level 3. (For more information about the track changes system and its levels, please see topic Track changes Note Please note that the current key affects only entities which are a successor of document entity (such as sales orders, store orders ...) and NOT entities such as product groups, bonus programs.. b.The user sets it manually, but if the key is not configured for the particular database or its value is different from \"VH\" or \"TC\", then the system will use the default value. The default value depends on the system version: Version 2019.1 - the default value is \"VH\"; Version 2020.1 and later - the default value is \"TC\"; c.The key is introduced in version: - 2019.1 Key - Crm/Pos/PrintGroupedSalesLinesType a.Action: When the value of this key is \"ShortName\" then items in the fiscal receipt are grouped by \"ShortName\" field in the product. When the value of this key is \"ProductGroup\" then items in the fiscal receipt are grouped by the product group of the product. When the value of this key is different or the key is missing then items in the fiscal receipt are not grouped. b.The key is introduced in version: - 2019.1 Key - UseStartScreen a.Action: When the value of this key is: \"1\" - the form that is going to be opened when the program is started by the specified user will be the Start screen. \"2\" - the starting form will be the Main menu. \"0\", different from \"1\" and \"2\" or the key is not configured for the particular database and user - the system will use the default value. The default value for version 2020.1 is Main Menu. Warning: The current key's value will be taken into account only if there is no global policy specifying the use of the start screen for the whole database using the key \"UseStartScreenPolicy\" b.The user sets it manually. c. The key is introduced in version: - 2020.1 Key - UseStartScreenPolicy a.Action: When the value of this key is: \"1\" - the form that is going to be opened when the program is started will be the Start screen. This applies to all users into the database, regardless of the \"UseStartScreen\" option. \"2\" - the starting form will be the Main menu. This applies to all users into the database, regardless of the \"UseStartScreen\" option/key. \"0\", different from \"1\" and \"2\" or the key is not configured for the particular database - there is no global policy. Each user decides whether they want to use the start screen using \"UseStartScreen\" option/key. b.The user sets it manually. c.The key is introduced in version: - 2020.1 Key UseDefaultMailClient a.Action: When this key has a value for the particular user and this value is \"1\", then when creating an email the system will start the default Windows mail client. This will apply even if there is a mailbox defined for the user. b. The user sets it manually (directly in the registry or using the option available in tab File => Settings => Use default Windows mail client). c.The key is introduced in version: - 2019.1"
  },
  "reference/conversion-validation-methods.html": {
    "href": "reference/conversion-validation-methods.html",
    "title": "Conversion validation methods | ERP.net Tech Docs",
    "keywords": "Conversion validation methods Conversion ratio providers like currency directories and products have methods IsConvertible and IsConvertibleToBase . They are used by the system in order to determine whether the input unit is valid and could be converted during the calculations. IsConvertibleToBase checks if using a specified provider object one measurement unit or one currency unit can be converted to the base unit of the provider. If the provider is null, the unit cannot be converted to base and the method returns as false. When the provider is a currency directory, the method uses the GetRatioToBaseOrDefault method for currency directories, which finds a ratio if one of the following requirements is fulfilled: the currency directory’s ToCurrency is the same as the selected currency the currency directory has lines where FromCurrency is the same as the selected currency When the provider is a product, the method uses the GetRatioToBaseOrDefault method for products, which finds a ratio if one of the following requirements is fulfilled: the selected measurement unit is part of the product's base measurement category; the product has defined dimension for the selected measurement unit; the selected measurement unit is part of a measurement category for which the product has defined dimension. IsConvertible checks if using a specified provider object one measurement unit or one currency can be converted to another of the same type. If the provider is null, the units cannot be converted and the method returns false. The method is based on the GetRatioThroughBaseOrDefault method. If the units are equal or both of them are null, the method returns true. If only one of them is null, the method returns false. If the units are different and not null, the method uses GetRatioToBaseOrDefault for each to get the ratios for conversion to the base unit of the provider. Then, both ratios are combined in a new one. If such a combined ratio is calculated successfully, the method returns true."
  },
  "reference/country-specific-functionality.html": {
    "href": "reference/country-specific-functionality.html",
    "title": "Country specific functionality | ERP.net Tech Docs",
    "keywords": "Country specific functionality ERP.net contains some country, region, or other specific functionalities that are needed in order to meet legal or regulatory requirements. Such functionality is the creation of VAT returns and the VAT export files for submission to the National Revenue Agency (Bulgaria), for example. Party applicable legislations In parties, there is a child table with the applicable legislations for the particular party. The table contains information about the countries, states, unions, or other entities whose regulations apply to the party. The records in this table are used when determining if a business rule must be activated when, for example, it incorporates rules that are specific for the particular country's laws. Bulgaria (BG) List of the system deal types and their correlation with the sales and purchases ledger's columns The VAT declaration in ERP.net is a document that serves as a basis for the creation of a VAT return and the VAT export files for submission to the National Revenue Agency. The information in the VAT declaration is based on the VAT entries created in the system for the particular period. The entries amounts (Amount base and VAT amount base) are entered in different columns of the sales and purchases ledger of the VAT declaration depending on their deal type (for more information about entries' deal type and amount calculation, see Defining VAT and base for VAT Entries ). This article contains information about the correlation between the system deal types and the columns of the sales and purchases ledgers according to which the entries amounts are distributed to those columns. Sales ledger Column Column name (EN) Column name (BG) Deal type (BG) Additional Conditions Column9_Data Total Base Amount Общ размер на данъчните основи ВОД - Column9_Data Total Base Amount Общ размер на данъчните основи Доставка по чл. 163а от ЗДДС част I (отпадъци) на Приложение 2 - Column9_Data Total Base Amount Общ размер на данъчните основи Доставка по чл. 163а от ЗДДС част II (земеделска продукция) на Приложение 2 - Column9_Data Total Base Amount Общ размер на данъчните основи Доставка по чл.140,146,173(1) или 173(4) - Column9_Data Total Base Amount Общ размер на данъчните основи Износ по глава трета от ЗДДС - Column9_Data Total Base Amount Общ размер на данъчните основи Начисляване на ДДС в др. случаи Apply_Date >= '20160201' Column9_Data Total Base Amount Общ размер на данъчните основи Облагаеми доставки 7/9% - Column9_Data Total Base Amount Общ размер на данъчните основи Облагаеми сделки - Column9_Data Total Base Amount Общ размер на данъчните основи Самоначисляване на ДДС по чл.82,ал.2-5 - Column9_Data Total Base Amount Общ размер на данъчните основи Самоначисляване на ДДС при ВОП - Column10_Data Total VAT Amount Всичко начислен ДДС Начислен ДДС при ползване за лични нужди Apply_Date >= '20160201' Column10_Data Total VAT Amount Всичко начислен ДДС Начисляване на ДДС в др. случаи - Column10_Data Total VAT Amount Всичко начислен ДДС Облагаеми доставки 7/9% - Column10_Data Total VAT Amount Всичко начислен ДДС Облагаеми сделки - Column10_Data Total VAT Amount Всичко начислен ДДС Самоначисляване на ДДС по чл.82,ал.2-5 - Column10_Data Total VAT Amount Всичко начислен ДДС Самоначисляване на ДДС при ВОП - Column11_Data Base Amount 20 Percent Данъчна основа 20% Доставка по чл. 163а от ЗДДС част I (отпадъци) на Приложение 2 - Column11_Data Base Amount 20 Percent Данъчна основа 20% Доставка по чл. 163а от ЗДДС част II (земеделска продукция) на Приложение 2 - Column11_Data Base Amount 20 Percent Данъчна основа 20% Начисляване на ДДС в др. случаи Apply_Date >= '20160201' Column11_Data Base Amount 20 Percent Данъчна основа 20% Облагаеми сделки - Column12_Data VAT Amount 20 Percent Начислен ДДС 20% Начисляване на ДДС в др. случаи Apply_Date >= '20160201' Column12_Data VAT Amount 20 Percent Начислен ДДС 20% Облагаеми сделки - Column13_Data Base Amount EUPurchase Данъчна основа на ВОП Самоначисляване на ДДС при ВОП - Column14_Data Base Amount VATL Article 82 Данъчна основа на доставките по чл.82, ал. 2 - 5 Самоначисляване на ДДС по чл.82,ал.2-5 - Column15_Data VAT Amount EUPurchase VATL Article 82 Начислен ДДС за ВОП и доставките по чл.82, ал. 2 - 5 Самоначисляване на ДДС по чл.82,ал.2-5 - Column15_Data VAT Amount EUPurchase VATL Article 83 Начислен ДДС за ВОП и доставките по чл.82, ал. 2 - 5 Самоначисляване на ДДС при ВОП - Column16_Data VAT amout in case of personal use Начислен данък при ползване за лични нужди Начислен ДДС при ползване за лични нужди Apply_Date >= '20160201' Column16_Data VAT amout in case of personal use Начислен данък при ползване за лични нужди Начисляване на ДДС в др. случаи Apply_Date < '20160201' Column17_Data Base Amount 9 % Данъчна основа 9 % Облагаеми доставки 7/9% - Column18_Data VAT Amount 9 % Начислен ДДС 9 % Облагаеми доставки 7/9% - Column19_Data Base Amount 0 Percent VATL Chapter 3 Данъчна основа 0 % по глава трета от ЗДДС Износ по глава трета от ЗДДС - Column20_Data Base Amount 0 Percent EUSale Данъчна основа 0 % на ВОД ВОД - Column21_Data Base Amount 0 Percent VATL Articles 140 146 173 Данъчна основа 0 % по чл. 140, чл. 146 ал. 1 и чл. 173, ал. 1 и 4 Доставка по чл.140,146,173(1) или 173(4) - Column22_Data Base Amount Service Sales VATL Article 21 Данъчна основа на услугите по чл. 21, ал. 2 Доставка по чл.21(2) в друга държава членка - Column23_Data Base Amount VATL Article 69 Данъчна основа почл. 69, ал. 2 Доставка по чл.69(2) и дистанц. продажба към др.членка - Column24_Data Base Amount Exempted Sales And EUPurchases Данъчна основа на освободени доставки и ВОП Освб. дост. по чл. 21(2), в рамките на ЕС - Column24_Data Base Amount Exempted Sales And EUPurchases Данъчна основа на освободени доставки и ВОП Освободени ВОД, извън територията на България - Column24_Data Base Amount Exempted Sales And EUPurchases Данъчна основа на освободени доставки и ВОП Освободени доставки и освободени ВОП - Column25_Data Base Amount Third Party Operation Данъчна основа от посредник в тристранна операция Доставки като посредник при тристранна операция - Column25_Data Base Amount Third Party Operation Данъчна основа от посредник в тристранна операция Доставки като посредник при тристранна операция (авансови плащания) - Purchases ledger Column Column name (EN) Column name (BG) Deal type (BG) Additional conditions Column9_Data Base Amount Without Tax Credit Данъчна основа без право на данъчен кредит Сделки, внос и ВОП без право на данъчен кредит - Column10_Data Base Amount With Full Tax Credit Данъчна основа с право на пълен данъчен кредит Сделки, внос и ВОП с право на пълен данъчен кредит - Column11_Data VAT Amount With Full Tax Credit ДДС с право на пълен данъчен кредит Сделки, внос и ВОП с право на пълен данъчен кредит - Column12_Data Base Amount With Partial Tax Credit Данъчна основа с право на частичен данъчен кредит Сделки, внос и ВОП с право на частичен данъчен кредит - Column13_Data VAT Amount With Partial Tax Credit ДДС с право на частичен данъчен кредит Сделки, внос и ВОП с право на частичен данъчен кредит - Column14_Data Annual Correction Годишна корекция Годишна корекция - Column15_Data Base Amount Third Party Operation Данъчна основа от посредник в тристранна операция Придобиване от посредник в тристранна операция -"
  },
  "reference/format-specifiers.html": {
    "href": "reference/format-specifiers.html",
    "title": "Format specifiers | ERP.net Tech Docs",
    "keywords": "Format specifiers Format specifiers are used to state the desired format when formatting object values. In ERP.net they can be used, for example, as a second parameter for the calculated attribute operator FORMATSTRING or in the formatting string (‘:FormatSpecifier’) when referencing domain attributes in the SENDMAIL action (‘{DomainAttribute:FormatSpecifier}’). There are two main types of format specifiers - standard .Net format specifiers (Numeric, Date - Time,..) and custom format specifiers (Multilanguge string, Custom property). Standard .Net format specifiers The standard .Net format specifiers are supported. The list below contains the most frequently used .Net format specifiers. For a complete list and more information, please look at the official .Net documentation site. Numeric format specifiers 'C', 'c' - abbreviation of Currency. Converts a number to a string that represents a currency amount. Can be used with a precision specifier that indicates the desired number of digits after the decimal point. The decimal symbol separator and the currency symbol depend on the local regional settings. Returns: 123.4656 ('C') → $123.46 123.4656 ('C3') → $123.466 'D', 'd' -abbreviation of Decimal. Converts a number to a string of decimal digits (0-9), prefixed by a minus sign if the number is negative. Can be used with a precision specifier that indicates the desired number of digits after the decimal point. This format is supported only for integral types. Returns:1234 ('D') → 1234 -1234 ('D6') → -001234 'N', 'n' - abbreviation of Number. Converts a number to a string. Can be used with a precision specifier that indicates the desired number of digits after the decimal point. The decimal symbol separator depends on the local regional settings. Returns 123.4656 (N) → 123.47 123.4656 (N3) → 123.466 'P', 'p' - abbreviation of Percent. Multiplies a number by 100 and converts it to a string that represents a percentage. The precision specifier indicates the desired number of decimal places. The decimal symbol separator depends on the local regional settings. Returns 0.488869 (P) → 48.89% 0.488869 (P3) → 48.887% Date and time format strings Standard date and time format specifiers can be used alone (standard date and time format string) or in a combination (custom format string) in order to define the text representation of a date and time value. A standard date and time format string uses a single format specifier to define the text representation of a date and time value. Any date and time format string that contains more than one character, including white space, is interpreted as a custom date and time format string. Standard date and time format strings: 'D', 'd' - Short date pattern. The returned format depends on the pattern set for Short date in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10.5.2019 'D' - Long date pattern. The returned format depends on the pattern set for Long date in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 'f' - Full date/time pattern (short time). The returned format depends on the pattern set for Long date and Short time in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 5:18 'F' - Full date/time pattern (long time).. The returned format depends on the pattern set for Long date and Short time in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 5:18:39 'M', 'm' - Month/day pattern. The returned format depends on the current culture set in the local regional settings. Returns: 2019-05-10 15:18:39.013 → May 10 'u' - Universal sortable date/time pattern. Returns: 2019-05-10 15:18:39.013 → 2019-05-10 15:18:39Z 'U' - Universal full date/time pattern. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 5:18:39 Custom format strings: 'd' - The day of the month, from 1 through 31. 'M' - The month, from 1 through 12. 'y' - The year, from 0 to 99. 'h' - The hour, using a 12-hour clock from 1 to 12. 'H' - The hour, using a 24-hour clock from 00 to 23. 'm' - The minute, from 0 through 59. 's' - The second, from 0 through 59. 'f' - The tenths of a second in a date and time value. '%' - Defines the following character as a custom '/' - Тhe current's culture date seperator. '' - The escape character. 'string', 'string' - Literal string delimiter. Examples: 2019-05-10 15:18:39.013 ('dd MM yyyy hh:mm:ss.fff')→ 10 05 2019 03:18:39.013 2019-05-10 15:18:39.013 ('yyyy MM dd hh:mm:ss.fff')→ 2019 05 10 03:18:39.013 2019-05-10 15:18:39.013 ('dd M yyyy hh:mm:ss.fff')→ 10 5 2019 03:18 2019-05-10 15:18:39.013 ('dd MMM yyyy hh:mm')→ 10 May 2019 03:18 2019-05-10 15:18:39.013 ('dd/MM/yyyy hh:mm')→ 10.05.2019 03:18 2019-05-10 15:18:39.013 ('dd/MM/yyyy hh:mm')→ 10/05/2019 03:18 2019-05-10 15:18:39.013 (dd-MM-yyyy hh:mm)→ 10-05-2019 03:18 2019-05-10 15:18:39.013 ('dd MM yyyy hh:mm 'h'')→ 10 05 2019 03:18 h Custom format specifiers There are also custom format specifiers that are created especially for ERP.net. They are different for the different data types and are described below. Multilanguge string 'C', 'CURRENT' - returns the string of the current value. 'D', 'DUMP' - returns the content of the multilanguage string in the format: EN= DE= 'T', 'TRANSLITERATED' - returns transliteration to the current language. format specifiers for a particular language - returns the translation of the specified language. If there is no transliteration set for this language, returns an empty string. Note: The format specifiers for a particular language are supported since EnterpriseOne version 2019.1. Language format specifiers: -'EN' - English 'BG' - Bulgarian 'CS' - Czech 'FR' - French 'DE' - German 'EL' - Greek 'HU' - Hungarian 'IT' - Italian 'MK' - Macedonian 'PL' - Polish 'PT' - Portuguese 'RO' - Romanian 'RU' - Russian 'SR' - Serbian 'ES' - Spanish Custom property 'VD' - abbreviation of Value/Description, returns: : 'V' - abbreviation of Value, returns: 'VDI' - abbreviation of Value/Description/Id, returns: : ( ) 'D' - abbreviation of Description, returns:"
  },
  "reference/forms-with-activated-domain-front-end-logic.html": {
    "href": "reference/forms-with-activated-domain-front-end-logic.html",
    "title": "Forms with activated domain front-end logic | ERP.net Tech Docs",
    "keywords": "Forms with activated domain front-end logic When a domain front-end logic is activated for a particular form, this means that it is activated for all referent panels in this form which are a part of the aggregate . E.i. if it is activated for the sales ordes form - it is also activated for panels such as Sales orders lines and Payment plan which are a part of the sales order's aggregate, but not for panels such as Document amounts which are a part of the document's aggregate. Module Form Activated BindDomainLogic Version Sales module Customer Types YES 20.1 CustomerCompanyLocations YES 20.1 Customers YES 20.1 Customers - Companies YES 20.1 Customers - Persons YES 20.1 Dealers YES 20.1 Dealers - Companies YES 20.1 Dealers - Persons YES 20.1 Offers YES 2017.1 Price Lists YES 20.1 Price Types YES 20.1 Sales Orders YES 2017.1 Sales Persons YES 20.1 Deals YES 21.1 Line Discounts YES 21.1 Product Prices YES 21.1 Promotional Packages YES 21.1 POS module POS Devices YES 20.1 POS Locations YES 20.1 POS Operators YES 20.1 POS Roles YES 20.1 POS Work Terminals YES 20.1 Product Types - Tax Groups YES 20.1 Invoicing module Invoice Orders YES 20.1 Invoices YES 20.1 Products module Coding Systems YES 20.1 Measurement Categories YES 20.1 Measurement Units YES 20.1 Product - Pictures YES 20.1 Product Groups YES 20.1 Product Types YES 20.1 Products YES 20.1 Products - Codes YES 20.1 Products - Dimensions YES 20.1 Products - Distribution channels YES 20.1 Products - Variants YES 2017.1 Product variants - Colors YES 21.1 Product variants - Sizes YES 21.1 Product variants - Styles YES 21.1 Configurator module Product Groups YES 20.1 Products YES 20.1 Product - Custom Properties NO - Product group - Required properties NO - Contacts & Tasks module Activities YES 20.1 ActivityParticipants YES 21.1 Areas YES 20.1 Call detail YES 20.1 Companies YES 20.1 Companies - Departments YES 20.1 Company EU configurator YES 20.1 Contact Mechanisms YES 20.1 Party - Pictures YES 20.1 Party Relationship Types YES 20.1 Party Relationships YES 20.1 Reminders YES 20.1 Resources YES 21.1 Resources - Availability YES 20.1 Resources - Resource instances YES 20.1 Resource Groups YES 21.1 Activities - Time intervals NO -- Companies - Divisions NO - Companies - Employees NO - Companies - Locations NO - Parties NO - Persons NO - Marketing module Bonus Programs YES 20.1 Campaingns YES 20.1 Distribution Channels YES 20.1 Forecast Items YES 20.1 Marketing Activities YES 20.1 Product Catalogs YES 20.1 Target Groups YES 20.1 Distribution module Customers - Products YES 20.1 Sales Person Groups YES 20.1 Sales Person Targets YES 21.1 Sales Persons NO - Pricing module Pricing Models YES 20.1 Products YES 20.1 Types NO - Shipment module Shipment Orders YES 20.1 Shipments YES 20.1 Inventory Management module Lots YES 20.1 Products - Default Store Bins YES 20.1 Products - Valuation Groups YES 20.1 Scrap Types YES 20.1 Serial Numbers YES 20.1 Store Bins YES 20.1 Store Groups YES 20.1 Store Orders YES 20.1 Stores YES 20.1 Transactions YES 20.1 Cost Corrections YES 21.1 Reconciliations NO - Transfer Orders NO - Logistics Planning module Product Supply YES 21.1 Procurement module Receiving Orders YES 20.1 Suppliers YES 20.1 Suppliers - Companies YES 20.1 Suppliers - Persons YES 20.1 Purchase Control Documents YES 21.1 Purchase Operation Types YES 21.1 Purchase Orders NO - Purchase Price Lists YES 21.1 Purchase Product Prices YES 21.1 Requisitions NO - Supplier Types YES 21.1 Products and Technologies module Products YES 20.1 Principal Recipies YES 21.1 Recipies YES 2015 Production Planning module Product Supply NO - Resources module Function Groups YES 21.1 Functions YES 21.1 Operation Groups YES 21.1 Operations YES 21.1 Resource Groups YES 21.1 Resources YES 21.1 Workgroups YES 21.1 Workgroups - Resources YES 21.1 Work Schedules YES 21.1 Shop Floor module Consumption Orders NO - Output Orders YES 21.1 Work Orders YES 21.1 Projects Management module Project Tasks NO - Projects NO - Projects - Risks YES 21.1 Projects Budgeting module Resources YES 21.1 Resource Groups YES 21.1 Gen_Resources - Resource Instances YES 20.1 Resources - Availability YES 20.1 Product Variants YES 21.1 Projects Executuion module Work Reports YES 21.1 Projects Setup module Project Types YES 21.1 Project Types - Participants Roles YES 21.1 Project Types - Work Elements YES 21.1 Project Types - Work Types YES 21.1 Task Types YES 21.1 Payments module Bulk Payment Orders YES 20.1 Parties - Bank Accounts YES 20.1 Payment Accounts YES 20.1 Payment Orders YES 20.1 Payment Reasons YES 20.1 Payment Slips YES 20.1 Payment Transfers YES 20.1 Payment Types YES 20.1 Payment Transactions NO - Expenses module Supliers YES 20.1 Supliers - Companies YES 20.1 Supliers - Persons YES 20.1 Purchase Invoice NO - Accounting module Account Groups NO - Accounts NO - Cost Centers NO - Operations NO - Profit Centers NO - Templates NO - Vouchers NO - Cost Accounting module Cost Distributions NO - Cost Types NO - Financial Statements NO - Finanse Analisys Module NO - VAT module Deal Types YES 21.1 Declaring Person NO - Document Type VAT Codes NO - Entries NO - VAT Declarations NO - Intrastat module Intrastat Declarations YES 21.1 Fixed Assets module Acquire and Retire Orders YES 21.1 Asset Categories YES 21.1 Asset Groups YES 21.1 Asset Transactions YES 21.1 Assets YES 21.1 Depreciation Methods YES 21.1 Depreciation Plans YES 21.1 Depreciations YES 21.1 Valuation Methods YES 21.1 Lease-Out Management module Asset Groups YES 21.1 Asset Types - Consumables YES 21.1 Asset Types - Properties YES 21.1 Assets NO - Assets - Consumables YES 21.1 Assets Types YES 21.1 Service module Service Activities YES 21.1- Service Agreements YES 21.1 Service Object Types YES 21.1 Service Objects YES 21.1 Service Orders YES 21.1 Service Types YES 21.1 Services YES 21.1 Services - Ivoicing YES 21.1 Vehicles module Crews YES 21.1 Equipment Types YES 21.1 Map Points YES 21.1 Trips YES 21.1 Vehicle Equipment YES 21.1 Vehicle Sets YES 21.1 Vehicles YES 21.1 Mail module Mail Messages NO - Mailboxes NO -- Data Warehouse module Data Measures NO - Data Measures Groups NO - Data Values NO - Personal Data (GDPR) module Personal Data Management Processes YES 21.1 Processing Consents YES 21.1 Rights Requests YES 21.1 Asset Maintanance module Maintenance Orders YES 21.1 Maintenance Types Groups YES 21.1 Maintenance Types YES 21.1 Managed Asset Groups YES 21.1 Managed Asset Types YES 21.1 Managed Assets YES 21.1 Service Centers YES 21.1 Tracked Parameters YES 21.1 General Administrative Regions YES 21.1 Countries YES 21.1 Currencies YES 21.1 Currency Directories NO - Custom Properties YES 21.1 Custom Properties Categories YES 21.1 Enterprise Companies NO - Communities Notification Settings YES 21.1 Notifications YES 21.1 Document Model Document Amount Types YES 21.1 Document Types - Amounts NO - Document Types YES 21.1 Document Types - Security Conditions NO - Printouts NO - Printouts - Layouts NO - Processes NO - Routes NO - Sales Orders - Default Payment Plans YES 21.1 Sequence Generators NO - Sequences NO - Business Rules Calculated Attributes YES 2018.1 User Business Rules YES 2018.1 Business Processes Business Processes YES 21.1 Process Connections NO - Process Elements NO - Process Groups YES 21.1 Process Instance YES 21.1 Process Lanes YES 21.1 Security Access Keys NO - Audit Log Entries YES 21.1 Column Permissions YES 21.1 Domains NO - Entities NO - Groups NO - Roles NO - Roles - Users NO - Trusted Applications NO - User Groups NO - Users NO - Tools Data Sources NO - Document Jobs NO - External Applications NO - Jobs NO - Reports NO - Translations YES 21.1 Web Hosts NO - Web Sites NO -"
  },
  "reference/glossary/entities-validation/code-validation-strict.html": {
    "href": "reference/glossary/entities-validation/code-validation-strict.html",
    "title": "Code validation (strict) | ERP.net Tech Docs",
    "keywords": "Code validation (strict) This code validation is stricter than the standard code validation . Discussion The primary reasons for creating codes are: Short visual identification of an entity. The code does not need to fully describe the entity just to uniquely identify it. Easily type the code in dropdown search fields. When needed, easily write down the code. Sort (order) the entities by different criteria. Allowed characters Under strict code validation, the code can only contain (in order of suggested usage): Digits Minus (-) Uppercase letters (the English alphabet only) Plus (+) The following symbols are NOT allowed: Space ( ) Dot (.) Forward slash (/) Backslash () Lowercase letters The reasons for strict limiting of the code symbols are concatenation, parsing and processing of codes with more freedom. Length The default maximum length for code attributes is 16 characters . It is still recommended that codes be 5 characters or less. Suggestions When creating codes, there are some general rules: Usage of digits is highly suggested. Digits (and the minus sign) are universal and language-agnostic. They can be typed on any keyboard without switching language settings. They are also easier to memorize. It is better to create short, consecutive code than a long, meaningful code (usually with several parts). Usage of letters is generally not advised. When letters are used, use uppercase English letters. Keep codes short. Preferably 5 characters maximum. Note The human eye can immediately read codes up to 5 chars in length (78542). Longer codes take more time (784521). For a small (less than 20) number of items, meaningful, letter-only codes might be adequate. For example \"ABC\", \"LIB\", etc. When creation of meaningful codes is unavoidable: a. You can still use digits and keep the code type-able on a numeric keypad. b. Separate the parts with a minus sign c. Keep the length of each part less than 5 chars. d. Keep the total length to minimum. For example: \"01-1234\"."
  },
  "reference/glossary/entities-validation/identifier-validation.html": {
    "href": "reference/glossary/entities-validation/identifier-validation.html",
    "title": "Identifier validation | ERP.net Tech Docs",
    "keywords": "Identifier validation The rules for naming an identifier are: An identifier cannot be a keyword. An identifier must begin with a letter or an underscore. The remaining part can contain letters, digits, and underscore symbols. Whitespaces and symbols other than letter, digit and underscore are not allowed. @ is not allowed to be used as a prefix. Identifiers are case-sensitive . That's why getName, GetName and getname represent 3 different identifiers. These are valid identifiers: number; doCalculation; identifier1; hello world; These are invalid identifiers: hello# - contains symbol other than letter, digit or underscore; int - this is a keyword hello world - contains whitespace 1HelloWorld @hello"
  },
  "reference/glossary/entities-validation/index.html": {
    "href": "reference/glossary/entities-validation/index.html",
    "title": "Entities validations | ERP.net Tech Docs",
    "keywords": "Entities validations Identifier validation Username validation Code validation (strict)"
  },
  "reference/glossary/entities-validation/username-validation.html": {
    "href": "reference/glossary/entities-validation/username-validation.html",
    "title": "Username validation | ERP.net Tech Docs",
    "keywords": "Username validation The rules for naming a user are: Usernames can contain both lowercase and uppercase characters. Usernames can contain alphanumeric characters. Usernames can contain underscore and hyphens. They cannot contain spaces. They cannot contain two underscores, two hyphens or two spaces in a row. They cannot contain an underscore, hyphen or space at the start or the end. These are valid usernames: username userName user.name username4 user_name user-name These are invalid usernames: username (there is space in the beginning) _username -username user__name user name user–name username_ username (there is space in the end) username- user name"
  },
  "reference/glossary/index.html": {
    "href": "reference/glossary/index.html",
    "title": "| ERP.net Tech Docs",
    "keywords": ""
  },
  "reference/index.html": {
    "href": "reference/index.html",
    "title": "Reference section | ERP.net Tech Docs",
    "keywords": "Reference section This section contains topics, which contain reference data. Select a topic from the menu to view reference data."
  },
  "reference/module-codes.html": {
    "href": "reference/module-codes.html",
    "title": "Module codes | ERP.net Tech Docs",
    "keywords": "Module codes This topic contains an up-to-date list of ERP.net modules. Generic access licenses CAL01 - Concurrent client access license ED01 - Edition - Mini ED02 - Edition - Small business ED03 - Edition - Standard ED04 - Edition - Corporate Applications APP01 - Applications - Project management APP02 - Applications - Lease-out management APP03 - Applications - Vehicle management APP04 - Applications - Mail APP05 - Applications - Personal data management APP06 - Applications - Data warehouse APP07 - Applications - Enterprise asset management APP08 - Applications - ERP.net POS CRM CRM01 - Clients - Sales CRM02 - Clients - Invoices CRM03 - Clients - Products CRM04 - Clients - Product configuration CRM05 - Clients - Contacts and tasks CRM06 - Clients - Marketing CRM07 - Clients - Service CRM08 - Clients - Distribution CRM09 - Clients - Unified communications CRM10 - Clients - Pricing CRM11 - Clients - POS sales Finance FIN01 - Finance - Payments FIN02 - Finance - Expenses FIN03 - Finance - Accounting FIN04 - Finance - VAT FIN05 - Finance - Fixed assets FIN06 - Finance - Financial analysis FIN07 - Finance - Intrastat reporting FIN08 - Finance - Cost accounting Logistics LOG01 - Logistics - Shipment LOG02 - Logistics - Inventory management LOG03 - Logistics - Planning LOG04 - Logistics - Procurement LOG05 - Logistics - Warehouse management LOG06 - Logistics - Transportation Production PRD01 - Production - Products and technologies PRD02 - Production - Planning PRD03 - Production - Resources PRD04 - Production - Shop floor control Security SEC01 - Security - Sign in with Azure AD Web WEB02 - Web - Client center Extras X01 - Extras - 10 Companies X02 - Extras - Unlimited companies X03 - Extras - Store bins X04 - Extras - Pictures editor X05 - Extras - Business intelligence X06 - Extras - Barcode controlling X07 - Extras - ERP.net API X08 - Extras - Business process management X09 - Extras - CSharp scripting"
  },
  "reference/system-permissions.html": {
    "href": "reference/system-permissions.html",
    "title": "System permissions | ERP.net Tech Docs",
    "keywords": "System permissions In ERP.net there are some predefined system permissions that are created in order to serve certain business cases and allow giving or restricting access of particular functionalities in the system. Each system permission has a specific access key ID that is the same in each database. The records for that which system permission is granted to which user groups is kept in the Group access keys table. We are adding a list with the predefined system permissions and their access key IDs. This information could, for example, be used to monitor the changes of those permissions using the Track changes system. System permission Access key ID Allow edit persist lot in shipment orders 17f56001-681a-4972-a75f-425e21158e4c Allow credit limit override in sales orders 39c19335-cdd2-4548-8d0d-b10d5fc9fc9f Allow edit unit price in offers and sales orders b85c23e3-f314-467a-9022-53e43c08b585 Allow edit historical unit cost in sales orders c88e4f8a-7e55-4029-9615-a7e2b12ddd1b Allow edit persist lot in sales orders b2a3cef0-e6e3-11e1-aff1-0800200c9a66 Allow edit line discount in offers and sales orders e71c31d2-e315-4a72-d021-f3143c08b58a Allow edit persist lot in store orders aebcc95b-41d1-494e-92f8-e01501b353a8 Allow release of correct logistics transactions that are not validated orders 61e43e33-5bc4-484c-b581-3737e05b0978 Use personal layout views 850945b7-91da-4aa4-9e55-9f8feb72e423 Show more than 2,000 rows d7208a56-2a02-4069-bbe7-a8ce65085094 Show more than 20,000 rows 4a3c7106-e15b-4c97-bae1-5500c0cf47c6 Show more than 200,000 rows 10c58661-8210-4a77-8444-5126b0d99c91 Advanced User 06051ccb-19ef-49f0-a224-2ce2bcea87cf Super User 0ee5ee4b-3cbc-4fd2-aa50-42b1c5fa1d9a Server Control c10b3c23-2cf0-470b-b80d-549e0533c190"
  }
}