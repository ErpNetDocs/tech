{
  "README.html": {
    "href": "README.html",
    "title": "Welcome to the ERP.net Technical Documentation | ERP.net Tech Docs",
    "summary": "Welcome to the ERP.net Technical Documentation The documentation uses DocFX to build."
  },
  "advanced/calculated-attributes/QA/How-to-check-if-a-custom-property-has-value.html": {
    "href": "advanced/calculated-attributes/QA/How-to-check-if-a-custom-property-has-value.html",
    "title": "How to check if a custom property has values? | ERP.net Tech Docs",
    "summary": "How to check if a custom property has values? When there is a need to check if a custom property of an object has a value, you can CAST the custom property to a string and then check if it is equal to null. However, the syntax of the calculated attribute should be tailored to the specifics of the property type of the particular custom property. Here are examples for the different custom property types which are universal to all repositories. The custom property code which is verified is CustomProperty1. Note When a custom property is cast to string, only its value will be processed, not its description. Property type is 'Text', 'Number' or 'Date' If the property type of the particular custom property is 'Text','Number' or 'Date', use the following expressions: 10: IIF EXP:20 CONST:'null' CONST:'not null' 20: OR EXP:30 EXP:40 30: EQUAL EXP:50 CONST:NULL 40: EQUAL EXP:50 CONST:'' 50: CAST ATTRIB:@CustomProperty1 CONST:System.String Explanation: 10: if EXP:20 is true, return the text 'null', else - return 'not null' 20: if EXP:30 OR EXP:40 is true, return 'true', else - return 'false' 30: if EXP:50 is empty, return 'true', else - return 'false' 40: if EXP:50 is an empty string, return 'true', else - return 'false' 50: cast CustomProperty1 to string Property type is 'Picture' If the property type of the particular custom property is 'Picture', use the following expressions: 10: IIF EXP:20 CONST:'null' CONST:'not null' 20: EQUAL EXP:30 CONST:0 30: SUM EXP:40 CONST:1 40: FILTER EXP:70 EXP:50 50: NOT EXP:60 60: EQUAL ATTRIB:Picture CONST:NULL 70: SELECT REPO:General.PropertyValues EXP:80 80: WHERE EXP: 90 EXP:100 90: EQUAL ATTRIB:PropertyId CONST:86ba82c9-8843-e611-82a1-b010410e63e2 100: EQUAL ATTRIB:EntityItemId CONST:47e225e9-f4b6-e611-af28-00155d001f28 Explanation: 10: if EXP:20 is true, return the text 'Null', else - return 'Not null' 20: if EXP:30 is equal to 0, return 'True', else - return 'False' 30: count the records of the list returned by EXP:40 40: filter the list returned by EXP:70 by the condition of EXP:50 50: if EXP:60 is true, return 'False', else - return 'True' 60: if ATTRIB:Picture is equal to NULL, return 'True', else - return 'False' 70: select the records of table General.PropertyValues filtered by the clauses of EXP:80 80: if EXP:90 AND EXP:100 are true, return 'True', else - return 'False' 90: if ATTRIB:PropertyId is equal to 86ba82c9-8843-e611-82a1-b010410e63e2, return 'True', else - return 'False' 100: if ATTRIB:EntityItemId is equal to 47e225e9-f4b6-e611-af28-00155d001f28, return 'True', else - return 'False' Note EntityItemId is the ID of the actual entity (document, line, product) for which the value is specified."
  },
  "advanced/calculated-attributes/QA/How-to-check-if-a-field-that-points-to-a-reference-object-has-a-value.html": {
    "href": "advanced/calculated-attributes/QA/How-to-check-if-a-field-that-points-to-a-reference-object-has-a-value.html",
    "title": "How to check if a field that points to a reference object has a value? | ERP.net Tech Docs",
    "summary": "How to check if a field that points to a reference object has a value? When you're creating a calculated attribute and want to get a value from a referent object, you need to check if the current record has a reference to this object at all - if a particular ID field has a value or not. The recommended way to perform this validation is to check whether there is a referent object: 20 EQUAL REF:AdjustedDocument CONST:NULL and not whether the ID fields itself is empty: 20 EQUAL ATTRIB:AdjustedDocumentId CONST:NULL The first approach is better because: a. the second approach may lead to incorrect results - there are cases with wrong results when this approach is used in a SELECT clause or in multiple nested calculated attributes. b. the first approach does not require type conversions - you're directly checking if there is a reference object and you don't have to use CAST or CONVERT operators to match the types before the comparison."
  },
  "advanced/calculated-attributes/QA/How-to-check-if-a-list-has-values.html": {
    "href": "advanced/calculated-attributes/QA/How-to-check-if-a-list-has-values.html",
    "title": "How to check if a list has values? | ERP.net Tech Docs",
    "summary": "How to check if a list has values? When working with lists, you can check if they contain any values (or records). For example, there is an attribute which calculates the quantity in the sales order lines in specified measurement unit. You could enter a product which has no dimensions for the required measurement unit. In such cases, an instrument to check the lists records count is needed. The described case is solved by the following expression: SUM(List, 1) This expression returns integer value containing the number of records in the entered list. Here is a sample expression and its description. This example is defined in the sales order header and checks if the lines contain one specific product. The repository of the calculated attribute is Crm.Sales.SalesOrders and its expressions are: 10: SUM EXP:20 CONST:1 20: FILTER CHILD:Lines EXP:30 30: EQUAL ATTRIB:ProductId CONST:d3d83bf0-d1fc-e611-9c53-00155d001f52 Explanation: 10: check the records count in list in expression 20 20: filter the list of lines (detailed objects of the sales order object) by the filter in expression 30 30: check if the ProductId in the line is equal to Guid d3d83bf0-d1fc-e611-9c53-00155d001f52 This calculated attribute returns zero or greater value, depending on the count of records in the sales order line with product with ID d3d83bf0-d1fc-e611-9c53-00155d001f52."
  },
  "advanced/calculated-attributes/QA/How-to-create-an-optimally-fast-calculated-attribute.html": {
    "href": "advanced/calculated-attributes/QA/How-to-create-an-optimally-fast-calculated-attribute.html",
    "title": "How to create an optimally fast calculated attribute? | ERP.net Tech Docs",
    "summary": "How to create an optimally fast calculated attribute? When creating a calculated attribute, there are some things to keep in mind in order to create an optimally fast syntax. Let's see some steps that should be followed during the design of the attribute: Use REF instead of SELECT If you have to use a SELECT, use WHERE clauses instead of FILTER clauses If you have to use a FILTER, then pre-filter the list as much as possible using WHERE clauses Add WHERE clauses by indexed fields Using References Using a REF means that you're using the collection of elements that have already been loaded in the memory. The REF connection leads only to the records that refer to the current entity. Using a [SELECT] means that for each attribute calculation, the system will create a request to the server and will look through the whole table that you have selected. A single table could contain millions of records. More records means slower calculation. Like any design, when creating a calculated attribute, there is usually more than one way to calculate the value. Sometimes [SELECT] is the simplest option to use to reach the value, but you should always try to find a link instead, in order to achieve faster calculation. Example: Suppose you need to show a field with Total Line Amount value in the sales order line. You will need to calculate the sum of the line amount of all sales order lines of the particular sales order. Such attribute can be created in at least two ways (the repository being Crm.Sales.SalesOrderLines): Using a [SELECT] (with all records in the Crm.Sales.SalesOrderLines table) 10 SUM EXP:20 ATTRIB:LineAmountValue 20 SELECT REPO:Crm.Sales.SalesOrderLines EXP:30 30 WHERE EXP:40 40 EQUAL ATTRIB:SalesOrderId EXP:50 50 GETOBJVALUE INPUT:10 ATTRIB:SalesOrderId Using a REF (with only the lines of the current SalesOrder) 10 SUM EXP:20 ATTRIB:LineAmountValue 20 GETOBJVALUE REF:SalesOrder CHILD:Lines Using SELECT There are some cases where you want to reach the data of a table, to which you could not use a reference connection. But with [SELECT], there are some tricks that you can master to speed up the calculation. When you [SELECT] a table, you can filter its records with [WHERE] or [FILTER] clauses. Keep in mind that when using: WHERE clauses, the conditions are applied together with [SELECT] to the whole list and directly on the server. Much faster performance in comparison with [FILTER], especially for a list with lots of records. the right WHERE clauses matters - always try to add atleast one WHERE clause with a filter by Indexed fields. Indexed fields help access find and sort information quickly—especially in large tables. So using them, significantly improves the attribute performance. FILTER clauses, filters are applied locally (on the client side) to the list returned from [SELECT]. Knowing this, you can reach two basic conclusions: First, you should choose [WHERE] clauses instead [FILTER] clauses, if possible. Most of the other operators are supported in both cases, though [WHERE] clauses do have certain limitation. For example, they cannot be used along with NOT, OR and LIKE operators. Second, always try to add alteast one WHERE clause with a filter by an indexed field. Check which are the indexed fields of the table you are selecting. To do this, simply visit the model documentation of the entity and search by \"Indexed: True\". See if there is an indexed field you can add to the filter of the [WHERE] clauses to speed up the calculation. And third, when you have no choice but to use [FILTER] clauses, you should try to narrow down the list you're returning. Just apply as many [WHERE] clauses as possible to [SELECT]. This way, you're filering the list before it's returned to the [FILTER] and therefore, it'll contain fewer records, which will lead to a faster calculation. Overall, [SELECT] is a very powerful tool that needs to be used wisely."
  },
  "advanced/calculated-attributes/QA/How-to-determine-the-party-type-of-a-party.html": {
    "href": "advanced/calculated-attributes/QA/How-to-determine-the-party-type-of-a-party.html",
    "title": "How to determine the party type of a party? | ERP.net Tech Docs",
    "summary": "How to determine the party type of a party? If you need to compare a PartyType to see what it is, the following calculation would do the job: CAST ATTRIB:PartyType CONST:System.Int32 Casting the PartyType to integer would return the following values: 0 - Company 1 - Company Location 2 - Person 3 - Store 4 - Company Division"
  },
  "advanced/calculated-attributes/QA/How-to-get-attribute-value-from-list.html": {
    "href": "advanced/calculated-attributes/QA/How-to-get-attribute-value-from-list.html",
    "title": "How to get attribute value from list? | ERP.net Tech Docs",
    "summary": "How to get attribute value from list? A typical mistake is when users try getting a value of an attribute from a list. For example, if you want to get the user who changed the document state: 10: GETOBJVALUE CHILD:StateChanges ATTRIB:UpdateUser This is an incorrect expression. The right expression would be to filter the child list and then get the first element of the list. Example: 10 GETOBJVALUE EXP:20 ATTRIB:UpdateUser 20 FIRST EXP:30 30 FILTER CHILD:StateChanges EXP:40 40 EQUAL ATTRIB:SystemInitiated CONST:False Explanation: 10: get the value of the UserUpdate field from object in expression 20 20: get the first record in the list in expression 30 30: filter the child list StateChanges by the filter in expression 40 40: check if the attribute SystemInitiated is equal to 'False'"
  },
  "advanced/calculated-attributes/QA/How-to-get-specific-field-of-a-parent-document.html": {
    "href": "advanced/calculated-attributes/QA/How-to-get-specific-field-of-a-parent-document.html",
    "title": "How to get specific field of a parent document? | ERP.net Tech Docs",
    "summary": "How to get specific field of a parent document? When calculating an attribute requires the value of an attribute of a parent document, there are two options: The attribute is part of the parent document table The attribute is part of the specific entity of the parent document (SalesOrder, StoreOrder, StoreTransaction, Payment, etc.) In the first case, you may get the value directly by GETOBJVALUE operator in the following expression: 10: GETOBJVALUE REF:Parent ATTRIB:DocumentNo This expression would be valid for every document which has a parent document. In the second case, you need to tell the calculated attribute what the parent document is. This is done by casting the parent document to the required entity. Example: 10: GETOBJVALUE EXP:20 ATTRIB:DocumentNo 20: CAST REF:Parent CONST:Aloe.EnterpriseOne.Model.Crm.Presales.Offer It's supposed to show such calculated attributes in the document form where the parent document is 'offer'."
  },
  "advanced/calculated-attributes/QA/How-to-show-contact-of-a-person-in-persons-navigator.html": {
    "href": "advanced/calculated-attributes/QA/How-to-show-contact-of-a-person-in-persons-navigator.html",
    "title": "How to show contact of a person in Persons navigator? | ERP.net Tech Docs",
    "summary": "How to show contact of a person in Persons navigator? The specifics of this calculated attribute is that the contact mechanism type is enum. Its values and codes are as follows: Member name Value Description Address 0 Address value. Stored as 'A'. Mail 1 Mail value. Stored as 'E'. Fax 2 Fax value. Stored as 'F'. MobilePhone 3 MobilePhone value. Stored as 'M'. Other 4 Other value. Stored as 'O'. Telephone 5 Telephone value. Stored as 'T'. WebSite 6 WebSite value. Stored as 'W'. Let's say you need to get a column with email addresses. The repositiry of the calculated attribute would be \"General.Contacts.Parties\" and it would have the following expressions: 10:GETOBJVALUE EXP:20 ATTRIB:Name 20:GETOBJVALUE EXP:30 REF:ContactMechanism 30:FIRST EXP:40 40:FILTER CHILD:ContactMechanisms EXP:50 50:EQUAL EXP:60 CONST:1 60:CAST EX:70 CONST:System.Int32 70:GETOBJVALUE REF:ContactMechanism ATTRIB:ContactMechanismType Explanation: 10: get the value of the Name attribute from EXP:20 20: get the referent object ContactMechanism of EXP:30 30: get the first value of the list returned by EXP:40 40: filter the list of records in the child table ContactMechanisms by the conditions in EXP:50 50: check if EXP:60 is equal to 1 (1 = email) 60: cast EXP:70 which contains the ContactMechanismType to integer 70: get the value of the attribute ContactMechanismType from the referent object ContactMechanism Notes If a person has more than one email, the attribute will return a random one. If a specific email is needed, more filters could be applied. If the person has no emails, the attribute will return an error. If you want to avoid that, you need to couny the records in the CHILD:ContactMechanisms first, and to try to get the email only if the records are more than one."
  },
  "advanced/calculated-attributes/QA/How-to-use-a-customer-as-a-company.html": {
    "href": "advanced/calculated-attributes/QA/How-to-use-a-customer-as-a-company.html",
    "title": "How to use a customer as a company? | ERP.net Tech Docs",
    "summary": "How to use a customer as a company? When you work with a customer, you can only get party attributes like company, company location or person. If you know that the customer is a company and need to get their company attributes, you can cast its reference party to Aloe.EnterpriseOne.Model.General.Contacts.Company. For example, to get the responsible person of the customer's company, the following attribute would do the job: (repository of the attribute: Crm.Customers) 10: GETOBJVALUE EXP:20 ResponsiblePersonName 20: CAST REF:Party CONST:Aloe.EnterpriseOne.Model.General.Contacts.Company Note If the customer is not a company, it would return an error."
  },
  "advanced/calculated-attributes/QA/index.html": {
    "href": "advanced/calculated-attributes/QA/index.html",
    "title": "Q & A | ERP.net Tech Docs",
    "summary": "Q & A How to check if a custom property has values? How to check if a field that points to a reference object has a value? How to check if a list has values? How to create an optimally fast calculated attribute? How to determine the party type of a party? How to get attribute value from list? How to get specific field of a parent document? How to show contact of a person in Persons navigator? How to use a customer as a company? What is the difference between DATESPAN and DATEDIFF operators?"
  },
  "advanced/calculated-attributes/QA/what-is-the-difference-between-datespan-and-datediff.html": {
    "href": "advanced/calculated-attributes/QA/what-is-the-difference-between-datespan-and-datediff.html",
    "title": "What is the difference between DATESPAN and DATEDIFF operators? | ERP.net Tech Docs",
    "summary": "What is the difference between DATESPAN and DATEDIFF operators? DATESPAN DATESPAN calculates the time duration between two dates based on specified intervals, such as days, weeks, or months. It provides the duration within these intervals and is ideal for scenarios where you need to measure time in meaningful units. For instance, if you want to know the time gap between two events in days or months, DATESPAN is the go-to operator. Example: Consider two dates - 2023-01-01 23:59, and 2023-01-03 00:00. Using DATESPAN with a day interval, you'd get a result of 1 day, emphasizing the specific interval. Another example: If you choose a month as the interval, the same two dates will yield a result of 0 months, focusing on the month-level duration. DATEDIFF DATEDIFF, on the other hand, computes the absolute difference between two dates in terms of the specified interval type, like days, months, or years. It's useful when you need a precise count of these units between two dates, disregarding the specific intervals. For instance, to determine the exact number of days between two dates, DATEDIFF provides this precise difference. Example: If you choose months as the interval, and the dates are 2023-01-01 and 2023-03-01, DATEDIFF would yield 2 months, reflecting the month-level difference. In summary, DATESPAN is ideal for measuring time in specified intervals, providing the duration within those intervals (e.g., days, months). DATEDIFF, however, offers the absolute difference between dates in terms of the specified interval type (e.g., days, months), disregarding specific intervals. -- DATESPAN operator DATEDIFF operator"
  },
  "advanced/calculated-attributes/examples/calculate-standardpriceperlot.html": {
    "href": "advanced/calculated-attributes/examples/calculate-standardpriceperlot.html",
    "title": "Calculate standard price per lot based on ingredients and operations in a recipe | ERP.net Tech Docs",
    "summary": "Calculate standard price per lot based on ingredients and operations in a recipe With this attribute, you can calculate the StandardPricePerLot set in a product’s definition as you save a recipe. StandardPricePerLot is determined by the prices of ingredients and operations used in the recipe. You can also use this attribute in a business rule to fill in the PricePerLotValue of the product in the recipe. 10: ADD EXP:20 EXP:25 20: SUM CHILD:Ingredients ATTRIB:PriceValue 25: SUM CHILD:Operations EXP:30 30: MULTIPLY EXP:40 EXP:45 40: DIVIDE ATTRIB:StandardPricePerHourValue CONST:60.00 45: CAST EXP:50 CONST:System.Decimal 50: ADD ATTRIB:RunTimeMinutes EXP:60 60: ADD ATTRIB:WaitTimeMinutes EXP:70 70: ADD ATTRIB:SetupTimeMinutes ATTRIB:MoveTimeMinutes Explanation: 10: Add the value of EXP:20 to the value of EXP:25. 20: Sum all recipe's ingredients PriceValues. 25: Sum EXP:30 for all of the recipe's operations. 30: Multiply the value of EXP:40 and EXP:45. 40: Divide the StandardPricePerHourValue by 60.00 to get the StandardPrice per minute. 45: Cast EXP:50 to decimal. 50: Add the RunTimeMinutes values to EXP:60 => EXP:70 to get full execution time of the operation."
  },
  "advanced/calculated-attributes/examples/check-for-first-releasing.html": {
    "href": "advanced/calculated-attributes/examples/check-for-first-releasing.html",
    "title": "Check whether the releasing of a document is first or not | ERP.net Tech Docs",
    "summary": "Check whether the releasing of a document is first or not Sometimes, you may want to know whether the 'Released' state of document is selected for the first time or not. А business case may require a certain business rule to be executed only upon first releasing of the document. The calculated attributes are a tool which, upon trigger, performs its calculation in real-time. If you use a calculated attribute as a condition for a business rule, the condition may be fulfilled today, but not tomorrow. If you reselect the document state, it may trigger actions no longer needed for this record For more information, see How to start a business rule only on first releasing. You can use a calculated attribute to define whether the releasing of a document is first or not: 10: IIF EXP:20 CONST:false CONST:true 20: EQUAL EXP:30 CONST:30 30: CAST ATTRIB:State CONST:System.Int32 Explanation: 10: Check if EXP:20 is true or false. If EXP:20 is true - the calculated attribute displays 'True', else - 'False'. 20: Check if EXP:20 is equal to '30'. 30: Cast the state of the document to integer. State 'Released' is stored as '30'. For more information, see DocumentState enumeration."
  },
  "advanced/calculated-attributes/examples/check-if-field-is-changed-in-adjustment.html": {
    "href": "advanced/calculated-attributes/examples/check-if-field-is-changed-in-adjustment.html",
    "title": "Check if a value of a field is changed in an adjustment document | ERP.net Tech Docs",
    "summary": "Check if a value of a field is changed in an adjustment document This attribute checks if a field value in an adjustment document is equal to the value of the same field in an original document. This helps you determine if the value is being or has been changed in the adjustment document. Using the attribute, you can create a business rule which that prohibits the correction of the field value. 10: IIF EXP:20 CONST:False EXP:30 20: EQUAL REF:AdjustedDocument CONST:NULL 30: IIF EXP:40 CONST:False CONST:True 40: EQUAL ATTRIB:@Property1 EXP:50 50: GETOBJVALUE REF:AdjustedDocument ATTRIB:@Property1 Explanation: 10: Check if EXP:20 is true or false. If EXP:20 is true - the calculated attribute displays 'True', else - 'False'. 20: Check if there is AdjustedDocument. If there's no reference, the document is not an adjustment document. 30: Check if EXP:40 is true or false. 40: Check if the value of the custom property 'Property1' is equal to EXP:50. 50: Get the value of the 'Property1' of the adjusted document."
  },
  "advanced/calculated-attributes/examples/check-if-quantity-is-whole-number.html": {
    "href": "advanced/calculated-attributes/examples/check-if-quantity-is-whole-number.html",
    "title": "Check if a quantity is a whole number | ERP.net Tech Docs",
    "summary": "Check if a quantity is a whole number This attribute returns 'Тrue' if the quantity in the sales order line is а whole number, and False - if it's decimal number. The repository of the attribute is Crm.Sales.SalesOrderLines. Its expressions are as follows: 10: IIF EXP:20 CONST:True CONST:False 20: EQUAL ATTRIB:QuantityValue EXP:30 30: CEILING ATTRIB:QuantityValue Explanation: 10: check if expression 20 is true. If so - return 'True', else - return 'False' 20: check if attribute QuantityValue is equal to expression 30 30: get the smallest integral value greater than or equal to the value in attribute QuantityValue"
  },
  "advanced/calculated-attributes/examples/check-if-system-type-is-in-cash.html": {
    "href": "advanced/calculated-attributes/examples/check-if-system-type-is-in-cash.html",
    "title": "Check if the system type of a payment type in a sales order is 'In cash' | ERP.net Tech Docs",
    "summary": "Check if the system type of a payment type in a sales order is 'In cash' This attribute checks if the system type of a payment type set in a sales order is 'In Cash'. You can use it to create a business rule that allows a credit limit override when the client pays in cash. For more information, see Allow a credit limit override when the client pays in cash. 10: IIF EXP:20 CONST:True CONST:False 20: EQUAL EXP:25 EXP:30 25: CAST CONST:0 CONST:System.Nullable`1[Aloe.EnterpriseOne.Model.Finance.Payments.PaymentTypesRepository+SystemType] 30: GETOBJVALUE REF:PaymentType ATTRIB:SystemType Explanation: 10: Return 'True' of 'False' according to the result of EXP:20 20: Check if EXP:25 is equal to EXP:30 25: Converts '0' to type System.Nullable`1[Aloe.EnterpriseOne.Model.Finance.Payments.PaymentTypesRepository+SystemType] using CAST 30: Get the system type of the payment type which is set in the sales order. Note When using EQUAL, make sure you're comparing parameters from the same type. If you don’t know which type the object is or what value it's going to return, you can use the Aloe.EnterpriseOne.Model Documentation. In the particular example, check PaymentTypesRepository.SystemType Enumeration, where you'll find the value corresponding to the system type in 'Cash' is '0'."
  },
  "advanced/calculated-attributes/examples/check-if-user-has-authorization.html": {
    "href": "advanced/calculated-attributes/examples/check-if-user-has-authorization.html",
    "title": "Check if a user has authorization | ERP.net Tech Docs",
    "summary": "Check if a user has authorization To determine if a logged-in user is authorized to do, see, or edit an entity, you need to know which group has such rights. You can then create a calculated attribute that checks if the user is part of that group: 10: IIF EXP:20 CONST:True CONST:False 20: GTE EXP:30 CONST:1 30: SUM EXP:40 CONST:1 40: SELECT REPO:Systems.Security.UserGroups EXP:50 50: WHERE EXP:60 EXP:80 60: EQUAL ATTRIB:UserId EXP:70 70: GETOBJVALUE INPUT:10 SYS:UserId 80: EQUAL ATTRIB:GroupId CONST:5daf849d-9986-462f-9171-a23c1c5839b7 Explanation: 10: Check the state of EXP:20. If it's true - the calculated attribute displays 'True', if else - 'False'. 20: Check if the list EXP:30 returns at least one record. 30: Return the count of records in the filtered list of EXP:40. 40: Select 'User Groups' filtered by EXP:50. 50: The filters are expression 60, expression 80... 60: Check if UserId is equal to EXP:70. 70: Get the Id of the user that is currently editing the entity. 80: Check if the GroupId is equal to the Id of an authorized group."
  },
  "advanced/calculated-attributes/examples/compare-unit-and-standard-unit-price.html": {
    "href": "advanced/calculated-attributes/examples/compare-unit-and-standard-unit-price.html",
    "title": "Compare unit price and standard unit price | ERP.net Tech Docs",
    "summary": "Compare unit price and standard unit price This attribute calculates if the unit price in the sales order lines is greater than the standard unit price of the product. It returns the following message: 10: IIF EXP:20 CONST:'OK!' CONST:'Not OK!' 20: GT ATTRIB:UnitPriceValue ATTRIB:StandardUnitPriceValue Explanation: 10: Checks if EXP:20 is true or false. If EXP:20 is true - the calculated attribute displays 'OK!' message, else - 'Not OK!'. 20: Checks if ATTRIB:UnitPriceValue is greater than ATTRIB: StandardUnitPriceValue. If so - returns 'True', else - 'False'. The same validation may be achieved using another operator: 10: IIF EXP:20 CONST:'Not OK!' CONST:'OK!' 20: LTE ATTRIB:UnitPriceValue ATTRIB:StandardUnitPriceValue Explanation: 10: Checks if EXP:20 is true or false. If EXP:20 is true - the calculated attribute displays 'Not OK!' message, else - 'OK!'. 20: Checks if ATTRIB:UnitPriceValue is less than or equal to ATTRIB:StandardUnitPriceValue. If so - returns 'True', else - 'False'."
  },
  "advanced/calculated-attributes/examples/convert-property-to-number.html": {
    "href": "advanced/calculated-attributes/examples/convert-property-to-number.html",
    "title": "Convert a value of a custom property to a number | ERP.net Tech Docs",
    "summary": "Convert a value of a custom property to a number The values of custom properties are a specific type of value that the CONVERT operator doesn't know how to handle. For this reason, if you want to CONVERT a custom property's value to a number, you have to CAST it first. Example: Let's say you want to multiply the standard price per lot of a product by a coefficient stored as a product's custom property @CustomProperty1. Note The repository of the attributes is General.Products.Products CORRECT calculated attribute: 10: MULTIPLY ATTRIB:StandardPricePerLotValue EXP:20 20: CONVERT EXP:30 CONST:System.Decimal 30: CAST ATTRIB:@CustomProperty1 CONST:System.String Explanation: 10: Multiply the value of the Standard Price Per Lot by EXP: 20. 20: Convert EXP:30 to a decimal number. 25: Cast the value of custom property CustomProperty1 to a string. FALSE calculated attribute: 10: MULTIPLY ATTRIB:StandardPricePerLotValue EXP:20 20: CONVERT ATTRIB:@CustomProperty1 CONST:System.Decimal Explanation: 10: Multiply the value of the Standard Price Per Lot by EXP: 20. 20: Convert the value of custom property CustomProperty1 to a decimal number. Note Before converting a CustomPropertyValue to a numeric value, you need to CAST it to a string first!"
  },
  "advanced/calculated-attributes/examples/day-from-document-date.html": {
    "href": "advanced/calculated-attributes/examples/day-from-document-date.html",
    "title": "Specific day from document date | ERP.net Tech Docs",
    "summary": "Specific day from document date This attribute calculates and displays a certain number of days added to a document date. Example: A calculated attribute is added with the following parameters: Repository Name:Crm.Sales.SalesOrders Name:TenDaysFromDocumentDay The calculated attribute expressions are as follows: 10: ADDDAYS ATTRIB:DocumentDate CONST:10 Explanation: 10: Add 10 days to the date in DocumentDate If showed in the sales order form, this attribute calculates and displays 10 days added to the DocumentDate."
  },
  "advanced/calculated-attributes/examples/format-property-date.html": {
    "href": "advanced/calculated-attributes/examples/format-property-date.html",
    "title": "Format date type custom property | ERP.net Tech Docs",
    "summary": "Format date type custom property This example shows how you can format the values of date type custom properties using a calculated attribute. 10: FORMATSTRING EXP:20 CONST:yyyy MM dddd 20: CONVERT EXP:30 CONST:System.DateTime 30: CONCAT EXP:40 EXP:50 40: SUBSTRING EXP:100 CONST:0 CONST:4 50: CONCAT CONST:- EXP:60 60: CONCAT EXP:70 EXP:80 70: SUBSTRING EXP:100 CONST:4 CONST:2 80: CONCAT CONST:- EXP:90 90: SUBSTRING EXP:100 CONST:6 CONST:2 100: FORMATSTRING ATTRIB:@Property1 CONST:V Explanation: Let's assume that the value of the custom poperty is 20200315. 10: Format the date returned from EXP:20 applying format type 'yyyy MM dddd', e.g. '2020 03 Sunday'. 20: Convert the type of the value returned from EXP:30 to DateTime 30: Concatenate the text from EXP:40 to the text from EXP:50 e.g. '2021' + '-03-15' 40: Get the first 4 characters from EXP:100 e.g. '2021' 50: Concatenate the character '-' to the text from EXP:60 e.g. '-' + '03-15' 60: Concatenate the text from EXP:70 to the text from EXP:80 e.g. '09' + '-15' 70: Get the first 2 characters from the string from EXP:100, starting from character 4 e.g. '03' 80: Concatenate the character '-' to the text from EXP:90 e.g. '-' + '15' 90: Get the first 2 characters from the string from EXP:100, starting from character 6 e.g. '15' 100: Get the value of custom property 'Property1' e.g. '20200315'"
  },
  "advanced/calculated-attributes/examples/get-atp.html": {
    "href": "advanced/calculated-attributes/examples/get-atp.html",
    "title": "Get available to promise (ATP) quantity | ERP.net Tech Docs",
    "summary": "Get available to promise (ATP) quantity This example shows how you can create a calculated attribute which gets the avaible to promise (ATP) quantity on a particular date using the AvailableToPromise view. In the example, you'll learn how to get the ATP quantity in a shipment order line on its required delivery date. Note The repository of the attributes is Logistics.Shipment.ShipmentOrderLines 10 GETOBJVALUE EXP:20 ATTRIB:ATPBaseValue 20 FIRST EXP:30 30 SORT EXP:40 ATTRIB:FromDate CONST:DESC 40 SELECT REPO:Logistics.Inventory.DemandManagement.AvailableToPromise EXP:50 50 WHERE EXP:80 EXP:60 60 AND EXP:110 EXP:70 70 AND EXP:140 EXP:170 80 EQUAL ATTRIB:ProductId EXP:90 90 GETOBJVALUE INPUT:10 EXP:100 100 GETOBJVALUE REF:ParentSalesOrderLine ATTRIB:ProductId 110 EQUAL ATTRIB:StoreId EXP:120 120 GETOBJVALUE INPUT:10 EXP:130 130 GETOBJVALUE REF:ParentSalesOrderLine ATTRIB:LineStoreId 140 EQUAL ATTRIB:EnterpriseCompanyId EXP:150 150 GETOBJVALUE INPUT:10 EXP:160 160 GETOBJVALUE REF:ShipmentOrder ATTRIB:EnterpriseCompanyId 170 LTE ATTRIB:FromDate EXP:180 180 GETOBJVALUE INPUT:10 EXP:190 190 GETOBJVALUE REF:ShipmentOrder ATTRIB:RequiredDeliveryDate Explanation: 10: Get the ATPBaseValue of the AvailableToPromise record returned by EXP:20 20: Get the first record of the list returned by EXP:30 30: Sort the list returned by EXP:40 - descending by the value of the FromDate attribute 40: Select the AvailableToPromise records which are matching the clauses of EXP:50 50: Filter the the records for which EXP:80 and EXP:60 are True 60: Filter the the records for which EXP:110 and EXP:70 are True 70: Filter the the records for which EXP:140 and EXP:170 are True 80: Return 'True' if the ProductId of the AvailableToPromise record is equal to EXP:90 90: Get EXP:100 from the repository of EXP:10 i.e. of the current shipment order line 100: Get the ProductId of the ParentSalesOrderLine 110: Return 'True' if the StoreId of the AvailableToPromise record is equal to EXP:120 120: Get EXP:130 from the repository of EXP:10 i.e. of the current shipment order line 130: Get the LineStoreId of ParentSalesOrderLine 140: Return 'True' if the EnterpriseCompanyId of the AvailableToPromise record is equal to EXP:150 150: Get EXP:160 from the repository of EXP:10 i.e. of the current shipment order line 160: Get the EnterpriseCompanyId of the ShipmentOrder 170: Return 'True' if the FromDate of the AvailableToPromise record lower or equal to EXP:180 180: Get EXP:160 from the repository of EXP:10 i.e. of the current shipment order line 160: Get the RequiredDeliveryDate of the ShipmentOrder"
  },
  "advanced/calculated-attributes/examples/get-current-availability-of-product.html": {
    "href": "advanced/calculated-attributes/examples/get-current-availability-of-product.html",
    "title": "Get current availability of a product | ERP.net Tech Docs",
    "summary": "Get current availability of a product This example shows how to create a calculated attribute which returns the sum of the available quantity base of a particular product. Filters are applied by enterprise company, store, product, lot, store bin and serial number, because of the unique nature of the repository of the calculation attribute. Additional filter by Product variant could also be added. We recommend always filtering by EnterpriseCompanyId, StoreId, and ProductId inside the Select clauses when searching for product availability. If EnterpriseCompanyId or StoreId is missed, the calculation will happen much slower. This is the order of filtering for the CurrentBalances. We can exclude filters from bottom to top but we cannot remove filters from above until we have removed all from below. EnterpriseCompanyId, StoreId, ProductId, LotId, StoreBinId, SerialNumberId, ProductVariantId The example is suited for consumption order lines, but such an attribute could be used with other documents or definitions as well. Repository Name: Production.ShopFloor.ConsumptionOrderLines 10: SUM EXP:20 ATTRIB:QuantityBaseValue 20: SELECT REPO:Logistics.Inventory.CurrentBalances EXP:30 30: WHERE EXP:50 EXP:80 50: EQUAL ATTRIB:EnterpriseCompanyId EXP:60 60: GETOBJVALUE INPUT:10 EXP:70 70: GETOBJVALUE REF:Document ATTRIB:EnterpriseCompanyId 80: AND EXP:120 EXP:90 90: AND EXP:140 EXP:100 100: AND EXP:160 EXP:110 110: AND EXP:180 EXP:200 120: EQUAL ATTRIB:StoreId EXP:130 130: GETOBJVALUE INPUT:10 ATTRIB:StoreId 140: EQUAL ATTRIB:ProductId EXP:150 150: GETOBJVALUE INPUT:10 ATTRIB:ProductId 160: EQUAL ATTRIB:LotId EXP:170 170: GETOBJVALUE INPUT:10 ATTRIB:LotId 180: EQUAL ATTRIB:StoreBinId EXP:190 190: GETOBJVALUE INPUT:10 ATTRIB:StoreBinId 200: EQUAL ATTRIB:SerialNumberId EXP:210 210: GETOBJVALUE INPUT:10 ATTRIB:SerialNumberId Explanation: 10: Sum Quantity Base from the filtered list returned by EXP:20 20: Select repository Logistics.Inventory.CurrentBalances and filter by the clauses in EXP:30 30: Filter the list above by the records WHERE, in which the clauses in EXP:50 and EXP:80 are True 50: Check whether ATTRIB:EnterpriseCompanyId is equal to EXP:60 60: Get value from the repository of EXP:10 and reference EXP:70 70: Get ATTRIB:EnterpriseCompanyId from the referenced document 80: EXP:120 EXP:90 90: EXP:140 EXP:100 100: EXP:160 EXP:110 110: EXP:180 EXP:200 120: Check whether ATTRIB:StoreId is EQUAL to EXP:130 130: Get ATTRIB:StoreId from the repository of EXP:10 140: Check whether ATTRIB:ProductId is EQUAL to EXP:150 150: Get ATTRIB:ProductId from the repository of EXP:10 160: Check whether ATTRIB:LotId is EQUAL to EXP:170 170: Get ATTRIB:LotId from the repository of EXP:10 180: Check whether ATTRIB:StoreBinId is EQUAL to EXP:190 190: Get ATTRIB:StoreBinId from the repository of EXP:10 200: Check whether ATTRIB:SerialNumberId is EQUAL to EXP:210 210: Get ATTRIB:SerialNumberId from the repository of EXP:10"
  },
  "advanced/calculated-attributes/examples/get-custom-property-from-parent-offer-line.html": {
    "href": "advanced/calculated-attributes/examples/get-custom-property-from-parent-offer-line.html",
    "title": "Get a value of a custom property in sales order lines from the parent offer line | ERP.net Tech Docs",
    "summary": "Get a value of a custom property in sales order lines from the parent offer line This attribute determines the value of a particular customer property set for the parent offer line of the current sales order line. Currently, offer lines customer properties are not transferred to the sales order. Thus, you can use this attribute in a user business rule to automate the process. For more information on how to create such a rule, see How to use business rules to set a value into a custom property?. Repository: Crm.Sales.SalesOrderLines 10: GETOBJVALUE EXP:20 ATTRIB:@Propery1 20: FIRST EXP:30 30: FILTER EXP:70 EXP:40 40: EQUAL ATTRIB:LineNo EXP:50 50: CAST EXP:60 CONST:System.Int32 60: GETOBJVALUE INPUT:10 ATTRIB:ParentLineNo 70: GETOBJVALUE EXP: 80 CHILD:Lines 80: CAST REF:ParentDocument CONST:Aloe.EnterpriseOne.Model.Crm.Presales.Offer Explanation: 10: Get the record of custom property 'Propery1' from EXP:20. 20: Get the first value of EXP:30. 30: Filter the list from EXP:70 with the filters from EXP:40. 40: Check in the LineNumber of the offer line is equal to the value from EXP:50. 50: Cast EXP:60 to \"System.Int32\". 60: Get the ParentLineNo of the sales order line, which is an input for EXP:10. 70: Get the list of child line of the object of EXP:80. 80: Cast the parent document of the sales order line to Aloe.EnterpriseOne.Model.Crm.Presales.Offer to define the type/entity of the parent document."
  },
  "advanced/calculated-attributes/examples/get-value-and-description-of-referent-object.html": {
    "href": "advanced/calculated-attributes/examples/get-value-and-description-of-referent-object.html",
    "title": "Get value and description of referent object | ERP.net Tech Docs",
    "summary": "Get value and description of referent object When a value is set to a custom property of an object, a new record is added to the General.PropertyValue repository. The new record has its own Id, and an EntityItemId, which is the id of the specific object. In a calculated attribute, you'll need to filter the value for the specific property (PropertyId) of the specific object (EntityItemId) and then get the value or description. Example: Let's see how to get the description of a property of the customer and show it in the offer form. Such a calculated attribute would have the following parameters: Repository Name:Crm.Presales.Offers And the calculated attribute expressions are as follows: 10: GETOBJVALUE EXP:20 ATTRIB:Description 20: FIRST EXP:30 30: SELECT REPO:General.PropertyValues EXP:40 40: WHERE EXP:50 50: AND EXP:60 EXP:70 60: EQUAL ATTRIB:PropertyId CONST:e7005814-6140-4708-a9d8-aaaeb5b151ed 70: EQUAL ATTRIB:EntityItemId EXP:80 80: GETOBJVALUE INPUT:10 ATTRIB:CustomerId Explanation: 10: get the attribute description of the object in expression 20 20: get the first record in the list from expression 30 30: select repository General.PropertyValues filtered by expression 40 40: the filter is expression 50 50: expression 60 AND expression 70 60: check if the attribute PropertyId is equal to the constant of e7005814-6140-4708-a9d8-aaaeb5b151ed (this is a guid) 70: check if the attribute EntityItemId is equal to expression 80 80: get the attribute CustomerId of the input object of expression 10 If you need the value of the property, the first expression may be set to GETOBJVALUE EXP:20 ATTRIB:PropertyValueField."
  },
  "advanced/calculated-attributes/examples/index.html": {
    "href": "advanced/calculated-attributes/examples/index.html",
    "title": "Examples | ERP.net Tech Docs",
    "summary": "Examples Calculate standard price per lot based on ingredients and operations in a recipe Check if a quantity is a whole number Check if a user has authorization Check if a value of a field is changed in an adjustment document Check if the system type of a payment type in a sales order is 'In cash' Check whether the releasing of a document is first or not Compare unit price and standard unit price Convert a value of a custom property to a number Format date type custom property Get a value of a custom property in sales order lines from the parent offer line Get available to promise (ATP) quantity Get current availability of a product Get value and description of referent object Sales amounts of a customer for the last 30 days Specific day from document date Total quantity and scrap quantity in recipe ingredients"
  },
  "advanced/calculated-attributes/examples/sales-amounts-last-30-days.html": {
    "href": "advanced/calculated-attributes/examples/sales-amounts-last-30-days.html",
    "title": "Sales amounts of a customer for the last 30 days | ERP.net Tech Docs",
    "summary": "Sales amounts of a customer for the last 30 days Let's say you want to show a field in the sales order which calculates the sales amounts of a selected customer for the last 30 days. Such a calculated attribute represents a report with specific filters. If you try to get that information, you'd open a sales order lines report and set the following filters: Client Enterprise company Enterprise company location (eventually) DocumentState (at least 'Released') Void Document date The calculated attribute will SELECT the sales order lines table and filter the records as described above. Such calculated attribute would have the following parameters: Repository Name:Crm.Sales.SalesOrders Name:SOAmountsForTheLast30days And the calculated attribute expressions are as follows: 10: SUM EXP:20 ATTRIB:LineAmountValue 20: SELECT REPO:Crm.Sales.SalesOrderLines EXP:30 30: WHERE EXP:40 EXP:90 40: AND EXP:50 EXP:70 50: EQUAL EXP:60 CONST:30 60: CAST EXP:61 CONST:System.Int32 61: GETOBJVALUE REF:Document ATTRIB:State 70: EQUAL EXP:80 CONST:False 80: GETOBJVALUE REF:Document ATTRIB:Void 90: AND EXP:100 EXP:130 100: AND EXP:101 EXP:160 101: EQUAL EXP:110 EXP:120 110: GETOBJVALUE REF:SalesOrder ATTRIB:CustomerId 120: GETOBJVALUE INPUT:10 ATTRIB:CustomerId 130: GTE EXP:140 EXP:150 140: GETOBJVALUE REF:SalesOrder ATTRIB:DocumentDate 150: ADDDAYS EXP:151 CONST:-30 151: GETOBJVALUE INPUT:10 ATTRIB:DocumentDate 160: EQUAL EXP:170 EXP:180 170: GETOBJVALUE REF:SalesOrder ATTRIB:EnterpriseCompanyId 180: GETOBJVALUE INPUT:10 ATTRIB:EnterpriseCompanyId Explanation: 10: Sum all records from expression 20 by their attribute LineAmountValue 20: Select Sales Order Lines filtered by expression 30 30: the filter is expression 40 AND expression 50 40: expression 50 AND expression 70 50: check if expression 60 is equal to expression 30 60: cast expression 61 to System.Int32 (integer) 61: get the value of attribute State of the referent object Document 70: check if expression 80 is equal to 'False' 80: get the value of attribute Void of the referent object Document 90: expression 100 AND expression 130 100: expression 101 AND expression 160 101: check if expression 110 is equal to expression 120 110: get the value of attribute CustomerId of the referent object SalesOrder 120:get the value of attribute CustomerId of the input object of expression 10 130: check if expression 140 is greater than or equal to expression 150 140: get the value of attribute DocumentDate of the referent object SalesOrder 150: add to expression 151 the value of \"-30\" 151: get the value of attribute DocumentDate of the input object of expression 10 160: check if expression 170 is equal to expression 180 170: get the value of attribute EnterpriseCompanyId of the referent object SalesOrder 180: get the value of attribute EnterpriseCompanyId of the input object of expression 10"
  },
  "advanced/calculated-attributes/examples/total-quantity-and-scrap-in-recipe-ingredients.html": {
    "href": "advanced/calculated-attributes/examples/total-quantity-and-scrap-in-recipe-ingredients.html",
    "title": "Total quantity and scrap quantity in recipe ingredients | ERP.net Tech Docs",
    "summary": "Total quantity and scrap quantity in recipe ingredients Let's say you want to see the total quantity of a material in a recipe, which would include the used quantity and the scrap rate. You would add the following calculated attribute: Repository Name:Production.Technologies.RecipeIngredients Name:TotalUsedQuantity And the calculated attribute expressions are as follows: 10: ADD ATTRIB:UsageQuantityValue EXP:20 20: MULTIPLY ATTRIB:UsageQuantityValue ATTRIB:ScrapRate Explanation: 10: Add the result from expression 20 to the attribute UsageQuantityValue 20: Multiply UsageQuantityValue and ScrapRate"
  },
  "advanced/calculated-attributes/index.html": {
    "href": "advanced/calculated-attributes/index.html",
    "title": "User calculated attributes | ERP.net Tech Docs",
    "summary": "User calculated attributes User calculated attributes are user-defined objects which extend the system entities. They're defined like formulas. When the value of a calculated attribute is requested, it's calculated \"on the fly\", in real-time. Note Calculated attribute formulas are compiled to native executable format. Their calculation speed is very similar to the speed of the system-defined calculated attributes. Example 1 - Get default payment term days Suppose that in a sales order, you want to display the customers default payment term (in days). You can define the following calculated attribute: No Operation Param1 Param2 Param3 10 GETOBJVALUE REF:Customer ATTRIB:DefaultPaymentTermDays Explanation: **GETOBJVALUE ** - gets information from a related entity. The related entity is specified in Param1. The desired information is specified in Param2. Line number 10 is the only line in the calculated attribute The return value is the value of the attribute DefaultPaymentTermDays in the customer entity. Example 2 - Complex filter and summation The following calculated attribute sums all sales order lines, the product of which: has a user data attribute called 'CustPropPrj', equal to '500' has a name containing the word 'Tool' No Operation Param1 Param2 Param3 10 SUM EXP:20 ATTRIB:LineAmount 20 FILTER CHILD:Lines EXP:30 30 IN ATTRIB:Product EXP:40 40 FILTER QUERY:Gen_Products EXP:50 50 AND EXP:60 EXP:70 60 EQUALS ATTRIB:CustPropPrj CONST:500 70 LIKE ATTRIB:Name CONST:'Tool' Explanation: Line 10: Iterates through the data set on Line 20 (EXP:20); SUMs the attribute LineAmount. Line 20: Filters the lines subset with the filter specified in Line 30 (EXP:30). Line 30: Creates a filter which is satisfied only by products in the query on Line 40 (EXP:40). Line 40: Creates a query, which filters the products with the condition specified on Line 50. Line 50: Specifies that the condition is comprised of two conditions linked with AND. Line 60: Specifies that the first condition is the value of an attribute called 'CustPropPrj' should be '500'. Line 70: Specifies that the second condition is that the name of the product should contain 'Tool'. Attributes can calculate complicated formulas, query the database and get related values. See more Operators Examples Parameter types Q&A"
  },
  "advanced/calculated-attributes/operators/add.html": {
    "href": "advanced/calculated-attributes/operators/add.html",
    "title": "ADD | ERP.net Tech Docs",
    "summary": "ADD Specification Value Name ADD Description Returns the sum (total) of two numbers. Parameter 1 Name Number1 Parameter 1 Type numeric type - int, double or decimal Parameter 2 Name Number2 Parameter 2 Type numeric type - int, double or decimal Parameter 3 Name Parameter 3 Type Return value Number1 + Number2 Make sure that the numbers which are summed up are from the the same type. For example, Parameter 1 and Parameter 2 must be both integers, doubles, or decimals. Example: The following example adds '0.25' to the the value of the Quantity field in the sales order lines and returns the sum of the two numbers. 10: ADD ATTRIB:QuantityValue CONST:0.25 OUTPUT: If 'QuantityValue = 1', the output will be '1.25'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More examples: Total quantity and scrap quantity in recipe ingredients"
  },
  "advanced/calculated-attributes/operators/adddays.html": {
    "href": "advanced/calculated-attributes/operators/adddays.html",
    "title": "ADDDAYS | ERP.net Tech Docs",
    "summary": "ADDDAYS Specification Value Name ADDDAYS Description Adds the specified number of days to the date. Parameter 1 Name Date Parameter 1 Type Date Parameter 2 Name NumDays Parameter 2 Type int Parameter 3 Name Parameter 3 Type Return value Date + NumDays Example: 10: ADDDAYS ATTRIB:DocumentDate CONST:5 OUTPUT: If 'DocumentDate = 2000-01-20', the output will be '2000-01-25'. Note The repository of the attribute is Crm.Sales.SalesOrders"
  },
  "advanced/calculated-attributes/operators/and.html": {
    "href": "advanced/calculated-attributes/operators/and.html",
    "title": "AND | ERP.net Tech Docs",
    "summary": "AND Specification Value Name AND Description Checks if two conditions are true. If so - the operator returns 'True'. If any of the specified conditions are not True, the operator returns 'False'. Parameter 1 Name Condition1 Parameter 1 Type boolean Parameter 2 Name Condition2 (optional) Parameter 2 Type boolean Parameter 3 Name Condition3 (optional) Parameter 3 Type boolean Return value Condition1 AND Condition2 Note Parameter 1 and Parameter 2 are optional. If only parameter 1 has value, the result is its value (Parameter 1). Example: 10: AND EXP:20 EXP:30 20: EQUAL ATTRIB:LineNo CONST:10 30: EQUAL ATTRIB:Notes CONST:Apple OUTPUT: If 'LineNo = 10' and 'Notes = Apple', the output will be 'True'. If 'LineNo = 50' and 'Notes = Apple', the output will be 'False'. If 'LineNo = 10' and 'Notes = Pear', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More examples: Sales amounts of the customer for the last 30 days Get value and description of referent object"
  },
  "advanced/calculated-attributes/operators/cast.html": {
    "href": "advanced/calculated-attributes/operators/cast.html",
    "title": "CAST | ERP.net Tech Docs",
    "summary": "CAST Specification Value Name CAST Description The CAST operator converts a parameter to a specified type. It is commonly used by other operators to ensure parameter values are of the same type, particularly when the type one of these parameters is a custom ERP.net type (e.g., a specific enum). Parameter 1 Name param Parameter 1 Type any type Parameter 2 Name type Parameter 2 Type const - 'System.Int32', 'System.String', 'System.Decimal', 'System.Double' and all standard .Net types + custom ERP.net types (e.g., a specific enum) Parameter 3 Name Parameter 3 Type Return value Returns the param converted to the type. Tip: If you can change the type using the CAST operator, you should typically use the CONVERT operator instead—and vice versa. Example: Let's convert the value of the state of a sales order with the type 'enum' to an integer number. Converting to an integer allows for comparison between the states (lower -> higher): 10: CAST ATTRIB: State CONST: System.Int32 OUTPUT: If 'State = Released', the output will be '30'. More examples: Check whether the releasing of the document is first or not Check if the system type of payment type in the sales order is 'In Cash' Convert a value of a custom property to a number"
  },
  "advanced/calculated-attributes/operators/ceiling.html": {
    "href": "advanced/calculated-attributes/operators/ceiling.html",
    "title": "CEILING | ERP.net Tech Docs",
    "summary": "CEILING Specification Value Description Returns the smallest integer greater than or equal to a specified number. Parameter 1 Name Number1 Parameter 1 Type double or decimal Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value The nearest integer which is larger than Number1. Example: Let's get the smallest integer greater than or equal to the quantity of a sales order line: 10:CEILING ATTRIB:QuantityValue OUTPUT: If 'QuantityValue = 14.15', the output will be '15'. If 'QuantityValue = 14', the output will be '14'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/concat.html": {
    "href": "advanced/calculated-attributes/operators/concat.html",
    "title": "CONCAT | ERP.net Tech Docs",
    "summary": "CONCAT Specification Value Description Concatenates two strings. Parameter 1 Name String1 Parameter 1 Type string Parameter 2 Name String2 Parameter 2 Type string Parameter 3 Name - Parameter 3 Type - Return value String1 + String2 Example: Let's concatenate the word 'Red' with the value of the field Notes in a sales order lines: 10: CONCAT CONST:Red ATTRIB:Notes OUTPUT: If 'Notes = Apple', the output will be 'RedApple'. Note The repository of the attribute is Crm.Sales.SalesOrderLines If you want to expand the example, you can add a space ( CONST:' ') between the both strings: 10: CONCAT CONST:Red EXP:20 20: CONCAT CONST:' ' ATTRIB:Notes OUTPUT: If Notes = Apple, the output will be = Red Apple"
  },
  "advanced/calculated-attributes/operators/convert.html": {
    "href": "advanced/calculated-attributes/operators/convert.html",
    "title": "CONVERT | ERP.net Tech Docs",
    "summary": "CONVERT Specification Value Description The CONVERT operator converts a parameter to a specified type. It is commonly used by other operators to ensure parameter values are of the same type, particularly when the type of both of these parameters is a standard .Net type. Accurate input data is crucial for successful conversion; otherwise, data loss may occur without triggering an error. For instance, converting the string '3.12' to decimal will succeed, but attempting to convert 'abc' to a numeric type will fail. Parameter 1 Name param Parameter 1 Type decimal, int, string, or date Parameter 2 Name type Parameter 2 Type string - 'System.Int32', 'System.String', 'System.Decimal', 'System.DateTime' and all standard .Net types Parameter 3 Name - Parameter 3 Type - Return value Returns the param converted to the type. Tip: If you can change the type using the CONVERT operator, you should typically use the CAST operator instead—and vice versa. Example: Let's convert the quantity value of a sales order line, which is a decimal number, to an integer number: 10: CONVERT ATTRIB: QuantityValue CONST: System.Int32 OUTPUT: If 'QuantityValue = 12.14', the output will be '12'. More examples: Convert a value of a custom property to a number"
  },
  "advanced/calculated-attributes/operators/count.html": {
    "href": "advanced/calculated-attributes/operators/count.html",
    "title": "COUNT | ERP.net Tech Docs",
    "summary": "COUNT Specification Value Description Gets the number of elements contained within a list. Parameter 1 Name list Parameter 1 Type list - repository, child. Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value int Introduced in version 2020.1 Example: Let's have a number of lines in a document (sales order) returned: 10: COUNT CHILD:Lines Note The repository of the attribute is Crm.Sales.SalesOrders. If you want to expand the example and get the number of lines with quantity greater than or equal to 10, the following attribute would do the job: 10: COUNT EXP:20 20: FILTER CHILD:Lines EXP:30 30: GTE ATTRIB:QuantityValue CONST:10.00"
  },
  "advanced/calculated-attributes/operators/datediff.html": {
    "href": "advanced/calculated-attributes/operators/datediff.html",
    "title": "DATEDIFF | ERP.net Tech Docs",
    "summary": "DATEDIFF Specification Value Description Returns the difference between dates as the date difference for the specified interval type Parameter 1 Name StartDate Parameter 1 Type Date, DateTime Parameter 2 Name EndDate Parameter 2 Type Date, DateTime Parameter 3 Name Interval Parameter 3 Type String (Days, Months, Years). Defaults to Days if not specified. Return value If Interval = 'Days' then Day(EndDate) - Day(StartDate) If Interval = 'Months' then Month(EndDate) - Month(StartDate) If Interval = 'Years' then Year(EndDate) - Year(StartDate) Note Parameter 3 (Interval) accepts input in the form of a string, allowing you to specify the interval type as either 'Days' (alias 'D'), 'Months' (alias 'M'), or 'Years' (alias 'Y'). If you don't explicitly specify an interval type, it will default to 'Days'. Examples: 10: DATEDIFF ATTRIB:DocumentDate ATTRIB:RequiredDeliveryDate ATTRIB:Days OUTPUT: If 'DocumentDate = 2020-01-01 23:59' and 'RequiredDeliveryDate = 2020-01-02 00:01' , the output will be '1'. If 'DocumentDate = 2020-01-01 23:58' and 'RequiredDeliveryDate = 2020-01-02 23:59' , the output will be '1'. If 'DocumentDate = 2023-09-20' and 'RequiredDeliveryDate = 2023-10-05', the output will be '15'. If 'DocumentDate = 2023-09-20' and 'RequiredDeliveryDate = 2023-09-10', the output will be '-10'. ** 10: DATEDIFF ATTRIB:DocumentDate ATTRIB:RequiredDeliveryDate ATTRIB:Months OUTPUT: If 'DocumentDate = 2023-09-20' and 'RequiredDeliveryDate = 2023-10-05' , the output will be '1'. If 'DocumentDate = 2023-09-20' and 'RequiredDeliveryDate = 2023-10-20' , the output will be '1'. ** 10: DATEDIFF ATTRIB:DocumentDate ATTRIB:RequiredDeliveryDate ATTRIB:Years OUTPUT: If 'DocumentDate = 2023-10-05' and 'RequiredDeliveryDate = 2024-01-20' , the output will be '1'. If 'DocumentDate = 2023-10-05' and 'RequiredDeliveryDate = 2024-10-05' , the output will be '1'. ** Note The repository of the attribute is Crm.Sales.SalesOrder See more DATESPAN operator Difference between DATESPAN and DATEDIFF"
  },
  "advanced/calculated-attributes/operators/datespan.html": {
    "href": "advanced/calculated-attributes/operators/datespan.html",
    "title": "DATESPAN | ERP.net Tech Docs",
    "summary": "DATESPAN Specification Value Description Returns the difference between dates as a duration in the specified interval type. The interval is fulfilled when the same date and time is reached in the next interval. Parameter 1 Name StartDate Parameter 1 Type Date, DateTime Parameter 2 Name EndDate Parameter 2 Type Date, DateTime Parameter 3 Name Interval Parameter 3 Type String (Days, Months, Years). Defaults to Days if not specified. Return value If Interval = 'Days' then Days(EndDate - StartDate) If Interval = 'Months' then Months(EndDate - StartDate) If Interval = 'Years' then Years(EndDate - StartDate) Note Parameter 3 (Interval) accepts input in the form of a string, allowing you to specify the interval type as either 'Days' (alias 'D'), 'Months' (alias 'M'), or 'Years' (alias 'Y'). If you don't explicitly specify an interval type, it will default to 'Days'. Examples: 10: DATEDIFF ATTRIB:DocumentDate ATTRIB:RequiredDeliveryDate CONST:Days OUTPUT: If 'DocumentDate = 2020-01-01 23:59' and 'RequiredDeliveryDate = 2020-01-02 00:01' , the output will be '0'. If 'DocumentDate = 2020-01-01 23:58' and 'RequiredDeliveryDate = 2020-01-02 23:59' , the output will be '1'. If 'DocumentDate = 2023-09-20' and 'RequiredDeliveryDate = 2023-10-05', the output will be '15'. If 'DocumentDate = 2023-09-20' and 'RequiredDeliveryDate = 2023-09-10', the output will be '-10'. ** 10: 10: DATEDIFF ATTRIB:DocumentDate ATTRIB:RequiredDeliveryDate CONST:Months OUTPUT: If 'DocumentDate = 2023-09-20' and 'RequiredDeliveryDate = 2023-10-05' , the output will be '0'. If 'DocumentDate = 2023-09-20' and 'RequiredDeliveryDate = 2023-10-20' , the output will be '1'. ** 10: DATEDIFF ATTRIB:DocumentDate ATTRIB:RequiredDeliveryDate CONST:Years OUTPUT: If 'DocumentDate = 2023-10-05' and 'RequiredDeliveryDate = 2024-01-20' , the output will be '0'. If 'DocumentDate = 2023-10-05' and 'RequiredDeliveryDate = 2024-10-05' , the output will be '1'. ** Note The repository of the attribute is Crm.Sales.SalesOrder See more DATEDIFF operator Difference between DATESPAN and DATEDIFF"
  },
  "advanced/calculated-attributes/operators/divide.html": {
    "href": "advanced/calculated-attributes/operators/divide.html",
    "title": "DIVIDE | ERP.net Tech Docs",
    "summary": "DIVIDE Specification Value Name DIVIDE Description Divides one number by a second number. Parameter 1 Name Number1 Parameter 1 Type numeric type - int, double or decimal Parameter 2 Name Number2 Parameter 2 Type numeric type - int, double or decimal Parameter 3 Name Parameter 3 Type Return value Number1 / Number2 Make sure that the numbers of both parameters are from the same type. For example, Parameter 1 and Parameter 2 must be both integers, doubles, or decimals. Example: 10: DIVIDE ATTRIB:QuantityValue CONST:2.00 OUTPUT: If 'QuantityValue = 6.00', the output will be '3.00'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More examples: Calculate standart price per lot based on the ingredients and the operations in the recipe"
  },
  "advanced/calculated-attributes/operators/equal.html": {
    "href": "advanced/calculated-attributes/operators/equal.html",
    "title": "EQUAL | ERP.net Tech Docs",
    "summary": "EQUAL Specification Value Name EQUAL Description Checks if two values are equal. If that's the case, the return value is 'True', else - the return value is 'False'. Parameter 1 Name Value1 Parameter 1 Type numeric type - int, double or decimal; string; Parameter 2 Name Value2 Parameter 2 Type numeric type - int, double or decimal; string; Parameter 3 Name Parameter 3 Type Return value boolean (True or False) Make sure the compared values are from the same type. For example, Parameter 1 and Parameter 2 must be both integers, or doubles, or decimals, or strings. Example: 10: EQUAL ATTRIB:LineNo CONST:30 OUTPUT: If 'LineNo = 30', the output will be 'True'. If 'LineNo = 10', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More examples: Check if the quantity is a whole number Check whether the releasing of the document is first or not Get current availability of a product"
  },
  "advanced/calculated-attributes/operators/filter.html": {
    "href": "advanced/calculated-attributes/operators/filter.html",
    "title": "FILTER | ERP.net Tech Docs",
    "summary": "FILTER Specification Value Name FILTER Description Filters a specified list by a condition. Parameter 1 Name list Parameter 1 Type list of objects Parameter 2 Name condition Parameter 2 Type boolean Parameter 3 Name Parameter 3 Type Return value Returns sub-list which meets the condition. Example: Let's return a list with all lines in a document (sales order) whose quantity is '1.00': 10: FILTER CHILD:Lines EXP:30 30: EQUAL ATTRIB:QuantityValue CONST:1.00 Note The repository of the attribute is Crm.Sales.SalesOrders"
  },
  "advanced/calculated-attributes/operators/first.html": {
    "href": "advanced/calculated-attributes/operators/first.html",
    "title": "FIRST | ERP.net Tech Docs",
    "summary": "FIRST Specification Value Name FIRST Description Returns the first element in a list. Parameter 1 Name list Parameter 1 Type list of objects Parameter 2 Name Parameter 2 Type Parameter 3 Name Parameter 3 Type Return value The first element in the list. Note The criteria concerning which element is first may not meet your expectations. If sorting matters to you, please use FIRST together with the SORT and ORDERBY operators. Example: Let's return the first met line of a document (sales order): 10: FIRST CHILD:Lines Note The repository of the attribute is Crm.Sales.SalesOrders If you want to expand the example, you can sort the line in an ascending order by line number. This way, the atrribute will return the line with lowest line number: 10: FIRST EXP:20 20: SORT CHILD:Lines ATTR:LineNo CONST:ASC"
  },
  "advanced/calculated-attributes/operators/floor.html": {
    "href": "advanced/calculated-attributes/operators/floor.html",
    "title": "FLOOR | ERP.net Tech Docs",
    "summary": "FLOOR Specification Value Name FLOOR Description Returns the largest integer less than or equal to a specified number. Parameter 1 Name Number1 Parameter 1 Type double or decimal Parameter 2 Name Parameter 2 Type Parameter 3 Name Parameter 3 Type Return value Returns the largest integer less than or equal to Number1. Example: Let's get the largest integer that is less than or equal to the quantity of a sales order line: 10: FLOOR ATTRIB:QuantityValue OUTPUT: If 'QuantityValue = 14.85', the output will be '14'. If 'QuantityValue = 14', the output will be '14'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/formatstring.html": {
    "href": "advanced/calculated-attributes/operators/formatstring.html",
    "title": "FORMATSTRING | ERP.net Tech Docs",
    "summary": "FORMATSTRING Specification Value Description Returns a specified object formatted by specified rules. Parameter 1 Name Param1 Parameter 1 Type object (any type) Parameter 2 Name Format Parameter 2 Type constant Parameter 3 Name - Parameter 3 Type - Return value Param1 as a string formatted by the rule in Format. Note The format argument must contain a valid .NET format string, either as a standard string (\"C\" or \"D\") or as a pattern of custom characters for dates and numeric values (\"MMMM DD, yyyy (dddd)\"). For more information about supported format specifiers, see Format specifiers. Example: Let's see some formats and format specifiers: 10: FORMATSTRING CONST:DocumentDate CONST:yyyy MM dddd OUTPUT: If 'DocumentDate = 2020-03-15', the output will be '2020 03 Sunday'. (the language of the day of the week depends on the local regional settings) 10: FORMATSTRING ATTRIB:QuantityValue CONST:n6 OUTPUT: If 'QuantityValue = 150.00', the output will be '150,000000'. (the decimal symbol separator depends on the local regional settings) 10: FORMATSTRING ATTRIB:LineAmountValue CONST:C OUTPUT: If 'LineAmountValue = 150.00', the output will be '150.00 $'. (the decimal symbol separator and the currency symbol depends on the local regional settings) Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/getobjvalue.html": {
    "href": "advanced/calculated-attributes/operators/getobjvalue.html",
    "title": "GETOBJVALUE | ERP.net Tech Docs",
    "summary": "GETOBJVALUE Specification Value Description Gets a value from a specified object. Used when you want to retrieve a value from an object different from the current one. That object is listed in the Repository Name field of the current row. Parameter 1 Name obj Parameter 1 Type object Parameter 2 Name value Parameter 2 Type attribute value Parameter 3 Name - Parameter 3 Type - Return value Returns value from obj. Example: Let's return the value of Default Delivery Term Days set in the definition of a customer in a sales order: 10: GETOBJVALUE REF:Customer ATTRIB:DefaultDeliveryTermDays OUTPUT: If 'DefaultDeliveryTermDays = 5', the output will be '5'. Note The repository of the attribute is Crm.Sales.SalesOrders More examples: Check if a value of a field is changed in the adjustment document Get value and description of referent object"
  },
  "advanced/calculated-attributes/operators/getvalue.html": {
    "href": "advanced/calculated-attributes/operators/getvalue.html",
    "title": "GETVALUE | ERP.net Tech Docs",
    "summary": "GETVALUE Specification Value Description Gets the value of an object. Parameter 1 Name Value Parameter 1 Type attribute value Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value Value Example: Let's return the value of Notes in a sales order line: 10: GETVALUE ATTRIB:Notes OUTPUT: If 'Notes = Apple', the output will be 'Apple'. Note The repository of the attribute is Crm.Sales.SalesOrderLiness"
  },
  "advanced/calculated-attributes/operators/gt.html": {
    "href": "advanced/calculated-attributes/operators/gt.html",
    "title": "GT | ERP.net Tech Docs",
    "summary": "GT Specification Value Description Checks if an attribute value is greater than another attribute's value (or a constant). Parameter 1 Name attribute1 Parameter 1 Type numeric (int, double, decimal) or datetime type Parameter 2 Name attribute2 Parameter 2 Type numeric (int, double, decimal) or datetime type Parameter 3 Name - Parameter 3 Type - Return value If attribute1 > attribute2, the returned value is 'True', if else - the operator returns 'False'. Make sure that the compared attributes are from the same type. For example, Parameter 1 and Parameter 2 must be both integers, or doubles, or decimals, or datetime. Example: 10: GT ATTRIB:LineNo CONST:30 OUTPUT: If 'LineNo = 40', the output will be 'True'. If 'LineNo = 30', the output will be 'False'. If 'LineNo = 20', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More examples: Compare unit price and standard unit price"
  },
  "advanced/calculated-attributes/operators/gte.html": {
    "href": "advanced/calculated-attributes/operators/gte.html",
    "title": "GTE | ERP.net Tech Docs",
    "summary": "GTE Specification Value Description Checks if an attribute value is greater than or equal to another attribute's value (or a constant). Parameter 1 Name attribute1 Parameter 1 Type numeric (int, double, decimal) or datetime type Parameter 2 Name attribute2 Parameter 2 Type numeric (int, double, decimal) or datetime type Parameter 3 Name - Parameter 3 Type - Return value If attribute1 >= attribute2, the returned value is 'True', if else - 'False'. Make sure the compared attributes are from the same type. For example, Parameter 1 and Parameter 2 must be both integers, or doubles, or decimals, or datetime. Example: 10: GT ATTRIB:LineNo CONST:30 OUTPUT: If 'LineNo = 40', the output will be 'True'. If 'LineNo = 30', the output will be 'True'. If 'LineNo = 20', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/iferror.html": {
    "href": "advanced/calculated-attributes/operators/iferror.html",
    "title": "IFERROR | ERP.net Tech Docs",
    "summary": "IFERROR Specification Value Name IFERROR Description Evaluates an expression and returns a specified value if the expression returns an error. Otherwise returns the value of the expression itself. Parameter 1 Name Value Parameter 1 Type any type Parameter 2 Name ValueIfError Parameter 2 Type any type Parameter 3 Name Parameter 3 Type Return value When the expression returns a value other than error, then the value of the Parameter 1 is returned. When the expression evaluates to an error, then the value of the Parameter 2 is returned. Example: 10: IFERROR EXP:20 CONST:'Error in calculation' 20: DIVIDE CONST:2.00 ATTRIB:QuantityValue OUTPUT: If 'QuantityValue = 1.00', the output will be 2. If 'QuantityValue = 0.00', the output will be 'Error in calculation'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/iif.html": {
    "href": "advanced/calculated-attributes/operators/iif.html",
    "title": "IIF | ERP.net Tech Docs",
    "summary": "IIF Specification Value Description Depending on a specified condition, it returns the second or the third argument. Parameter 1 Name Condition Parameter 1 Type Boolean Parameter 2 Name TrueValue Parameter 2 Type any type Parameter 3 Name FalseValue Parameter 3 Type any type Return value When Condition is 'True', it returns the TrueValue. When Condition is 'False', it returns the FalseValue Example: 10: IIF EXP:20 CONST:'Quantity is 1.00' CONST: 'Quantity is not 1.00' 20: EQUAL ATTRIB:QuantityValue CONST:1.00 OUTPUT: If 'QuantityValue = 1.00', the output will be 'Quantity is 1.00'. If 'QuantityValue = 2.00', the output will be 'Quantity is not 1.00'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More examples: Compare unit price and standard unit price Check if a value of a field is changed in the adjustment document"
  },
  "advanced/calculated-attributes/operators/in.html": {
    "href": "advanced/calculated-attributes/operators/in.html",
    "title": "IN | ERP.net Tech Docs",
    "summary": "IN Specification Value Description Determines if a specified value matches any value from a list. Used in combination with SELECT and FILTER as condition. It can be used to search through values of string and guid types. It cannot be used to search through numeric values or dates. Parameter 1 Name param Parameter 1 Type String or Guid Parameter 2 Name list of values Parameter 2 Type the values must be equal to the param type Parameter 3 Name - Parameter 3 Type - Return value True or False depending on whether a parameter equals a member from a list of values. Note Single quotes are only necessary when the compared values are strings. Example: Let's check whether there are sales orders with notes 'Apple' and 'Pear' in the datatabase: 10: SELECT REPO:Crm.Sales.SalesOrders EXP:20 20: WHERE EXP:30 30: IN ATTRIB:Notes CONST:'Apple', 'Pear' OUTPUT: If there is at least one sales order with 'Notes = Apple', the output will be 'True'. If there is at least one sales order with 'Notes = Pear', the output will be 'True'. If there are NO sales orders with 'Notes = Apple OR Pear', the output will be 'False'."
  },
  "advanced/calculated-attributes/operators/incnum.html": {
    "href": "advanced/calculated-attributes/operators/incnum.html",
    "title": "INCNUM | ERP.net Tech Docs",
    "summary": "INCNUM Specification Value Description Increases the value of its parameter by 1. Can be used only with string values whose last character is a number. Allows for consecutive numbering of documents and nomenclatures. Parameter 1 Name Value Parameter 1 Type string Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value ++Value Note If you try incrementing a string whose last character is 'AA01', the incrementation will be successful and result will be 'AA02'. If you increment a value of type decimal, int or date, the incrementation will be unsuccessful and the attribute won't compilate. If the value is a string whose last character isn't a number ('AA', for example), the incrementation won't be successful. Example: Let's see how to increase the LotNumber of a lot by 1: 10: INCNUM ATTRIB:Number OUTPUT: If 'Number = 0001'', the output will be '0002'. If 'Number = AA01'', the output will be 'AA02'. Note The repository of the attribute is Logistics.Inventory.Lots"
  },
  "advanced/calculated-attributes/operators/index.html": {
    "href": "advanced/calculated-attributes/operators/index.html",
    "title": "Operators | ERP.net Tech Docs",
    "summary": "Operators ADD ADDDAYS AND CAST CEILING CONCAT CONVERT COUNT DATEDIFF DATESPAN DIVIDE EQUAL FILTER FIRST FLOOR FORMATSTRING GETOBJVALUE GETVALUE GT GTE IFERROR IIF IN INCNUM INTERPOLATE LEFT LEN LIKE LIST LT LTE MULTIPLY NOT OR ORDERBY POS REGEX REPLACE RIGHT ROUND SELECT SORT SUBSTRING SUM TODAY TOLOWER TOP TOUPPER WHERE"
  },
  "advanced/calculated-attributes/operators/interpolate.html": {
    "href": "advanced/calculated-attributes/operators/interpolate.html",
    "title": "INTERPOLATE | ERP.net Tech Docs",
    "summary": "INTERPOLATE Specification Value Description Performs a string interpolation, according to the context of the input or explicitly passed object. Parameter 1 Name InterpolatedString Parameter 1 Type string Parameter 2 Name InterpolationContext (optional) Parameter 2 Type object (DomainObject) Parameter 3 Name - Parameter 3 Type - Return value Returns a string, result from the string interpolation. Warning The interpolate operator fully depends on the ERP.net string interpolation functionality. All expressions in Parameter 1 must conform to the specification. Examples: Note The repository of the calculated attribute is Crm.Customers. Let's try with something simple. We'll get the country name of the enterprise company for each customer. In English. 10: INTERPOLATE CONST: Customer's enterprise company country of origin: {EnterpriseCompany.Company.Country.Name:en} OUTPUT: Enterprise company country of origin: Bulgaria EXPLAINED: The essential part of the CONST parameter is enclosed in curly braces {}. It means the following: { - start of a single interpolated string expression. EnterpriseCompany - follow the enterprise company reference of the customer. .Company - follow the company reference of the enterprise company. .Country - follow the country reference. .Name - get the Name attribute. :en - because it's a multilanguage string - show it in English. } - end of the interpolated string expression. Now let's involve a system variable. 10: INTERPOLATE CONST: What year is it? {$datetime:yyyy}; Who am I? {$user.Name:en}. OUTPUT: What year is it? 2023; Who am I? John Doe EXPLAINED: $datetime is the system variable for the current date and time. It's followed by the :yyyy format specifier, \"extracting\" just the year part. $user is the currently logged in user. And with .Name we're getting its Name attribute. :en in English. This example wasn't very practical, but it demonstrates a powerful feature- the system variables. The next example is something quite useful. We'll define a calculated attribute, returning its data in JSON format. Just with a single line. 10: INTERPOLATE CONST: {{\"Timestamp\": \"{$datetimeutc}\", \"Id\": \"{Id}\", \"Number\": \"{Number}\", \"Active\": {Active}, \"Name\": \"{Party.PartyName:en}\", \"SalesPerson\": \"{SalesPerson.Person.PartyName:en}\"}} OUTPUT: { \"Timestamp\":\"2023-01-18 12:46:37\", \"Id\":\"901d254b-7ad9-44e4-ab96-0668e9258311\", \"Number\":\"ab30162\", \"Active\":true, \"Name\":\"Test PK 1\", \"SalesPerson\":\"\" } See more String interpolation"
  },
  "advanced/calculated-attributes/operators/left.html": {
    "href": "advanced/calculated-attributes/operators/left.html",
    "title": "LEFT | ERP.net Tech Docs",
    "summary": "LEFT Specification Value Description Gets the first N characters of a string (starting from left). Parameter 1 Name String Parameter 1 Type string Parameter 2 Name NumChars Parameter 2 Type int Parameter 3 Name - Parameter 3 Type - Return value Returns the first numchars characters of the string. Example: Let's return the first 3 characters of the notes set in a sales order: 10: LEFT ATTRIB:Notes CONST:3 OUTPUT: If 'Notes = Apple', the output will be 'App'. If 'Notes = I am', the output will be 'I a'. Note The repository of the attribute is Crm.Sales.SalesOrders."
  },
  "advanced/calculated-attributes/operators/len.html": {
    "href": "advanced/calculated-attributes/operators/len.html",
    "title": "LEN | ERP.net Tech Docs",
    "summary": "LEN Specification Value Description Returns the length of a string. Parameter 1 Name String Parameter 1 Type string Description Returns the length of a string. Parameter 1 Name String Parameter 1 Type string Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value The string's length. Return value The string's length. Note It is important to note that if the string being passed to the LEN function is null, it will return an error. Therefore, it is recommended to add an IF > > > operator to check whether the string is null before passing it to the LEN function. This will prevent any errors from occurring and ensure that the function > > works as intended. Example: | 10 | IIF EXP 7 CONST 0 EXP 10 | | 20 | EQUAL ATTRIB DocumentNotes CONST Null | | 30 | LEN ATTRIB DocumentNotes |"
  },
  "advanced/calculated-attributes/operators/like.html": {
    "href": "advanced/calculated-attributes/operators/like.html",
    "title": "LIKE | ERP.net Tech Docs",
    "summary": "LIKE Specification Value Description Searches for a specified pattern in a string. Used in combination with the wildcars '%' and '_': The '%' symbol defines 0 or more characters before and after the searched string. '_' is used to define 1 specific character. Parameter 1 Name String1 Parameter 1 Type string Parameter 2 Name Mask Parameter 2 Type string Parameter 3 Name - Parameter 3 Type - Return value True in case String1 matches Mask. False in case String1 doesn't match Mask. Examples: 'a%' → Finds any values starting with \"a\". '%a' → Finds any values ending with \"a\". '%a%' → Finds any values having \"a\" in any position. 'a%' → Finds any values having \"a\" in second position. 'a_%%' → Finds any values starting with \"a\" and at least 3 characters in length. 'a%o' → Finds any values starting with \"a\" and ending with \"o\". The following example returns 'True' if the string contains 'Apple'. After 'Apple', there is exactly one character: 10 LIKE ATTRIB:Notes CONST:%Apple_ OUTPUT: If 'Notes = Apples', the output will be 'True'. If 'Notes = Green apples', the output will be 'True'. If 'Notes = apples', the output will be 'False'. If 'Notes = Apple', the output will be 'False'. If 'Notes = Green bananas', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrders."
  },
  "advanced/calculated-attributes/operators/list.html": {
    "href": "advanced/calculated-attributes/operators/list.html",
    "title": "LIST | ERP.net Tech Docs",
    "summary": "LIST Specification Value Description Returns a list with string values of a specified attribute from a list of objects. The values in the list are separated. If there's no indicated separator, the list is separated with \", \" (comma + space) by default. Parameter 1 Name list Parameter 1 Type list of objects Parameter 2 Name attribute Parameter 2 Type attribute of the object // An attribute of a referent object could be used as well. See the example below. Parameter 3 Name separator (optional) // If Parameter3 is not specified, then the default separator is \", \" (comma + space) Parameter 3 Type string Return value (attributeValue1, attributeValue2, ...) Introduced in version 2019.1 Note The operator creates a list with limited number of values - only the top 100 records of the indicated list of objects will be 'converted'. Example: 10: LIST CHILD:Lines EXP:20 CONST:'; ' 20: GETOBJVALUE REF:Product ATTRIB:Name OUTPUT: 'ProductsName1; ProductName2 ...' Note The repository of the attribute is Crm.Sales.SalesOrders"
  },
  "advanced/calculated-attributes/operators/lt.html": {
    "href": "advanced/calculated-attributes/operators/lt.html",
    "title": "LT | ERP.net Tech Docs",
    "summary": "LT Specification Value Description Checks if an attribute value is smaller than another attribute's value (or a constant). Parameter 1 Name attribute1 Parameter 1 Type numeric (int, double, decimal) or datetime type Parameter 2 Name attribute2 Parameter 2 Type numeric (int, double, decimal) or datetime type Parameter 3 Name - Parameter 3 Type - Return value If attribute1 < attribute2, the returned value is 'True', if else - the operator returns 'False'. Make sure the compared attributes are from the same type. For example, Parameter 1 and Parameter 2 must be both integers, or doubles, or decimals, or datetime. Example: 10: LT ATTRIB:LineNo CONST:30 OUTPUT: If 'LineNo = 20', the output will be 'True'. If 'LineNo = 30', the output will be 'False'. If 'LineNo = 40', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/lte.html": {
    "href": "advanced/calculated-attributes/operators/lte.html",
    "title": "LTE | ERP.net Tech Docs",
    "summary": "LTE Specification Value Description Checks if an attribute value is smaller than or equal to another attribute's value (or a constant). Parameter 1 Name attribute1 Parameter 1 Type numeric (int, double, decimal) or datetime type Parameter 2 Name attribute2 Parameter 2 Type numeric (int, double, decimal) or datetime type Parameter 3 Name - Parameter 3 Type - Return value If attribute1 <= attribute2, the returned value is 'True', if else - the operator returns 'False'. Make sure the compared attributes have the same type. For example, Parameter 1 and Parameter 2 must be both integers, or doubles, or decimals, or datetime. Learn more in Compare unit price and the standard unit price. Example: 10: LTE ATTRIB:LineNo CONST:30 OUTPUT: If 'LineNo = 20', the output will be 'True'. If 'LineNo = 30', the output will be 'True'. If 'LineNo = 40', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/multiply.html": {
    "href": "advanced/calculated-attributes/operators/multiply.html",
    "title": "MULTIPLY | ERP.net Tech Docs",
    "summary": "MULTIPLY Specification Value Description Multiplies specified numbers. Parameter 1 Name Number1 Parameter 1 Type numeric type - int, double or decimal Parameter 2 Name Number2 Parameter 2 Type numeric type - int, double or decimal Parameter 3 Name - Parameter 3 Type - Return value Number1 * Number2 Make sure the numbers of both parameters are from the same type. For example, Parameter 1 and Parameter 2 must be both integers, doubles, or decimals. Example: 10: MULTIPLY ATTRIB:QuantityValue CONST:2.00 OUTPUT: If 'QuantityValue = 3.00', the output will be '6.00'. Note The repository of the attribute is Crm.Sales.SalesOrderLines More examples: Total quantity and scrap quantity in recipe ingredients."
  },
  "advanced/calculated-attributes/operators/not.html": {
    "href": "advanced/calculated-attributes/operators/not.html",
    "title": "NOT | ERP.net Tech Docs",
    "summary": "NOT Specification Value Description Returns logical negation on an expression. Parameter 1 Name Condition Parameter 1 Type boolean Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value 'False' - if Condition is true; 'True' - if Condition is false Example: 10: NOT EXP:20 20: EQUAL ATTRIB:LineNo CONST:10 OUTPUT: If 'LineNo = 10', the output will be 'False'. If 'LineNo = 20', the output will be 'True'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/or.html": {
    "href": "advanced/calculated-attributes/operators/or.html",
    "title": "OR | ERP.net Tech Docs",
    "summary": "OR Specification Value Description Checks if any conditions are true. If so - the operator returns 'True'. If all specified conditions aren't true, the operator returns 'False'. Parameter 1 Name Condition1 Parameter 1 Type boolean Parameter 2 Name Condition2 Parameter 2 Type boolean Parameter 3 Name - Parameter 3 Type - Return value Condition1 OR Condition2 Example: 10: OR EXP:20 EXP:30 20: EQUAL ATTRIB:LineNo CONST:10 30: EQUAL ATTRIB:LineNo CONST:20 OUTPUT: If 'LineNo = 10', the output will be 'True'. If 'LineNo = 20', the output will be 'True'. If 'LineNo = 30', the output will be 'False'. Note The repository of the attribute is Crm.Sales.SalesOrderLines"
  },
  "advanced/calculated-attributes/operators/orderby.html": {
    "href": "advanced/calculated-attributes/operators/orderby.html",
    "title": "ORDERBY | ERP.net Tech Docs",
    "summary": "ORDERBY Specification Value Description Specifies a column or expression on which the query result set is sorted. Used as a clause of SELECT. Parameter 1 Name attribute Parameter 1 Type any type Parameter 2 Name order (optional) // if not set, the default is ASC Parameter 2 Type const - ASC or DESC Parameter 3 Name inner clauses (optional) Parameter 3 Type expression Return value Ordered result set of a query by the specified column or expression. Introduced in version 2020 Note Not all attributes support sorting by ORDERBY. You can check if the attribute supports ORDERBY in the \"Supports Order By: True/False\" property of the attribute. The information is available in the Attribute Details section in the model documentation of the entity. E.g. https://docs.erp.net/model/entities/Crm.Sales.SalesOrders.html#documentdate Example: Select the last 5 Sales Order Lines sorted by Sales Order's document date . 10: SELECT REPO:Crm.Sales.SalesOrderLines EXP:20 20: TOP CONST:5 EXP:30 30: ORDERBY EXP:40 CONST:DESC EXP:50 40: GETOBJVALUE REF:SalesOrder ATTRIB:DocumentDate 50: WHERE ..."
  },
  "advanced/calculated-attributes/operators/pos.html": {
    "href": "advanced/calculated-attributes/operators/pos.html",
    "title": "POS | ERP.net Tech Docs",
    "summary": "POS Specification Value Description Searches terms in string. Returns first position, or '-1', if not found. Parameter 1 Name term Parameter 1 Type string Parameter 2 Name string Parameter 2 Type string Parameter 3 Name - Parameter 3 Type - Return value Returns the position of a term in string. If there are more occurrences of a term in string, it returns the first position. If the term is not part of the string, it returns '-1'."
  },
  "advanced/calculated-attributes/operators/regex.html": {
    "href": "advanced/calculated-attributes/operators/regex.html",
    "title": "REGEX | ERP.net Tech Docs",
    "summary": "REGEX Specification Value Description Returns whether a string matches the regex mask or not. Parameter 1 Name String1 Parameter 1 Type string Parameter 2 Name Mask Parameter 2 Type regex expression Parameter 3 Name - Parameter 3 Type - Return value 'True' - if String1 matches Mask; 'False' - if String1 doesn't match Mask ."
  },
  "advanced/calculated-attributes/operators/replace.html": {
    "href": "advanced/calculated-attributes/operators/replace.html",
    "title": "REPLACE | ERP.net Tech Docs",
    "summary": "REPLACE Specification Value Description Replaces an old value in a string with a new one. Parameter 1 Name String1 Parameter 1 Type string Parameter 2 Name OldValue Parameter 2 Type string Parameter 3 Name NewValue Parameter 3 Type string Return value A string that is equivalent to String1, except that all instances of OldValue are replaced with NewValue. If OldValue isn't found in String1, the operator returns String1."
  },
  "advanced/calculated-attributes/operators/right.html": {
    "href": "advanced/calculated-attributes/operators/right.html",
    "title": "RIGHT | ERP.net Tech Docs",
    "summary": "RIGHT Specification Value Description Gets the last N characters of a string. Parameter 1 Name String Parameter 1 Type string Parameter 2 Name NumChars Parameter 2 Type int Parameter 3 Name - Parameter 3 Type - Return value Returns the last NumChars characters of String."
  },
  "advanced/calculated-attributes/operators/round.html": {
    "href": "advanced/calculated-attributes/operators/round.html",
    "title": "ROUND | ERP.net Tech Docs",
    "summary": "ROUND Specification Value Description Rounds mathematically with specified precision. Parameter 1 Name Number Parameter 1 Type double or decimal Parameter 2 Name DecimalPlaces (optional) Parameter 2 Type int (optional) // if not set, it's considered 0 Parameter 3 Name - Parameter 3 Type - Return value A number rounded up to the digit, specified in DecimalPlaces."
  },
  "advanced/calculated-attributes/operators/select.html": {
    "href": "advanced/calculated-attributes/operators/select.html",
    "title": "SELECT | ERP.net Tech Docs",
    "summary": "SELECT Specification Value Description Gets objects that match clauses. Parameter 1 Name Repository Parameter 1 Type repository Parameter 2 Name Clauses (optional, but highly recommended) // For more information, see the section below) Parameter 2 Type operators (WHERE, TOP) Parameter 3 Name - Parameter 3 Type - Return value Returns a list of objects from Repository that matches Clauses. Note SELECT returns a limited number of records - 20 000. This limit is only for the returned records count. It's recommended to set as many filters as possible. (in the WHERE clause). Example: The [WHERE] clause of the SELECT statement supports the following operators: AND TOP EQUAL GT GTE LT LTE Operators not supported by SELECT but used by the FILTER operator are: NOT OR LIKE FILTER AND WHERE filtering of a SELECT Having this in mind, it's really important to extract lists from the database. When using SELECT, you send a request to the database with as many [WHERE] filters as possible. If there's an unsupported filter, then the list returned by SELECT may be filtered additionally by [FILTER]. A SELECT statement makes a direct request to the database, which may influence productivity and slow down the calculation of the attribute. When using SELECT, you have to apply as many [WHERE] filters as possible, because this would limit the amount of data extracted from the database into the client. If SELECT doesn't provide enough filters, the result may be filtered by [FILTER], which operates on data already loaded in the client. Examples: Let's say you need a list of documents whose DocumentTypeId is equal to 'bbd8e7ae-c0e0-4c1b-8730-7d68fa52971e' or '89ca5ca4-ad57-44c7-9b33-2ff44e054bff'. The documents are work orders. The following calculated attribute would be incorrect and return errors when used: 10: SELECT REPO:Production.ShopFloor.WorkOrders EXP:20 20: WHERE EXP:30 30: OR EXP:40 EXP:50 40: EQUAL CONST:bbd8e7ae-c0e0-4c1b-8730-7d68fa52971e 45: ATTRIB:DocumentTypeId CONST:System.Guid 50: EQUAL EXP:45 CONST:89ca5ca4-ad57-44c7-9b33-2ff44e054bff You can set an attribute which selects the work orders. Then, to filter the list which the SELECT operator returned, apply the [FILTER] operator for more precision. The correct calculated attribute is as follows: 10: FILTER EXP:20 EXP:30 20: SELECT REPO:Production.ShopFloor.WorkOrders 30: OR EXP:40 EXP:50 40: EQUAL EXP:45 CONST:bbd8e7ae-c0e0-4c1b-8730-7d68fa52971e 45: CAST ATTRIB:DocumentTypeId CONST:System.Guid 50: EQUAL ATTRIB:DocumentTypeId CONST:89ca5ca4-ad57-44c7-9b33-2ff44e054bff"
  },
  "advanced/calculated-attributes/operators/sort.html": {
    "href": "advanced/calculated-attributes/operators/sort.html",
    "title": "SORT | ERP.net Tech Docs",
    "summary": "SORT Specification Value Description Sorts an input list according to a specified attribute and order. Parameter 1 Name list Parameter 1 Type list Parameter 2 Name attribute Parameter 2 Type any type Parameter 3 Name order (optional) Parameter 3 Type string - ASC or DESC Return value Returns the input list from parameter1, sorted by the specified attribute and in the specified order. If not specified, the default order is ascending (ASC) Example: Take the last line of a sales order (ordered by LineNo), which has quantity >= 0: 10: FIRST EXP:20 20: SORT EXP:30 ATTR:LineNo CONST:DESC 30: FILTER CHILD:Lines EXP:40 40: GTE ATTR:QuantityValue CONST:0"
  },
  "advanced/calculated-attributes/operators/substring.html": {
    "href": "advanced/calculated-attributes/operators/substring.html",
    "title": "SUBSTRING | ERP.net Tech Docs",
    "summary": "SUBSTRING Specification Value Description Returns a sub-string with specified start and length. Parameter 1 Name string Parameter 1 Type string Parameter 2 Name start Parameter 2 Type int Parameter 3 Name len Parameter 3 Type int Return value Part of string, starting from position start and with length of len."
  },
  "advanced/calculated-attributes/operators/sum.html": {
    "href": "advanced/calculated-attributes/operators/sum.html",
    "title": "SUM | ERP.net Tech Docs",
    "summary": "SUM Specification Value Description Returns the sum of a value for all elements in a specified list. Parameter 1 Name List Parameter 1 Type list of objects Parameter 2 Name Value Parameter 2 Type numeric type - int, double or decimal Parameter 3 Name - Parameter 3 Type - Return value Returns the sum of the values of the elements in List. More examples: Sales amounts of the customer for the last 30 days"
  },
  "advanced/calculated-attributes/operators/today.html": {
    "href": "advanced/calculated-attributes/operators/today.html",
    "title": "TODAY | ERP.net Tech Docs",
    "summary": "TODAY Specification Value Description Returns today's date, according to the server's regional settings. Parameter 1 Name - Parameter 1 Type - Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value Today's date"
  },
  "advanced/calculated-attributes/operators/tolower.html": {
    "href": "advanced/calculated-attributes/operators/tolower.html",
    "title": "TOLOWER | ERP.net Tech Docs",
    "summary": "TOLOWER Specification Value Description Returns a string converted to lowercase. Parameter 1 Name string Parameter 1 Type string Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value string (in lowercase)"
  },
  "advanced/calculated-attributes/operators/top.html": {
    "href": "advanced/calculated-attributes/operators/top.html",
    "title": "TOP | ERP.net Tech Docs",
    "summary": "TOP Specification Value Description Clause returning only the first N elements Parameter 1 Name Number Parameter 1 Type int Parameter 2 Name Clauses Parameter 2 Type operator WHERE Parameter 3 Name - Parameter 3 Type - Return value The first Number elements. Note This operator is used with WHERE. Example: 10: SELECT REPO:General.Products.Products EXP:20 20: TOP CONST:5 EXP:30 30: WHERE ..."
  },
  "advanced/calculated-attributes/operators/toupper.html": {
    "href": "advanced/calculated-attributes/operators/toupper.html",
    "title": "TOUPPER | ERP.net Tech Docs",
    "summary": "TOUPPER Specification Value Description Returns а string converted to uppercase. Parameter 1 Name string Parameter 1 Type string Parameter 2 Name - Parameter 2 Type - Parameter 3 Name - Parameter 3 Type - Return value string (in uppercase)"
  },
  "advanced/calculated-attributes/operators/where.html": {
    "href": "advanced/calculated-attributes/operators/where.html",
    "title": "WHERE | ERP.net Tech Docs",
    "summary": "WHERE Specification Value Description Clause which filters by the specified conditions. The second and the third parameters are optional. Parameter 1 Name Condition1 Parameter 1 Type boolean Parameter 2 Name boolean Parameter 2 Type Condition2 (optional) Parameter 3 Name boolean Parameter 3 Type Condition3 (optional) Return value Clause, filtered by Condition1, Condition2 AND Condition3 Note This operator is used with SELECT."
  },
  "advanced/calculated-attributes/parameter-types/const.html": {
    "href": "advanced/calculated-attributes/parameter-types/const.html",
    "title": "CONST | ERP.net Tech Docs",
    "summary": "CONST CONST indicates that the value for a parameter type is a constant for every calculation of the attribute. The formats of the different types of values which are entered are as follows: Value Description Example NULL null or empty value NULL Boolean true or false value True Integer a whole number that can be positive, negative, or zero 93 Decimal number, containing decimal symbol - '.' 93.012 Date date values used in the 'yyyy-MM-dd' format 2020-12-25 GUID Global Unique Identifier - used for objects identification 6B29FC40-CA47-1067-B31D-00DD010662DA String explicitly denoted string, entered in single quotation marks 'Example text.' Type used with CAST for type conversions; the constant is the type to which you want to convert. System.Int32 Everything else is treated as string!"
  },
  "advanced/calculated-attributes/parameter-types/index.html": {
    "href": "advanced/calculated-attributes/parameter-types/index.html",
    "title": "Parameter types | ERP.net Tech Docs",
    "summary": "Parameter types The type of a parameter specifies how you can obtain a parameter value. CONST - this value would be a constant for every calculation of the attribute. ATTRIB - the value of system or user-defined attribute; REF - reference to another object; CHILD - detailed objects, related to the current master object; EXP - the value of the expression with the specified number (in the Value field); INPUT - the input parameter for the specified expression number (in the Value field); REPO - a repository; SYS - the value of a particular system variable such as Login, Today, EnterpriseCompanyId, etc. The parameter types are used in every calculated attributes. Here are some examples. See more CONST SYS"
  },
  "advanced/calculated-attributes/parameter-types/sys.html": {
    "href": "advanced/calculated-attributes/parameter-types/sys.html",
    "title": "SYS | ERP.net Tech Docs",
    "summary": "SYS SYS is used with system variables. They can be applied when you need to acquire information for the current user, date, time, enterprise company and others. Here's a list of those variables: Value Description Example (returned value) Login The login of the user that's logged into the program. admin UserId The ID of the user that's currently logged in the program. 9da64839-a8d0-491d-aebb-4d18fa42b014 RoleName The name of role that's currently set for the user. Administration RoleId The role that is currently set for the user. c764ff2b-38ca-4906-893a-2a21a1691f43 Today Current date. 23.6.2017 0:00:00 Now Current date-time from the server time zone. 23.6.2017 13:25:33 UtcNow Current date-time in Coordinated Universal Time (UTC) 23.6.2017 10:25:33 EnterpriseCompanyId The ID of the enterprise company that's set for the user. b0e80577-fbbe-4c9b-811e-20b6c6dd465f EnterpriseCompanyLocationId The ID of the enterprise company location that's currently set for the user. f2947790-e21f-4def-b533-fdc00a343ce6 Example: 10: GETVALUE SYS:Login The line returns the login of the user who's currently logged into the program."
  },
  "advanced/concepts/aggregates.html": {
    "href": "advanced/concepts/aggregates.html",
    "title": "Aggregates | ERP.net Tech Docs",
    "summary": "Aggregates Aggregates are patterns in domain-driven design. A DDD aggregate is a cluster of domain objects that can be treated as a single unit. For an order and its line-items, aggregates will be separate objects, but it's useful to treat them as a single aggregate. Learn more here. In ERP.net, these are single aggregates: a SalesOrder the sales order lines of this sales order the distributed amounts for each of these sales order lines the document amounts of this sales order the payment plan of this sales order Parent and root objects Each object in an aggregate can have a parent object. The parent is the logical \"owner\" of the child object(s). For example: The parent of a sales order line is sales order. The parent of a distributed amount is the sales order line. The ultimate object, which has no parent in the aggregate, is the aggregate root. Here, this is the sales order. Aggregate events The Commit and ClientCommit events are now available in two different variations: object commit / client-commit aggregate commit / alient-commit What's the difference? When an object commit event occurs, it means the object itself was changed. The aggregate event occurs for the object when there's a change in ANY of its constituent objects, but only if the object is an aggregate root. Let's take a look at the following structure, which is a single aggregate in ERP.net: a SalesOrder (which is the aggregate's root) the sales order lines of this sales order the distributed amounts for each of these sales order lines the document amounts of this sales order the payment plan of this sales order A COMMIT event would occur for the sales order only if the sales order object itself has changed. An AGGREGATE CLIENT COMMIT event will occur for the sales order if any of the objects in the aggregate has changed. Changing a single sales order line without changing the order itself would still trigger the aggregate event. Note Commit and client-commit have the same meaning. Commit is a low-level event triggered for anything committed to the database. Client-commit is triggered by client requests and is the more light-weight approach. Currently, only the agregate client commit event is available for user-defined business rules. The aggregate commit will be used only internally, for system-defined business rules The end goal is to have a lighter approach. See also: Systems.Core.ExtensibleDataObjects Entity"
  },
  "advanced/concepts/default-language.html": {
    "href": "advanced/concepts/default-language.html",
    "title": "Default language | ERP.net Tech Docs",
    "summary": "Default language"
  },
  "advanced/concepts/index.html": {
    "href": "advanced/concepts/index.html",
    "title": "Concepts | ERP.net Tech Docs",
    "summary": "Concepts Aggregates Object relational mapping Master / Detail attributes Scheduled document events Default language Webhooks Real-time events"
  },
  "advanced/concepts/master-detail-attributes.html": {
    "href": "advanced/concepts/master-detail-attributes.html",
    "title": "Master / Detail attributes | ERP.net Tech Docs",
    "summary": "Master / Detail attributes When a document has identical fields in its header and lines, these fields interact in a specific manner. An example is the Store field in the sales order header and lines. If a field in the document header has a value, you need to make sure that the corresponding field in the document lines contains the same value. On the other hand, if the different lines contain different values, the document's header field should be empty. When this principle isn't obeyed and the Store field in the document header contains a value despite the document lines having different store values, you may look in the header and think that this store applies to all of its lines as well, which may not be true. Concepts and rules To make sure the main principles are followed, requirements and rules apply to each set of Master/Detail fields. Concepts In order to allow different lines to contain different stores and at the same time follow the main principle, you need to make sure that the Store field in the document header contains empty (NULL) values. Such values are set only when the document lines have different values. In contrast, the value in the field in the document lines is required/mandatory (TRUE) and must always contain a value. The main/leading field is the required/mandatory field in the lines. It's set to always contain a value. For example, if you're generating a store order from a sale order, the Store field taken into account is the one in the sales order lines. You need to create a separate store order for each store line in order to execute the sales order correctly. Keep in mind that in store orders, there's only one Store field, and it's in the header. If the document doesn't contain any lines, then there's no limitation for the document header value. It doesn't matter if it's empty (NULL) or if it contains a value (not-NULL). Front-end rules When the value of a document header's field is changed, it's automatically set to ALL document lines. When all document lines have the same value in the Store field, the field in the document header must contain the same value. The presence of a value in the document header field makes it unnecessary to constantly monitor whether the lines have different values or not. When editing the value in the Line Store field or deleting lines, if it turns out that all lines contain the same Store value, this value is automatically set in the document header field. When different document lines have different values in the Store field, the field in the document header must be empty (NULL). For this reason, after editing the value in the Line Store field and when deleting lines, if it turns out that the line contains a different Store value, then this value is automatically set as empty in the document header. When adding a new line, you're setting the default value in the Line Store field, which equals the one in the document header (unless another default value is explicitly set). If the document header value is empty (NULL), the value from the previous lines is considered as a default value in the new line. If this is impossible, then the default value remains empty (NULL). Back-end rules When the document header is saved, the master/detail field's value is updated according to the value of the lines field. If all lines contain the same Store value, it's automatically set in the document header field. If the lines contain different Store values, the Store field is automatically set to NULL. When а document line is saved, the master/detail field's value is updated according to the value of the field in the header. When the document's header and lines are saved, there is a final back-end validation. If it turns out that despite the rules above, the values of the master/detail fields are invalid, an error is thrown: The master attribute '{the name of the field in the header}' should have the same values as the detail '{the name of the field in the lines}' attribute for all lines or null, if there are different values through the lines."
  },
  "advanced/concepts/object-relational-mapping.html": {
    "href": "advanced/concepts/object-relational-mapping.html",
    "title": "Object relational mapping | ERP.net Tech Docs",
    "summary": "Object relational mapping Entities and entity types frequently used terms throughout the documentation. Entities are information object which represent real-world objects. Entity types are a collection of all objects of a given type. For example, customer 'XYZ' is an entity. Customer 'ABC' is another entity. All customers are of an entity type called 'Customers'. Definitions Entity - A single object of a given entity type. Also called 'entity object' or simply 'object'. Entity type - The set of all objects of a given type. Attribute - A named value containing information about an entity object. Relationship to tables and rows This section contains more advanced information not usually needed to operate the system. However, a deeper understanding of the inner-workings might help when you need to access an ERP.net database directly using database tools. Generally, entity types, entities, and attributes are much like tables, rows, and columns. Data of the entities is ultimately stored in the database in the form of tables and rows. There's one important distinction: entity types and entities are object-oriented representation of table data. A technology called ORM (Object-Relational Mapping) is used to map between entities and tables. In order to illustrate the difference between objects and tables, let's include real-world tables and objects: There's an entity type called 'Party'. It has two descendants (more specialized) entity types called 'Company' and 'Person'. 'Party' is the more abstract and broad term, while 'Company' and 'Person' are just specializations. Let's illustrate this: Party +---- company +---- person Each party has some attributes such as 'parent party' and 'area'. Each company has 'VAT number' and 'registration type' attributes. Each person has 'first name' and 'last name'. Now, if you look at the tables, they have the following schema: Parties Party Id Parent party Id Area Id Companies Party Id VAT number Registration type Person Party Id First name Last name If you look at the objects, they'll have the following attributes: Party Parent rty Area Company Parent party Area VAT Number Registration type Person Parent party Area First name Last name If you use table data to access all attributes of a company or a person, you need to relate (join) data from different tables using unique identifiers. These are 'surrogate keys' - they exist only in the database and have no real-world counterpart. Using such keys and relating data between tables is normal in the world of databases. Internally, the systems use objects because it's much easier to process them. Objects already have all necessary attributes related together and there's no need to use identifiers or table relations. Conclusion This is only an introduction to the topic of object-relational mapping. A deeper look would exceed the developer details of the subject."
  },
  "advanced/concepts/real-time-events.html": {
    "href": "advanced/concepts/real-time-events.html",
    "title": "Real-time events | ERP.net Tech Docs",
    "summary": "Real-time events The real-time events are a core part of ERP.net. As the name suggests, these are events that are triggered in real time. As an end-user experience, the real-time events may seem as \"live notifications\" (and in a matter of fact they are), but ERP.net makes a distinction between these terms. Note A notification is a \"first-class citizen\"- i.e. it's an entity (aggregate root). It lives in the database. Communities.Notifications Entity On the other hand a real-time event is a non-persistent data unit and it's used for on-the-fly signaling of user-relevant events. Each real-time event consists of a header, specifying its type, as well as a payload- the event data itself. As a comparison to the notification definition above: Note A real-time event's payload MAY OR MAY NOT hold a notification. See below for more information on all types of real-time events. A real-time event in a nutshell Some of the key aspects: They're produced real time and don't depend on the client application. They're addressed to the concerned user (i.e. the recipient), regardless of whether it uses ERP.net Windows Client or Web Client. The real-time events are \"broadcasted\" to the target user no matter how many instances of the Windows Client or Web Client are opened. They're only created (and sent) when there's someone to receive them. I.e. the target user is online. The real-time events themselves aren't persistent data. They aren't stored in the database. Use-case(s) Obviously, they have one purpose- to notify you of something that concerns you. Now For example, if someone reacts to your comment: Or someone comments on a object you're following (e.g. a specific document like an offer, sales order, etc): What about if there's a planned maintenance? Or several events at once: Variety of types The payload (i.e. the data), provided by the real-time events can be of the following different types: Code Description CM_REMINDER Reminder (a.k.a alarm), related to an activity. MAIL Incoming mail message. VOIP Voice over IP. Incoming call. SHUTDOWN Warning of an upcoming shutdown event. SYS_MSG System message. PERF Performance measurement. This is often a system measurement for the duration of an operation. NOT Social interaction as a notification. For more information, check the separate notifications documentation topic. WRN System message."
  },
  "advanced/concepts/scheduled-document-events/index.html": {
    "href": "advanced/concepts/scheduled-document-events/index.html",
    "title": "Scheduled document events | ERP.net Tech Docs",
    "summary": "Scheduled document events Scheduled document events are postponed events which will be executed later. They typically appear in the form of numerous recalculations resulting from other events. For example, releasing a cost correction creates scheduled events for all affected documents. A scheduled document event needs to be executed before it's applied. If it's created by a cost correction, the execution causes a reset of the document state of the store transactions, included in the cost correction. A reset triggers the accounting voucher generation procedures and causes re-accounting of documents, including adjusted cost. An execution can be performed: manually through the ''Execute Scheduled Events'' navigator automatically, using the job J30724 - Run scheduled events."
  },
  "advanced/concepts/webhooks.html": {
    "href": "advanced/concepts/webhooks.html",
    "title": "Webhooks | ERP.net Tech Docs",
    "summary": "Webhooks A webhook is technically an HTTP POST request. Under the hood, this simple form of messaging can be responsible for a variety of use cases. In practice, webhooks are used as custom callbacks. These callbacks are triggered when a specific event occurs. Use cases The introduction of webhooks reveals a wide variety of use cases: Real-time custom data synchronization with external systems. Ability to implement more complex real-time business logic from external applications. Integration with external BPM platform orchestrators. Real-time sending to message brokers such as Azure Service Bus and RabbitMQ. External logging or chat services like Slack and Graylog. Issue and project tracking systems - create issues in Jira or cards in a Trello list. Setting things up The process of triggering a webhook can be divided into two stages. Create a webhook template that specifies the contents of the webhook, as well as the endpoint it will trigger. Then, create an event that will trigger the webhook via its template. Such an event can be raised by the user-defined business rules. 1. Webhook template The webhook template is just an entity part of the Systems.Config namespace Systems.Config.WebHooks. The attributes are self-explanatory and must be filled in to meet the requirements of the external system (which will de facto receive the webhook). Let's see some of the more interesting attribute values in the example below: The Repository Name field must have a value that matches the one in the user business rule. The URL and Body attributes contain the destination address and the body content of the webhook. As you can see, they are provided in interpolated string form. https://my.extsvc.com:12345/{EntityName}/{Id} {{ \"Id\": \"{Id}\", \"Number\": \"{DocumentNo}\", \"Date\": \"{DocumentDate}\", \"Subject\": \"{Subject}\", \"State\": \"{State}\" }} Post-evaluation, they should look like this: https://my.extsvc.com:12345/Srv_Service_Activities/{925bc44b-787e-4e73-b8da-a4dfd2e442b6} { \"Id\": \"925bc44b-787e-4e73-b8da-a4dfd2e442b6\", \"Number\": \"000015\", \"Date\": \"13.01.2022\", \"Subject\": \"Test service activity\", \"State\": \"New\" } The Headers content is straightforward. It contains an authorization token as a constant and a format specifier for the body (application/json). 2. Event (user business rule) We already have a webhook template, but the final step is to reference it from a user business rule when a particular event occurs. Let's take a look at the picture below: This is the definition of a user business rule. The following key points need to be mentioned: The business rule is defined for the Applications.Service.ServiceActivities repository. It has a defined event of type AGGREGATECLIENTCOMMIT. It introduces an action of type WEBHOOK with a single parameter equal to \"wh_01\". In other words: A webhook template with code wh_01 will be triggered on each COMMIT in the ServiceActivities aggregate tree. Example We have a user business rule executing a webhook when a service activity is created or updated: Repository Applications.Service.ServiceActivities Events Event type Event parameter Execution priority AGGREGATECLIENTCOMMIT Normal Actions Action No Action type Parameter1 type Parameter1 value 1 WEBHOOK Constant wh_01 The value of the WEBHOOK's Parameter1 is simply the code of the corresponding WebHook entity. Name Value Code wh_01 Name Webhook 01 Repository name Applications.Service.ServiceActivities URL http://my-external-system:12345/{EntityName} Body {{ \"Id\": \"{Id}\", \"Number\": \"{DocumentNo}\", \"Date\": \"{DocumentDate}\", \"Subject\": \"{Subject}\", \"State\": \"{State}\" }} Headers User-Agent: ERP.net X-Auth-Token: my_security_token Retry logic Retry up to 3 times Notes Sends an HTTP POST request to the target URL, identifying the updated service activity. The table above shows the webhook template \"behind\" the code \"wh_01\". Note that the values for the URL and body properties are using string interpolation. Because a webhook is by definition just an HTTP POST request, this is what the HTTP message would look like: POST /Srv_Service_Activities HTTP/1.1 Host: my-external-system:12345 User-Agent: ERP.net X-Auth-Token: my_security_token Content-Length: 153 { \"Id\": \"9b68c23b-e3bc-4aa3-a906-cfa83fe1cdfc\", \"Number\": \"00001\", \"Date\": \"12.01.2022\", \"Subject\": \"Test activity\", \"State\": \"New\" } See more Webhook wiki New WebHooks entity Webhook action type Send a message to Azure Service Bus Create a card in Trello Send a message in a channel in Slack String interpolation Note The screenshots taken for this article are from v24 of the platform."
  },
  "advanced/data-objects/default-tracking-levels.html": {
    "href": "advanced/data-objects/default-tracking-levels.html",
    "title": "Default tracking levels | ERP.net Tech Docs",
    "summary": "Default tracking levels Some entities track their changes by default. The tracking level is system-configured and cannot be lowered. However, you can specify a higher level. The following table contains default system-specified tracking levels: Entity Default tracking level Activated in version Calculated attributes 3 2019.1 Cases 4 25 Companies 3 2019.1 Company locations 3 2019.1 Config 3 2019.1 Document types 4 2019.1 Documents 3 2019.1 Enterprise companies 3 2019.1 Entities 3 2019.1 Group access keys 3 2019.1 Groups 3 2019.1 Parties 4 2019.1 Payment accounts 2 2019.1 Payment types 2 2019.1 Persons 3 2019.1 POS locations 3 2019.1 POS operators 3 2019.1 POS roles 3 2019.1 POS sequences 2 2019.1 POS terminals 2 2019.1 Printout layouts 4 2019.1 Products 2 2019.1 Trusted Applications 3 2022.1 User business rules 3 2019.1 User groups 3 2019.1 Users 3 2019.1 Web Sites 3 2022.1 Custom Properties 4 2025.1 For more information on track changes, please check out Track Changes."
  },
  "advanced/data-objects/display-format.html": {
    "href": "advanced/data-objects/display-format.html",
    "title": "Display format | ERP.net Tech Docs",
    "summary": "Display format Each entity object must have a representation as text, so it can be visualized in a user interface - in ERP.net Windows Desktop Client or ERP.net Web Client. This is quite a simple task for entity types that have few attributes - not so much for the ones that don't. Let's see the following entity types as examples: Client Product They're one of the most commonly used in a typical workflow, and can expand to real (sample) data like entities. Client Number Name Sales person nmb001 Nia Cartwright Kristy Griffin 123456 Kamile Farrington Natalie Dunn ab1234 Kurtis Dickinson Anderson Fraser Product Code Name Measurement unit Group 1103 DEO GALERIA PINK F 150 ML pcs Goods 1102-01-011 1U Server pcs Computers 12345678 Remote support h Services These entities make sense in the context of others (documents, reports, analysis, etc). The easiest way to visualize them is to display their names (the \"Name\" attribute): Client Nia Cartwright Kamile Farrington Kurtis Dickinson Product DEO GALERIA PINK F 150 ML 1U Server Remote support Everything seems fine, but what if you need something more? This entity visualization should also apply when you choose a customer or a product. How will you act when you have several products named \"1U Server\"? Wouldn't it be better to see more information about each entity? What about if you see the product availability at the time that you choose it? This is where display format helps. ERP.net allows you to specify it for each entity type. If you need more attributes to be displayed, or a specific format of your choice, you're free to customize it. Here's an example of how you could customize a product's entity type: Display format Visualization {Name:T} DEO GALERIA PINK F 150 ML {Name:T} ({Code}) DEO GALERIA PINK F 150 ML (1103) {Name:T} #{Code} DEO GALERIA PINK F 150 ML #1103 {Code} 1103 {Code}: ({Name:T}) 1103: (DEO GALERIA PINK F 150 ML) Display formats use string interpolation, allowing you to customize your entity types. Configuring display format Changing the display format of an entity type is an easy task. Just open its definition and edit the 'Display Text Format' attribute to the desired one. As a result, each entity of this type will be displayed according to the selected display format. In the picture below, you can see how a customer dropdown is shown in the Web Client: Furthermore, it's possible to specify the display format yourself, if the pre-defined formats don't suit you. Just follow the rules when specifying the string interpolation. Note How do you know the specific attributes of the entity type that you need? Refer to the ERP.net Domain Model documentation. Following the example above, all the necessary information is available in Crm.Customers Entity. The display format attribute for an entity is located in the Systems.Core.EntitySettings Entity table. Display format inside look Each entity type has its corresponding record in another entity- EntitySettings. There's an attribute DisplayTextFormat- here is stored the interpolated string, which defines the display format for the entity type. If there's no settings record for an entity, then the default display format takes place. Defaults The default display format for an entity is defined at the system level. For entities that have Code and Name attributes, the default display format is specified by the database configuration option CodeNameFormat - the system default is {Name}. Note Often the Code and Name attributes for an entity are not literally named so. They are expressed by the types CodeDataMember and NameDataMember. In the table below you can see some entities and their Code and Name attributes (i.e., the CodeDataMember and NameDataMember): Entity Code attribute Name attribute Products PartNumber Name Customers Number Party.PartyName DefaultDisplayTextFormat, CodeDataMember and NameDataMember can be found in the documentation of each entity. Searchable Display text attribute is searchable. This means that when an entity is searched, the attributes, defined in the display format are also searched for a match. You can find more information here, https://docs.erp.net/dev/domain-api/query-options/search.html Examples In this section, you can see several examples of different entity types: sample data available predefined display formats and their corresponding visualization. Customers Customers entity documentation Sample data Number Name nmb001 Nia Cartwright 123456 Kamile Farrington ab1234 Kurtis Dickinson Display formats Display format Visualization {Party.PartyName:T} Nia Cartwright {Party.PartyName:T} ({Number}) Nia Cartwright (nmb001) {Party.PartyName:T} #{Number} Nia Cartwright #nmb001 {Number} nmb001 {Number}: ({Party.PartyName:T}) nmb001: (Nia Cartwright) {Party.PartyName:T} Kamile Farrington {Party.PartyName:T} ({Number}) Kamile Farrington (123456) {Party.PartyName:T} #{Number} Kamile Farrington #123456 {Number} 123456 {Number}: ({Party.PartyName:T}) 123456: (Kamile Farrington) {Party.PartyName:T} Kurtis Dickinson {Party.PartyName:T} ({Number}) Kurtis Dickinson (ab1234) {Party.PartyName:T} #{Number} Kurtis Dickinson #ab1234 {Number} ab1234 {Number}: ({Party.PartyName:T}) ab1234: (Kurtis Dickinson) Products Products entity documentation Sample data Name Part number DEO GALERIA PINK F 150 ML 1103 1U Server 1102-01-011 Remote support 12345678 Display formats Display format Visualization {Name:T} DEO GALERIA PINK F 150 ML {Name:T} ({PartNumber}) DEO GALERIA PINK F 150 ML (1103) {Name:T} #{PartNumber} DEO GALERIA PINK F 150 ML #1103 {PartNumber} 1103 {PartNumber}: ({Name:T}) 1103: (DEO GALERIA PINK F 150 ML) {Name:T} 1U Server {Name:T} ({PartNumber}) 1U Server (1102-01-011) {Name:T} #{PartNumber} 1U Server #1102-01-011 {PartNumber} 1102-01-011 {PartNumber}: ({Name:T}) 1102-01-011: (1U Server) {Name:T} Remote support {Name:T} ({PartNumber}) Remote support (12345678) {Name:T} #{PartNumber} Remote support #12345678 {PartNumber} 12345678 {PartNumber}: ({Name:T}) 12345678: (Remote support)"
  },
  "advanced/data-objects/edo.html": {
    "href": "advanced/data-objects/edo.html",
    "title": "EDO | ERP.net Tech Docs",
    "summary": "EDO The Extensible Data Objects (EDO) is a system in ERP.net, which allows attaching additional data to all entities in the system. The following can be attached: files Track Changes tracking data How does it work? Extensible data objects are stored in the Sys_Objects entity. The system works in the following way: An object in an entity requires attaching additional data => A new record is created in Sys_Objects. Additional data is created in sub-tables which have referential integrity to Sys_Objects. The record in Sys_Objects has only untyped soft reference (not referential integrity) to the original record. It contains the Entity_Type and Entity_Item_Id fields, which uniquely identify the original record. All additional data is related to Sys_Objects through typed referential integrity. Therefore, the only untyped soft reference is the original reference in Sys_Objects. Most data is solidly related through typed referential integrity. Note The Custom attributes system was implemented prior to the EDO system, so it also uses untyped soft reference. If it was implemented now, it would be in the form of 'additional data' to the EDO system. Future plans The EDO system is very useful for creating additional data which can be attached to multiple entities. It's not required for the type of data to be attachable to ALL entities. The data model allows attaching data to any entity, but system business rules or business rules can be used to limit the entities which 'accept' the data. Possible (planned) future uses: Comments/Replies - many objects in the system can be augmented by allowing users to comment and reply to them. All kinds of attachments - links, pictures, other system objects, etc. Tags/Labels for back-link navigation. Future simplified implementation of custom properties. Reactions - Facebook-inspired reactions. Reviews - Marketplace-inspired reviews. See also: Systems.Core.ExtensibleDataObjects Entity"
  },
  "advanced/data-objects/index.html": {
    "href": "advanced/data-objects/index.html",
    "title": "Data objects management | ERP.net Tech Docs",
    "summary": "Data objects management Data objects are a design pattern used to encapsulate logic which is available to most data records in the system. Each aggregate root is a data object. All data objects have some common attributes, sub-entities and operations. The following data and operations can be associated with a data object: track changes file attachments See more Extensible Data Objects Track Changes Default tracking levels Display format"
  },
  "advanced/data-objects/track-changes.html": {
    "href": "advanced/data-objects/track-changes.html",
    "title": "Track Changes | ERP.net Tech Docs",
    "summary": "Track Changes Track Changes is a system in ERP.net which can be used to track changes in а data table. Tracking levels Тracking levels specify the detail level of the tracking, as per the following table: Level Name Description 0 Do not track changes Do not track any changes for this entity. 1 Track last change Stores information for the latest modification of the tracked object. 2 Track object changes All the data of Level 1 + General tracking information about each update of the object. Does not store information about the changes in the attributes. 3 Track object & attribute changes All the data of Level 2 + Information about the changes in the attributes, excluding BLOB attributes. These are large-size attributes like images, files, etc. 4 Track object, attribute & BLOB changes All the data of Level 3 + Changes in the values of BLOB attributes. Effects and storage The system stores information based on tracking level. The following topics summarize the stored data as well as other considerations and remarks: Level 0 - do not track changes. No information is stored. Level 1 - track last change This is the lightest tracking mode with the least storage requirements. Information is stored only for the latest modification, in **@Systems.Core.ExtensibleDataObjects**. Note An extensible data object is created and maintained ONLY for the root object of the aggregates. Upon first update of the tracked object, a new EDO record is created, if there isn't already one. For each successive update of an object in the aggregate, the data in the EDO is updated. The tracking data includes: Version number - incremented on each update Creation user - the user who initially created the tracked object (if the Track Changes system was enabled by that time). Creation time (UTC) - the time of initial creation in Universal Coordinated Time (UTC) timezone. Last update user - the user who performed the last update OR deleted the object. Last update time (UTC) - the time of the last update. Is deleted - specifies whether the tracked object is deleted. After the tracked object is deleted, the EDO information stays in the database for some time, but can be purged by cleanup processes. The deletion user & time are stored in Last update user / Time. Level 2 - track object changes Here, the extensible data object is still updated, but for each modification, a new record is created in two tables: **@Systems.Core.ObjectChangesets** contains data about change-sets. A change-set is a modification request sent to the server. One request can contain modifications (creates/updates/deletes) of multiple objects. Each change-set stores the following data: User - the user who initiated the server request. Time (UTC) - server time in UTC showing when the request was executed. Application - the name of the client application that executed the request. Server version - the version of the server by the time the request was executed. Object changes stores one row for each modified object. One change-set can contain data about multiple object changes. The following data is stored: Repository name - the name of the repository containing the object. Entity item id - the ID of the tracked object. Change type - the type of modification: C, U, or D for Create/Update/Delete. Root object id - the ID of the EDO for the root object of the aggregates. Level 3 - track object & attribute changes When this level is selected, all data from Level 2 is still stored and maintained. But now, data about each attribute (field) change is also kept. When activated, stores the following data about each attribute change within the entity: Attribute name -The name of the attribute that was changed. New value - A culture-insensitive string representation of the updated value. Example: [Default Customer Credit Limit Base] set to BGN 20000.00 Attribute changes for the record can be viewed through the Changes History mode in the ERP.net web client. The option is accessible from the Form Menu for each entity record definition. Note This level can consume an increased amount of disk space. Use it only when necessary. Additionally, ensure to set up some cleanup process (integrated or external). Some attribute changes might not be reflected properly by the system. Since it works at the application level, changes made by direct SQL statements will not be recorded. When a future update occurs, the system will record the changes to the attribute as if they're being made by the next update. This behavior is part of its core design. Such an example is the Document No attribute (set by SQL statements) is often recorded as changed by the 2nd modification of the document. Additionally, certain attributes have tracking disabled at the system level. This means that even if attribute tracking is enabled for a table, changes to specific attributes or fields will still not be recorded. Such an example is the Last Interaction Time UTC field in Social Groups. This field is designed to capture frequent updates from system processes. Enabling tracking for it would generate excessive load, potentially impacting system performance and stability. Attribute changes storage and processing Before v24: Each attribute change was stored as a separate entry in the Sys_Attribute_Changes table, leading to increased storage usage and performance overhead. Record creation and updates were processed synchronously, which could slow down operations. As of v24: Attribute changes are now stored in the Old_Values_Json field within the Sys_Object_Changes table. To optimize storage, JSON data exceeding 50 characters is compressed. Instead of logging changes synchronously, tracking operations are now processed asynchronously in the background, reducing performance impact on user operations. This resulted in major optimizations: attribute tracking time was reduced by approximately 64%, while storage usage saw a significant drop, with Sys_Attribute_Changes now taking up zero additional space-cutting storage needs by over 50% Level 4 - track object, attribute & BLOB changes Same as Level 3, but the values of BLOB attributes are also saved. It can severely affect storage requirements and should be used only for small tables and as a last-resort measure. Configuring track changes The track-changes functionality is activated through the Entities navigator (Systems.Core.EntitySettings table). Steps: Create a record in Entity Types, specifying the desired entity. In the Track Changes Level field, fill in the desired tracking level. Save and close. Tracking will soon start. For document entities, mass activation of the Track Changes system using the DocumentVersioningSystem registry key is possible. To learn more, see the description key number 42 in Config options reference. Note If you try to configure a level lower than the default tracking levels, the option will be ignored. Enable or disable attribute changes tracking for document entities Tracking attributes changing history may be useful for invoices and other field-sensitive documents, but may result in unnecessary accumulation of data if not needed. Therefore, a specific configuration can be applied to each document type. You can define how attribute (field) changes to be tracked for documents of a certain type through the Track Attribute Changes field in the document type definition. Within the Track Attribute Changes field, it is possible to enforce one of the following rules: • Default - Allows attribute changes for the documents of the particular document type to be tracked. Does not apply if the document is transitional. • Force Disable - Prevents the ability for changes to be tracked. • Force Enable - Allows attribute changes to be tracked regardless of whether the document is transitional or not. Note Regardless of the Track Attribute Changes field configuration: attribute changes will not be tracked for adjustment documents Level 1 and Level 2 tracking levels will continue to apply, so the data collected by them will be stored and available for review."
  },
  "advanced/document-amounts/amounts-calculation/explicit-calculation.html": {
    "href": "advanced/document-amounts/amounts-calculation/explicit-calculation.html",
    "title": "Explicit value calculation | ERP.net Tech Docs",
    "summary": "Explicit value calculation The explicit amount entered through the Input Amount and Input Amount Currency fields is converted to the document currency. The result is the end amount of the additional amount. Example: There's a document with currency 'BGN' and an additional amount entered as explicit amount - 60 EUR. The additional amount is set to use round scale-up to the second digit after the decimal point. If the conversion rate is from EUR to BGN 1.96, the additional amount is: [Input Amount] = ROUND(60 * 1.96, 2) = 117.60 BGN. See Percent calculation for comparison."
  },
  "advanced/document-amounts/amounts-calculation/index.html": {
    "href": "advanced/document-amounts/amounts-calculation/index.html",
    "title": "Amounts calculation | ERP.net Tech Docs",
    "summary": "Amounts calculation There are two common ways to determine the value of additional amounts: setting an explicit amount; setting an amount as a percent of other amounts (additional or base amounts from the document rows) Which method is used depends on the information iserted into the the Additional Document Amounts panel of the document and the corresponding Input Percent, Input Amount and Input Amount Currency fields. Usually, you either set a value in the Input Percent field and leave the other two empty, or set a value for Input Amount and Input Amount Currency and leave the remaining one empty. In the additional amount definition, you can control which method for determining the additional amount value is allowed. This is achieved by the Amount Input Allowed and Percent Input Allowed fields. If the second one is True, you can set a default percent value which will appear in the documents. The values entered in Input Percent and Input Amount can be managed by the Allowed Directions field: when ‘Allow only positive’ is selected, you can only enter numbers bigger than or equal to 0; when ‘Allow only negative’ is selected, you can only enter numbers less than or equal to 0; when ‘Allow all’ is selected, there are no limitations to the value entered in the fields. Note In both methods, the program calculates an end amount rounded to a specific number of digits after the decimal point. This is an option of the additional amount definition – the Round Scale field. The round scale itself isn't used in the end amount. It's used as an intermediate amount for amount distribution. The rounded amounts are always limited to the second digit after the decimal point before being saved in the database. See more Explicit value calculation Percent value calculation"
  },
  "advanced/document-amounts/amounts-calculation/percent-calculation.html": {
    "href": "advanced/document-amounts/amounts-calculation/percent-calculation.html",
    "title": "Percent value calculation | ERP.net Tech Docs",
    "summary": "Percent value calculation Here is the place where the input percent is used. Starts by determining the amounts to which the percent calculation will be applied. It's defined by the Base On Line field and the Document Amount Type Dependencies panel (also known as Base Additional Amounts) in the the additional amount definition. Based on the values of these fields is calculated the base amount of the additional amounts. The calculation is in two steps: Sum the amounts of the current document to all additional amounts listed in the Document Amount Type Dependencies panel. This requires the previous calculation of the other amounts. If the аdditional аmount is marked as Base On Lines, the sum from p.1 is added to the sum of the document rows, multiplied by their specific weights (if there are no weights, you multiply by 100%). The resulting base amount is used to find the end value of that amount with the following formula: [Amount] = ROUND([Base Amount] * [Input Percent], [Round Scale]). For more information, see Rows weighting. Example 1: If you have the following additional amounts: Corporate discount: Default Percent is -3%; Base On Lines is True; there are no other additional amounts listed in the Document Amount Type Dependencies panel; Round Scale is '2'; Easter bonus: No default percent; Amount input allowed is True; Percent input allowed is False; Round Scale is '2'; VAT: Default Percent is 20%; Base On Lines is True; the Document Amount Type Dependencies panel states that VAT is applied to Corporate discount and Easter bonus; Round Scale is '2'; If you have two document lines - one with a line amount of 150 EUR and another with 40 EUR, then you enter an additional Easter bonus value of -10 EUR. The calculations for the three additional amounts are as follows: Corporate discount base amount is 150 EUR + 40 EUR = 190 EUR (only the sum of the document lines); so [Corporate discount] is calculated = ROUND(190 EUR * -0.03, 2) = -5.70 EUR; Easter bonus is -10 EUR (there's no currency conversion because the amount is in EUR); VAT is calculated: [base amount] = [document rows amounts] + [Corporate discount] + [Easter bonus] = 190 EUR + -5.70 EUR+ -10 EUR = 174.3 EUR; so [VAT] = ROUND(174.3 EUR * 0.2, 2) = 34.86 EUR Example 2: You have only one additional amount - commission. Its definition has the following properties: Default Percent is 5%; Distribute By is 'Product Definition'. The weight of the specific product is 100%; Base On Lines is True; Add To Customer is False; Add To Line is False; Round Scale is '2'. The example document has three lines: line #10 with the amount of 150 EUR; line #20 with the amount of 40 EUR; the line contains the specific product; line #30 with the amount of 69 EUR; the line contains the specific product. So the line have the following specific weights: line #10: weight = 0.00; line #20: weight = 1.00; line #20: weight = 1.00; The base amount for the commission additional amount is calculated as follows: [base amount] = 150 EUR * 0.00 + 40 EUR * 1.00 + 69 EUR * 1.00 = 109 EUR The final result for the amount is: [Commission] = ROUND(109 EUR * 0.05, 2) = 5.45 EUR Note When you have to calculate percent and the document amount is part of the base amount (Base On Lines is True) and it has lines with different signs (negative and positive amounts), then there is a specific way to calculate the additional amount. Besides the end result, two subtotals are calculated - [positive amount] and [negative amount]. This is achieved by separating the line types - lines with positive amounts and lines with negative amounts - and for every group of lines, the additional amount is calculated separately. Тhe final result is: [additional amount] = [positive amount] + [negative amount] These two subtotals may be used in the additional amount distribution. For further information, see Amounts distribution. Example 3: If you have the following properties in the additional amount, VAT: Default Percent is True; Round Scale is '2'; Base On Lines is True; the example document has the following lines: line #10 with the amount of 74 EUR; line #20 with the amount of 26 EUR; line #30 with the amount of -45 EUR; and the base amount of the additional amount is: [VAT] = ROUND((74 EUR+ 26 EUR + -45 EUR) * 0.2, 2) = ROUND(55 EUR * 0.2, 2) = 11 EUR, But you also have the additional subtotals: [positive VAT amount] = ROUND((74 EUR + 26 EUR) * 0.2, 2) = ROUND(100 EUR * 0.2, 2) = 20 EUR, [negativeVAT amount] = ROUND(-45 EUR * 0.2, 2) = -9 EUR. and their sum is equal to [VAT](20 EUR + -9 EUR = 11 EUR)"
  },
  "advanced/document-amounts/amounts-distribution/by-amount.html": {
    "href": "advanced/document-amounts/amounts-distribution/by-amount.html",
    "title": "Amount distribution by amount | ERP.net Tech Docs",
    "summary": "Amount distribution by amount When distributing by amount, lines amounts are used to define the distribution proportions. Two types exist: line amounts (only if Base On Lines in the additional amount definition is 'True'); amounts distributed to the lines (only the ones which participate in the base amount of the current additional amount). To define the proportion of line i, its coefficient is calculated as follows: [ki] = [distributed to line i amount1] + [distributed to line i amount2] + ... + [distributed to line i amountm]. 'amount1', 'amount2' ... 'amountm' are the additional amounts to which you add the current additional distributed amount (the amounts listed in its definition in the Document Amount Type Dependencies panel). If there are no such amounts, thеn in this initial calculation, you have [ki] = 0. If Base On Lines is 'True' (in the additional amount), the line amount is added to the initial value for [ki]: [ki] = [ki] + [line i amount]. This is how each line coefficient is calculated. Тhe distribution is performed as usual, except for when the amount [S] is 0 and the additional amount is calculated as a percent. In this case, the amount is distributed equally throughout the lines, and for each line, the calculation is performed like this: [line i distribution] = ROUND([ki] * [Input Percent], [Round Scale). If a percent is used for the additional amount calculation, it may be used for the calculation of the distributed amount for each line (to multiply the percent by [ki], which is the base amount only for the i line). You may avoid the disadvantage of even distribution, but the amount distributed to a line may not be equal to the input percent. This is a huge problem for things like VAT. Example 1: There are the following additional amounts: Corporate discount: Input Percent: -3%; Distributed By: Amount; Round Scale: 2; Base On Lines: True. Eastern bonus: Distributed By: Amount; Round Scale: 2; Input Amount: -10 EUR. VAT: Input Percent: 20%; Distributed By: Amount; Round Scale: 2; Base On Lines: True; in the Document Amount Type Dependencies panel, VAT is also applied on the Corporate discount and Easter bonus; The document has two lines: line \\#10 for 150 EUR and line \\#20 for 40 EUR. Percent value calculation explains how the additional amounts are calculated: [Corporate Discount] = -5.70 EUR [Eastern Bonus] = -10 EUR [VAT] = 34.86 EUR For the distribution of corporate discount, there are the following coefficients: [k1] = 150 and [k2] = 40 (only the base line amounts are taken into account) The [Corporate Discount] is distributed in 150:40 ratio as follows: [Corporate Discount for line #10] = -5.70 EUR * 150 / 190 = -4.50 EUR; [Corporate Discount for line #20] = -5.70 EUR * 40 / 190 = -1.20 EUR. For the next amount - 'Easter bonus' - the distribution is in the same 150:40 ratio. The result is: [Easter Bonus for line #10] = -10 EUR * 150 / 190 = -7.894736842105263 EUR ~ -7.89 EUR; [Easter Bonus for line #20] = -10 EUR * 40 / 190 = -2.105263157894737 EUR ~ -2.11 EUR. For the last additional amount, the coefficients are different. The distributed amounts from the other additional amounts have to be added to the line amounts. The coefficients are as follows: [k1] = [Corporate Discount for line #10] + [Easter Bonus for line #10] + [line amount for line #10] = -4.5 + -7.89 + 150 = 137.61; [k2] = [Corporate Discount for line #20] + [Easter Bonus for line #20] + [line amount for line #20] = -1.2 + -2.11 + 40 = 36.69. The VAT distribution is as follows: [VAT for line #10] = 34.86 EUR * 137.61 / 174.3 = 27.522 EUR ~ 27.52 EUR; [VAT for line #20] = 34.86 EUR * 36.69 / 174.3 = 7.338 EUR ~ 7.34 EUR. Example 2: There are 20% VAT and three document lines - #10 with 100 EUR, #20 with -30 EUR and #30 with -70 EUR. In this case, VAT is 0 EUR, but it's inappropriate to distribute 0 EUR on each line, no matter what the coefficients are. By rule, each separate line must have nonzero VAT. Even if for some reason the VAT is not equal to 0, then it shouldn't be distributed equally throughout the lines (as it will be, if you distribute by quantity and have [S] = 0). The amounts on each line are different. This is why a specific calculation of the distributed amounts is applied: [VAT for line #10] = 100 EUR* 0.2 = 20 EUR; [VAT for line #20] = -30 EUR * 0.2 = -6 *EUR*; [VAT for line #30] = -70 EUR * 0.2 = -14 *EUR*. Note There's a specific case where the additional amount is distributed by amount. If some lines/coefficients in the document are positive and others negative, as is described in Percent value calculation, except the total amount of the additional amount, there are also two subtotals - positive amount/part and negative amount/part. The amount distribution is performed in two stages: first, the positive subtotals are distributed among the lines with positive amounts and then, the negative subtotal is distributed among the lines with negative amounts. Example 3: There's an additional amount VAT with input percent 20% and three document lines: line #10 with amount of 74 EUR, line #20 with amount of 26 EUR and line #30 with amount of -45 EUR. The VAT amount is 11 EUR and the the subtotals are [positive VAT] = 20 EUR and [negative VAT] = -9 EUR. The 20 EUR are distributed on line #10 and line #20 in 74:26 ratio: [VAT for line #10] = 20 EUR * 74 / 100 = 14.80 EUR; [VAT for line #20] = 20 EUR * 26 / 100 = 5.20 EUR Then, the [negative VAT] subtotal is distributed on the last document line: [negative VAT] = -9 EUR = [VAT for line #30]"
  },
  "advanced/document-amounts/amounts-distribution/by-product-definition.html": {
    "href": "advanced/document-amounts/amounts-distribution/by-product-definition.html",
    "title": "Amount distribution by product definition | ERP.net Tech Docs",
    "summary": "Amount distribution by product definition Distribution by product definition is similar to the by amount distribution, the only difference being that line weights are used. When the additional amount has Based On Lines = True, the distributional coefficients are multiplied by the lines' weights. The only difference is in the following calculation formula: [ki] = ([ki] + [line amount i]) * [line weight i]. In addition to Example 3 from Percent value calculation, there's an additional amount commission with input percent of 5 and three lines (line #10 for 150 EUR, line #20 for 40 EUR and line #30 for 69 EUR) which have the following weights: line #10: weight = 0.00; line #20: weight = 1.00; line #30: weight = 1.00. The commission amount is 5.45 EUR and its distribution is calculated by the following coefficients: [k1] = [line amount #10] * [line weight #10] = 150 * 0.00 = 0; [k2] = [line amount #20] * [line weight #20] = 40 * 1.00 = 40; [k3] = [line amount #30] * [line weight #30] = 69 * 1.00 = 69. The amount of 5.45 EUR is distributed in 40:69 ratio as follows: [line #10 commission] = 5.45 EUR * 0 / 109 = 0 EUR; [line #20 commission] = 5.45 EUR * 40 / 109 = 2 EUR; [line #30 commission] = 5.45 EUR * 69 / 109 = 3.45 EUR."
  },
  "advanced/document-amounts/amounts-distribution/by-quantity.html": {
    "href": "advanced/document-amounts/amounts-distribution/by-quantity.html",
    "title": "Amount distribution by quantity | ERP.net Tech Docs",
    "summary": "Amount distribution by quantity When using this distribution method, the coefficients for calculating the proportions [ki]/[S] are defined by the quantities in the lines on which the additional amount is distributed. It's necessary to convert the quantities to the same measurement unit. Therefore, the additional amounts using this property (Distribute By = Quantity), are required to have a selected value in the Distribute By Measurement Category field. The base measurement unit in the selected category is the unit to which quantities from all lines will be converted. If a line with a product has no such dimension, the calculation stops and an error message is displayed. As long as [distribution measurement unit] is the measurement unit from the selected category in the additional amount definition, then for each line, the coefficients are as follows: [ki] = [quantity on line i] converted to [distribution measurement unit]. The additional amount distribution is performed by a standard formula (in proportions [ki]/[S], if [S] is not 0, or otherwise - equally throughout the lines). Example 1: There's a transport additional amount with input of 42 EUR, which is paid by goods 'box'. In the definition, transport is distributed by quantity and the measurement category is 'Boxes' (base measurement unit = boxes). The document where the additional amount is selected has three lines: line #10 with quantity of 2 boxes, line #20 with quantity of 25 pieces line #30 with quantity of 18 kg. The product ofline #20 has the following dimension: 1 boxes = 10 pieces. The product of line #30 has the following dimension: 1 boxes = 3 kg. After converting all line quantities to 'boxes', the following coefficients are calculated: line #10: [k1] = 2; line #20: [k2] = 2.5; line #30: [k3] = 6. The amount of 42 EUR is distributed in 2:2.5:6 ratio. The results are: line #10: 42 EUR * 2 / 10.5 = 8 EUR; line #20: 42 EUR * 2.5 / 10.5 = 10 EUR; line #30: 42 EUR * 6 / 10.5 = 24 EUR. Example 2: There is an amount of 42 EUR of transport as in Example 1. The document lines are: line #10 with quantity of 2 boxes line #20 with quantity of 30 pieces line #30 with quantity of -15 kg The coefficients are [k1] = 2, [k2] = 3 and [k3] =-5 and total amount of [S] = 0. In this case, the additional amount is distributed equally among the lines and the result is: line #10: 42 EUR / 3 = 14 EUR; line #20: 42 EUR / 3 = 14 EUR; line #30: 42 EUR / 3 = 14 EUR."
  },
  "advanced/document-amounts/amounts-distribution/index.html": {
    "href": "advanced/document-amounts/amounts-distribution/index.html",
    "title": "Amounts distribution | ERP.net Tech Docs",
    "summary": "Amounts distribution After an additional sum is calculated, the result is not saved directly in the document, but distributed among document lines with nonzero weight where the additional amount is applied to. This distribution is then reflected in the document. After the amount is calculated and distributed, if you need to see the total value of the additional amount, you'll have to sum up all the values from its distribution. This is more conveniently than saving the total additional amount in the document. To see the VAT or the transport distributed to a specific product, you may often need just the amount distributed to a specific line. The following article(s) will descirbe different methods for distributing amounts through lines. Common principle of distribution The distribution principle is defined in the additional amount definition (by Distributed By field). There are three basic methods by quantity, by amount, by product definition. Every method suggests that a proportion of the amount distributed by the lines should be defined so the distribution can be executed. If you have n lines on which you have to distribute additional amount, a weight is defined for every line: [k1], [k2] ... [kn] These are different coefficients from those described in lines weighting, but in some specific cases the latter may participate in the calculation of the distribution weights. Uf the amount of these coefficients is [S] (i.e. [S] = [k1] + [k2] + ... + [kn]) and this amount isn't equal to 0, then the i-line of the proportion is [ki]/[S]: [distribution to line i] = ROUND([amount] * [ki] / [S], [Round Scale]), where Round Scale is property of the additional amount definition. This is a standard distribution alogorithm. A specific case is when [S] is 0. Most of the time, the additional amount is distributed evenly throughout the lines, using the following formula: [line i distribution] = ROUND([amount] / [lines count], [Round Scale]), but in some cases, there are more specific calculations, such as when the amount is distributed by amount or by product definition and the additional amount is percent. Sometimes, the additional amount may not be distributed evenly among the lines. An attempt is then made to allocate the balance. It's impossible to distribute equal part of the balance to all lines - otherwise, there will be no balance. The balance is therefore distributed throughout the first several lines. You can't distribute less than: [minimal balance distribution on a line = 1 / 10[Round Scale]. Example: You have 12 lines and the amount of 9.13 EUR to distribute with the following weights: [k1] = [k2] = ... = [k10] = 1, and [k11] = [k12] = 0 9.13 EUR is distributed on the first 10 lines and you'll apply the formula to get the the distribution of 9.13 EUR / 10 ~ 0.91 EUR (assuming you have Round Scale = 2). In this case, you distribute only 10 * 0.91 = 9.10 EUR and the amount left (0.03 EUR) needs to be distributed through the first 10 lines. Since you can't distribute less than 1 / 102 = 0.01 EUR, only the first three lines increase by 0.01 EUR. This is how the final distribution looks like: on the first three lines, the amount of 0.92 EUR is distributed; on the next seven lines, the amount of 0.91 EUR is distributed; on the last two lines, no amount is distributed. If the round scale is more than 2, there's a chance that part of the amount will be lost. For example, if the additional amount is 10 EUR and it's distributed equally throughout 3 lines and the round scale is 3., then for every line, the amount of ROUND(3.333333333333333, 3) = 3.333 EUR will be distributed. When you save a document like this, the numbers after the second digit will be cut. In the database, you'll have 3.33 EUR for each line. The total amount will be 9.99 EUR and 0.01 EUR will be lost. See more Amount distribution by amount Amount distribution by product definition Amount distribution by quantity"
  },
  "advanced/document-amounts/determination-and-recording.html": {
    "href": "advanced/document-amounts/determination-and-recording.html",
    "title": "Additional amounts determination and recording | ERP.net Tech Docs",
    "summary": "Additional amounts determination and recording These amounts are recorded in the Аdditional Amounts panel, found in the following documents: Sales orders Invoice orders Invoices purchase orders Purchase invoices Transfer orders Transactions The input/primary data is entered in the Additional Amounts panel, where it's used for calculating the amount and determining its impact on the document. This calculation is executed every time the document is saved and consists of 2 stages: Amounts determination Distribution of the detrmined amounts through the affected documents The distribution is saved in the document in which it's entered, no matter if the amount affects the current or another document. The amount is determined by entering an exact value, or by indicating that the amount is calculated as a percent of the base document amount or other additional amounts. This data is entered by adding the amount to a document in its Additional Amounts panel. Then, it's used to calculate the real value. After the amount value is calculated, it's distributed among the affected documents. This is necessary because you often need to determine what part of the additional amount is distributed to a specific line - for example, the value of the additional amount VAT for a specific sales order lines. There may be cases when an additional amount is entered in one document, but it affects others as well. Take the transport of deliveries from outside the country as an example. In this case, the original purchase invoice for the delivery of goods has arrived and is entered in ERP.net. The purchase invoice is released before the purchase invoice for the transport arrives. Transport is entered as an additional amount so it can be included in the product's costs. Transport can't be entered in the original purchase invoice (because the document state is Released and also the transport is not actually part of it and it should not be included there). Instead, transport is entered in another document and it should be distributed into the original purchase invoice, so its amount can be included in the invoice's products costs. As a result, you're able to indicate additional - referenced documents, to which you have to distribute the current amount. No matter if it's distrubuted only in the document it's entered or in other/referenced documents, once an amount is calculated and distributed, to see its real value, which shows how the amount affects business activities from the documents, its distributions should be summed from all documents it's distributed in."
  },
  "advanced/document-amounts/index.html": {
    "href": "advanced/document-amounts/index.html",
    "title": "Additional amounts | ERP.net Tech Docs",
    "summary": "Additional amounts Additional amounts are a mechanism for reporting financial amounts in documents that aren't contained in document lines and/or don't represent measurement of the main purpose of the document. This main purpose is written in document lines or in the document header. An example of amounts reletaed to the main purpose are: product price or product cost of a product (goods or services), which is sold or bought; enterprise company asset price or cost (fixed, financial or rental); value/amount of monetary transaction (transfer, payment or obligation). The amounts listed above are base amounts in documents and they are NOT additional. Additional amounts, on the other hand, are amounts that should not be indicated together with the main activity or are secondary effect of the main document purpose. Here are some examples: VAT (and other taxes) - taxes are not products an enterprise company is selling, producing or supplying; that's why they're usually reported as additional amounts in the documents; VAT deviation - this special amount is used for equalization of the VAT in store sales (because of specific roundings); this amount is additional because it's used to obtain the legal rate of the VAT. Taxes (as customs) - the same principles as in taxes are applied; Discounts - some types of customer discounts are represented as additional amounts when the discount can't be entered in a specific document row or there are no active promotions or bonus programs which control the discount; Increases and decreases - the same principle as in discounts: if the increases and/or decreases can't be defined in the rows or as part of a sale instrument, such as promotional programs or bonus packages, they're entered as additional amounts; Commissions (and other internal mechanisms for payments or money accounting) - if used as additional amounts, they can represent a percentage of the document amount and the result can be used for recording internal company performance or personal employee indicators. Usage Additional amounts are used for different reasons, such as adding amounts to the main business activity in a document or reporting secondary measurements for a business or outside activities. Calculating the amount to pay Some additional amounts serve to calculate the amount-to-pay for a document. This is marked in the definition by adding a check to the Add To Customer field. Usually, these are amounts like VAT, VAT deviation, discounts, increases, decreases. Calculating goods cost Additional amounts may be used to add value to the cost of the goods in the Logistics. For example, if the transport is entered as an additional amount when goods are purchased, the transport value will be added to the purchase price. When a stock transfer from one store to another is executed and it includes transport cost added to the issued products, the value of this transport should be added to the products cost before they are received in the second store. Adding transport to the purchase price or the store cost is done in the receiving store orders or store transactions. When a row in the sub-document is created, the value of this row is increased by the distribution in the current row amount of the transport. The same procedure is applied to all additional amounts marked as part of the store cost calculation. This is the Add To Line field in the definition of the additional amount. Calculating outside activities Additional amounts may also be used to report the external activities of an enterprise company. For example, if a salesman in a company receives commission or other additions to their salaries equal to a percentage of the turnover they achieve, the commision may be entered as an additional amount in the sales order, which is a percentage of the amount to pay. See more Additional amounts determination and recording Amount distribution by amount Amount distribution by product definition Amount distribution by quantity Amounts calculation Amounts distribution Explicit value calculation Lines weighting Percent value calculation Referenced documents"
  },
  "advanced/document-amounts/lines-weighting.html": {
    "href": "advanced/document-amounts/lines-weighting.html",
    "title": "Lines weighting | ERP.net Tech Docs",
    "summary": "Lines weighting Amounts from document lines often play a major role in the additional amounts calculation. Either the value of the additional amount is defined by the line amounts (VAT or customs), or the distribution of the additional amount through the lines depends on their lines amounts. However, there are cases when not all lines participate equally in the distribution. For example, it's possible for some products in an invoice to be exempt from income tax (VAT). This leads to some document lines unable to participate in the VAT calculation. The calculated amount will be distributed only among the ones that have participated. Similarly, for the 'Customs' additional amount in purchase invoices, a customs fee is due for particular products. There's a mechanism that allows for the indication of particular lines as being more important than others. You can set weights, coefficients, or in some cases percentages for each document line. The feature is found in the Document: Input line percentages panel, also known as amounts distribution by lines. Here, the coefficient of the specific row is entered in the Line Percent field. These specific parameters may only be entered for additional amounts marked as distributed by product definition. In this panel, weights are entered in two ways: manually, when the document is created automaticall using pre-entered default values in the product'с definition Note If there are no weights for an additional amount in the panel, all weights are considered equal to 100%. Below you'll find brief descriptions and examples for different input methods. For more information, see Amounts calculation and Amounts distribution. Default weights/coefficients in product definitions Sometimes, weights of specific services are known before documents are created. When customs taxes are paid for goods on import, some of the products have taxes and others don't. For many, taxes are defined by law and they're a constant percentage of the product value. You have to enter their weight for the additional amount 'Customs'. Once the documents are entered in ERP.net and a product is selected in a document line, its weight is copied from the product definition into the Document: Input line percentages panel. Of course, these are just default values that can be changed if necessary. Example 1: There's an additional amount 'Customs' with the following properties: Distributed By: Product definition; Default Percent: 100%. You enter a purchase invoice with four lines: line #10 for 44 EUR; line #20 for 56 EUR; line #30 for 24 EUR; line #40 for 71 EUR. In line #10, there's a product with default weight for additional amount ‘Customs’ of 5% and in line #30, there's a product with default weight of 25%. These are the coefficients/weights for each row: row #10: weight = 0.05; row #20: weight = 0.00; row #30: weight = 0.25; row #40: weight = 0.00; The 'Customs' amount is 8.20 EUR and it's distributed as 2.20 EUR : 0 EUR : 6 EUR : 0 EUR Manual weights/coefficients in the document In certain cases, products weights for specific additional amounts are not known in advance. They may depend on a document parameter and rely on the deal type of the sales order. Regardless of whether VAT is applicable or not and whether the document lines have different deal types, you will have to enter the weights/coefficients in the specific document, along with deal type. Products don't have default weights/coefficients in their definitions in advance. Example 2: There's an additional amount 'Specific VAT', distributed by product definition with a default percentage of 20%. You enter a sales order with four lines: line #10 for 44 EUR; line #20 for 56 EUR; line #30 for 24 EUR; line #40 for 71 EUR. Rows #10 and #20 are exempt from VAT, while the others have 20% VAT. You manually set the following percentages (100% on lines #30 and #40): line #10: weight = 0.00; line #20: weight = 0.00; line #30: weight = 1.00; line #40: weight = 1.00. The Specific VAT is 19 EUR and it's distributed through the rows as 0 EUR : 0 EUR : 4.80 EUR : 14.20 EUR. Example 3: This is a case where data is absent from the Document: Input line percentages panel: There's an additional amount VAT, distributed by amount with a default percentage of 20%. The amount is not distributed by the product definitions, therefore there will be no data in the Document: Input line percentages panel. In this case, no weights/coefficients are used for calculating and distributing the VAT amounr, so it is considered that all document lines have 100% VAT."
  },
  "advanced/document-amounts/referenced-documents.html": {
    "href": "advanced/document-amounts/referenced-documents.html",
    "title": "Referenced documents | ERP.net Tech Docs",
    "summary": "Referenced documents There are cases when you enter an additional amount in a document and calculate it, distributing it not only to the lines of the current document, but to others as well. For example, if there's a purchase invoice for goods transported to your location, and this transport must be paid, then it can be delivered later than the original purchase invoice. That original invoice may already be 'Released and possibly 'Completed'. As a result, you'll have to enter the transport as an additional amount in a separate document. Even if the purchase invoice isn't late, it could still be necessary to enter the transport in a separate document. This might help when the transport is performed by a different company from the supplier of the goods. Therefore, the additional amount 'transport' in one purchase invoice will be distributed to the lines of other 'Released' or 'Completed' documents, so its value can be added to the goods cost in Logistics module. The additional amount is calculated and distributed by documents different from the ones in which you enter it. This is performed using the Document Amount Referenced Documents panel, where can be specified referenced documents for each additional amount of the current document. These documents are usually from the same system type as the current one (invoices, sales orders), or at least support additional amounts. If it's entered in the listed documents, the amount is calculated and distributed by these exact documents (as if the amount was originally entered in the listed documents). The documents which will be used in the calculations are determnined as follows: If there's no information for the additional amount in the Document Amount Referenced Documents panel, the amount is distributed only in the current document and no other documents; If there are listed documents in the Document Amount Referenced Documents panel - the amount is distributed in the listed documents and no other documents. This makes it possible to enter additional amounts in the document which is distributed only in other documents. Note Respectively, if you want the same amount to be distrbuten in both the current document and other documents, this requires listing the current document as 'Referenced' as well. For more information, see Amounts calculation and Amounts distribution. Let's see the standard case for referenced document usage: transport of purchased goods. Example 1: Purchase invoice #1 has three lines: #10 with amount of 50 EUR; #20 with amount of 80 EUR; #30 with amount of 140 EUR; Second purchase invoice #2 is entered with no lines - only an additional amount with Input Amount of 38 EUR. Then, purchase invoice #1 is entered as a referenced document for the additional amount in the Document Amount Referenced Documents panel of purchase invoice #2, without adding a record for #2 itself . The amount is distributed among the lines from #1, and distribution is entered in purchase invoice #1. This is the resulting distribution, assuming transport is distributed by amount and is rounded up to the second digit: line #10, purchase invoice #1: 7.04 EUR; line #20, purchase invoice #1: 11.26 EUR; line #30, purchase invoice #1: 19.70 EUR; Example 2: There's sales order #1 from the end of last year. It has two lines: line #10 with amount of 100 EUR; line#20 with amount of 80 EUR; You have missed to enter holidays discounts: additional amount 'Christmas discount’ Default Percent: -3% Base On Lines: True Distributed By: Amount Round Scale: 2 You don't edit the sales order since it comes from the previous fiscal year. During the Easter holidays, a sales order for the same customer is added separately. You enter the discount missed from the first sales order: ‘Christmas discount’ in sales order #2 is distributed only in sales order #1. This is indicated in the Document Amount Referenced Documents panel. In sales order #2, you enter a new discount for the Easter holidays: Default Percent: -2% Base On Lines: True Distributed By: Amount Round Scale: 2 This additional amount is applied only to the current document and it's NOT entered in Document Amount Referenced Documents. Sales order #2 gets a special bonus, which decreases 10% of the amounts from sales order #1 and #2. This becomes an additional amount ‘Reorder bonus’ and has the following properties: Default Percent: -10% Base On Lines: True (the amount is also based on ‘Christmas discount’ and ‘Easter discount’) Distributed By: Amount, Round Scale: 2 For the last additional amount in Document Amount Referenced Documents, both orders are listed. If the lines in sales order #2 are: line #10 with amount of 35 EUR; line #20 with amount of 75 EUR; line #30 with amount 40 EUR; the three additional amounts in sales order #2 are calculated and distributed as follows: The amount of [Christmas discount] is -5.40 EUR and it is distributed as follows: line #10, Sales Order #1: -3 EUR; line #20, Sales Order #1: -2.40 EUR. The amount of [Easter discount] is -3 EUR and it is distributed as follows: line #10, Sales Order #2: -0.70 EUR; line #20, Sales Order #2: -1.50 EUR; line #30, Sales Order #2: -0.80 EUR. The amount of [Reorder bonus] is -32.16 EUR and it is distributed as follows: line #10, Sales Order #1: -9.70 EUR; line #20, Sales Order #1: -7.76 EUR; line #10, Sales Order #2: -3.43 EUR; line #20, Sales Order #2: -7.35 EUR; line #30, Sales Order #2: -3.92 EUR."
  },
  "advanced/document-flow/creating-duplicate.html": {
    "href": "advanced/document-flow/creating-duplicate.html",
    "title": "Creating a duplicate document and a new document from current | ERP.net Tech Docs",
    "summary": "Creating a duplicate document and a new document from current The current article describes the principles behind the process of creating a duplicate of an existing document. Different usages of the algorithm are also presented. Basic principles А duplicate of a given document is a new document which contains identical business data as the original one, meaning that all substantial and meaningful information is copied. There's some exception for technical details like internal identification numbers - primary keys, IDs of reference links between different parts of a document, and more. This is the common algorithm for creating a duplicate: A new document is created with a particular document type. Inside its headers, the substantial data from the original is copied. a. substantial data from the original document header is copied to the new document header; b. in each header of the new document, only the substantial data from the original is copied. In the duplicate, new rows are created for each original row, and the substantial data is copied there. If the original document has a row with dependent records in different parts of the document, for each main row, its duplicate in the new document is fixed; for each sub-row of the main row, a new sub-row in the duplicate is created. Only substantial data is copied from the original sub-row. If the original has rows of rows of the rows, the step 3 is applied until the original structure is copied. The new duplicate document must contain the same number of records (headers, rows, rows of rows) and structure as the original. Document rows are considered standard rows which most documents have, but properties and additional amounts also play a role. If a document header has its own properties, they are considered document rows. The records in the Document Amount Referenced Documents panel are considered rows of rows (rows of the additional amounts). The records in Document Line Amounts are considered rows of the standard document rows. For now, attached files are not copied when creating a duplicate of a document. Example 1: There's a purchase invoice with a document header and a specific header, two additional amounts, and four rows. 3 properties are specified for the first row values. The last row value has only 1 property. The second and third rows have 0 properties. The properties of the purchase invoice rows are considered rows of rows within the document. When creating a duplicate of this purchase invoice, a new one is created, which also has a document header and a specific document header, two additional amounts, and four document rows. For the document rows, there are the following records: row 1 - 3 properties; row 2 - no properties; row 3 - no properties; row 4 - 1 property. Each record in the new document copies the substantial data from its corresponding record in the original. Other examples for 'rows of rows' are: Depreciation plan line fixed value - rows of depreciation plan lines Payment slip lines - rows of payment slip amounts Operations - rows of work order items The voucher rows and their specific properties playing the role of their sub-rows. This is the common algorithm for copying substantial data from original to duplicate records: Values in fields which are primary key or referent ID of a link to an upper record in the document hierarchy, are not copied; originals are kept, since they're generated during the creation of the duplicate; For fields processed specifically, the value of the original record is not copied, and the specific logic for filling the duplicate record is followed; For the rest of the fields, the original record value is copied in the corresponding field of the duplicate. Example 2: In the first example, when copying data from original to duplicate records, the following fields are skipped: in the document header: the value of the Id field as well as fields processed specifically; in the specific header of the purchase invoice: values of fields PurchaseInvoiceId and DocumentId; in additional amounts: values of fields DocumentAmountId and DocumentId; in purchase invoice lines: values of fields PurchaseInvoiceLineId and PurchaseInvoiceId; in purchase invoice lines user properties: values of fields PurchaseInvoiceId and EntityItemId. Cases of specific data copying The current section describes specific field processing during data copying. Document headers If a document is a master document on its own, the original ID is filled in the MasterDocumentId field of the duplicate document. If this isn't the case - MasterDocumentId is copied from the original document. In DocumentDate, the current date is filled in and DocumentVersion is set to '1'. EnterpriseCompanyId and EnterpriseCompanyLocationId house the enterprise company and location currently used by the user. CreationTime is filled in with the current date and time, while CreationUser is set to the current user. State field is set to 'New' and 'ReadOnly'. Void is set to 'False'. If the original document is voided, DocumentNo of the duplicate record takes the number of the original document. Otherwise, DocumentNo is null. The fields UserStatusId, AssignedToUserId, VoidTime, VoidUser, VoidReason, AccessKeyId and ParentDocumentId are always empty. Document headers and rows of a voucher If DefaultReferencedDocumentId in the original document is the same as the ID, this field is filled with the Id of the duplicate in the duplicate document. The same logic is applied for ReferencedDocumentId in the Voucher's rows. Payment slip amounts IsPartyPayment is always set to 'True'. Transactions rows The fields LineBaseCost, LineDocumentCost, LineProductCost and LineStoreCost are always set to '0'. Ingredients When creating duplicates of work order rows with ingredients, there are some specifics which aren't exactly related to the fields, but to how they fit in the document hierarchy: If the WorkOrderItemId field in the material record is filled in, it's considered a sub-record of the work order item record from the main document, the Id of which is the value of WorkOrderItemId. These records are considered rows of the work order items rows; If WorkOrderItemId is null, the record is instantly considered a document row. Such records are rows only of the document header and not of other rows. The duplicate creation algorithm usage The algorithm for creating a duplicate works as follows: Duplicate creation is a function of the document form; the number of the original document is kept, as are the date and the parent document (no matter the specifics of copying data from document headers). Creating new from current is a function of the document form; the document number and the parent document are not kept, and the document date is the current date. Creating correction is a function of the document form; a duplicate of the current document is created and in its header, the field AdjustingDocumentId is filled with the Id of the original document; all other scalar fields in the duplicate are reset. Creating a copy of the sales order is a generation procedure in а sales order which produces a copy of the parent sales order; the standard duplicate creation is used and in the header of the duplicate, the standard logic of document creation is applied."
  },
  "advanced/document-flow/deterministic-generations.html": {
    "href": "advanced/document-flow/deterministic-generations.html",
    "title": "Deterministic generations | ERP.net Tech Docs",
    "summary": "Deterministic generations Not all generations support generating and adjusting (patching) a transitional document. Since the adjustment (patch) procedure supports matching the lines primarily by Line No. the generation should guarantee to always generate the same line numbers, given the same starting document. If you execute a generation several times for the same document, the same line numbers will be generated. This can be guaranteed if the generation creates the sub-document(s) using data only from the source (parent) document and doesn't look outside of it. Common external data that can make a generation non-deterministic includes: Using date or time Using available quantities Using data from the definitions of related objects Generations sometimes use outside data and are still considered deterministic. The main driving factor is whether this outside data influences the resulting line numbers. If a generation uses outside data, but still generates the same line numbers, it's considered deterministic for the purposes of document generation. Most often, deterministic generations generate exactly one line for each parent line. They use the line number from the parent line to set the line number of the generated line (without auto-numbering). For example, let's have the following sales order: sales order line 10: Product1 Qty=15 sales order line 20: Product2 Qty=25 and two generations that use this input to create a store order: Generation A generates the store order using strictly the data from the sales order and generates: store order line 10: Product1 Qty=15 store order line 20: Product2 Qty=25 Generation A is deterministic and can support adjusting transitional documents. Generation B uses the current available quantities to split the lines of the sales order, based on the availability of the different lots. It generates: store order line 10: Product1 Lot11 Qty=8 store order line 20: Product1 Lot12 Qty=7 store order line 30: Product2 Lot21 Qty=25 Generation B cannot be used to adjust (patch) the generated document. The line numbers of the generated document will vary, based on the current availability. Therefore, Generation B is non-deterministic Adjustment procedure If a transitional document needs adjustment after it's generated (to be in-line with its parent), an adjustment document is created. It's a peer document that contains changes, and is usually hidden in the document tree. Such documents are used to adjust (patch) main documents. The operation is executed upon setting the adjustment document status. Then, the main document is updated to reflect the changes. Generating adjustment documents When a generation supporting adjustment of transitional documents is executed, it checks the sub-documents. If it founds documents that can be adjusted (patched), it automatically generates changes-only document(s). Generations usually determine the changes in the following way: If a quantity, amount or other scalar attribute is updated, a 'changes' line is generated, containing the numeric difference between the scalars. If notes, dates or other non-scalar attributes are updated, a 'changes' line is generated, containing the new values for the non-scalars. Rule 1 and 2 can be combined. A 'changes' line can include both scalar and non-scalar changes. However, scalars are updated with 'difference' value, while non-scalars are updated with 'last' value."
  },
  "advanced/document-flow/fulfillment.html": {
    "href": "advanced/document-flow/fulfillment.html",
    "title": "Document fulfillment | ERP.net Tech Docs",
    "summary": "Document fulfillment Fulfillment is related to document generation and makes sure that all quantities and amounts from a parent document are transferred to a sub-document. Differences in quantities and amounts between parent and sub-documents require fulfillment. Documents in ERP.net usually require total fulfillment before their state can be set to 'Completed'. Fulfillment documents A document is fulfilled with another document. For example: A shipment order is fulfilled by creating a shipment. An invoice order is fulfilled by creating an invoice. Different document entity types usually come in pairs: orders and execution of entity types. More and more entity types come in triples - requisition, order and transaction. Note Order documents naturally require fulfillment, which is recorded as 'execution documents'. Discrepancies in quantities and amounts between the parent and the sub-document(s) Quantities and amounts in a sub-document may not represent an exact execution of a parent document. Differences between parent and sub-documents can arise for many reasons: Partial execution. For example, you shipped goods partially. In this case, the shipment doesn't fulfill the shipment order. Partial payment by customer. Adjustments to the parent document due to processing errors. Adjustments to the parent document by customer request. Adjustments to the sub-document. All these cases require fulfillment before the document state can be set to 'Completed'. Fulfillment tracking This process calculates what remains for fulfillment and how it's divided in terms of detail lines. For example, a sales order from a customer requests shipment of 10 oranges. 8 oranges and 2 tangerines were shipped. Did you fulfill the sales order? The system tracks the fulfillment of a document, using several tracking techniques: Natural matching Parent line Fulfillment table Natural matching Natural matching matches the parent and the sub-documents, based on natural attribute values. Note Natural attributes are attributes representing real-world things. This is in contrast with artificial attributes, which are required by the inner workings of the software system. In the example above, natural matching will compare the values of: Product Product variant Lot Serial number Let’s review the previous example in the light of natural matching. sales order: line 1: oranges, 10 kg shipment: line 1: oranges, 8 kg line 2: tangerines, 2 kg Natural matching will not qualify the shipment of tangerines as execution of the sale of oranges, because it's a different product. Even if the customer agrees to accept the tangerines, this can't be represented in the system. Another example: А customer orders a specific lot of a product, but they're ready to accept another lot: sales order: 10 oranges, lot 202 shipment: 10 oranges, lot 203 This shipment satisfies the customer in the real world. However, using natural tracking, this will be considered a severe difference. The system will propose a reversal of the shipment of lot 203 and shipment again of lot 202. This is problematic and might confuse some users. Even more problematic would be if two or more lines of a sales order contain oranges. In this case, natural matching just doesn't work well. While natural matching won't require special (artificial) tracking attributes or tables, it does not work well for some real-world scenarios. It's used in document generations, created in the earlier stages of ERP.net, but mostly abandoned in newer developments. Parent line Parent line is a widely used algorithm in ERP.net for keeping track of executions. The sub-document keeps reference of the parent line which is being executed. Let's see an example. sales order: line 1: oranges, 10 kg line 2: apples, 2 pcs shipment: line 1: oranges, 8 kg, parent line = 1 line 2: tangerines, 2 kg, parent line = 1 line 3: pears, 2 pcs, parent line = 2 Here, you can see that: Although you sent tangerines, they replace the oranges; You sent the missing quantity; You sent pears, instead of apples. Note The measurement unit of the sub-document line should be the same as the parent line. Of course, all this has to be arranged with the customer. Once done, you have to represent it in the system. Fulfillment table As good as parent line algorithm is, it cannot be used in all places. There are cases where it might be impossible to match all sub-document lines using only parent line. For example, in the WMS, suppose you have the following: Warehouse requisition: line 1: despatch oranges, 10 pcs line 2: despatch apples, 2 pcs In the optimization phase, the WMS has created the following plan: Warehouse order: line 1: pick oranges, 30 pcs (there are other orders that will be sorted out on the packing table) line 2: pick apples, 2 pcs line 3: move everything to packing table 3. There's a problem establishing a direct relationship with the parent document. The solution is to use Fulfillment table. It's like a notebook in which you record how much of the quantity has already been created for the sub-document. This allows the system to generate complicated sub-documents, without tracking the direct relationship between the created and the parent lines. In this example, after the warehouse order is created, the fulfillment table will contain: Warehouse requisition XXX, execution of line 1: Qty:10 Warehouse requisition XXX, execution of line 2: Qty:2 The fulfillment table simply contains executed quantities, without any regard of how they are executed. It does not contain any reference to the sub-document(s). The system tracks the execution, without specifically deciphering the sub-document(s) contents. The fulfillment table algorithm allows the application of complex algorithm execution. These algorithms don't need to represent the parent document lines 1:1 with the sub-document lines and thus can employ subtle optimization techniques."
  },
  "advanced/document-flow/generation-procedures.html": {
    "href": "advanced/document-flow/generation-procedures.html",
    "title": "Generation procedures | ERP.net Tech Docs",
    "summary": "Generation procedures Generation procedures are automated procedures which generate documents from other documents. They're the basis of the document flow and the arrows in the document flow diagrams. Setup In order to start generating documents, the procedures need to be configured. The configuration is performed in the document type routes child entity. Each document type route is a configuration of a single generation procedure. Generation procedures lifetime stages This is the lifetime of a generation procedure: NEW - in development, cannot be used. ACTIVE - could be actively used by users. AGEING - triggers a warning, can be silenced. OBSOLETE – triggers a warning or an error and has to be replaced by an active generation procedure. DEAD – does not work, throws an error, or is permanently deleted. Details When creating a NEW generation procedure, it may replace one that's currently in use. The older generation enters the AGEING lifetime stage. In this case, the AGEING generation procedures, which later becomes OBSOLETE, has to be replaced by an ACTIVE procedures that have been released, because they maintain the contemporary business logic, methods of computing and have better and faster performance. The transition doesn't need to be happen after the release of the new version, but it must be performed before the generation procedure enters the DEAD stage - before its date of suspension. This is the date on which an OBSOLETE generation procedure will be discontinued. It's added in the procedure's name like 'To be deleted: 9.2021'. There are three time periods in which the software will inform users: AGEING - From ([date of suspension] - 3 years) to (date of suspension] - 1 year) A pop-up (balloon) message will display, saying that the generation is now obsolete. The purpose is to inform users so they don’t interrupt/stop their workings with the system. The message will be logged into the Information Messages navigator and will stop popping up if the field Allow Obsolete Generation is check-marked for the particular line of the document type's routes. OBSOLETE - From ([date of suspension] - 1 year) to ([date of suspension]) If Allow Obsolete Generation is NOT check-marked, an error in a modal window will pop-up during the execution of the obsolete generation procedure. The error will inform users that they're using an obsolete procedure and the generation of the sub-document will be interrupted. The error stops popping up if Allow Obsolete Generation is check-marked. If Allow Obsolete Generation IS check-marked, a pop-up message will be displayed saying that the generation is obsolete. The purpose of the message is the same as in the AGEING stage. Messages will be logged into the Information Messages navigator. While using this generation, popping up could no longer be avoided. DEAD - From [date of suspension] onwards The generation ceases to operate and enters the DEAD lifetime stage. An unavoidable error will be thrown. With the release of a new main version after the date of suspension, the obsolete generation procedure is 'to be deleted' and it'll no longer appear in the drop-down lists."
  },
  "advanced/document-flow/generation.html": {
    "href": "advanced/document-flow/generation.html",
    "title": "Document generation | ERP.net Tech Docs",
    "summary": "Document generation Document generation is a key part of the document flow as it's not only used to automate it, but to provide the automatic generation of inheriting documents from a parent document. Generation is a special case of direct order fulfillment when there's only one source document. It creates a single target but can often make multiple documents. When many instances are generated, it's because of different values of some key attribute(s) in the different lines of the source document. Automating the document generation Having just a single document as a source allows for easy document generation. One instance can create multiple and different types of target documents under different conditions and events. The definition of a document type includes a special sub-entity type called workflow routes. These routes specify procedures, conditions and events for the automatic generation of inheriting documents. Each document type can host many workflow routes. They start automatically or require user initiation. Together, the routes of different document types form a general network graph called document flow. Properties of a document generation route Each document generation route contains the following properties: Generation events Events that trigger the document route. The most used event usually changes the document state. State The system state of the source document which will trigger the workflow route. When you change a state, the system initiates all routes marked with intermediate states. If a document has a 'Planned' state changed to 'Released', a route specified for the intermediate 'Firm Planned' state will be started. User state When not blank, it specifies that the workflow route will be started only when the final user state of the source document matches the specified user state. Contrary to system states, when changing this state, routes for the intermediate user states are not initiated. Source enterprise company If left blank, the route will be valid for all enterprise companies. When not blank, it'll be run only for documents in a specified enterprise company. Generation procedure The procedure which will be used to generate a target document. Properties of a document generation procedure Generation procedures are fixed procedures provided by the system. When defining a document route, you can choose one from a list. Each generation procedure is defined using the following attributes: Procedure code - A unique procedure code used for identification purposes. It has the following structure: Subsystem code 3-5 characters which uniquely identify the sub-system of the source document. Module code 2 digits that uniquely identify the module within the sub-system of the source document. Procedure code 2 digits which specify the consecutive number of the procedure within the module. For example, ‘CRM0103’ specifies a procedure in the CRM sub-system, 01-Sales module, procedure #3. Name Name of a generation procedure. Obsolete Specifies whether a generation procedure is still active in the latest version of the system. Old generations are no longer supported and are marked as ‘Obsolete’. Source document entity type Specifies the entity type of a source document, which defines the general type of the document (e.g sales order). The generation procedure can be used only for documents with specified entity type. There can be many user-defined document types within a single entity type. Target document entity type The entity type of a target document. A generation procedure only generates documents with specified entity type. Each document type can specify different user-defined document types only within this specified type. Description Detailed description and business case when a generation procedure is used."
  },
  "advanced/document-flow/index.html": {
    "href": "advanced/document-flow/index.html",
    "title": "Document flow | ERP.net Tech Docs",
    "summary": "Document flow The sequence of documents in a process forms a document flow. Just a sequence of documents is a rare occurrence, so documents in a process are more likely to be in a hierarchy. Documents in ERP.net often have sub-documents. Most of the time, they're automatically generated or created by some fulfillment function. However, manually entering a sub-document is also allowed and sometimes encouraged. Documents and sub-documents can form a sequence, or hierarchy. The document flow design, therefore, is one of the most important aspects of implementing ERP.net for a target enterprise. The design is achieved with the help of specific routes built for each document type. See more Creating a duplicate document and a new document from current Deterministic generations Document fulfillment Document generation Generation procedures Parent document relationship type Transitional documents"
  },
  "advanced/document-flow/parent-document-relationship-type.html": {
    "href": "advanced/document-flow/parent-document-relationship-type.html",
    "title": "Parent document relationship type | ERP.net Tech Docs",
    "summary": "Parent document relationship type When a document has a parent document, there are constraints that determine which states are allowed. The applicable states depend on the relationship between a parent document and a child document. The relationship is contained in the 'parent-document relationship type' attribute. Its possible values are: Sub-task - the child document is a sub-task that must be done to complete the parent document Next task - the child document is NOT related to the next task and the parent document can be completed without requiring the child document to be completed. Independent task - the child document is an independent task, and there are no restrictions regarding the states of the parent and the child document. For example, the sales order-store order relationship tends to be of 'sub-task' type since the store order must be completed before the sales order. The offer-sales order relationship is of 'next task' type, as the work on the offer can be completed once the sales order is created. There's no need to complete the sales order first. The allowed child document states depend on the relationship type and the parent document state. The following table summarizes the allowed states: Relationship type Parent state Allowed child states Sub-task New New Sub-task Planned New, Planned Sub-task Firm Planned New, Planned, Firm Planned Sub-task Released New, Planned, Firm Planned, Released, Completed, Closed Sub-task Completed Completed, Closed Sub-task Closed Closed Next task New New Next task Planned New, Planned Next task Firm Planned New, Planned, Firm Planned Next task Released New, Planned, Firm Planned, Released, Completed, Closed Next task Completed New, Planned, Firm Planned, Released, Completed, Closed Next task Closed New, Planned, Firm Planned, Released, Completed, Closed Independent task Each possible state Each possible state"
  },
  "advanced/document-flow/transitional-documents.html": {
    "href": "advanced/document-flow/transitional-documents.html",
    "title": "Transitional documents | ERP.net Tech Docs",
    "summary": "Transitional documents Transitional documents are maintained to contain the most up-to-date information from a parent document. Once generated, they're adjusted with the latest changes after each change in a parent document. Transitional documents are hidden from the document flow by default, since they're totally automated and not user-created. Another reason for remaining invisible is to keep the document flow contiguous. Only deterministic generations can create such documents. The main purpose of transitional documents is to decrease the number of sub-documents in cases when there are many changes in the data from which sub-documents are created by the document fulfillment system. Transitional document setup To set up a document type as transitional: Go to the document type definition and select 'transitional document'. To generate documents of this type, use generations that support transitional document generation. Example 1: When creating payment orders by a sales order payment plan, there are preconditions for a great increase in the number of sub-documents. If a sales order has a payment plan with three payments: 40 EUR, 50 EUR, 10 EUR, then three payment orders will be created (with no invoice data) for each scheduled playment. When the amount of 60 EUR from the sales order is invoiced, two additional payment orders are created: one for -40 EUR and one for -20 EUR, for planned payments №1 and №2, which have no invoice data, and two more payment orders for 40 EUR and 20 EUR for planned payments №1 и №2 with invoice data. The sub-documents are now seven. When more invoices are released, more payment orders will be created. If an invoice is voided, even more payment orders will be created. The 'collective' state of the sub-documents is reached when the voided invoice is no longer reported. What happens? Transitional documents are meаnt to decrease the sub-documents' number. Changes are applied as corrections on already existing sub-documents. See Adjustment documents for more information. Another condition is for the existing documents to be 'Released'. If they have a document state higher than 'Released', new documents are created for the discrepancies that occur. In such а case, you can call the sub-documents transitional. If a document is transitional, it's a property of the document type definition. Activating this property is available only when all active procedures that create the current document allow transitional documents and are set to create а 'Released' document. On first sub-document creation, the sub-documents will have 'Released' document state. The next document changes can be applied as corrections. Not only is the sub-documents' number smaller, but you don't need to process it. There's no need to change sub-documents' states, nor edit or correct them so they can reach the values of the parent document. This, by itself, becomes an automatic processing of the documents by the system. You have to work only on the parent document. This is where the name 'transitional' comes from, as these documents don't need direct processing by the user. Example 2: There's a sales order for 100 pcs. It creates a transitional store order. The first store order has 100 pcs. When you correct the parent sales order so the quantity is 70 pcs, there are the following two cases: When the primary store order has 100 pcs and is 'Firm Planned'. There's no released document to correct, so a new store order is created with -30 pcs. As a result, you get two documents. If the primary store order is 'Released' (the usual case), the discrepancy of -30 pcs is applied as a document correction and the quantity in the primary store order is now 70 pcs. The sub-document is only one. As the discrepancy documents are not independent documents, they're applied to the primary document as corrections. Example 3 (continuing Example 1): There's a sales order with a payment plan for 3 payments - 40 EUR, 50 EUR, and 10 EUR. The payment orders are set as transitional documents. Initially, there are no invoices on this sales order so there are three released payment orders: payment №1, 40 EUR, no invoice data; payment №2, 50 EUR, no invoice data; payment №3, 10 EUR, no invoice data. Then, invoice #1 is created based on this sales order for 60 EUR. The first two payments need to be corrected. The first should have invoice data, the second should have 20 EUR with invoice data, and the rest 30 EUR don't have invoice data yet. For the additional four payment orders from Example 1, the first two payment orders containing -40 EUR and -20 EUR are applied as corrections of the already existing payment orders for planned payments №1 and №2, with no invoice data. The second two orders with invoice data are created as new 'Released' documents, as there are no released payment orders with invoice data yet. The payment orders now are: payment №1, 0 EUR, no invoice data; payment №1, 40 EUR, invoice #1; payment №2, 30 EUR, no invoice data; payment №2, 20 EUR, invoice #1; payment №3, 10 EUR, no invoice data; After invoice #1 is edited to 35 EUR (or voided and created again), the invoice amount may cover only part of the first payment, which will cause discrepancies/changes in the first four payments. As the payment orders are transitional, the existing payment orders will be adjusted: payment №1, 5 EUR, no invoice data; payment №1, 35 EUR, invoice #1; payment №2, 50 EUR, no invoice data; payment №2, 0 EUR, invoice #1; payment №3, 10 EUR, no invoice data; The previous example shows cases when the sub-documents have zero values in the scalar value fields. This is equal to removing the sub-documents (it doesn't order/execute anything anymore). The fact that the sub-documents are not voided or erased completely is useful, since in a future action they may be used to be adjusted again with zero values (only to be recovered as active documents)."
  },
  "advanced/index.html": {
    "href": "advanced/index.html",
    "title": "Advanced section | ERP.net Tech Docs",
    "summary": "Advanced section This section contains information for advanced concepts, systems and deep dive in the security. It is intended primarily for advanced ERP implementation consultants. Advanced systems Document flow - document-related concepts and services. Document amounts - mechanisms for reporting financial amounts in documents. Custom attributes - user-defined data attributes. Calculated attributes - user-defined calculations. User business rules - user-defined and system business rules. String interpolation - inserting values or expressions into a string, allowing for dynamic and customized output. Data objects - data object extensibility systems. Jobs - systems which automatically run processes. Security - security-related topics. Web sites - web sites, part of ERP.net. Advanced concepts Master / Detail attributes Object / Relational mapping Aggregates Scheduled document events"
  },
  "advanced/jobs/J30632.html": {
    "href": "advanced/jobs/J30632.html",
    "title": "J30632 Deletе old notifications | ERP.net Tech Docs",
    "summary": "J30632 Deletе old notifications Code J30632 Entity Communities.Notifications Job type name Deletе old notifications Parameters - Description The system job deletes all old notifications, whose CreationTimeUtc is older than 7 days First to process Notification.CreationTimeUtc (ASC) Automatically created YES Version Introduced: 2020.1 Updated: 2023 - the condition for deleting old notifications is changed – from older than 32 to older than 7 days - the job is automatically created and activated into the databases To learn more about the documentation template and get a short explanation for each table column, see Jobs documentation template."
  },
  "advanced/jobs/J30724.html": {
    "href": "advanced/jobs/J30724.html",
    "title": "J30724 Run scheduled events | ERP.net Tech Docs",
    "summary": "J30724 Run scheduled events Code J30724 Entity General.ScheduledDocumentEvents Entity Job type name Run Scheduled Events Parameters ScheduledDocumentEvent.Processed = False2. ScheduledDocumentEvent.Cancelled = False Description The system job executes all scheduled document events which are not cancelled. First to process ScheduledDocumentEvent.CreationDate (ASC) Version Introduced: 2020.1 To learn more about the documentation template and get a short explanation for each table column, see Jobs documentation template."
  },
  "advanced/jobs/J30777.html": {
    "href": "advanced/jobs/J30777.html",
    "title": "J30777 Document state change | ERP.net Tech Docs",
    "summary": "J30777 Document state change Code J30777 Entity General.Documents Namespace Job type name Document State Change Parameters Job.DocumentJob.Condition// Note that in 2020.1 in the condition can be used only the fields from the Documents table. Description Used to change the state of a set of documents. A record in Document Jobs must be created for each job of this type, containing information about the state that needs to be set, the new user state (optional), and the conditions which define the set of documents that will be processed. First to process - Version 2020.1 Important notes: The Document Type field is NOT a filter for the job. If you set a specific document type, it doesn't mean that it'll be executed only for documents with this document type or entity. The filters meant to determine the processed documents are found in the Conditions field. The Conditions field is the only one that's taken into account when determining which documents will be processed. If there are no conditions, the system will try to process all documents into the database! In Conditions, you have to choose and specify the right combination of criteria which will filter the desired set of documents among all documents in the system. Commonly used filters would be: Document.Void = false - the job will exclude voided documents. Document.Entity Name - the job will be executed for all documents of this entity. Document.Document Type - the job will be executed for all documents of this document type/s. Document.State - the job will be executed for all documents with this document state. Document.User State - the job will be executed for all documents with this user state. Document.Document Date >= and Document.Document Date >= - the job will be executed for all documents with document date in this period. Currently, the only conditions taken into account are the filters from the Document panel. To learn more about the documentation template and get a short explanation for each table column, see Jobs documentation template."
  },
  "advanced/jobs/J30903.html": {
    "href": "advanced/jobs/J30903.html",
    "title": "J30903 Deletе old document print images | ERP.net Tech Docs",
    "summary": "J30903 Deletе old document print images Code J30903 Entity General.DocumentPrintImages Entity Job type name Deletе Old Document Print Images Parameters DocumentPrintImage.DocumentPrints.Document.EnterpriseCompany.PrintImagesRetentionMonths Description Deletes old document print images whose retention period has expired. Expiration occurs when the period between the print time of the document image and today is larger than the period set in the Print Images Retention Months field in the enterprise company's definition. The default value for that field is 60 months but it can be adjusted according to the company's needs. First to process - Automatically created YES Version Introduced: 2020.1 Updated: 24 - the job is automatically created and activated into the databases Updated: 24 SP9 - Sorting by DocumentPrintImage.DocumentPrints.PrintTime (ASC) has been removed for performance reasons. As a result, the job will no longer prioritize deleting the oldest records. Instead, any record that falls within the expired retention period might be deleted in the iteration, regardless of order. It is considered that the order of deleting of obsolete records is not important, especially in favor of the job's speed, the number of processed records, and overall efficiency. Note The job will NOT delete the information from the Document Prints panel/table. Information about when and by whom the document has been printed will continue to be available. The job deletes only the visual representation of the document that has been printed. To learn more about the documentation template and get a short explanation for each table column, see Jobs documentation template."
  },
  "advanced/jobs/J33898.html": {
    "href": "advanced/jobs/J33898.html",
    "title": "J33898 Delete old document versions | ERP.net Tech Docs",
    "summary": "J33898 Delete old document versions Code J33898 Entity Systems.Core.DocumentVersions Entity Job type name Delete Old Document Versions Parameters - Description The system job deletes all old document versions, whose UpdateTime is older than 60 months First to process DocumentVersion.UpdateTime (ASC) Automatically created YES Version Introduced: 2023 To learn more about the documentation template and get a short explanation for each table column, see Jobs documentation template."
  },
  "advanced/jobs/J35026.html": {
    "href": "advanced/jobs/J35026.html",
    "title": "J35026 Delete old information messages | ERP.net Tech Docs",
    "summary": "J35026 Delete old information messages Code J35026 Entity Systems.Monitoring.InformationMessages Entity Job type name Delete Old Information Messages Parameters - Description The system job deletes all old information messages, whose InformationMessageTime is older than 12 months First to process InformationMessageTime (ASC) Automatically created YES Version Introduced: v.24 To learn more about the documentation template and get a short explanation for each table column, see Jobs documentation template."
  },
  "advanced/jobs/J35666.html": {
    "href": "advanced/jobs/J35666.html",
    "title": "J35666 Delete attribute changes history | ERP.net Tech Docs",
    "summary": "J35666 Delete attribute changes history Code J35666 Entity Systems.Core.AttributeChanges Job type name Delete attribute changes history Parameters /TrackChanges/AttributeChangesRetentionMonths key Description Deletes old history data for attribute changes whose object changeset’s TimeUtc is older than 36 months. The default value of 36 months can be adjusted according to the specific needs by configuring and setting a preferred value in the /TrackChanges/AttributeChangesRetentionMonths key*. First to process AttributeChange.ObjectChange.ObjectChangeset.TimeUtc (ASC) Automatically created YES Version Introduced: v.24 *To learn more about the /TrackChanges/AttributeChangesRetentionMonths key, see key №57 in Config options. Note The job will NOT delete information from the Object Changes and the Object Changesets tables. That means that the details regarding when and by whom the document or the definition has been changed will continue to be available. The job deletes only data related to the changed attributes and their updated values. To learn more about the documentation template and get a short explanation for each table column, see Jobs documentation template."
  },
  "advanced/jobs/J38417.html": {
    "href": "advanced/jobs/J38417.html",
    "title": "J38417 Delete old audit logs | ERP.net Tech Docs",
    "summary": "J38417 Delete old audit logs Code J38417 Entity Systems.Monitoring.AuditLogEntries Job type name Delete old audit logs Parameters /Monitoring/AuditLogEntriesRetentionMonths key Description Deletes old audit log entries whose EventTimeUtc is older than 12 months. The default value of 12 months can be adjusted according to the specific needs by configuring and setting a preferred value in the /Monitoring/AuditLogEntriesRetentionMonths key*. First to process N/A Automatically created YES Version Introduced: v.25 *To learn more about the /Monitoring/AttributeChangesRetentionMonths key, see key №66 in Config options. To learn more about the documentation template and get a short explanation for each table column, see Jobs documentation template."
  },
  "advanced/jobs/J38458.html": {
    "href": "advanced/jobs/J38458.html",
    "title": "J38458 Complete unfinished time entries | ERP.net Tech Docs",
    "summary": "J38458 Complete unfinished time entries Code J38458 Entity Projects.Agile.TimeEntries Entity Job type name Complete unfinished time entries Parameters - Description The system job completes unfinished time entries whose Date is at least one day old by setting the End Time field to 23:59:00. First to process - Automatically created YES Version Introduced: v.25 To learn more about the documentation template and get a short explanation for each table column, see Jobs documentation template."
  },
  "advanced/jobs/J38662.html": {
    "href": "advanced/jobs/J38662.html",
    "title": "J38662 Calculate historical Reporting currency amounts | ERP.net Tech Docs",
    "summary": "J38662 Calculate historical Reporting currency amounts Code J38662 Entity Finance.Accounting.AccountingVoucherLines Job type name Calculate historical reporting currency amounts Parameters EnterpriseCompany Used for retrieving the exchange rate and the start date. ReportingCurrency Retrieved from EnterpriseCompany.ReportingCurrency. FromDate (Optional, default is NULL) The starting date for processing. It is set within the task. If left empty, the processing begins from the oldest available documents. ToDate Retrieved from EnterpriseCompany.ReportingCurrencyStartDate. If empty, no calculations are performed. ReportingCurrencyRate Retrieved from EnterpriseCompany.ReportingCurrencyRate. LastProcessedDate The last date up to which calculations have been completed. The value is retrieved and stored from /Finance.Accounting/RCDate_EC{EnterpriseCompany.Id}. Description Calculations Performed: ReportingCurrencyDebit = DebitBC * ReportingCurrencyRate ReportingCurrencyCredit = CreditBC * ReportingCurrencyRate Execution Logic: Processes only documents whose date is: Earlier than the ToDate If LastProcessedDate has a value → processes documents with a date greater than LastProcessedDate If LastProcessedDate is empty: If FromDate has a value → processing starts from the FromDate If FromDate is also empty → processing starts from the oldest document in the database The calculated values are stored in the fields: ReportingCurrencyDebit ReportingCurrencyCredit Upon successful execution, the job updates the LastProcessedDate with the last processed document date. If ToDate is empty, the job does not make any changes. First to process N/A Automatically created YES Version Introduced: v.25 */Finance.Accounting/RCDate_EC{EnterpriseCompany.Id} has different value for each EnterpriseCompany *To learn more about the /Finance.Accounting/RCDate_EC{EnterpriseCompany.Id} key, see key №68 in Config options. To learn more about the documentation template and get a short explanation for each table column, see Jobs documentation template."
  },
  "advanced/jobs/J38722.html": {
    "href": "advanced/jobs/J38722.html",
    "title": "J38722 Complete old store orders | ERP.net Tech Docs",
    "summary": "J38722 Complete old store orders Code J38722 Entity Logistics.Inventory.StoreOrders Entity Job type name Complete Old Store Orders Parameters Systems.Config.Jobs.JobConfigurations, where the tag is \"RetentionPeriod\" + the number of months eg.{\"RetentionPeriod\":24} Description The system job completes with sub-documents store orders whose Retention period has expired. Expiration occurs when the period between the Document date and Today is larger than the set retention period in years in field Job Configurations in the definition of the Job. By default the period is two years. It can be adjusted to the company's needs. First to process - Automatically created YES Version Introduced: To learn more about the documentation template and get a short explanation for each table column, see Jobs documentation template."
  },
  "advanced/jobs/index.html": {
    "href": "advanced/jobs/index.html",
    "title": "Jobs | ERP.net Tech Docs",
    "summary": "Jobs Jobs is a system in ERP.net that runs processes such as document state changing, executing scheduled events, deleting old notifications, print images, and others. Running can be done both manually and automatically - in non-busy hours, without requiring any user interaction. Create and configure a job For a start, you have to create a new record with a desired job type in the Job navigator. Most job parameters have a default value and can operate without additional adjustments. An example is J30903 Document print images - Delete old document print images. It has only one parameter - the Print Images Retention Months field in the enterprise company's definition, with a default value of '60 months'. However, there are jobs performing more complicated processes that shouldn't be executed for all records in the database. They require additional settings. An example is the Document state change job. The parameters and settings for each job are described in its documentation. Job scheduling Jobs can be started automatically by an execution system, following a predefined schedule. Note Idle jobs are started in non-busy hours, subject to the availability of resources. A job uses the on-idle auto-start schedule only when the Is Active and Run On Idle options are activated in its definition. The job's execution system works only when the following requirements are met: The time of day is between 22:00 and 05:00. The current server sessions are fewer than 5. (this requirement can be manipulated through the /JobsManager/IgnoreSessionsForIdleSchedule config option) The last time the job's procedure was completed is more than 30 minutes ago. The procedure is not currently working. There are no manually started jobs currently running. If these conditions are met, the execution system initiates a special long-running procedure called System Jobs, which can be monitored like any other long-running procedure in the Procedures navigator in ERP.net, or the Procedures tab in the Server Manager. The jobs execution system will then create a list of pending jobs and will start executing them sequentially. The list is made on the basis of active jobs defined in the databases Each job can run a maximum of 5 minutes before it's cancelled by the job runner. Jobs can actually execute up to six 5-minute runs, or 30 minutes, until they break the existing loop of pending jobs. If a job is interrupted before its work is finished, it must be started again during the 30-minute period. If there are more records that need to be processed after the 30-minute window has elapsed, the job will start again on the next day. Manual job execution Each job could be started manually. This way, its execution begins immediately, without the need to wait for the next on-idle iteration. There are a few important things to keep in mind when executing a job manually: The same job can't be executed more than once simultaneously (e.g., \"in parallel\"). The job execution system will discard its job's queue if manual job execution is running. A job execution won't start if the Is Active option is disabled in its definition. Execution log Each job execution is logged in Information Messages. The log contains information about the starting time, ending time, the processed records, and errors that have occurred during the processing. Example: Process: Job J30777 Finish Store Transactions Message Succeeded: 259; Failed: 0 LOG: [10:00:10] Total: 259 [10:04:42] Succeeded: 259 [10:04:42] Failed: 0 Failure log Each job failure is logged in Information Messages. The log contains the reason for the job failure. Example: Process: Job J30903 Delete Print Images Message There is a running job. This job execution can't continue and will be skipped. See more J30632 Deletе old notifications J30724 Run scheduled events J30777 Document state change J30903 Deletе old document print images J33898 Delete old document versions J35026 Delete old information messages J35666 Delete attribute changes history J38417 Delete old audit logs J38458 Complete unfinished time entries J38662 Calculate historical Reporting currency amounts J38722 Complete old store orders"
  },
  "advanced/jobs/template.html": {
    "href": "advanced/jobs/template.html",
    "title": "Jobs documentation template | ERP.net Tech Docs",
    "summary": "Jobs documentation template Each job has a documentation topic that includes a standardized table containing detailed information about it. This table allows you to organize data in a structured way and helps you quickly navigate through the info. The table columns and content explained Template column name Template column description Code Unique job code. Always starts with 'J' and continues with a digit number. Entity The entity records processed by the job. Job type name Unique job type name. Parameters Field values (conditions) determining the entity records which will be processed by the job. Description An explanation of what the job does. First to process Specifies the condition/s by which the job determines which records will be processed first. Automatically created Shows whether the job is created and activated automatically into the databases or not. Possible values are YES and NO. Version A list of all versions in which the job has been changed. It usually contains two types of records: 'Introduced: 2xxx.x' - the version since which the job type has been available; 'Updated: 2xxx.x ' - the version in which the job has been changed (including description of the changes). There could be neither no records nor multiple records of this type. To learn more about the documentation template and get a short explanation for each table column, see Jobs documentation template."
  },
  "advanced/security/authentication/azuread.html": {
    "href": "advanced/security/authentication/azuread.html",
    "title": "Azure authentication | ERP.net Tech Docs",
    "summary": "Azure authentication ERP.net supports Azure as an authentication provider. There are a couple of Azure and ERP.net settings that should be configured for this authentication method to work. Azure settings Log into your Azure subscription via https://portal.azure.com. Manage Azure Active Directory. Register your application with your Azure Active Directory tenant by clicking App registrations -> Register an application. Enter the required details. You can use anything for the name (for example: ERP.net Identity Server). Leave “Accounts in this organizational directory only (Default Directory only - Single tenant)” checked. In the Redirect URI field enter the callback path configured in IdentityServer4 for Azure AD auth. This will be https://<UIN>.my.erp.net/id/signin-aad, where: <UIN> is the ERP.net unique instance name /id is the relative path of the ID site /signin-aad is the endpoint responsible for AZURE AD redirects (/signin-aad is constant for all databases) In the “Select a platform” drop-down menu, select Web. Confirm the app registration creation by clicking Register. Now, you have a new app registration. Navigate to “App registrations” and open your new app. Make a note of your Application (client) ID and Directory (tenant) ID values - they should be copied in the corresponding fields in the Sec_Domain_Providers table. Open “Authentication”, located in the left pane. If you have to add more redirect URIs (in case you have more than one instance of ERP.net application server), you can add them via the “Redirect URIs” panel, by clicking Add URI. Additionally, check the ID tokens checkbox. Finally, save your changes. ERP.net settings In the \"Setup / Security / Domains\" section a \"Domain providers\" record should be created. There is a default domain in the databases and the Azure record should be added there. The users are referenced by their email: There should be a license SEC01 - Security - Sign in with Azure AD"
  },
  "advanced/security/authentication/index.html": {
    "href": "advanced/security/authentication/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "advanced/security/index.html": {
    "href": "advanced/security/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "advanced/stored-attributes/domain-with-property-allowed-values.html": {
    "href": "advanced/stored-attributes/domain-with-property-allowed-values.html",
    "title": "Domain with property allowed values | ERP.net Tech Docs",
    "summary": "Domain with property allowed values Domain is the range of the allowed values of a particular stored attribute (custom property). It's determined in one of the following ways, sorted by high-to-low priority: If Limit To Allowed Values doesn't have a check mark, any value is valid and the domain is a range of all possible values. If Allowed Values Entity Name has a value, the domain is all records of the specified data type. This field has a value ONLY if Limit To Allowed Values has a check mark and Allowed Values Property does NOT have a value. If Allowed Values Property has a value, the stored attribute domain is equal to the stored attribute domain specified in this field. CustomProperty.Domain = CustomProperty.AllowedValuesProperty.Domain This field has a value ONLY if Limit To Allowed Values has a checkmark and Allowed Values Entity Name does NOT have a value. A range of the Property Allowed Values listed in the Gen_Property_Allowed_Values sub-table. Example 1: Let's assume you have the following properties: Property 1 (entity name = Products) Property 2 (allowed values property = Property 1) Property 3 (entity name = Products) Property 4 (entity name = Companies) Property 5 (allowed values property = Property 2) Property 6 (limit to allowed values = False) In this case, the domains are: Property 1 - Products Property 2 - Products Property 3 - Products Property 4 - Companies Property 5 - Products Property 6 – all possible values Compatible stored attributes Two stored attributes are copy-compatible ONLY when their domains are the same. Compatibility allows you to copy values from one stored attribute to another. This process could result in an error, but it would be caused by various reasons, such as additional filters being set in the definition. Note Additional filters don't change the domain of the stored attribute - they simply reduce the range with allowed values. It's also possible for future procedures or rules to be added, but they won’t change the domain of the stored attribute, either. From a programming perspective, the domain of allowed values could be defined as a stored attribute type. Example 2: If you use Example 1, you can conclude that: 'Property 1' is compatible with 'Property 2'. Both of them are compatible with 'Property 3' and 'Property 5'. Therefore, 'Property 1', 'Property 2', 'Property 3' and 'Property 5' are compatible with еach other. 'Property 4' is compatible with none of the above. 'Property 6' can take any value and it is also incompatible with the other stored attributes. Inheriting and hereditary root A stored attribute inherits another stored attribute by indicating a (hereditary) parent property in the Allowed Values Property field. The hereditary root of a stored attribute is considered grand-parent, which doesn't have a root on its own. It clearly defines the domain and is a prerequisite for automatic copying of its allowed values. A hereditary root is defined as follows: If Allowed Values Property doesn't have a value, the hereditary root is the stored attribute itself. Otherwise, it's equal to the hereditary root of the parent stored attribute. This means that: HereditaryRoot (Property) = HereditaryRoot(Property. AllowedValuesProperty) i.e. you look recursively in the relation Allowed Values Property. Example 3: According to the example above, stored attributes have the following hereditary roots: Property 1: Property 1 Property 2: Property 1 Property 3: Property 3 Property 4: Property 4 Property 5: Property 1 Property 6: Property 6 Copying Hereditary roots determine the most appropriate 'partner' to copy allowed values of stored attributes. Example 4: Let’s assume that you want to copy stored attributes from a customer to a sales order document. The customer has the following properties: FAVORITE-PRODUCT: (entity name = Products) ADVANCE-PRODUCT: (entity name = Products) In the sales order document type, the following stored attributes are set: FAVORITE-PRODUCT-CUSTOMER: Allowed Values Property = CUSTOMER. FAVORITE-PRODUCT SALE-ADVANCE-PRODUCT: Allowed Values Property = CUSTOMER.ADVANCE-PRODUCT In this case: All four stored attributes are 'compatible'. They could inherit values from one another. At the same time, only the following pairs have the same hereditary root: ​ A) FAVORITE-PRODUCT-CUSTOMER and FAVORITE-PRODUCT ​ B) SALE-ADVANCE-PRODUCT and ADVANCE-PRODUCT When specifying a customer in a sales order, only the stored attributes that have the same hereditary root will be automatically copied to the document. Stored attributes value priorities The priority for automatic copying of stored attributes by the following priorities: Note If a value with higher priority is found for a stored attribute, it's copied. If not – you should search for values with lower priorities. Values inherited from the parent document. (Priority 80) Values set in the panel Copy Customer Properties. (Priority 70) This is valid for sales orders, but the same priority applies if there's a similar table for other data. Values of stored attributes with the same hereditary root in the definition of the 'main contractor' of the document. (Priority 50) In general cases, this is the party loaded in the field To Party. Purchase invoices are exceptions - there, the supplier is considered a 'main contractor'. Default values specified in the document type. (Priority 20) If none of the above contains a value for the stored attributes, but the value is instead specified in the document type: Set an empty (NULL) value. (Priority 10) Note Every manual change of a value of a stored attribute should be done after the values are entered in the relevant nomenclatures (enterprise company, customer, parent document etc.)"
  },
  "advanced/stored-attributes/index.html": {
    "href": "advanced/stored-attributes/index.html",
    "title": "Stored attributes | ERP.net Tech Docs",
    "summary": "Stored attributes Stored attributes, also known as custom properties or custom attributes, allow you to extend the data model with user-defined attributes. They store values in the database, expanding the system tables. Similarity with system attributes Stored attributes behave mostly like system attributes: They can be shown in columns, grouped and filtered in navigators. They can have default values and be shown in the view of data forms. Most of the time, you won't be able to distinguish between system and stored attributes. It's up to the implementation team to define the latter, which is subject to implementation requirements. Note Many stored attributes can easily be defined and set as 'required'. However, this might endanger the whole ERP implementation, since requiring too much data entry for each operation can alienate the end users from the system. Business needs should be carefully balanced with the end-user comfort. See more Domain with property allowed values"
  },
  "advanced/string-interpolation/escape-sequences.html": {
    "href": "advanced/string-interpolation/escape-sequences.html",
    "title": "Escape sequences | ERP.net Tech Docs",
    "summary": "Escape sequences An escape sequence is a sequence of characters that isn't represented when used inside a character or string literal, but it's translated into another character or a sequence of characters. Let's form the most typical example of an escape sequence as a question: How do you put a \"new line\" in a single input field? If you can't think of it now, how about this: \\r\\n Yes, that's pretty standard. And yes - ERP.net supports it. So you can write down something like: Hello, \\r\\n\\ world! and the interpolated string will be this: Hello, world! Syntax The escape sequence's sytnax is quite straightforward. Just put a \\ (backslash) before the escape character. E.g., Escape sequence Interpretation \\' ' \\\" \" \\{ { \\} } \\r NEW LINE \\R R Did you notice the last row of the table? Note Escaping sequences in ERP.net is case SENSITIVE. That's the reason why \\R is different than \\r. Supported escape sequences The following escape sequences are defined and supported in ERP.net. Escape sequence Interpretation ERP.net representation (ASCII) \\r NEW LINE #13#10 \\n NEW LINE #13#10 \\r\\n NEW LINE #13#10 *NEW LINE is platform dependent. Any other escape sequence that is not part of the supported ones will be escaped by removing the backslash. E.g., This: \\z, will become this: z \\A - A etc Caution about Windows file paths Because file paths in Windows consist of backslashes- e.g., C:\\MyFolder\\file.txt They themselves have to be escaped. That's done by doubling them. So, when you need to visualize a backslash, you should write \\\\ instead of \\. Or to the example above, the path should look like this: C:\\\\MyFolder\\\\file.txt"
  },
  "advanced/string-interpolation/examples/constant.html": {
    "href": "advanced/string-interpolation/examples/constant.html",
    "title": "Constant expression examples | ERP.net Tech Docs",
    "summary": "Constant expression examples Plain string Input 'This is a simple string.' Will result to the same output because string interpolation is not applicable. The input doesn't meet the syntax requirements. Output 'This is a simple string.' Expression with escaped curly braces Input '{{This is a simple string.}}' '\\{This is a simple string.\\}' Will create a constant expression, which results to an output that's the same as the input. Output '{This is a simple string.}'"
  },
  "advanced/string-interpolation/examples/data-member.html": {
    "href": "advanced/string-interpolation/examples/data-member.html",
    "title": "Data member expression examples | ERP.net Tech Docs",
    "summary": "Data member expression examples Same-level data member reference Input 'The document Id is {DocumentId}.' Output 'The document Id is 929bdc15-79d8-4a1f-9467-c237f040939d.' Breakdown 'The document Id is ' {DocumentId} Evaluates to \"929bdc15-79d8-4a1f-9467-c237f040939d\" '.' Assuming that the domain object has: data member 'DocumentId' equal to '929bdc15-79d8-4a1f-9467-c237f040939d'. Referencing data members deeper Input 'The customer is {Customer.Party.PartyName} and its number is {Customer.Number}.' Output 'The customer is John Doe and its number is C12345.' Breakdown 'The customer is ' {Customer.Party.PartyName} Follows the reference path: Customer .Party .PartyName Evaluates to 'John Doe ' and its number is ' {Customer.Number} Follows the reference path: Customer .Number Evaluates to 'C12345' '.' Assuming that the domain object has: data member 'Customer' with members 'Party.PartyName' equal to 'John Doe' and 'Number' equal to 'C12345'. Including a format specifier Input \"The customer is {Customer.Party.PartyName:de}.\" Output \"The customer is John Doe.\" Breakdown 'The customer is ' {Customer.Party.PartyName:de} Follows the reference path: Customer .Party .PartyName Evaluates to MultilanguageString object Format specifier finds :de and applies it. Returns 'Max Mustermann' '.' #Error# Not existing reference Input 'The customer is {Customer.Name}.' Output 'The customer is #Error: Attribute 'Name' not found#.' Breakdown 'The customer is ' {Customer.Name} Follows the reference path: Customer .Name --> Fail. Reference doesn't exist. Returns error. '.'"
  },
  "advanced/string-interpolation/examples/entity.html": {
    "href": "advanced/string-interpolation/examples/entity.html",
    "title": "Entity expression examples | ERP.net Tech Docs",
    "summary": "Entity expression examples Acquiring an entity object and referencing its data member Input 'Hi, {Public_Users(a08baf52-de7a-4a39-a567-c6d7e2ab1dc8).Name}, welcome to our forum!' Output 'Hi, John Doe, welcome to our forum!' Breakdown 'Hi, ' {Public_Users(a08baf52-de7a-4a39-a567-c6d7e2ab1dc8).Name} Acquires an object of type 'User' from the Public_Users entity with the provided 'Id'. Follows the reference path: .Name Evaluates to 'John Doe' ', welcome to our forum!' Acquiring an entity object and deep-referencing its data member, including a format specifier Input 'The parent group of this product is <{General_Products_Products(1908c05a-790a-42be-a8d8-e850798b5530).ProductGroup.Parent.Name:en}>.' Output 'The parent group of this product is <Materials>.' Breakdown 'The parent group of this product is ' {General_Products_Products(1908c05a-790a-42be-a8d8-e850798b5530).ProductGroup.Parent.Name:en} Acquires an object of type 'Product' from the General_Products_Products entity with the provided 'Id'. Follows the reference path: .ProductGroup .Parent .Name Evaluates to MultilanguageString object Format specifier finds :en and applies it. Returns \"Materials\" '>.' #Error# Not existing entity Input 'Not_Existing_Entity(4ab5e1ee-c613-4f6c-aa02-eb478c99bc80)' Output \"#Error: Entity 'Not_Existing_Entity' not found#\" Breakdown 'Not_Existing_Entity(4ab5e1ee-c613-4f6c-aa02-eb478c99bc80)' Acquires an object from the Not_Existing_Entity entity with the provided 'Id' --> Fail. Entity does not exist Returns error. #Error# Not existing entity object 'Id' Input 'Public_Users(ba8469d7-4854-4ff1-a5ac-a0a60414b061)' Output '#Error: Entity object 'ba8469d7-4854-4ff1-a5ac-a0a60414b061' not found#' Breakdown 'Public_Users(ba8469d7-4854-4ff1-a5ac-a0a60414b061)' Acquires an object of type 'User' from the Public_Users entity with the provided 'Id' --> Fail. Could not find an object with such an Id. Returns error."
  },
  "advanced/string-interpolation/examples/index.html": {
    "href": "advanced/string-interpolation/examples/index.html",
    "title": "Examples | ERP.net Tech Docs",
    "summary": "Examples Below are some examples of string interpolation, grouped into different types of interpolation expressions. Each example contains an input and its corresponding ouput after the interpolation is applied. Constant expressions Data member expressions System variable expressions Entity expressions"
  },
  "advanced/string-interpolation/examples/system-variable.html": {
    "href": "advanced/string-interpolation/examples/system-variable.html",
    "title": "System variable expression examples | ERP.net Tech Docs",
    "summary": "System variable expression examples Interpolation of a globally resolved system variable Input 'Now is {$datetimeutc} (UTC)' Output 'Current database name is 01.01.2021 15:00:00 (UTC)' Breakdown 'Now is ' {$datetimeutc} Evaluates to \"01.01.2021 15:00:00' '(UTC) Externally resolved system variable Input 'Current database name is {$dbname}' Output \"Current database name is E1_PROD\" Breakdown 'Current database name is' {$dbname} Evaluates to 'E1_PROD' via an external resolver. Acquiring a data member from a system variable and applying a format specifier Input 'Current company location is {$enterprisecompanylocation.LocationName:en}.' Output 'Current company location is London, UK.' Breakdown 'Current company location is ' {$enterprisecompanylocation.LocationName:en} Resolves system variable $enterprisecompanylocation to 'CompanyLocation' object type. Follows the reference path: .LocationName Evaluates to MultilanguageString object Format specifier finds :en and applies it. Returns \"London, UK' \".\" #Error# Not existing system variable Input 'Yesterday was {$yesterday}.' Output 'Yesterday was #Error: System Variable '$yesterday' not found#.' Breakdown 'Yesterday was' {$yesterday} Resolves system variable $yesterday --> Fail. Such a system variable doesn't exist. Returns error. '.' #Error# Not existing reference Input 'My name is {$user.RealName}.' Output 'My name is #Error: Attribute 'RealName' not found#.' Breakdown `'My name is'' {$user.RealName} Resolves system variable $user to a 'User' object type. Follows the reference path: .RealName --> Fail. Reference doesn't exist. Returns error. '.'"
  },
  "advanced/string-interpolation/expression-types/constant.html": {
    "href": "advanced/string-interpolation/expression-types/constant.html",
    "title": "Constant expressions | ERP.net Tech Docs",
    "summary": "Constant expressions These expressions don't perform any evaluation and will produce an output that's the same as the input. There's no interpolation. // Input 'test' // Output 'test' // Input 'Good morning!' // Output 'Good morning!' Multi-line input is also supported. The \\n sequence is interpreted as a new line. // Input 'line1\\nline2' // Output @'line1 line2' // Input 'line1\\n\\nline3' // Output @'line1 line3' It's also possible to escape the control characters for beginning and end of an interpolation expression {, }, either by doubling {{, }}, or by using the escape character \\{, \\}. // Input '{{This one is escaped}}' // Output '{This one is escaped}' // Input '\\{This one also\\}' // Output '{This one also}' Note More details and examples are available in the Examples section."
  },
  "advanced/string-interpolation/expression-types/data-member.html": {
    "href": "advanced/string-interpolation/expression-types/data-member.html",
    "title": "DataMember expressions | ERP.net Tech Docs",
    "summary": "DataMember expressions Acquires a data member according to the object's context by the passed reference. // Input '{DocumentId}' // Output '6d954d04-105b-4277-ad2c-6a9a80076a63' // Input *Note the (two-level) reference path - (1)Customer.(2)Id '{Customer.Id}' // Output '54feef7d-c397-44f1-8c23-580a62dd93f6' // Input *Note the (three-level) reference path - (1)Customer.(2)Party.(3)PartyName '{Customer.Party.PartyName}' // Output 'John Doe' // Input (Customer.SalesPerson evaluates to null) '{Customer.SalesPerson}' // Output: '' Evaluation fails if the resolved data member doesn't exist. The output will contain an error message. In contrast, if the data member is null, the expression will evaluate to an empty string. // Input (There is no 'Name' data member in Customer) '{Customer.Name}' // Output '#Error: Attribute 'Name' not found#'. // Input (Typo error) '{Customr.Id}' // Output '#Error: Attribute 'Customr.Id' not found#'. Note More details and examples are available in the Examples section."
  },
  "advanced/string-interpolation/expression-types/entity.html": {
    "href": "advanced/string-interpolation/expression-types/entity.html",
    "title": "Entity expressions | ERP.net Tech Docs",
    "summary": "Entity expressions Resolves an object by its entity name and Id. // Input (the passed id exists) '{Public_Users(7af30531-d15d-4004-a4bb-21052299f549).Name}' // Output: 'John Doe' // Input (the passed id exists) '{General_Products_Products(4282f8c5-2ba8-4adc-b112-c9f5ca2675f2).Name}' // Output 'Product X' If the entity name or the Id don't exist, the evaluation fails, and the output will contain an error message. // Input '{General_Product(2fa67d60-be11-41ec-beac-976e666ece4f)}' // Output '#Error: Entity 'General_Product' not found#' // Input (the passed id does NOT exist) '{General_Products_Products(1cbbe47c-2f54-4fcf-be46-7eb7c5a139e8)}' // Output '#Error: Entity object '1cbbe47c-2f54-4fcf-be46-7eb7c5a139e8' not found#' The error handling when passing invalid reference still applies. The evaluation will return an error. // Input '{Public_Users(7af30531-d15d-4004-a4bb-21052299f549).FullName}' // Output '#Error: Attribute 'FullName' not found#' Note More details and examples are available in the Examples section."
  },
  "advanced/string-interpolation/expression-types/index.html": {
    "href": "advanced/string-interpolation/expression-types/index.html",
    "title": "Interpolation expression types | ERP.net Tech Docs",
    "summary": "Interpolation expression types A string is subject to interpolation and treated as a set of multiple discrete expressions. After each one is evaluated, the resulting value replaces its corresponding expression definition in the input string. There are several types of interpolation expressions, depending on the type of acquired data and the way it's obtained. Currently, ERP.net supports: Constant Data member System variable Entity"
  },
  "advanced/string-interpolation/expression-types/system-variable.html": {
    "href": "advanced/string-interpolation/expression-types/system-variable.html",
    "title": "System variable expressions | ERP.net Tech Docs",
    "summary": "System variable expressions They are case InsENSitiVE and always start with $, providing additional data unrelated to a specific object or its state. For example, if you need to get the current date, you can do it directly via the system variable $date. // Input '{$date}' // Output '01.01.2021' // Input '{$datetimeutc}' // Output '01.01.2021 15:00:00' // Input '{$rooturl}' // Output 'db.myerp.net' // Input '{$user.Name}' // Output 'John Doe' // Input '{$user.Name}' // Output 'John Doe' Note See System variables for more information and all supported system variables. If a system variable exists but is null, the expression will evaluate to an empty string. // Input '{$role.Name}' // Output '' If a system variable doesn't exist or its further reference is invalid, the evaluation will return an error. // Input '{$yesterday}' // Output '#Error: System Variable '$yesterday' not found#' // Input (FullName does not exist) '{$role.FullName}' // Output '#Error: Attribute 'FullName' not found#' Note More details and examples are available in the Examples section."
  },
  "advanced/string-interpolation/format-specifiers.html": {
    "href": "advanced/string-interpolation/format-specifiers.html",
    "title": "Format specifiers | ERP.net Tech Docs",
    "summary": "Format specifiers Format specifiers are used to state a desired format when formatting object values. In ERP.net, they can be used as a second parameter for the calculated attribute operator FORMATSTRING or in the formatting string (‘:FormatSpecifier’) when referencing domain attributes in the SENDMAIL action (‘{DomainAttribute:FormatSpecifier}’). There are two main types of format specifiers: standard .Net format specifiers (Numeric, Date - Time, etc.) custom format specifiers (Multilanguge string, Custom property) Standard .Net format specifiers The list below contains the most frequently used .Net format specifiers. For a complete list and more information, please look at the official .Net documentation site here: https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings#standard-format-specifiers Numeric format specifiers 'C', 'c' - abbreviation for Currency. Converts a number to a string that represents a currency amount. Can be used with a precision specifier that indicates the desired number of digits after the decimal point. The decimal symbol separator and the currency symbol depend on the local regional settings. Returns: 123.4656 ('C') → $123.46 123.4656 ('C3') → $123.466 'D', 'd' - abbreviation for Decimal. Converts a number to a string of decimal digits (0-9), prefixed by a minus sign if the number is negative. Can be used with a precision specifier that indicates the desired number of digits after the decimal point. This format is supported only for integral types. Returns: 1234 ('D') → 1234 1234 ('D6') → -001234 'N', 'n' - abbreviation for Number. Converts a number to a string. Can be used with a precision specifier that indicates the desired number of digits after the decimal point. The decimal symbol separator depends on the local regional settings. Returns: 123.4656 (N) → 123.47 123.4656 (N3) → 123.466 'P', 'p' - abbreviation for Percent. Multiplies a number by 100 and converts it to a string representing a percentage. The precision specifier shows the desired number of decimal places. The decimal symbol separator depends on the regional settings. Returns: 0.488869 (P) → 48.89% 0.488869 (P3) → 48.887% Date and time format strings In order to define the text representation of a date and time value, standard date-and-time format specifiers can be used alone, as standard date-and-time format string, or in combination, as custom format string. A standard date-and-time format string uses a single format specifier. Any date and time format string that contains more than one character, including white space, is interpreted as a custom format string. Standard date and time format strings: 'D', 'd' - Short date pattern. The returned format depends on the pattern set for Short date in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10.5.2019 'D' - Long date pattern. The returned format depends on the pattern set for Long date in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 'f' - Full date/time pattern (short time). The returned format depends on the pattern set for Long date and Short time in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 5:18 'F' - Full date/time pattern (long time). The returned format depends on the pattern set for Long date and Short time in the local regional settings. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 5:18:39 'M', 'm' - Month/day pattern. The returned format depends on the current culture set in the local regional settings. Returns: 2019-05-10 15:18:39.013 → May 10 'u' - Universal sortable date/time pattern. Returns: 2019-05-10 15:18:39.013 → 2019-05-10 15:18:39Z 'U' - Universal full date/time pattern. Returns: 2019-05-10 15:18:39.013 → 10 May 2019 5:18:39 'O' - Round-trip date/time pattern. ISO8601 Returns: 2019-05-10 15:18:39.013 → 2019-05-10T15:18:39.00000013Z Custom format strings 'd' - The day of the month, from 1 through 31. 'M' - The month, from 1 through 12. 'y' - The year, from 0 to 99. 'h' - The hour, using a 12-hour clock from 1 to 12. 'H' - The hour, using a 24-hour clock from 00 to 23. 'm' - The minute, from 0 through 59. 's' - The second, from 0 through 59. 'f' - The tenths of a second in a date and time value. '%' - Defines the following character as a custom '/' - Тhe current's culture date seperator. '' - The escape character. 'string', 'string' - Literal string delimiter. Examples 2019-05-10 15:18:39.013 ('dd MM yyyy hh:mm:ss.fff')→ 10 05 2019 03:18:39.013 2019-05-10 15:18:39.013 ('yyyy MM dd hh:mm:ss.fff')→ 2019 05 10 03:18:39.013 2019-05-10 15:18:39.013 ('dd M yyyy hh:mm:ss.fff')→ 10 5 2019 03:18 2019-05-10 15:18:39.013 ('dd MMM yyyy hh:mm')→ 10 May 2019 03:18 2019-05-10 15:18:39.013 ('dd/MM/yyyy hh:mm')→ 10.05.2019 03:18 2019-05-10 15:18:39.013 ('dd/MM/yyyy hh:mm')→ 10/05/2019 03:18 2019-05-10 15:18:39.013 (dd-MM-yyyy hh:mm)→ 10-05-2019 03:18 2019-05-10 15:18:39.013 ('dd MM yyyy hh:mm 'h'')→ 10 05 2019 03:18 h Custom format specifiers There are also custom format specifiers created specifically for ERP.net. They're different for the different data types and are described below. Multilanguge string 'C', 'CURRENT' - returns the string of the current value. 'D', 'DUMP' - returns the content of the multilanguage string in the format: EN=<english-string> DE=<german-string> 'T', 'TRANSLITERATED' - returns transliteration to the current language. format specifiers for a particular language - return the translation of a specified language. If there's no transliteration set for that language, they return an empty string. Note Format specifiers for a particular language are supported since ERP.net version 2019.1. Language format specifiers 'EN' - English 'BG' - Bulgarian 'CS' - Czech 'FR' - French 'DE' - German 'EL' - Greek 'HU' - Hungarian 'IT' - Italian 'MK' - Macedonian 'PL' - Polish 'PT' - Portuguese 'RO' - Romanian 'RU' - Russian 'SR' - Serbian 'ES' - Spanish Custom property 'VD' - abbreviation for Value/Description. Returns: <Value>: <Description> 'V' - abbreviation for Value. Returns: <Value> 'VDI' - abbreviation for Value/Description/Id. Returns: <Value>: <Description> (<Value-Id>) 'D' - abbreviation for Description. Returns: <Description> Language specifier as <_Lang> suffix - Custom property value also support language specifier for the multilanguage Description. The language can be specified at the end of the format specifier like FORMAT_LANGUAGE. For example: VD_EN, VDI_EN, D_EN where _EN specifies that the english translation of the Description will be returned."
  },
  "advanced/string-interpolation/index.html": {
    "href": "advanced/string-interpolation/index.html",
    "title": "String interpolation | ERP.net Tech Docs",
    "summary": "String interpolation String interpolation is a process in which an input string is broken into (interpolation) expressions. ERP.net tries to evaluate each interpolation expression and replace it with its string representation. String interpolation is available for each object. Abstract Below is a pseudo example of how string interpolation works: In the following input: 'Where there’s {EXPRESSION1}, there’s {EXPRESSION2}.'. {EXPRESSION1} and {EXPRESSION2} will be replaced with their string representations - smoke and fire. Finally, the interpolated string is presented to the output: 'Where there’s smoke, there’s fire.' Let's try a real-world example: Input: Now is {$date}. My name is {$user.Name}. Note {$date} and {$user.Name}. They're real expressions. Output: Now is 4.10.2021 17:49:55. My name is John Doe. More advanced examples: // Input \"The following string was interpolated on {$date:ddd}\" // Output (interpolated) \"The following string was interpolated on 21-09-27\" // Input \"https://myservice.com?database={$dbname}&id={Id}\" // Output (interpolated) \"https://myservice.com?database=mydbname&id=39acf964-4e92-4d35-846e-c8a38efff02d\" It's possible to interpolate even far more complex strings: // Input @\"Hello, {Public_Users(d30f16c9-a07a-41ca-9d63-e15c3e4db6b4).Name:en}! My name is {$user.Name:en} and I work as a {$role.Name} in {$enterprisecompany.Company.Name:en}.\" // Output (interpolated) @\"Hello, John Doe! My name is Jane Doe and I work as a Manager in ABC Company Ltd.\" Note More details and examples are available in the Examples section. Syntax The overall syntax for an interpolation expression is: {<$>reference<(args)><.subref><:fmt>} where: The curly brackets {, } define the start and the end of the interpolation expression. $ - specifies that the expression is a System Variable. ref (required) - the identifier to the context of the interpolation expression. (args) - additional arguments must be passed when evaluating a Entity expressions. E.g. an Id. .subref - required when ref referes to an object, but a data member is needed. E.g. Customer.Party.PartyName, where Customer is the context (i.e. the ref) and the .Party.PartyName is the path to the data member - the subreference. In short, .subref defines a path that will be followed after evaluation of ref. :fmt - format specifier. Further formatting of the evaluated value. E.g. Customer.Party.PartyName:en will format the resulting PartyName MultiFormatString according to particular language, referenced with en (English). Warning If an interpolation expression can't be evaluated because of incorrect syntax or wrong (non-existing) reference, the evaluation will fail and will return an error. '{Customer.Number}' will produce 'C12345', but '{Customer.Numer}' will output \"#Error: Attribute 'Customer.Number' not found#\". Format specifiers If an interpolation expression evaluates to an object, future customization of the value to a desired format is possible. The target format depends on the object type. For a 'Number' type, the 'C' format specifier acts as number-to-currency string conversion, but if the object type is 'MultilanguageString', the format specifier will return the string of the current value. See more Expression types Format specifiers System variables Escape sequences Examples"
  },
  "advanced/string-interpolation/system-variables.html": {
    "href": "advanced/string-interpolation/system-variables.html",
    "title": "System variables | ERP.net Tech Docs",
    "summary": "System variables System variables are an essential part of ERP.net string interpolation. They provide additional kind of data, unrelated to a specific object or its state. For example, if you need to get the current date, you can do it directly via the system variable $date. Each system variable starts with $, which identifies it as such, and must be surrounded by curly brackets { }. {$date} is a legitimate system variable selector (or expression) which will evaluate to the current date. There are also system variables with values depending on specific context, like the current transaction or a specific application. They're evaluated via an externally provided resolver. Below, you can find all system variables, their return type and the resolvers by which they're supported. System Variable Type Description $date DateTime Server system date. $time DateTime Server system time. $datetime DateTime Server system date and time. $datetimeutc DateTime Server system date and time in UTC. $newguid string Serialized random Guid. $dbname string Database name. $instance string Current database instance. Equals to $rooturl, but without the scheme prefix (i.e., https://) $rooturl string Current database URL. $repository1 string The repository name the object is part of. $entity1 (obsolete) string The entity name the object is part of. $idlist1 string Comma-separated list with Ids (serialized Guid) of the current context. For example, the selected rows in a Navigator Form. $enterprisecompany EnterpriseCompanies The enterprise company in the current (transaction) context. $enterprisecompanylocation CompanyLocations The enterprise company Location in the current (transaction) context. $user Public.Users User instance of the current user. $role Roles Role instance of the user's role. $language string The language name (UI culture) of the current user. 1 When applicable. E.g., $repository can't be evaluated when there's no repository context where the interpolation is performed."
  },
  "advanced/user-business-rules/action-types/aiset.html": {
    "href": "advanced/user-business-rules/action-types/aiset.html",
    "title": "AISET | ERP.net Tech Docs",
    "summary": "AISET Name AISET Description AISET sets the value of an attribute with the result of an AI prompt. It uses the default AI model to process the prompt. Parameter 1 Attribute, which should be set. Parameter 1 type Attribute Parameter 2 AI Prompt Parameter 2 type string - Constant, Formatted string or Interpolate Parameter 3 Timeout, ms (optional) Default = 2000 ms. Parameter 3 type string - Constant, Formatted string or Interpolate Examples See the Example section below Version Introduced in: 24 Compatible events chart AISET is compatible with all events. Event type Compatibility with AISET Client commit (e.g. CLIENTCOMMIT, AGGREGATECLIENTCOMMIT) compatible Client committed (e.g. CLIENTCOMMITTED, AGGREGATECLIENTCOMMITTED) compatible Document events - (e.g. STATECHANGING, STATECHANGED, VOIDING) compatible Commit (e.g. COMMIT) compatible Committed (e.g. COMMITTED) compatible Front-end (e.g. CREATENEW, ATTRIBUTECHANGING, ATTRIBUTECHANGED) compatible Example: А business rule triggers when a product name is changed and generates its abbreviated version (i.e., Product.ShortName). Repository General.Products.Products Events Event type Event parameter Execution priority ATTRIBUTECHANGED Name Normal Actions Action No Action type Parameter1 type Parameter1 value Parameter2 type Parameter2 value Parameter3 type (optional) Parameter3 value 1 AISET Attribute ShortName Interpolate Just return a 4-symbol abbreviation of this input: {Name}. Constant 2000 The parameters are as follows: Specifies that we'll set a new value in the ShortName attribute. Specifies an AI prompt, instructing for the desired result. Specifies that there's a timeout of 2000 milliseconds. Key points and specific limitations The results depend entirely on the AI engine and the specified prompt. With vaguer instructions, it's possible to receive different output for the same input. If the AI engine doesn't respond within the specified timeout, you will receive an empty string. See more String interpolation"
  },
  "advanced/user-business-rules/action-types/aivalidate.html": {
    "href": "advanced/user-business-rules/action-types/aivalidate.html",
    "title": "AIVALIDATE | ERP.net Tech Docs",
    "summary": "AIVALIDATE Name AIVALIDATE Description Perform a validation, based on AI prompt. If the validation fails, an exception is thrown. Parameter 1 The AI prompt used to perform the validation. Usually, the AI prompt would be an interpolated string, interpolating the values, which should be validated in an AI prompt. It should return \"true\" if the validation is successful. Any other value (or timeout) would mean failure. Parameter 1 type string - Constant, Formatted string or Interpolate Parameter 2 The message, which should be provided to the user if the validation fails. The message might include the validated values using an interpolated (formatted) string parameter. Parameter 2 type string - Constant, Formatted string or Interpolate Parameter 3 Timeout, ms (optional) Parameter 3 type Constant (integer) Default = 2000 ms. Examples See the Example section below Version Introduced in: 24 Compatible events chart AIVALIDATE is compatible with all events. Event type Compatibility with AIVALIDATE Client commit (e.g. CLIENTCOMMIT, AGGREGATECLIENTCOMMIT) compatible Client committed (e.g. CLIENTCOMMITTED, AGGREGATECLIENTCOMMITTED) compatible Document events - (e.g. STATECHANGING, STATECHANGED, VOIDING) compatible Commit (e.g. COMMIT) compatible Committed (e.g. COMMITTED) compatible Front-end (e.g. CREATENEW, ATTRIBUTECHANGING, ATTRIBUTECHANGED) compatible Example: А business rule FAILS when a bank account code is not validated. Repository General.Contacts.PartyBankAccounts Events Event type Event parameter Execution priority ATTRIBUTECHANGED BankAccountCode Normal Actions Action No Action type Parameter1 type Parameter1 value Parameter2 type Parameter2 value Parameter3 type (optional) Parameter3 value 1 AIVALIDATE Interpolate Is '{BankAccountCode}' a valid IBAN? Interpolate The provided IBAN {BankAccountCode} isn't valid! Constant 2000 The parameters are as follows: Specifies that we're checking if the provided IBAN is valid. Specifies the error message to return if the validation fails. Specifies that there's a timeout of 2000 milliseconds. Key points and specific limitations The results depend entirely on the AI engine and the specified prompt. With vaguer instructions, it's possible to receive different output for the same input. If the AI engine doesn't respond within the specified timeout, you will receive an empty string. See more String interpolation"
  },
  "advanced/user-business-rules/action-types/aiwarning.html": {
    "href": "advanced/user-business-rules/action-types/aiwarning.html",
    "title": "AIWARNING | ERP.net Tech Docs",
    "summary": "AIWARNING Name AIWARNING Description Perform a validation, based on AI prompt. If the validation fails, a warning is sent. Parameter 1 The AI prompt used to perform the validation. Usually, the AI prompt would be an interpolated string, interpolating the values, which should be validated in an AI prompt. It should return \"true\" if the validation is successful. Any other value (or timeout) would mean failure. Parameter 1 type string - Constant, Formatted string or Interpolate Parameter 2 The message, which should be provided to the user if the validation fails. The message might include the validated values using an interpolated (formatted) string parameter. Parameter 2 type string - Constant, Formatted string or Interpolate Parameter 3 Timeout, ms (optional) Parameter 3 type Constant (integer) Default = 2000 ms. Examples See the Example section below Version Introduced in: 24 Compatible events chart AIWARNING is compatible with all events. Event type Compatibility with AIWARNING Client commit (e.g. CLIENTCOMMIT, AGGREGATECLIENTCOMMIT) compatible Client committed (e.g. CLIENTCOMMITTED, AGGREGATECLIENTCOMMITTED) compatible Document events - (e.g. STATECHANGING, STATECHANGED, VOIDING) compatible Commit (e.g. COMMIT) compatible Committed (e.g. COMMITTED) compatible Front-end (e.g. CREATENEW, ATTRIBUTECHANGING, ATTRIBUTECHANGED) compatible Example: А business rule sends a warning when a party name doesn't look like a real one. Repository General.Contacts.Persons Events Event type Event parameter Execution priority ATTRIBUTECHANGED PartyName Normal Actions Action No Action type Parameter1 type Parameter1 value Parameter2 type Parameter2 value Parameter3 type (optional) Parameter3 value 1 AIWARNING Interpolate Does this '{PartyName}' seem like a real name? Interpolate The provided name '{PartyName}' does not seem like a real one. Constant 10000 The parameters are as follows: Specifies that we're checking if the provided IBAN is valid. Specifies the error message to return if the validation fails. Specifies that there's a timeout of 2000 milliseconds. Key points and specific limitations The results depend entirely on the AI engine and the specified prompt. With vaguer instructions, it's possible to receive different output for the same input. If the AI engine doesn't respond within the specified timeout, you will receive an empty string. See more String interpolation"
  },
  "advanced/user-business-rules/action-types/fail.html": {
    "href": "advanced/user-business-rules/action-types/fail.html",
    "title": "FAIL | ERP.net Tech Docs",
    "summary": "FAIL It's mostly used to include additional validations in the system which aren't yet implemented. If FAIL is performed, the current business rule will throw an error. You can set the error text as a constant that's entered as a first parameter type and a value. Example: Action No: 1; Action type: FAIL; Parameter1 type: Constant; Parameter1 value: 'error message text'"
  },
  "advanced/user-business-rules/action-types/index.html": {
    "href": "advanced/user-business-rules/action-types/index.html",
    "title": "Action types | ERP.net Tech Docs",
    "summary": "Action types The following types of actions are available when creating user business rules: AISET AIVALIDATE AIWARNING FAIL NOTIFYUSER SENDMAIL SETVALUE WARNING WEBHOOK"
  },
  "advanced/user-business-rules/action-types/notifyuser.html": {
    "href": "advanced/user-business-rules/action-types/notifyuser.html",
    "title": "NOTIFYUSER | ERP.net Tech Docs",
    "summary": "NOTIFYUSER Name NOTIFYUSER Description Used for creating notifications with a specific text for the object that triggered the business rule. These notifications will later be sent to users indicated in the rule by the Notifications system. The action creates a record in the Notifications table for each user specified in Parameter1: UserId = the Id of the user in Parameter1 ValueSubject = Parameter2 ValueNotificationClass = Parameter3 DataObject = the EDO of the aggregate root of the entity for which the rule has been triggered. if empty - set a default value 'BR' + '_ ' + 'UserBusinessRule.Code', e.g. 'BR_0005' For more info, see Aggregates and EDO. If there aren't explicitly created notification settings for the class specified in Parameter3, the notification will only be sent as an in-app notification. IMPORTANT: NOTIFYUSER is not compatible with all events. For more info, see the Compatible events chart section below. Parameter 1 The user(s) for which a notification will be created. You can set either the UserId or the user's login. If there's more than one recipient, they can be entered in a comma-separated list which must contain only UserIds (Id1,Id2,...IdN) or logins (Login1,Login2,...LoginN). Parameter 1 type Guid, String, List Parameter 2 The text displayed in the notification. Parameter 2 type String // usually used in combination with formatted string Parameter 3 (Optional) The class which will be set for the notification. It must meet the format specified in R35312 Notifications - Validate Notification Class If the parameter isn't explicitly set, a default value will be used instead: 'USR' + '_' + 'BR' + '_' + 'UserBusinessRule.Code', e.g. 'USR_BR_0005'. For more information about classes, see Notifications. Parameter 3 type String Examples see the Example section below Version Introduced in: 2020.1 Compatible events chart NOTIFYUSER is not compatible with all events. Event type Compatibility with NOTIFYUSER Client commit (e.g. CLIENTCOMMIT, AGGREGATECLIENTCOMMIT) compatible Document events - (e.g. STATECHANGING, STATECHANGED, VOIDING) compatible Commit (e.g. COMMIT) incompatible// NOTIFYUSER will create a notification which will be displayed on the next login into the program. Front-end (e.g ATTRIBUTECHANGING, ATTRIBUTECHANGED) incompatible// NOTIFYUSER won't create a notification. Example: А business rule creates a notification for а sales person when one of their sales orders has been released. Repository Crm.Sales.SalesOrders Events Event type Event parameter Execution priority Change of state RELEASED Normal Actions Action No Action type Parameter1 type Parameter1 value Parameter2 type Parameter2 value Parameter3 type Parameter3 value 1 NOTIFYUSER Attribute SalesPersonId Formatted string sales order {DocumentNo} has been released. Constant USR_SALESPERSON_SORELEASED"
  },
  "advanced/user-business-rules/action-types/sendmail.html": {
    "href": "advanced/user-business-rules/action-types/sendmail.html",
    "title": "SENDMAIL | ERP.net Tech Docs",
    "summary": "SENDMAIL Name SENDMAIL Description Used for sending notification emails using business rules. Emails can be sent to multiple recipients and the subject and body can be customized according to the business's needs. For more information, check out the Subject and body customization section below. The address from which emails are sent is the one set in the From E-mail Address For System Notifications field in the ERP.net application server settings. IMPORTANT: SENDMAIL is not compatible with all events. For more info, see the Compatible Events Chart section below. Parameter 1 [TO] - the email address/es to which the mail is going to be sent. If there's more than one recipient, they can be entered in a comma-separated list (email1,email2...,emailN). Parameter 1 type Constant, Attribute (type must be 'String') Parameter 2 [SUBJECT] - the line with the subject of the email. Parameter 2 type Constant, Attribute (type must be 'String') Parameter 3 [BODY] - the content of the body of the email. Supports multi-line. Parameter 3 type Constant, Attribute (type must be 'String') Example see the end of the article Introduced in version 2019.1 Note Currently, parameters of business rules can include up to 256 symbols. Compatible events chart SENDMAIL is not compatible with all events. Take a look at the following chart: Event type Compatibility with SENDMAIL Client commit (e.g. CLIENTCOMMIT, AGGREGATECLIENTCOMMIT) compatible Document events - (e.g. STATECHANGING, STATECHANGED, VOIDING) compatible Commit (e.g. COMMIT) compatible but not recommended - if possible, use CLIENTCOMMIT instead Front-end (e.g ATTRIBUTECHANGING, ATTRIBUTECHANGED) incompatible, the server won't send an email Subject and body customization Text in the parameters for Subject and Body can be customized. For added convenience, there are a couple of implementations providing more formatting capabilities and facilitating the action as a whole. escape charts The following escape chars are handled: \\n - newline - supported in the Body \\r\\n - new line - supported in the Body \\{ - insert opening curly bracket '{' in output. - supported in both the Subject and the Body \\} - insert closing curly bracket '}' in output. - supported in both the Subject and the Body HTML tags - supported in the Body For text to be recognized as HTML, the Body has to contain the </html> tag. The position of the tag is irrelevant. If it's placed somewhere, the whole text is considered written in HTML. Use of domain attributes in text - supported in both the Subject and the Body In the text of both parameters for Subject and Body, you can reach and use the domain attributes' values (system domain attributes and calculated attributes). They're calculated for the entity record for which the rule is executed. In order for a domain attribute to be property recognized by the system, it needs to be surrounded with curly brackets '{...}'. The following options are supported: Attributes: {DocumentDate}. References: {Customer}. Reference path: {Customer.Party.PartyName}. Note that child collections are not supported. Domain attributes formatting - supported in both the Subject and the Body Domain attribute values can be formatted with standard .Net format specifiers and system-specific attributes. Example: А business rule that sends an email with an order confirmation to the customer and the sales manager when a sales order has been released. Repository Crm.Sales.SalesOrders Events Event type Event parameter Execution priority Change of state RELEASED Normal Actions Action No Action type Parameter1 type Parameter1 value Parameter2 type Parameter2 value Parameter3 type Parameter3 value 1 SENDMAIL Constant salesmanager@mail.com, customer@gmail.com Constant Order No{DocumentNo} has been confirmed Constant <p>Dear Customer,</p><p><b> Your order has been confirmed! </b></p><br/><p><h3>SUMMARY</h3></p><p>Order Number: <i>{DocumentNo}</i></p><p>Order Date: <i>{DocumentDate:dd-MM-yyyy}</i></p><p>Shipping Address: <i>{ShipToPartyContactMechanism. ContactMechanism.Name}</i></p><p>Delivery Date: <i>{RequiredDeliveryDate:dd-MM-yyyy}</i></p><p>Order Total: <i>{#CalculatedAttributeTotalSalesOrderAmount:C}</i></p><p>Payment Method: <i>{PaymentType.Name}</i></p><br/><p>Please expect your parcel to arrive on the delivery date stated above at the address or at the office of the courier company.</p><br/><p>Kind Regards,</p><strong>{SalesPerson.Person.FirstName} {SalesPerson.Person.LastName}<strong/></html> Sample email received by the recipients: Subject: 'Order No00329 has been confirmed' Body: Dear Customer, Your order has been confirmed! SUMMARY Order number: 00329 Order date: 10-05-2019 Shipping address: 21 Lombard St Delivery date: 12-05-2019 Order total: $14.82 Payment method: Cash on delivery Expect your parcel at the address or the office of the courier company on the delivery date stated above. Kind Regards, John Smith"
  },
  "advanced/user-business-rules/action-types/setvalue.html": {
    "href": "advanced/user-business-rules/action-types/setvalue.html",
    "title": "SETVALUE | ERP.net Tech Docs",
    "summary": "SETVALUE This action type is used to implicitly update information or data in the system. When all conditions of a business rules are met and a specified event happens, SETVALUE updates the value of the specified attribute available for the repository, including custom properties of the particular entity. The action requires the following parameters: Parameter 1 - the updated (or set) value. Currently, the available parameter type is 'Attribute'. You should enter the name of the attribute whose value needs to be modified. Parameter 2 - the value set in Parameter 1. The available parameter types are 'Attribute' and 'Constant'. If the parameter type is 'Attribute', select the name of the attribute in the parameter value. This value will be used to as a value for Parameter 1. If the parameter type is 'Constant', enter a constant in the parameter value. Every time the user business rule is executed, Parameter 1 will be set to a constant value. The format of the different types of constants is described here. Example: Repository Crm.Sales.SalesOrders Events Event type Event parameter Execution priority Change of state RELEASING Normal Actions Action No Action type Parameter1 type Parameter1 value Parameter2 type Parameter2 value 1 SETVALUE Attribute Notes Constant 'Approved'"
  },
  "advanced/user-business-rules/action-types/warning.html": {
    "href": "advanced/user-business-rules/action-types/warning.html",
    "title": "WARNING | ERP.net Tech Docs",
    "summary": "WARNING Typically used to show a non-blocking message that can help when you want to display a reminder instead of stopping a transaction with an error using a FAIL business rule. If WARNING is performed, the displayed message is set as a first parameter for the action. Example: Action No: 1; Action type: WARNING; Parameter1 type: Constant; Parameter1 value: 'warning message text'"
  },
  "advanced/user-business-rules/action-types/webhook.html": {
    "href": "advanced/user-business-rules/action-types/webhook.html",
    "title": "WEBHOOK | ERP.net Tech Docs",
    "summary": "WEBHOOK Name WEBHOOK Description Used for executing a webhook using business rules. The webhook to be executed must be an existing webhook template, part of the Web Hooks entity. Parameter 1 specifies its code. The WEBHOOK action type is executed asynchronously by the server with the limitations, listed in the section below Key points and specific limitations. Parameter 1 [WEBHOOK CODE] - the code of the webhook to be executed. Parameter 1 type Constant (string) Parameter 2 Not used Parameter 3 Not used Examples See the Example section below Version Introduced in: 2022 Compatible events chart WEBHOOK is compatible with all events. Event type Compatibility with WEBHOOK Client commit (e.g. CLIENTCOMMIT, AGGREGATECLIENTCOMMIT) compatible Client committed (e.g. CLIENTCOMMITTED, AGGREGATECLIENTCOMMITTED) compatible Document events - (e.g. STATECHANGING, STATECHANGED, VOIDING) compatible Commit (e.g. COMMIT) compatible Committed (e.g. COMMITTED) compatible Front-end (e.g. CREATENEW, ATTRIBUTECHANGING, ATTRIBUTECHANGED) compatible Example: А business rule executes a webhook when a service activity is created or updated. Repository Applications.Service.ServiceActivities Events Event type Event parameter Execution priority AGGREGATECLIENTCOMMIT Normal Actions Action No Action type Parameter1 type Parameter1 value 1 WEBHOOK Constant wh_01 The value of the WEBHOOK's Parameter1 is simply the code of the corresponding Web Hook entity. Name Value Code wh_01 Name Webhook 01 Repository name Applications.Service.ServiceActivities URL http://my-external-system:12345/{EntityName} Body {{ \"Id\": \"{Id}\", \"Number\": \"{DocumentNo}\", \"Date\": \"{DocumentDate}\", \"Subject\": \"{Subject}\", \"State\": \"{State}\" }} Headers User-Agent: ERP.net X-Auth-Token: my_security_token Retry logic Retry up to 3 times Notes Sends a HTTP POST request to the target url, identifying the updated service activity. The table above shows the webhook template \"behind\" the code \"wh_01\". Note that the values for the URL and body properties are using string interpolation. And because a webhook is by definition just a HTTP POST request, you can see below what the HTTP message would look like, according to the examples above. POST /Srv_Service_Activities HTTP/1.1 Host: my-external-system:12345 User-Agent: ERP.net X-Auth-Token: my_security_token Content-Length: 153 { \"Id\": \"9b68c23b-e3bc-4aa3-a906-cfa83fe1cdfc\", \"Number\": \"00001\", \"Date\": \"12.01.2022\", \"Subject\": \"Test activity\", \"State\": \"New\" } Key points and specific limitations Each webhook is executed asynchronously by the server, by putting it in a queue (FIFO). Each ERP instance has its own queue, processed independently. There's an intentional pause of 1 second after the execution of each webhook before proceeding to the next one. A queue is capped of 1000 webhooks. Any webhook that would exceed it will be discarded. Only the first webhook discard event will be logged for a calendar day as a warning. Each webhook has a timeout of 10 seconds to get a response from the external system. All HTTP response codes that are not in the range [200-299] (as well as the timeouts) are treated as errors and logged as such. There's a quota allowing logging up to 100 errors per calendar day. Warning When a webhook action is triggered by events other than *COMMITTED, the webhook is dispatched. However, at this point, the ERP.net transaction is still in progress. This means that the upcoming changes haven't yet taken place. Consequently, if your external application performs a READ operation, there's a chance that you're reading an outdated record— i.e., one that has not yet been physically committed. The same applies when you CREATE and CHANGE the state of a document simultaneously, i.e., at once, especially when utilizing a document generation procedure. A common approach is for your external application to implement an initial delay upon receiving the webhook, ensuring sufficient time for the entire process (i.e. the ERP.net transaction) to complete before proceeding with its subsequent actions. See more Webhook wiki WebHooks entity String interpolation"
  },
  "advanced/user-business-rules/events/aggregate-client-commit.html": {
    "href": "advanced/user-business-rules/events/aggregate-client-commit.html",
    "title": "AGGREGATE CLIENT COMMIT | ERP.net Tech Docs",
    "summary": "AGGREGATE CLIENT COMMIT Name AGGREGATECLIENTCOMMIT Layer Back-end Description Occurs for the aggregate root when saving a change of an aggregate object, but only when the change is made by a client application. If it's made by the server, the event won't be triggered. Version Introduced: 2019.1, Updated:- This event is a variation of the CLIENT COMMIT event. It allows triggering user business rules for objects which are an aggregate root. This can happen when there's a change for the object itself and/or when some of its referent objects are edited. Let's take a look at the following structure - a single aggregate in ERP.net: sales order (which is the aggregate's root) sales order lines of this sales order distributed amounts for each of these sales order lines document amounts of this sales order payment plan of this sales order In the example above, a CLIENT COMMIT event would occur for the sales order only if its object has changed. The AGGREGATE CLIENT COMMIT will occur if any of the objects in the aggregate have changed. Changing just a single sales order line without changing the order itself still triggers the aggregate event. In summary, a user business rule with an aggregate client commit event will be triggered when: the saving is performed by a client application; the repository of the user business rule is an aggregate root entity; there's a change for the aggregate root or for some of its constituent objects."
  },
  "advanced/user-business-rules/events/aggregate-client-committed.html": {
    "href": "advanced/user-business-rules/events/aggregate-client-committed.html",
    "title": "AGGREGATE CLIENT COMMITTED | ERP.net Tech Docs",
    "summary": "AGGREGATE CLIENT COMMITTED Name AGGREGATECLIENTCOMMITTED Layer Back-end Description Occurs for the aggregate root after a change is made to an aggregate object, but only when the change is made by a client application. If it's made by the server, the event won't be triggered. Version Introduced: 2023 Updated:- This event is a variation of the CLIENT COMMITTED event. It allows triggering user business rules for objects which are an aggregate root. This can happen when there's a change for the object itself and/or when some of its referenced objects are edited. Let's take a look at the following structure - a single aggregate in ERP.net: sales order (which is the aggregate's root) sales order lines of this sales order distributed amounts for each of these sales order lines document amounts of this sales order payment plan of this sales order In the example above, a CLIENT COMMITTED event would occur for the sales order only if its object has changed. The AGGREGATE CLIENT COMMITTED will occur if any of the objects in the aggregate have changed. Changing just a single sales order line without changing the order itself still triggers the aggregate event. In summary, a user business rule with an aggregate client committed event will be triggered when: the saving was performed by a client application; the repository of the user business rule is an aggregate root entity; there's a change for the aggregate root or for some of its objects, part of the aggregate tree. Note The main difference with the \"AGGREGATECLIENTCOMMIT\" event is that AGGREGATECLIENTCOMMITTED occurs after the actual commit. I.e. if AGGREGATECLIENTCOMMITTED triggers, there's a guarantee that the entity is already saved and exists in the database."
  },
  "advanced/user-business-rules/events/attributechanged.html": {
    "href": "advanced/user-business-rules/events/attributechanged.html",
    "title": "ATTRIBUTECHANGED | ERP.net Tech Docs",
    "summary": "ATTRIBUTECHANGED Name ATTRIBUTECHANGED Layer Front-end Description Occurs after the attribute's value is changed. The attribute's name is specified in the 'Event Parameter' field. Version Introduced: 2019 Updated: - The ATTRIBUTECHANGED event is always used with a Parameter, which is the name of the Attribute (Field) whose value change triggers the event. This event occurs immediately after the value changes. A typical use case is when you need to save, set, or calculate something based on the new value of the field. Example Event: ATTRIBUTECHANGED(QuantityValue) Action: ActionType: SETVALUE | Attribute: Notes | Attribute: QuantityValue The Quantity in the line is 5.00. The user changes the Quantity to 7.00. The change of the Quantity field triggers the rule and sets the New value i.e. 7.00 to the Notes field."
  },
  "advanced/user-business-rules/events/attributechanging.html": {
    "href": "advanced/user-business-rules/events/attributechanging.html",
    "title": "ATTRIBUTECHANGING | ERP.net Tech Docs",
    "summary": "ATTRIBUTECHANGING Name ATTRIBUTECHANGING Layer Front-end Description Occurs before the attribute's value is changed. The attribute's name is specified in the 'Event Parameter' field. Version Introduced: 2019 Updated: - The ATTRIBUTECHANGING event is always used with a Parameter, which is the name of the Attribute (Field) whose value change triggers the event. This event occurs immediately before the value changes. A typical use case is when you need to save, set, or calculate something based on the previous (old) value of the field. Example Event: ATTRIBUTECHANING(QuantityValue) Action: ActionType: SETVALUE | Attribute: Notes | Attribute: QuantityValue The Quantity in the line is 5.00. The user changes the Quantity to 7.00. The change of the Quantity field triggers the rule and sets the Old value i.e. 5.00 to the Notes field."
  },
  "advanced/user-business-rules/events/beforerecalculate.html": {
    "href": "advanced/user-business-rules/events/beforerecalculate.html",
    "title": "BEFORERECALCULATE | ERP.net Tech Docs",
    "summary": "BEFORERECALCULATE Name BEFORERECALCULATE Layer Front-end Description Occurs before every recalculation of the amounts in the document. Version Introduced: 2025 Updated: - This event occurs before every recalculation of the amounts in the logistic documents. It can be used in the headers of documents, the rows with prices and amounts, and the additional amounts for documents. The recalculation occurs at different times depending on the key DisableDocumentRecalculationOnIdle. If DisableDocumentRecalculationOnIdle <> 1, it happens after entering each row as well as when certain fields in the header are changed. If DisableDocumentRecalculationOnIdle = 1, it happens upon saving the document. BEFORERECALCULATE would be to used it in rules for additional amounts in documents, such as applying discounts or changing the VAT rate depending on other fields in the document. Note It should be noted that BEFORERECALCULATE can only be used in Front-End rules."
  },
  "advanced/user-business-rules/events/client-commit.html": {
    "href": "advanced/user-business-rules/events/client-commit.html",
    "title": "CLIENT COMMIT | ERP.net Tech Docs",
    "summary": "CLIENT COMMIT Name CLIENTCOMMIT Layer Back-end Description Occurs when saving a change of an object, made by a client application. If the change is made by the server, the event won't be triggered. Version Introduced: 2019.1 Updated: - This event is a variation of COMMIT. Both occur for a particular object from the repository of a user business rule when an object change is saved. However, CLIENT COMMIT is triggered only when the saving is initiated by a client application, such as ERP.net Windows Client. If an object is modified by the ERP.net server, the event won't be triggered. This could be used if, for example, you want the business rule to be executed when you're manually saving a document, but the system is currently saving the document after its creation with a generation procedure."
  },
  "advanced/user-business-rules/events/client-committed.html": {
    "href": "advanced/user-business-rules/events/client-committed.html",
    "title": "CLIENT COMMITTED | ERP.net Tech Docs",
    "summary": "CLIENT COMMITTED Name CLIENTCOMMITTED Layer Back-end Description Occurs after saving a change to an object, made by a client application. If the change is made by the server, this event won't be triggered. Version Introduced: 2023 Updated: - This event is a variation of COMMITTED. Both occur for a particular object from the repository of a user business rule after an object change is saved. However, CLIENT COMMITTED is triggered only if the saving was initiated by a client application, such as ERP.net Windows Client or ERP.net Web Client. If an object is modified by the ERP.net server, the event won't be triggered. This is especially useful for data-sync scenarios when the external application has to be notified (e.g., via a webhook) when an entity changes (or is created)."
  },
  "advanced/user-business-rules/events/commit.html": {
    "href": "advanced/user-business-rules/events/commit.html",
    "title": "COMMIT | ERP.net Tech Docs",
    "summary": "COMMIT Name COMMIT Layer Back-end Description Occurs when saving a change of an object. Version Introduced: 2017.1 Updated: - This event occurs when data is saved into a database. It's used for all kinds of data types - definitions, documents and more. When an object change is saved, the rule is activated, as long as it meets the conditions. COMMIT may be used to validate that all necessary data of a product is entered. If not - an error could be thrown (with the help of FAIL) and the product wouldn't be saved in the database until correct data is entered."
  },
  "advanced/user-business-rules/events/committed.html": {
    "href": "advanced/user-business-rules/events/committed.html",
    "title": "COMMITTED | ERP.net Tech Docs",
    "summary": "COMMITTED Name COMMITTED Layer Back-end Description Occurs after an object change is saved. Version Introduced: 2023 Updated: - This event occurs after data is actually saved into a database. It's used for all kinds of data types - definitions, documents and more. After an object change is saved, the rule is activated, as long as it meets the conditions. COMMITTED can be used for scenarios where you want to notify that an object has been created or modified. E.g. to send an email, notification or a webhook. Note The main difference with the \"COMMIT\" event is that COMMITTED occurs after the actual commit. I.e. if COMMITTED triggers, there's a guarantee that the entity is already saved and exists in the database."
  },
  "advanced/user-business-rules/events/create-new.html": {
    "href": "advanced/user-business-rules/events/create-new.html",
    "title": "CREATENEW | ERP.net Tech Docs",
    "summary": "CREATENEW Name CREATENEW Layer Front-end Description Occurs immediately after creating a new object. Version Introduced: 2022 Updated: - This event occurs immediately after the following core events: The object creation Initialization of its system attributes This is the earliest possible point in the object's life cycle. A typical use case is when you need to initialize one or more object attributes with user-defined values. Note The object has not yet been saved and has never been. I.e., its first commit is coming up. See more Set an initial attribute for a new sales order"
  },
  "advanced/user-business-rules/events/index.html": {
    "href": "advanced/user-business-rules/events/index.html",
    "title": "User business rules - Events | ERP.net Tech Docs",
    "summary": "User business rules - Events AGGREGATE CLIENT COMMIT AGGREGATE CLIENT COMMITTED ATTRIBUTECHANGED ATTRIBUTECHANGING BEFORERECALCULATE CLIENT COMMIT CLIENT COMMITTED COMMIT COMMITTED CREATENEW STATECHANGED STATECHANGING VOIDING"
  },
  "advanced/user-business-rules/events/statechanged.html": {
    "href": "advanced/user-business-rules/events/statechanged.html",
    "title": "STATECHANGED | ERP.net Tech Docs",
    "summary": "STATECHANGED Name STATECHANGED Layer Back-end Description Occurs when a document state specified in the Parameter field is changed. Version Introduced: 2017.1 Updated: - This event occurs AFTER the change of the document state but BEFORE that change is saved. Example 1 There's a FAIL action set on a STATECHANGED event. The rule will be triggered once all rules and validations registered on STATECHANGING are performed. However, this happens before the document is saved into the database. When conditions are met and the rule fails, the state of the document won't be changed and it'll remain in its previous state. Example 2 When you receive a batch of goods, you want to check if the availability of a product would be over 100 PCS. It's best to use STATECHANGED so the quantities of the current store transaction are included in the calculation. STATECHANGED always goes with an event parameter. Possible values are: PLANNED FIRMPLANNED RELEASED COMPLETED CLOSED"
  },
  "advanced/user-business-rules/events/statechanging.html": {
    "href": "advanced/user-business-rules/events/statechanging.html",
    "title": "STATECHANGING | ERP.net Tech Docs",
    "summary": "STATECHANGING Name STATECHANGING Layer Back-end Description Occurs during a document state change, specified in the Parameter field. Version Introduced: 2017.1 Updated: - This event happens during a change. Example 1 There's a FAIL action set on a STATECHANGING event. If the rule is activated, the state of the document won't be changed and it'll remain in its previous state. It's crucial to set the event correctly, as it happens in the data of the repository of the business rule. Example 2 When you set а STATECHANGING event in a business rule with repository 'General.Products.Products', this rule would never be activated because the products don't support the event. Example 3 If a rule has a repository with document lines 'Crm.Invoicing.InvoiceLines', the event wouldn't activate the rule as the document lines don't support it. However, the event is supported by documents (their headers). STATECHANGING always goes with an event parameter. Possible values are: PLANNING FIRMPLANNING RELEASING COMPLETING CLOSING"
  },
  "advanced/user-business-rules/events/voiding.html": {
    "href": "advanced/user-business-rules/events/voiding.html",
    "title": "VOIDING | ERP.net Tech Docs",
    "summary": "VOIDING Name VOIDING Layer Back-end Description Occurs during the voiding of a document. Version Introduced: 2019.1 Updated: - This event is recommended only when the business rule repository is a document header - Crm.Sales.SalesOrders, Logistics.Inventory.StoreOrders... VOIDING may prohibit voiding using FAIL when certain conditions are met. For example, the rule could throw an error when a sales order that's already been FIRMPLANNED is being voided."
  },
  "advanced/user-business-rules/examples/azure-service-bus-send-message.html": {
    "href": "advanced/user-business-rules/examples/azure-service-bus-send-message.html",
    "title": "How to send a message to Azure Service Bus when an entity is created or updated? | ERP.net Tech Docs",
    "summary": "How to send a message to Azure Service Bus when an entity is created or updated? To be able to send a message to Azure Service Bus you need to have a: Webhook template set up according to the service bus endpoint. User business rule configured to trigger when an entity object of specific type is created or updated. The user business rule must define an action of type WEBHOOK, pointing to the code of the webhook template. Note For the purposes of the example, the ServiceActivities entity is used, but you can do it with any entity of your needs. Webhook template Below is an example of what the webhook template should contain. Attribute name Attribute value Code sb_service_activity_01 Name Azure Service Bus - service activity updates Repository name Applications.Service.ServiceActivities URL https://<serviceNamespace>.servicebus.windows.net<queuePath | topicPath>/messages Body {{ \"Id\": \"{Id}\", \"Number\": \"{DocumentNo}\", \"Date\": \"{DocumentDate}\", \"Subject\": \"{Subject}\", \"State\": \"{State}\" }} Headers Authorization: <authorizationToken> Notes Sends a message to Azure Service Bus queue when a service activity is created or updated. Where, <serviceNamespace>, <queuePath> OR <topicPath> are specific to your service bus endpoint's configuration. <authorizationToken> as the name suggests, is an authorization token that can be: Azure AD JWT token - in case registration of an application. Authorization: Bearer <Azure AD JWT token> SAS token - in case of a shared access key. Authorization: SharedAccessSignature sr=<NAMESPACE NAME>.servicebus.windows.net&sig=<SIGNATURE>&se=<TOKEN EXPIRY INSTANT>&skn=<SHARED KEY NAME>, where the <SIGNATURE> is to be calculated as follows (pseudocode): urlencode(base64(hmacsha256(urlencode('https://<NAMESPACE NAME>.servicebus.windows.net/') + \"\\n\" + '<TOKEN EXPIRY INSTANT>', '<SHARED ACCESS KEY>'))) For how you can generate a SAS token in different programming languages, visit the following link: Generate SAS token The Body is an interpolated string, formed in JSON format. When evaluated, it will contain the data for the entity in the context of which the business rule is executed. User business rule The webhook template can't be used as a standalone thing. This is simply a template that in this particular case must be evaulated in the context of a service activity when the latter is created or updated. Therefore, a user business rule needs to be defined. Repository Applications.Service.ServiceActivities Events Event type Event parameter Execution priority AGGREGATECLIENTCOMMIT Normal Actions Action No Action type Parameter1 type Parameter1 value 1 WEBHOOK Constant sb_service_activity_01 This seems pretty straightforward. A business rule that will trigger on AGGREGATECLIENTCOMMIT event and will execute a WEBHOOK action with code sb_service_activity_01. See more User business rules String interpolation Service Bus service REST / Send messages to queue Authentication with Shared Access Signatures Generate SAS token Authenticate from an application"
  },
  "advanced/user-business-rules/examples/credit-limit-override.html": {
    "href": "advanced/user-business-rules/examples/credit-limit-override.html",
    "title": "Allow a credit limit override when a client pays in cash | ERP.net Tech Docs",
    "summary": "Allow a credit limit override when a client pays in cash If the system type of a payment type in a sales order document is set as 'In cash', you can create a business rule that inserts a check mark in the field Credit Limit Override. You can get that information using this calculated attribute, which returns 'True' or 'False'. To set a rule to allow a credit limit override when a client pays in cash, use the following data: Repository Crm.Sales.SalesOrders Events Event type Event parameter Execution priority Change of State RELEASING Normal Conditions Condition No Attribute name Comparison type Value 1 #IsInCash = True Actions Action No Action type Parameter1 type Parameter1 value Parameter2 type Parameter1 value 1 SETVALUE Attribute CreditLimitOverride Constant True Note '#IsInCash' is a calculated attribute. For more information, see Check if the system type of payment type in a sales order is 'In cash'."
  },
  "advanced/user-business-rules/examples/index.html": {
    "href": "advanced/user-business-rules/examples/index.html",
    "title": "User business rules - Examples | ERP.net Tech Docs",
    "summary": "User business rules - Examples Allow a credit limit override when a client pays in cash How to create a card in Trello when a sales order has been released? How to send a message in a channel in Slack when voiding a sales order? How to send a message to Azure Service Bus when an entity is created or updated? How to use business rules to set a value into a custom property? Manage the user status of a document Set DeliveryTerms in purchase invoice Set an initial attribute for a new sales order Set the VAT rate depending on Deal type Start a business rule only on first releasing Whole quantity validation"
  },
  "advanced/user-business-rules/examples/manage-user-status.html": {
    "href": "advanced/user-business-rules/examples/manage-user-status.html",
    "title": "Manage the user status of a document | ERP.net Tech Docs",
    "summary": "Manage the user status of a document You can use system variables for business rules with the \"STATECHANGED\" and \"STATECHANGING\" events to trigger specific actions when changing the user status of a document. $FromUserStatusId - ties the rule to the initial user status, ensuring that actions are triggered based on the starting status of a document $ToUserStatusId - ties the rule to the target user status, allowing actions to be triggered when the document transitions to the specified status. Set up a business rule In this example, we will create a business rule for documents of type Offer. In the end, we should trigger a warning message when changing an offer's document status. Step-by-step example If not present, create at least two user statuses for the FIRMPLANNED document state of the Offer document type. Define a STATECHANGED event with a FIRMPLANNED parameter. In the Conditions panel, select $ToUserStatusId from the Attribute name field. Within the Value field, input the ID of the user status corresponding with the FIRMPLANNED state of the Offer document type. Define a warning action with a formatted string parameter (e.g. \"yes\") and save the business rule. Now, if you change the user status of an offer in Firm planned state to the one specified in the condition of the business rule, you will trigger a warning."
  },
  "advanced/user-business-rules/examples/sales-order-init-attribute.html": {
    "href": "advanced/user-business-rules/examples/sales-order-init-attribute.html",
    "title": "Set an initial attribute for a new sales order | ERP.net Tech Docs",
    "summary": "Set an initial attribute for a new sales order If a business logic requires only whole numbers, a user business rule can be set to check users' work. For example, a validation of a sales order lines may be applied with the following data: Repository: Crm.Sales.SalesOrders Events - CREATENEW Action - SETVALUE + Parameter1Type = Attribute + Parameter1 Value = Note + Parameter2Type = Constant + Parameter2 Value = your initial value. Conditions: No conditions for such a simple task."
  },
  "advanced/user-business-rules/examples/set-deliveryterms.html": {
    "href": "advanced/user-business-rules/examples/set-deliveryterms.html",
    "title": "Set DeliveryTerms in purchase invoice | ERP.net Tech Docs",
    "summary": "Set DeliveryTerms in purchase invoice The DeliveryTerms field is of 'enum' type. Here, you can find values of different codes: Member name Value Description ExWorks 0 ExWorks value. Stored as 'EXW'. FrancoCarrier 1 FrancoCarrier value. Stored as 'FCA'. FreeAlongsideShip 2 FreeAlongsideShip value. Stored as 'FAS'. FreeOnBoard 3 FreeOnBoard value. Stored as 'FOB'. CostAndFreightCF 4 CostAndFreightCF value. Stored as 'CFR'. CostInsuranceAndFreight 5 CostInsuranceAndFreight value. Stored as 'CIF'. CarriagePaidTo 6 CarriagePaidTo value. Stored as 'CPT'. CarriageAndInsurancePaidTo 7 CarriageAndInsurancePaidTo value. Stored as 'CIP'. DeliveredAtPlace 8 DeliveredAtPlace value. Stored as 'DAP'. DeliveredAtTerminal 9 DeliveredAtTerminal value. Stored as 'DAT'. DeliveredDutyPaid 10 DeliveredDutyPaid value. Stored as 'DDP'. If you need to set a value in the DeliveryTerms field of a purchase invoice, the action of the user business rule must set a casted value from a calculated attribute in the DeliveryTermsCode attribute. The calculated attribute must cast an integer to type Aloe.ERP.net.Model.Finance.Intrastat.DeliveryTerms. Example: To set DeliveryTermsCode on 'FOB' automatically, the user business rule must contain an action: 1 SETVALUE ATTRIB:DeliveryTermsCode ATTRIB:#CA And the #CA should have an integer value casted to Aloe.ERP.net.Model.Finance.Intrastat.DeliveryTerms: 10 CAST CONST:3 CONST:Aloe.@@name.Model.Finance.Intrastat.DeliveryTerms Having this rule set up, when an event happens, it would set the delivery terms of the purchase invoice to 'FOB'."
  },
  "advanced/user-business-rules/examples/set-quantity-or-amount.html": {
    "href": "advanced/user-business-rules/examples/set-quantity-or-amount.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Set value into Amount and Quantity fields Values cannot be set directly in the main Amount and Quantity fields, as these fields require a specific format that includes both a 'Value' and a 'Unit of Measure. However, the attribute list contains a special version of the field, ending with \"Value\", which holds only the numerical value. This version allows you to set values with business rules. Example If you want to fill in the \"VATAmountBase\" in VAT Entries entity, you must create a Business Rule that sets the value in the \"VATAmountBaseValue\" instead. More Information For further details about Amount and Quantity data types, refer to the model documentation: Amount Data Type Quantity Data Type"
  },
  "advanced/user-business-rules/examples/set-value-into-custom-property.html": {
    "href": "advanced/user-business-rules/examples/set-value-into-custom-property.html",
    "title": "How to use business rules to set a value into a custom property? | ERP.net Tech Docs",
    "summary": "How to use business rules to set a value into a custom property? You can use business rules to set values into different fields, including custom properties action types. To set a value into a custom property, you'll either copy or get that value from another custom property. Alternatively, you can use an attribute/field/constant with data type 'String'. Example 1 Let's say you have a sales order document. If you want to copy a value from a specific custom property and set it as a value in another custom property, you can create a user business rule with the following data: Repository Crm.Sales.SalesOrders Events Event type Event parameter Execution priority Change of State RELEASING Normal Actions Action No Action type Parameter1 type Parameter1 value Parameter2 type Parameter2 value 1 SETVALUE Attribute @Property1 Attribute @Property2 Note Both the custom property's value and description are copied. Note In this case, there are NO limitations for custom properties in which you set the value to inherit its allowed values from another entity or custom property. The only condition is the setting in both custom properties to follow the principles described in Inheriting and copying custom properties. Example 2 Let's say you have a sales order document. If you want to set a specific value for a custom property that's not copied from another custom property's value, you can create a user business rule with the following data: Repository Crm.Sales.SalesOrders Events Event type Event parameter Execution priority Change of State RELEASING Normal Actions Action No Action type Parameter1 type Parameter1 value Parameter2 type Parameter2 value 1 SETVALUE Attribute @PropertyCode Constant 'StringValue01 Note Using this method, you can only set the custom property's value - not its description. An exception is when you're setting a value defined as a Property Allowed value. Note Parameter2 Type is not limited to a constant. You could use the attribute type as well and load the value from another system attribute or a calculated attribute. However, the value must be from a 'String' type. Otherwise, you can CAST or CONVERT it. If a custom property has allowed values, you may want to set one of them as a value of the particular property. This is possible only when the property doesn't inherit its allowed values from another entity. Custom properties can inherit their values from another custom property or have them manually defined in the Property Allowed Values panel. If one value is set by a business rule, it'll be recognized as an allowed value for this property. The value's description will then be inherited as well."
  },
  "advanced/user-business-rules/examples/set-vat-percent-by-deal-type.html": {
    "href": "advanced/user-business-rules/examples/set-vat-percent-by-deal-type.html",
    "title": "Set the VAT rate depending on Deal type | ERP.net Tech Docs",
    "summary": "Set the VAT rate depending on Deal type In Sales orders, the VAT rate can be set dynamically based on the selected DealType in the header using the following rule. You can get that information using this calculated attribute, which returns 'True' or 'False'. Тo achieve this, a calculated attribute #VATBYDEALTYPE is used, which returns the VAT percentage based on the selected Deal type. The BEFORERECALCULATE event is utilized, which occurs just before the calculation of additional amounts. There are two conditions: one based on the code of the Document Type, for which the calculated attribute #DocType is used, and the other based on the ID of the additional amount type for VAT. Repository General.Documents.DocumentAmounts Events Event type Event parameter Execution priority BEFORERECALCULATE Normal Conditions Condition No Attribute name Comparison type Value 1 #DocType = DirectSales 2 DocumentAmountTypeId = 3340ebbc-9253-4aa9-8e7c-5cf2d18bfe95 Actions Action No Action type Parameter1 type Parameter1 value Parameter2 type Parameter1 value 1 SETVALUE Attribute InputPercent Attribute #VATBYDEALTYPE Note '#DocType' is a calculated attribute. '#VATBYDEALTYPE' is a calculated attribute."
  },
  "advanced/user-business-rules/examples/slack-send-message.html": {
    "href": "advanced/user-business-rules/examples/slack-send-message.html",
    "title": "How to send a message in a channel in Slack when voiding a sales order? | ERP.net Tech Docs",
    "summary": "How to send a message in a channel in Slack when voiding a sales order? The following is required to send a message in Slack when а sales order is voiding: Webhook template set up according to the endpoint in Slack REST API. User business rule configured to execute when a sales order is voiding. The user business rule must define an action of type WEBHOOK, pointing to the code of the webhook template. Webhook template Below is an example of what the webhook template should contain. Attribute name Attribute value Code slack_void_01 Name Slack - voiding a sales order Repository name Crm.Sales.SalesOrders URL https://slack.com/api/chat.postMessage?channel=<channel>&text=<{DisplayText}> Headers Authorization: Bearer <accessToken> Notes Sends a message in a Slack channel when a sales order is voiding. Where, <channel> - the Slack channel where the message will be sent. {DisplayText} - the message contents. It is also an interpolated string. It will be evaluated by ERP.net and will contain the display text of the sales order (e.g., Sales Order 00108). <accessToken> - the access token provided from Slack. Note Body attribute is missing intentionally. It's not required. User business rule А business rule that triggers when a sales order is voiding. Repository Crm.Sales.SalesOrders Events Event type Event parameter Execution priority VOIDING Normal Actions Action No Action type Parameter1 type Parameter1 value 1 WEBHOOK Constant slack_void_01 See more User business rules String interpolation Display format Slack API Reference Slack access tokens"
  },
  "advanced/user-business-rules/examples/start-business-rule.html": {
    "href": "advanced/user-business-rules/examples/start-business-rule.html",
    "title": "Start a business rule only on first releasing | ERP.net Tech Docs",
    "summary": "Start a business rule only on first releasing Sometimes, a business case may require a certain business rule to be executed only on first releasing of a document. When calculated attributes are triggered, they perform their calculation in real-time. If you use them as conditions for business rules, they may be fulfilled today, but not after a certain period of time. A business rule can be used to allow a sales order to be released only if the lots used in its lines haven't expired. The condition is fulfilled at the moment of first releasing, and the goods are delivered to the customer. What if the released state of the sales order is re-selected after a month because of an adjustment of the document notes? The rule will be executed again, though the adjustment may be impossible because some of the lots could have expired by this time. You can set a business rule that's triggered only when you're releasing a document for the first time. This works despite business rules currently not supporting a first releasing event parameter. You can create a calculated attribute like 'IsFirstReleasing' that check whether the releasing is first and returns 'True' or 'False'. For more information, see Check whether the releasing of the document is first or not?. You can use this attribute as a business rule condition #IsFirstReleasing = True - the rule is triggered only when the document is released for the first time, not when the released state is re-selected."
  },
  "advanced/user-business-rules/examples/trello-create-card.html": {
    "href": "advanced/user-business-rules/examples/trello-create-card.html",
    "title": "How to create a card in Trello when a sales order has been released? | ERP.net Tech Docs",
    "summary": "How to create a card in Trello when a sales order has been released? To successfully create a Trello card, you need the following: Webhook template set up according to the endpoint in Trello REST API. User business rule configured to trigger when a sales order is released. The user business rule must define an action of type WEBHOOK, pointing to the code of the webhook template. Webhook template Below is an example of what the webhook template should contain. Attribute name Attribute value Code trello_release_so_01 Name Trello - released sales order Repository name Crm.Sales.SalesOrders URL https://api.trello.com/1/cards?idList=<id_list>&name={DisplayText}&key=<yourKey>&token=<yourToken> Notes Creates a card in Trello when a sales order is released. Where, <yourKey> and <yourToken> - the API keys, provided from Trello. <id_list> - the Id of the list where the new card should be created. {DisplayText} - the name of the card. It is also an interpolated string. It will be evaluated by ERP.net and will contain the display text of the sales order (e.g., Sales Order 00108). Note Body and Headers attributes are missing intentionally. They are not required. User business rule А business rule that triggers when a sales order has been released. Repository Crm.Sales.SalesOrders Events Event type Event parameter Execution priority STATECHANGED RELEASED Normal Actions Action No Action type Parameter1 type Parameter1 value 1 WEBHOOK Constant trello_release_so_01 See more User business rules String interpolation Display format Trello API Introduction Trello REST API Reference"
  },
  "advanced/user-business-rules/examples/whole-quantity-validation.html": {
    "href": "advanced/user-business-rules/examples/whole-quantity-validation.html",
    "title": "Whole quantity validation | ERP.net Tech Docs",
    "summary": "Whole quantity validation If a business logic requires only whole numbers, a user business rule can be set to check users' work. For example, a validation of a sales order lines may be applied with the following data: Repository: Crm.Sales.SalesOrderLines Events - COMMIT Action - FAIL + Parameter1Type = Constant + Parameter1 Value = \"You have entered decimal number as a quantity. Please, check the data entered in the sales order lines and try again!\" Conditions: check if the calculated attribute from the example in here is equal to 'False' When this user business rule is activated and you try to release a sales order with the following lines, line 10 - product A - Quantity 5.05 line 20 - product B - Quantity 5.00 the system would return an error with the text you entered in the action of the user business rule: You have entered decimal number as a quantity. Please, check the data entered in the sales order lines and try again! With this user business rule activated, if the sales order has the following lines, line 10 - product A - Quantity 5.00 line 20 - product B - Quantity 5.00 the release of the document would be possible."
  },
  "advanced/user-business-rules/index.html": {
    "href": "advanced/user-business-rules/index.html",
    "title": "User business rules | ERP.net Tech Docs",
    "summary": "User business rules These are business rules which you define on your own. They may be used: to provide some kind of validation unavailable in the system business rules to create working logic which is unavailable in the software. User business rules can be registered on different layers - BackEnd and/or FrontEnd. BackEnd means that the rule is processed on the server. FrontEnd implies that the rule is processed in the client application. User business rules are based around questions: 'where?', 'when', and on 'what conditions?' something ('what?') should happen. They contain the following information: Code - unique code of the rule. Name - the name of the user business rule. Repository Name - the name of the repository for which the business rule is defined. For example, 'Invoices' or 'Invoice lines'. The value of a repository name can be selected from a dropdown list. It contains the path to the selected value, dot-separated. If you need to create a user business rule which you can use in invoice forms or in invoice navigators, the repository should be 'Crm.Invoicing.Invoices'. If the rule is created for usage in invoice lines, the repository name becomes 'Crm.Invoicing.InvoiceLines'. Notes - notes, comments or short information about the user business rules' usage, purpose and more. IsActive - a user business rule may be activated or deactivated. Layer - currently, this is unavailable. All user business rules are registered in the BackEnd layer. Events Some events need to happen for a user business rule to become active. The Events panel consists of the following fields: Event type - the event the user business rule can be registered for. Event parameter - registration parameter, determined by the type of the event. Execution priority - lower values indicate earlier priorities. Possible values: 30-Early, 50-Normal; 70-Late. Layer - currently, this is unavailable. All events belong to the BackEnd layer. Conditions There are several conditions that must be met for an event to happen: Condition No - consecutive number of the condition, unique within the user business rule. Attribute name - the name of the attribute that will be validated in the condition. Comparison type - the type of comparison. Available options are: '=', '!=', '>=', '<=', 'Like', 'IsNull', Value - the constant value to which the value specified in Attribute name is compared. A condition is met when the value of the specified attribute and the specified value compose a TRUE statement with the selected comparison type. For example, IsActive = True, Quantity < 100.0 and more. Note If there's more than one condition, the rule will be applied when all conditions are true. Actions Actions executable by rules contain the following information: Action No - consecutive number of the action, unique within the user business rule. Action type - specifies the type of action that will be performed by the rule. Possible values are: SETVALUE and FAIL. Parameter1 type, Parameter2 type, Parameter3 type - the type of parameter specifies how to obtain the parameter value. Parameter1 value, Parameter2 value, Parameter3 value - the actual value of the parameter. See more Action types Business rules Parameter types Events Examples"
  },
  "advanced/user-business-rules/parameter-types/formattedstring.html": {
    "href": "advanced/user-business-rules/parameter-types/formattedstring.html",
    "title": "FormattedString | ERP.net Tech Docs",
    "summary": "FormattedString FormattedString is a parameter type of the user business rules actions, introduced in version 2020.1. It represents a text which supports multi-line, variable interpolation, and variable formatting. This parameter type is typically used with NOTIFYUSER. Functionalities which can be used in the value of the formatted string parameter are: escape charts The following are handled: \\n - newline - supported in the Body. \\r\\n - also new line - supported in the Body. \\{ - insert opening curly bracket '{' in output. \\} - insert closing curly bracket '}' in output. variable interpolation This allows specifying variables into a string using placeholders. When these placeholders are executed, they're replaced with their corresponding values. In ERP.net, those variables are domain attributes - both system domain and calculated attributes. When called, the domain attribute value is calculated for the particular entity record for which the rule is executed. In order to specify a placeholder, a.k.a call a domain attribute in text, you must specify the domain attribute name in curly brackets '{...}'. Currently, the following options are supported: a. Attributes: {DocumentDate}, {#CalsulatedAttribute1}, {@CustomProperty1}. b. References: {Customer}. c. Reference path: {Customer.Party.PartyName}. Note that child collections are not supported. variable formatting The value of the domain attributes which will be loaded in the text can be formatted. This is achieved using format specifiers: {DocumentDate:dd-MM-yyyy}. Example: Using formatted string, this text Your web store has a new order!\\r\\n\\n\\{SUMMARY\\} \\nNumber: {DocumentNo}\\nOrder date: {DocumentDate:dd-MM-yyyy}\\nShipping address: {ShipToPartyContactMechanism.ContactMechanism.Name}\\nOrder total: {#CalculatedAttributeTotalSalesOrderAmount:C} will be returned as: Your web store has a new order! {SUMMARY} order number: 00329 order date: 10-05-2019 shipping address: 21 Lombard St delivery date: 12-05-2019 order total: $14.82"
  },
  "advanced/user-business-rules/parameter-types/index.html": {
    "href": "advanced/user-business-rules/parameter-types/index.html",
    "title": "Parameter types | ERP.net Tech Docs",
    "summary": "Parameter types Parameter types specify how to obtain a parameter value: Constant - indicates the value for this param type would be a constant whenever the rule is activated; Attribute - the value of the system or user-defined attribute; Reference - link to another object, typically used with Attribute as a second parameter. The attributes would be attributes of the referenced object - not of the current repository; ChildList - detailed objects related to the current master object; FormattedString - Text which supports multi-line, variable interpolation, and variable formatting. Interpolate - ERP.net string interpolation. Formatted string on steroids."
  },
  "advanced/user-business-rules/parameter-types/interpolate.html": {
    "href": "advanced/user-business-rules/parameter-types/interpolate.html",
    "title": "Interpolate | ERP.net Tech Docs",
    "summary": "Interpolate Interpolate is a parameter type of the user business rules actions, introduced in version 24. It represents a string interpolation as input, which supports: reference following system-variables format specifiers expanding entities and much more Warning The interpolate operator fully depends on the ERP.net string interpolation functionality. All expressions in Parameter 1 must conform to the specification. Example: Using Interpolate, this text Hello, {$user.Name}\\r\\n Today is {$date}.\\r\\n Your web store has a new order!\\r\\n {{SUMMARY}}\\r\\n Number: {DocumentNo}\\r\\n From: {Customer.Party.PartyName}\\r\\n Order date: {DocumentDate:dd-MM-yyyy}\\r\\n Shipping address:{ShipToPartyContactMechanism.ContactMechanism.Name}\\r\\n Order total: {#CalculatedAttributeTotalSalesOrderAmount:C} will be returned as: Hello, John Doe Today is 2023-11-01. Your web store has a new order! {SUMMARY} Number: 00329 From: Jane Doe Order date: 10-05-2019 Shipping address: 21 Lombard St Order total: $14.82 See more String interpolation Calculated attributes INTERPOLATE operator"
  },
  "advanced/web-sites/index.html": {
    "href": "advanced/web-sites/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "advanced/web-sites/rate-limits.html": {
    "href": "advanced/web-sites/rate-limits.html",
    "title": "Rate limits | ERP.net Tech Docs",
    "summary": "Rate limits The rate limits in ERP.net are a set of limits, related to the requests per each session that can be made within a specified period. Rate limiting is used to prevent overloading and ensure fair usage for all users (i.e. sessions). Exceeding any type of limit will result in an HTTP response 429 - Too Many Requests. Types \"ERP.net introduces several types of rate limits, each targeting a specific use case. These rate limits are summarized in the following table and described in more detail below. Rate limit Config key Default value Requests per minute per session SessionRpm 600 Concurrent requests per session SessionConcurrentRequests 1 Concurrent transactions per session SessionConcurrentTransactions 1 Global concurrent requests GlobalConcurrentRequests 2 Note Please note that the support for these rate limits may vary across different websites, so you should refer to the documentation of the specific site you are interested in for more information. SessionRpm A session requests per minute (RPM) rate limit restricts the number of API requests that can be made within a single session, measured over a one-minute period. The default session RPM rate limit is set to 600, allowing up to 600 requests per minute. Exceeding this limit will result in an HTTP response of 429 - Too Many Requests. SessionConcurrentRequests Session concurrent requests is a rate limit that restricts the number of simultaneous API requests within a single session. The default limit is set to 1, allowing only one request at a time during a session. If the concurrency limit is reached, an internal queue with a size of 5 is used to hold additional requests. If the queue is full, all further requests will immediately return a 429 - Too Many Requests response. SessionConcurrentTransactions Session concurrent transactions is a rate limit that restricts the number of simultaneous API transactions within a session. By default, only one open transaction is allowed at a time during a session. Exceeding this limit will result in an HTTP response of 429 - Too Many Requests until the current transaction is completed. GlobalConcurrentRequests GlobalConcurrentRequests is a rate limit that restricts the total number of concurrent API requests across all sessions. The default limit is set to 2, but it can be configured to allow up to the lesser of the number of processor cores or 4 concurrent requests. If the concurrency limit is reached, an internal queue with a size of 5 is used to hold additional requests. If the queue is full, all further requests will immediately return a 429 - Too Many Requests response. Configuring rate limits The limits above are the default ones. You may specify others in the related web site definition. The rate limits settings are expressed by a JSON object in a specific format. Here's what it looks like as part of a complete web site configuration: { \"RateLimits\": { \"SessionRpm\": 600, \"SessionConcurrentRequests\": 1, \"SessionConcurrentTransactions\": 1 } } Note To apply the changes, a restart of the website is required. This task can be performed by your ERP.net instance administrator or by accessing the website Instance Manager and navigate to the 'Web Sites' section. Тypically, Instance Manager is located at the following address: https://<your-erpnet-instance>.my.erp.net/manage"
  },
  "advanced/web-sites/types/domain-api.html": {
    "href": "advanced/web-sites/types/domain-api.html",
    "title": "Domain API | ERP.net Tech Docs",
    "summary": "Domain API The web site provides Domain API to the ERP.net domain model using the OData (Open Data Protocol) standard. Domain API allows for the creation and consumption of data, in a RESTful manner and provides an opportunity for external applications to interact with the domain model. It enables external applications to access the domain model by querying, filtering, and updating the data through standard HTTP requests. Domain API provides a convenient and standardized way for external applications to interact with the domain model while also ensuring the security of the data being accessed. Domain API is secured using OAuth 2.0, which provides an industry-standard for authorization. Rate limits Domain API is subject to rate limiting, which means that the number of requests you can make within a given time period is limited. The rate limit policy for this API includes multiple constraints, such as the maximum number of requests per minute, maximum number of concurrent requests, and so on. If you exceed any of these constraints, your requests may be rejected with an error response. For more information, see the separate topic Rate limits. Applicable rate limits Below are the rate limiting options supported by Domain API: SessionRpm - Limits API requests per minute per session. SessionConcurrentRequests - Restricts simultaneous API requests in a session. SessionConcurrentTransactions - Limits the number of concurrent transactions in a session. See more Domain API docs Rate limits"
  },
  "advanced/web-sites/types/index.html": {
    "href": "advanced/web-sites/types/index.html",
    "title": "Types | ERP.net Tech Docs",
    "summary": "Types Domain API Table API"
  },
  "advanced/web-sites/types/table-api.html": {
    "href": "advanced/web-sites/types/table-api.html",
    "title": "Table API | ERP.net Tech Docs",
    "summary": "Table API The web site provides Table API to the ERP.net table model using the OData (Open Data Protocol) standard. Table API allows for data consumption in a RESTful manner and offers external applications the opportunity to interact with the table model. The primary purpose of the Table API is to allow external BI (Business Intelligence) tools to quickly pull raw data for further analysis. Table API is secured using OAuth 2.0, which provides an industry-standard for authorization. Rate limits Table API is subject to rate limiting, which means that the number of requests you can make within a given time period is limited. The rate limit policy for this API includes multiple constraints, such as the maximum number of requests per minute, maximum number of concurrent requests, and so on. If you exceed any of these constraints, your requests may be rejected with an error response. For more information, see the separate topic Rate limits. Applicable rate limits Below are the rate limiting options supported by Table API: GlobalConcurrentRequests - Caps total concurrent API requests across all sessions. See more Table API docs Rate limits"
  },
  "concepts/documents/adjustments.html": {
    "href": "concepts/documents/adjustments.html",
    "title": "Adjustments documents | ERP.net Tech Docs",
    "summary": "Adjustments documents Using adjustment documents is a system to adjust released documents. As the released document states that the execution of the document has already started, therefore the released documents are read-only (see Document states). So when there is a need to change such a document, the usual way of editing it is not available and a specific system is needed. The adjustment documents are separate documents trough which a released document can be edited. They contain the main document that they are making corrections on. So one released document may have more than one correction. The adjustment documents are allowed two (Document states) - New and Corrective. The Corrective state is specific only for the adjustment documents and it is not allowed at the rest of the documents. When the document state is switched from New to Corrective, the changes in the adjustment document are applied to the main released document. Then the field \"Adjustment number\" is filled in with the consecutive number of the correction. The adjustment documents contain only the changes which has to be applied. For example, if there is a released issuing Transaction with 10 PCS and it turns out that now only 8 PCS are issued, in this case, an adjustment issuing Transaction is executed with the quantity of -2 PCS. Thus, it can be considered that the adjustment document is the difference between the current values in the released document and the values, which have to be achieved after the correction. So the current data in every released document are a result of the original data (the document content when released for the first time) and the data added by all adjustment documents. This mechanism is preferred over the direct redaction of the released documents because of easier tracking of the separated corrections that are executed (tracking of these changes is important). For example, in the previous example with the transactions, the user may easily see that the quantity has been decreased by 2 PCS by the adjustment document. Otherwise, the user would have to compare the consecutive versions of the main document which may be a complicated and uncomfortable task, especially with large documents. Also, this mechanism allows the adjustment documents to be used for adjustment of transitional documents and sub-documents. Adjustment document application The mechanism, when an adjustment document (when the document state is switched to Corrective) is applied on the main released document, is as follows: For each record in the adjustment document its corresponding record in the main document is searched. Matching the records is as follows: ​ a. if the record is in the adjustment document header, than the corresponding record is in the header of the main document; ​ b. if the record is in a row in the adjustment document then the record from the same row table in the main document is searched. The record should have the same natural key as the adjustment record; as natural key usually the document row number is used or another field (if there is no row number); for example, if in the adjustment document there is a row with number 30, then in the main document a row in the same table and with the same number 30 is searched. If no corresponding record is found in the main document (this is possible only if the current record is in the rows of the adjustment document), then the adjustment record is simply added to the corresponding table in the main document with no changes in it; If a corresponding record is found in the main document, then the system reviews all the fields in the correction record and the following applies to each field: ​ a. if the field is a key field (see the article about Scalar and Key Fields), then it is checked if it has the same value in the main document and in the adjustment document; if there is a difference, the adjustment is rolled back, and the user is notified by an error message; ​ b. if the field is scalar-valued, then the value of the adjustment record is added to the value of the main record; ​ c. if the field is neither key nor scalar-valued, then the value of the main record is replaced by the value of the adjustment record. Thus, in the adjustment document, only the changes in the main document are marked. I.e. the user can decrease or increase the value of a scalar-valued field (quantity or amount) or change/replace the value of a field that is neither key nor scalar-valued. Note Key fields cannot be adjusted by adjustment documents! Also if the adjustment document has no record corresponding to a record in the main document, then the original document will not be changed after the correction takes place. For example, if in the main document there is a row with a number 30, and in the adjustment document there is no such row, then row 30 from the main document will remain unchanged after the correction. What can be done by adjustment documents? Can adjust values of non-key fields (the scalar-valued fields are adjusted by adding the value in the adjustment document, and the rest of the fields are adjusted by replacing the value with the one from the adjustment document); New records can be added in row tables; All scalar-valued fields in a row can be reset (so the row will no longer affect the document behavior). What cannot be done by adjustment documents? A value of a key field cannot be changed; A row cannot be deleted. Special types of adjustment documents There are some special types of adjustment documents in ERP.net, which are prepared by the system and the user does not have to fill the scalar values in them. Such types are the Nullify corrections. They are accessible in all documents and are used to adjust all scalar-valued fields so they become 0. By this correction, the document no longer \"has value\" (i.e. it does not order or fulfill any quantities or amounts). This is an alternative to document voidance. For the Receiving orders there two special types of adjustments - Correction according to stored quantities and Correction according to invoiced quantity. The first type automatically calculates the necessary correction so the quantities in the Receiving Order become equal to the quantities from the current Receiving Order which are receipts in the store. This correction is used to eliminate the difference between the Receiving Order and its Transactions. The second type is used to equalize the quantities in the Receiving Order as they are in the Purchase invoices, created for the current Receiving order."
  },
  "concepts/documents/display.html": {
    "href": "concepts/documents/display.html",
    "title": "Display and search document and line numbers | ERP.net Tech Docs",
    "summary": "Display and search document and line numbers 1. Displaying document and line numbers a) The general format for displaying document and line numbers is: <DocTypeCode>:<DocNumber>:<LineNumber> - <DocTypeName> For example, let's have the following: The document type is ‘Sales order’, with code ‘SO’ The document number is ‘00503’ The line number is 120 (the line numbers are integers) This will be represented as: SO:00503:120 - Sales order b) If we have to display only a document number (without line number), the format is the following: <DocTypeCode>:<DocNumber> - <DocTypeName> Now, let's have the following: The document type is ‘Sales order’, with code ‘SO’ The document number is ‘00503’ This will be represented as: SO:00503 - Sales order 2. Sorting lists of documents and line numbers When a list containing document and line numbers is sorted, the order is the following: First, sort lexicographically by \"DocTypeCode\" Then, sort lexicographically by \"DocNumber\" Then, sort numerically by \"LineNumber\" (if applicable) 3. Searching through document and line numbers When a user wants to find a document or a specific document line, they enter a search term. The following rules apply: a) Generally, a search is processed in the same format as the display text <DocTypeSearchTerm>:<DocNumberSearchTerm>:<LineNumberSearchTerm> For example, searching for ‘SO:00503:120’ will find and match ‘O:00503:120’ and nothing else. This is a non-wildcard search and is the fastest search. It is usually used when a value is pasted in a user application. b) Some of the search terms might be missing We can search for ‘SO:00503’ and this will match all lines from ‘SO:00503’, e.g. ‘SO:00503:10’, ‘SO:00503:20’, etc. If the search contains only one search term and does not contain colon (':'), it will be performed over the document number! Searching for '00503' will find 'SO:00503'. But searching for 'SO' will NOT match 'SO:00503', because 'SO' would not be found among the document numbers (unless there is a document with the number 'SO'). c) Some of the search terms might contain a wildcard symbol (%) The \"DocTypeSearchTerm\" and \"DocNumberSearchTerm\" can contain the wildcard symbol and it will perform a wildcard search. However, the \"LineNumberSearchTerm\" cannot contain wildcard symbol and will not perform a wildcard search. The system wildcard symbol is '%'. In the user applications, the generally accepted symbol is ' ' (space). 4. Examples System search term User Application Visualization Description S%:%503 'S : 503' • Document types, starting with 'S'. • Document Numbers, finishing with '503' SO:%503 'SO: 503' • Document type with code 'SO'. • Document Numbers, finishing with '503' SO:%503:10 'SO: 503:10' • Document type with code 'SO'. • Document Numbers, finishing with '503'. • Line Number 10 (line numbers do not support wildcard search) ::10 '::10' • All lines in all documents, with line number = 10 SO::10 'SO::10' • Document type with code 'SO'. • All lines, with line number = 10 :%503% ': 503 ' • All documents, with numbers, containing '503'. This could be specified simpler, as in the following example: %503% ' 503 ' Because there are no colons (':'), the search term is applied to the document number. • All documents, with number, containing '503'. Note: If you want to search by document type only, append a colon at the end of the search string, as in the following example: SO: 'SO:' • All documents (and lines) for document type with code = 'SO' SO:: 'SO::' (same as above). • All documents (and lines) for document type with code = 'SO' When searching in large databases, DO NOT put a wildcard symbol in front of the document number. Search for '0047858%' instead of '%47858%'. In a user application, search for '0047858' instead of ' 47858'. The difference in speed might be substantial. Performance tests have shown 0.2 sec for '0047858%', against 120 sec for '%47858%' in a database with 50 million documents. This recommendation is only for the document number. The document type code can contain wildcard symbols in any position and this does not affect performance."
  },
  "concepts/documents/index.html": {
    "href": "concepts/documents/index.html",
    "title": "Documents | ERP.net Tech Docs",
    "summary": "Documents Description Documents are one of the three main categories of entities in ERP.net. They represent things that have occurred or will occur. The main categories are: Documents - facts; things that occur: Sales orders, invoices, purchase orders, etc. Definitions - they represent real-world objects; things that (generally) do not change: Customers, Products, Stores, etc. Settings - system-related; data about the way the system works: Document types, Document routes, Form views, etc. The most important attributes All documents derive from a base entity type called Document and share similar attributes. This is a non-extensive list of the more important attributes: Enterprise company - the company that created the document. Company location - the company location where the document was created. Document date - the date the document was constituted. If it was created electronically, then this is the system date of creation. When it is created outside the system and entered post-factum, the attribute contains the date of actual creation. Document type - a user-defined document type for classification of the documents. Also defines print-out forms, document flow and other rules. Document number - a unique number within the sequence, defined in Document type. Usually created by the system, but can also be set up to accept manual entry or import from external sources. State - each document in the system has a current state at any given moment. It affects how the document influences the system and whether it is updateable. Currency directory - the primary directory for currency rates which will be used for currency conversions throughout the document. Further reading: States Display and choose Adjustments Scalar and Key Fields Advanced topics: Document flow Document amounts"
  },
  "concepts/documents/scalar_and_key_fields.html": {
    "href": "concepts/documents/scalar_and_key_fields.html",
    "title": "Scalar-value and Key fields | ERP.net Tech Docs",
    "summary": "Scalar-value and Key fields Understanding how fields are classified in documents is critical for managing data integrity and ensuring accurate calculations in complex systems. Here we explore the roles of scalar-value, key, and non-participating fields in the discrepancy system, highlighting their impact on document creation, corrections, and recalculations. By clearly defining these field types, businesses can streamline processes and maintain consistency across interconnected documents. Scalar-value Fields Scalar fields in documents represent the quantitative effects of those documents. These fields typically include quantities — such as counts of products, materials, or people — and monetary values. Theys are the foundation of the discrepancy system, providing the basic numerical data on which calculations are performed. For example, consider a Store order for 100 units of a product. When a corresponding store transaction document is created, it will attempt to account for the entire 100 units. However, if a sub-document has already been generated for 42 units, the discrepancies system calculates the remaining quantity by subtracting the 42 units from the original 100, yielding a difference of 58 units. In this case, the system creates a new document for the remaining 58 units. Scalar-value fields also play a crucial role in Adjustments. When an adjustment is created, its scalar-value field values are added to the corresponding fields in the original document. This approach allows the correction document to effectively represent the difference between the released document’s current values and the adjusted values. Determining Scalar-value Fields Most fields that represent quantities or monetary amounts are classified as scalar. If a field represents such data, it is almost always considered scalar. However, there are notable exceptions where fields, although representing quantities or amounts, are derived from other scalar fields or external calculations and are therefore not declared scalar. For example: • Shipments and Shipment Order Lines: Fields such as “Net, kg,” “Gross, kg,” “Volume, l,” and others reflect physical characteristics of goods. These values are derived from quantities in the lines, using product dimensions ratios or user input. Since these fields are recalculated for every document — whether manually entered, generated, corrected, or processed through the discrepancy system — they are not scalar; • Cost fields in Store transactions: system cost fields, such as cost in base currency, warehouse currency, product currency, and document currency, depend on the cost source. If the cost source is “document,” these fields are derived from the line amount after applying currency conversions. If the cost source is “warehouse,” the values depend solely on line quantities and current warehouse costs, which are external to the document. In both cases, these fields are systematically recalculated rather than declared scalar. Key Fields Key fields are identifiers that distinguish parts of a document or groups of documents within a larger set. They serve as natural, analytical, or business keys, allowing the system to recognize distinct captions, lines, or other business components. Key fields are integral to the discrepancy system, as they enable the segmentation of documents into components and determine the extent to which each part has been fulfilled. Returning to the example of a Store order for 100 units, where 42 units have already been received: scalar fields quantify the remaining 58 units, while key fields identify which warehouse, product, or other analytical categories are associated with these quantities. When released documents are updated through adjustment documents, key fields are protected against changes. This ensures that the document’s business logic and structure remain consistent, preventing conflicts that could arise from altering key identifiers. Defining Key Fields A field is classified as key if it is essential for recognizing distinct business activities or if the field’s value must remain constant to ensure the integrity of the document’s purpose. Common key fields include Customer, Store, and product fields. For example: • Store in Store Orders: This key field is used when documents from modules such as Procurement and Sales create Store Orders for receiving or issuing goods across multiple stores. If the parent document’s quantities are edited, the system checks existing warehouse orders to determine how much of the quantities have already been processed. Since these checks are performed separately for each store, the store field is key; • Store in Store Transactons: If a store order generates a store transaction specifying a store, this field becomes key. Altering it in the transaction document would violate the discrepancy system’s integrity, as key field differences are not permitted. This ensures that sub-documents remain consistent with their parent documents. In addition to business logic, fields related to units of measure or currencies are always classified as key. This prevents inconsistencies between sub-documents and parent documents, simplifying scalar field calculations and corrections by avoiding the need for complex conversions. Key field classification involves several considerations: 1. Is the field essential for distinguishing specific business processes or components? If yes, it is likely key. 2. Should the parent document enforce a fixed value for the field in sub-documents? If yes, it is likely key. 3. Can the field’s value be modified in a released document through adjustments? If yes, it is probably not key. 4. Does the field indicate a unit of measure, currency, or other scalar-related metric? If yes, it must be key. Other Fields Fields that are neither scalar nor key, such as notes or dates, do not participate in the difference system. These fields are excluded from discrepancy calculations and are not assigned analytical significance. They can be updated through corrections, but their updates follow a simpler principle: the latest adjustment sets the current value. Exceptions to this behavior occur when specific fields, such as cost fields in warehouse receipts, undergo recalculations triggered by status changes."
  },
  "concepts/documents/states.html": {
    "href": "concepts/documents/states.html",
    "title": "Document states | ERP.net Tech Docs",
    "summary": "Document states Description The documents in the system have a current STATE. This state determines the effect on the system and whether the document can be updated. The allowed states of the document are: New - the document is entered and saved in the system but does not affect (on planning, availability, etc.) Planned - the document is planned automatically by the system to occur at some point in the future Firm Planned - the document is planned to occur at some point in the future by a user. Firm Planned status is automatically set by the system if a user edits a Planned document. Released - the document is released for execution. The responsible party starts to execute it. Completed - the activities of the document are finished. Sometimes this state is also referred to as \"Finished\". Closed - the document is verified and no more changes are expected in it. Document editing rules Whether a document can be edited by a user depends on its state: New - the document can be edited freely. Planned - the document can be edited, but if you save the changes, the state will automatically change to Firm Planned (see below). Firm Planned - the document can be edited. Released - the document can no longer be edited, but an adjustment document can be created and applied (see heading below). Completed - the document cannot be changed, but its state can be returned to Released. Closed - the document cannot be changed, but its state can be returned to Completed. Planned documents reflect a plan, created automatically by the system. On the next planning run, planned documents are usually erased or voided (actually the system tries to erase them, but if they use sequence generators, they can only be voided, not erased). The Firm Planned state helps avoid the voiding. When a user makes changes to Planned document, the system changes the state automatically to Firm Planned in order to protect the user changes before the next planning run. Note Planned sub-documents are also erased or voided when a parent document state changes. This behavior is system defined and cannot be changed. Planned documents can only be protected from voiding by making them Firm Planned. Rules for changing document state Changing the document state usually goes straight, from New to Closed. However, sometimes it might be needed to revert back to the previous state. The following table shows when this is allowed: Old State New State Allowed Planned New Allowed Firm Planned Planned Allowed Released Firm Planned Not Allowed Completed Released Allowed Closed Completed Allowed There is a borderline at the Released state - once reached, the state cannot be reverted. The document can only be voided. Adjustment documents Adjustment documents are documents, which adjust other documents. Adjustments can be made only on documents, which are in the Released or Completed states. Adjustment documents can change only primary measurement values. They are usually used to increase or decrease quantities and/or amounts of released documents. Adjustment documents are separate documents, but when applied to a main document, they change its internal values. If an adjusted document is opened on the screen, it will look like it always has been adjusted. The previous versions of the document are securely stored and can be revealed by the document history. The adjustment documents come in effect (e.g. change the main document) when their state is changed to the special \"Adjustment state\". As these documents are only used to adjust other documents, they cannot have parent and/or child documents. Planning only Some documents are created specifically only for planning purposes. They are not intended to be ever released. There is a special flag, which signals this intention to the system, called \"Planning Only\". When this flag is set, the system would allow only New and Planned states for the document. No upper states would be allowed by the system. Usually, the document is later voided by its creator (when the plan changes or actual execution is about to begin). User-defined document statuses Each document type can contain user-defined sub-statuses to the system states. For example, one can define the following user statuses for a document type, called \"Direct Production Order\": Document Type(user defined) Document State(system defined) User Status(user defined) Exit Status(Yes/No) Document Type(user defined) Document State(system defined) User Status(user defined) Exit Status(Yes/No) Direct Production Order New Direct Production Order Planned Direct Production Order Firm Planned For Processing Direct Production Order Firm Planned Needs Check Direct Production Order Firm Planned Needs Approval Direct Production Order Firm Planned Approved Yes Direct Production Order Released Started Direct Production Order Released Tested Yes Direct Production Order Completed Direct Production Order Closed Each system state can have as many user statuses, as needed. As shown in the table above, one of the user statuses within each system state can be defined as Exit Status. The Exit Status is required to be reached to move to the next system state. In the example above, in order to release a direct production order, the Firm Planned/Approved state must first be set. This creates a control point for moving ahead of the state. Note The exit User status-es are usually secured, so that only the authorized users can set them."
  },
  "concepts/erp-instances.html": {
    "href": "concepts/erp-instances.html",
    "title": "ERP instances | ERP.net Tech Docs",
    "summary": "ERP instances The ERP.net service is a hosted ERP service. Accessing the data is done through ERP instances. When you sign up at erp.net, you can create and manage a new instance. It's a tenant in a hosting environment, allowing the management of multiple related legal entities (companies) in one instance. You don't need to create separate instances per managed company. Each instance has a unique name and can be accessed at https://<<instance_name>>.my.erp.net For example, the demonstration database, DEMODB, is located at: https://demodb.my.erp.net"
  },
  "concepts/index.html": {
    "href": "concepts/index.html",
    "title": "Business logic concepts | ERP.net Tech Docs",
    "summary": "Business logic concepts This section contains concepts applicable to all modules. Documents Products Multi-language Multi-company support Parties concepts ERP instances"
  },
  "concepts/multi-company.html": {
    "href": "concepts/multi-company.html",
    "title": "Multi-company support in ERP instances | ERP.net Tech Docs",
    "summary": "Multi-company support in ERP instances ERP.net allows a single ERP instance (database) to contain multiple companies. Different owned companies stored in a database are called enterprise companies. Many data objects (definitions, settings and documents) have an EC attribute. When filled, it specifies that the data is unique to one of the enterprise companies. When left blank, it means that the data is valid for all enterprise companies. Some data objects like documents have a required enterprise company attribute. In this case, the data is always specific to one enterprise company. Let's have the following accounts in a chart of accounts: 60201 - Expenses, general 60209 - Other expenses (specific to \"Company X\", one of the companies, managed in the database) This can be defined as follows: Account Enterprise company 60201 60209 Company X Similarly, products and other definitions can belong to a single enterprise company or all enterprise companies. Note There's no way to make a data object belong to several enterprise companies. It's either one or all."
  },
  "concepts/multi-language.html": {
    "href": "concepts/multi-language.html",
    "title": "Multi-language support | ERP.net Tech Docs",
    "summary": "Multi-language support Multi-language strings are attributes in ERP.net support that save data in multiple languages. When visualizing the data, the correct version of the string is displayed automatically by the system, depending on the current user language. A product name, for example, can be entered in many languages simultaneously. Note For reports, a report designer can use the current user language or a fixed language. In a Portuguese invoice, it'd be required for all labels and data to be displayed in Portuguese. Entering data in multiple languages The client applications of ERP.net usually allow the following abilities regarding multi-language strings: Entering the string in many languages Transliterating a string from one language to another (or all) Translating a string from one language to another (or all) When entering translations, the client application displays a table with cells for each translation: Language Value EN: Toothpaste DE: Zahnpasta Depending on the client application, translation can sometimes be automated. Some applications support using an online service like Google Translate to automatically translate a string to other languages. Translation is better suited to Description and Notes attributes. Transliteration of names and addresses from Cyrillic Transliteration is the process of converting text from one language script to another, based on the phonetic sounds of the original text. This is particularly useful for names of people, companies, and addresses, allowing local branch offices in Cyrillic-using countries to operate in their native language while maintaining consistency in corporate reports. For example, \"Елена\" (in Cyrillic) would be transliterated as \"Elena\" (in Latin) and vice versa. When users enter data, they enter it using their current language setting. If the user does not enter the latin translation, the system automatically generates one, based on transliteration. Default Language Configuration The default language is fundamental to the system's operation from day one. It serves as the base language from which all translations are derived and to which they are returned. Once the default language is set, it is strongly recommended not to change it. This setting is configured via the “Default language” option, which defines the default language for multilingual fields. For example: en – English bg – Bulgarian You can find the configuration here: Desktop Client: Settings > Tools > Setup > Configurations Web Client: System > Configurations > Setup > Config Warning Due to the architecture of multilingual strings, the system does not keep track of previous language values. If you change the default language after it has been initially set: All existing translations will be lost Current string values will become invalid The instance will require complete retranslation of all fields."
  },
  "concepts/parties-concepts.html": {
    "href": "concepts/parties-concepts.html",
    "title": "Parties concepts | ERP.net Tech Docs",
    "summary": "Parties concepts Parties are one of the most widely used definitions in ERP.net. They usually participate in business relations or transactions. Examples include: Business customers Consumer customers Employees in our or external companies Contacts Dealers Company locations Departments Basic party types Parties don't exist on their own - they're always created as separate objects, like person or company. In object terms, it means that 'Person' and 'Company' inherit 'Party'. 'Party' is considered of type 'Person' or 'Company'. Note Parties can't be created directly. They're always instantiated as some sub-type, like 'Person' or 'Company'. This diagram shows the relationship between party, person and company: Party attributes inheritance All attributes of 'Party' are also attributes of 'Person' and 'Company'. For example, if a party has an Area attribute, all 'Person' and 'Company' objects would also have it. The opposite isn't true. 'Person' and 'Company' objects have attributes which are specific only to them. In this diagram, 'Party' has Parent Party and Area attributes, inherited by 'Company' and 'Person'. 'First name' and 'Last name' are specific only to 'Person'. Neither companies nor parties have them. Relationships with other entity types Although parties don't exist on their own, they can participate in relationships. For example, customer and supplier contracts are objects that can coexist with a party. As a result of the relationship, a both would relate to either a person or a company. This is shown on the following diagram: Note In ERP.net, Customer (contract), Supplier (contract) and Dealership (contract) = Customer, Supplier and Dealer. Note The diagram shows how one 'Party' object can be in relationships with many 'Customer contract' objects. The current implementation of ERP.net allows multiple customer contracts per party, but only one for each enterprise company. In other words, a party can only have a single customer contract with any given enterprise company. Let's suppose you have: A customer (company), called \"ABC\" A supplier (person), named \"John\" This will be represented by the following objects: Party (ABC) Company (ABC), which inherits Party (ABC) Customer (ABC), which points to Party (ABC) Party (John) Person (John), which inherits from Party (John) Supplier (John), which points to Party (John) If you query the system with something like \"Show me ALL parties\", the result will be: Party (ABC) Party (John) If you query with \"Show me ALL customers\", the result will be: Customer (ABC) Party hierachy There are other party types in addition to the main ones. Among them are 'Department' and 'Division'. By using all types, data about parties can be neatly organized. A useful example is the ability to structure parties hierarchically. Having departments and divisions as parties allows for flexible representation of different corporate hierarchies. For example, let's have 'Corporation A' structured in the following way: Corporation A Division 1 Sales Department Marketing Department Division 2 Sales Department Marketing Department Global Marketing Department Global Accounting Department The flexible party hierarchy also allows structuring different companies within a corporation: Corporation B Company A Consumer Electronics Division Sales Department Business Consulting Division Sales Department Accounting Department Company B Sales Department Accounting Department Corporate Financials Department Note Because our own enterprise companies Multi-company are also parties, such hierarchy can be used for organizing our own corporate structure and the corporate structure of our business partners. Party relationships Relationships between different parties can be formal or informal. Using them allows for the easy representation of information: Peter works for Company A Peter is a friend of George Steven has been married to Susan since 8/3/2011 John worked for Company B from 1/1/2010 till 3/5/2015 This information, on the other hand, is represented by a table: From Party Relationship Type To Party From Date To Date Notes Peter works for Company A Peter is friend with George Steven is husband of Susan 8/3/2011 John works for Company B 1/1/2010 3/5/2015 From Date and To Date represent the dates when the relationship was established and terminated, respectively."
  },
  "concepts/products/coding-systems.html": {
    "href": "concepts/products/coding-systems.html",
    "title": "Coding systems | ERP.net Tech Docs",
    "summary": "Coding systems Coding Systems group together multiple product codes according to different criteria. All product codes are grouped in coding systems. Product codes are codes other than the part numbers that bring meaning to the company such as supplier codes, customer codes, barcodes and more. A default measurement unit could also be specified in coding systems. If a product code relating to a coding system with a default measurement unit is selected, then this unit must load in the document instead of the product's default unit. For example, if in the products definition \"Measurement Unit = Pcs\" is set, and for this product there is also a product code that relates to a coding system with a \"Default Measurement Unit = Package\", then we expect the following behavior: When a product in the sales order is selected through product code via barcode, then: Product’s part number loads in the Product field in the particular sales order line; \"Quantity Unit = Package\", which corresponds to the default measurement unit in the coding system’s definition; \"Unit Price\" must be recalculated according to the product dimensions."
  },
  "concepts/products/index.html": {
    "href": "concepts/products/index.html",
    "title": "Products | ERP.net Tech Docs",
    "summary": "Products Description Products are the most detailed items which a company sells or buys. Products can be tangible or intangible. A tangible product is a physical object that can be perceived by touch such as a building, vehicle, gadget, or clothing. An intangible product is a product that can only be perceived indirectly such as services. In ERP.net, all product-specific data is kept in the product’s definition. Product’s definition includes the information that is needed to identify the product, for example: product name; part number; product group. And some other basic data that describes and categorizes the product, for example: product type; measurement unit; costing currency and others. Different panels can also be visualized in the product’s definition, allowing the user to have access to all of the product related information such as product dimensions, current stock holds, serial numbers, lots, product prices and others. Part numbers, product codes, serial numbers, and lots The products are identified in ERP.net by their part numbers. The part number is the unique identifier of the product. You cannot create a product without entering a product part number that is unique for the whole database. Conversely, the product name is not designed to be unique identifier, so it is possible to have different products with the same name but with different part numbers. In addition to the part number, the user is able to specify alternative product codes – e.g. supplier’s product codes, client’s product codes, barcodes, etc. In this way, the product can be searched and selected not only by its product number but by its product codes as well. For more information, see Product codes and Coding systems. As opposed to part numbers and codes, the serial numbers are used to identify not the whole product but its separate pieces and help to keep track of what happens with them (e.g., to whom they are sold, if they are under guarantee, etc.). If the option Serialized in the product definition is checked, this product cannot be used in the logistic documents if its serial number is not explicitly indicated. For more information, see Serial numbers. ERP.net allows the separate product units to be grouped in lots. An unlimited number of lots could be defined for a particular product. Each lot can contain product units that have the same expiry date or that are received within the same receiving order or that are produced within the same production output order. For more information, see Lots. In the product definition, you can manage the settings of using lots by determining the following parameters: whether the lots are allowed or not allowed or required the method by which the lots are automatically issued – FIFO, LIFO, and FEFO the standard cost per lot the standard price per lot the size of a standard lot. The above information is represented in the following table as an example: Part number Product name Product code (Coding system: Billa) Product code (Coding system: Metro) Serial number Lot number (Expiry date) 456789 X 88559910 777RR69PP 1111111111 20200611 456789 X 88559910 777RR69PP 1111111112 20200611 456789 X 88559910 777RR69PP 1111111113 20220810 999888 X 55889941 777RR69PP Product groups and product types Each product must belong to a user defined product group (e.g. goods, materials, services …) as well as to a user defined product type (e.g. goods, materials, services …): The Product groups allow the products to be grouped according to different criteria, so they could inherit certain properties from the groups – such as next part number, default measurement unit, product name mask, default product type, etc. For more information, see Product groups. The Product types provide the functionality of creating different automatizations for a certain product type - e.g., you can set whether the products of a certain type are allowed to be serviced, shipped, stocked, etc. For more information, see [Product types]. Measurement units The products can be presented in multiple measurement units. A base measurement category is used for storing the product in the warehouse, for sales reporting, etc. However, you may choose a different measurement unit that will be loaded by default when creating documents with this product. In order to make conversions between the different units of measurement for the same quantity, the user is able to define measurement ratios. For more information, see [Measurement categories], [Measurement units] and Product dimensions. Furthermore, no matter what the recalculation based on the measurement ratios is, if the option Allow variable measurement ratios is checked, the user has the opportunity to manually adjust the right base quantity in the particular situation. For more information, see Variable (dynamic) measurement ratios. Example of setting different measurement units for a product: Part number Product name Base measurement category Measurement unit Purchase measurement unit Product dimension 456789 X PCS KG Pallet 5 kg = 1 PCS; 1 pallet = 10 PCS Other settings When creating a product, the user must specify the currency in which the product cost will be calculated. By default - this is the base currency of the enterprise company. It is important to define the costing method as well. If the costing method is not set in the product definition, the one set in the enterprise company definition will be used instead. Some of the products are used as materials for producing other products. In this case, a flushing method must be set in the product definition. This method determines how the material will be written off from the warehouse – manually (using consumption orders) or automatically (by releasing or finishing the work order). The product can be activated or deactivated depending on whether it is a part of the company’s sales or procurement product lists. These settings are managed via the Active field in the product definition. In addition, there is an option to show or not this product in the company’s catalogs, related to its product group. If the option Is featured is checked – the product will be presented at the title space in promotional materials, web pages, etc. ERP.net provides a functionality to add one or several pictures of the product in order to be visually presented in the system. Pictures can be displayed when searching for products, printing reports, documents, etc. To automate the creation of the Intrastat declaration some fields in the product definition must be filled as well: Intrastat commodity code, Intrastat Supplementary Unit, and Origin Country. In the product definition the user can specify some other parameters of the product, such as those listed below: short name – the name that will be used for space-constrained devices, like mobile phones, fiscal printers, etc. expiry period days (from the date of production); guarantee period days (if the product type is serviced); cargo type – by choosing one of the user defined cargo types (e.g. container cargo, Liquid cargo, etc.); minimum sales quantity base; minimum sales price; planning demand time fence days; scrap rate (when the product is used as an ingredient); ABC class – product importance classification where A is the highest class and C is the lowest class. The products in class A are with the highest turnover and with the highest value; valuation group – a user-defined group that is used in reconciliations when compensating pluses and minuses. excise product – the excise product code (if the product is excised); excise alcoholic atrength (if the product is subject to alcoholic Excise reporting)."
  },
  "concepts/products/product-codes.html": {
    "href": "concepts/products/product-codes.html",
    "title": "Product codes | ERP.net Tech Docs",
    "summary": "Product codes Product codes are mechanisms that allow products to be selected not by their part number (indicated in the product definition), but by alternative codes for this product. For example, using this mechanism, products are selected via barcode. Product codes are used for the creation of new codes for existing products in the database. All product codes are grouped in coding systems. This mechanism is applied in the lines of logistics documents. It is implemented through a special field for the product code in the table and is a foreign key to the product codes table. By selecting the number from the drop-down list box you actually select the product for which the code is set. The field is commonly used when the documents are created manually by the user. When the documents are created automatically by the system (through procedures, for example) values in this field are carried by parental documents to sub-documents (if set), but are not automatically filled by the system (if not set). There are certain relations between the fields Product, Product Code and Quantity Unit: If the field Product Code has a value or the value in the field is changed, then the value of the Quantity Unit is taken from the definition of coding system (if set) to which the code belongs; If the value in the field Product is changed, then the field Product Code must be empty, because the product is no longer selected through this mechanism."
  },
  "concepts/products/product-dimensions.html": {
    "href": "concepts/products/product-dimensions.html",
    "title": "Product Dimensions | ERP.net Tech Docs",
    "summary": "Product Dimensions Product Dimensions are used for conversion between different units of measurement for the same quantity. In order to make this possible, product dimensions must be set for the products as a ratio between multiplier and divider to the base unit. The formula for calculation of quantity base in the documents lines is as follows: Quantity Base = Quantity * Product Dimension Dest Quantity / Product Dimension Source Quantity Required fields Description Quantity The quantity in the non-base unit. Source Quantity Unit The non-base unit for which the conversion ratio is specified. Dest Quantity The quantity in some of the base units. Dest Quantity Unit The measurement unit of the dest quantity. Should be one of the units of the base measurement category of the product. Measurement Category The measurement category of the source quantity unit. For each product, only one conversion ratio can be specified for a measurement category. Example: We need to load two pallets of a product. But we know that each pallet contains 15 pieces. So the total pieces that we need to load are 30. This means that if we want to automate this calculation, we need to insert the following information to create a conversion ratio in the product dimensions: Source Quantity - 1.00 Source Quantity Unit - Pallet Dest Quantity - 15.00 Dest Quantity Unit - Pcs Measurement Category - Complectation (e.g.)"
  },
  "concepts/products/product-groups.html": {
    "href": "concepts/products/product-groups.html",
    "title": "Product groups | ERP.net Tech Docs",
    "summary": "Product groups Product groups form a hierarchical tree structure of the products. ERP.net allows multiple groups with different names and characteristics to be created. Each product group can contain an unlimited number of products which are grouped together according to different criteria. It is strongly recommended that products are grouped in a meaningful way, as they could inherit certain properties from the groups. Product groups could also facilitate the creation of the individual products. For example, in their definition, it could be set: Next part number – a part number to be auto assigned to the products created in the group or the sub-group; Default measurement unit - a measurement unit to be auto assigned to the products created in the group or the sub-group; Product name mask – specifies a mask for the name of the products created in the group or the sub-group. The function allows creation of more accurate names that follow a certain pattern. The mask needs to be set for each language separately. Product groups could also contain other important settings, such as 'Product group required properties', 'Principal recipes', 'Product supply', etc."
  },
  "concepts/products/serial-numbers.html": {
    "href": "concepts/products/serial-numbers.html",
    "title": "Serial numbers | ERP.net Tech Docs",
    "summary": "Serial numbers Serial numbers are a way of identifying the different pieces of a product. They may be used for equipment, software, assets and more. With the Serial numbers the user can follow what happens with objects, which are otherwise identified by the system with one product definition (i.e. one Product_Id). The Serial numbers are also important for identification when providing guarantee and support. For example, in a sales order, the user may enter a row with three pieces which will have to be shipped separately (1 piece at a time). But (in the sales order) the user cannot mark which one of the three pieces is shipped first, which one is shipped second and etc. In the sales order, three Serial numbers are entered, but in the Shipments, the user may specify by Serial numbers which one is shipped each time and which Shipment exactly refers to it. Implementation The Serial numbers are recorded in a separate table where each record is an individual Serial number. Additional information is specified as Product, Lot (eventually), Availability (is the current piece blocked), Serial number card data and more. This way of implementation is preferred instead of the initial idea of defining number groups. In this implementation, the numbers in each group cannot be identified by something other than the symbols of their record. This is not very helpful because there are cases with fundamental differences between two Serial numbers which may be entered in one document row. For example, one of them may be blocked for future usage, and the second one - not. Other than that, visually, it looks better when the different Serial numbers are displayed in different document rows. This corresponds with the fact that we treat the products with different Serial numbers as different products. Also, the current implementation considerably eases the entering of Serial numbers by barcode scanner. Tracking of the current availability is easier as well as the tracking of the product with a specified serial number. Usage in documents Whether a product should be used with or without Serial numbers, is a property set in its definition - Is Serialized field. If a product is not serialized, Serial numbers are forbidden when working with this product. If it is serialized, than serial number usage is required in Transactions and Reconciliations, and in the other documents it is allowed, but not required. Usually, Serial numbers are entered in the transactions and reconciliations. In the previous documents (Receiving orders, Sales orders etc.) the user is able to enter a serial number but such kind of usage is rare. If the serial number is not entered, for example in the Receiving order, the user may enter just one row with the quantity of 10 PCS and breaking down this row to 10 separated rows with different Serial numbers and quantity of 1 PCS happens in the Transaction. The main way to break down one row to several with different Serial numbers happens through the Barcode commands panel for Store orders execution. Data entry validation The serial number is specified in the documents rows by selecting it from a dropdown list. When the value in this field changes, the following validations should be performed: if the row is a Transaction row or a Reconciliation row - then the value should be different than null only if the product is serialized; if the row is a different document row (not a Transaction or a Reconciliation) - then the value may (but not necessarily) be not-null only if the product is serialized. If it is not serialized, then null value is required; If there is a serial number in the row, then the quantity in the row must be 1, 0 or -1 and the measurement unit must be pieces ; if the entered value in the Serial Number field is different from null, then the product from the current row must be the same as the product in the serial number definition. Easy entry/selection Entering new Serial numbers and selecting an already entered one should be as easy as possible. For this purpose, when entering a serial number and in a dropdown list a number ( nonexistent in the database for the current product) is selected, then a record with this value is created in the database automatically. This will have the greatest effect when working with the Barcode commands panel. This panel has a working mode which creates new Serial numbers and it is available only when receiving goods in the store. If the user issues goods, they can choose only Serial numbers, which are already entered in the database. Also, there are modes for quick entering/selection of a list of Serial numbers. By them, the user may enter directly the numbers separated by commas (for example - \"KHC4500071, KHC4500072, KHC4500073, KHC4500074, KHC4500075, KHC4500076, KHC4500077\"), or they may set a range of numbers (in the previous example list, the user may enter just \"KHC4500071\" and \"KHC4500077\"). For more information about the Barcode panel's serial number modes, see Barcode Panel Modes and its subtopics. Availability And product tracking The products availability (both current and at a specified date) for serialized products is detailed to serial number level. The same is valid for the stock movements reports. By them, the user is able to track the movements of specified products and their Serial numbers. Such tracking is always executed by store documents (i.e. store movements) and if there comparing operations from specialized modules is required, then a link between the Transactions and the documents from the specified module is used (for example - links as [Parent Document] <-> [Sub-Document]). For example, in purchasing orders Serial numbers will rarely be entered (except for returns) and the Serial numbers will show up in the transactions. So if the user wants to see when a specified serial number is bought, then they would use stock movements and follow the link to the Purchasing orders (for example - through the parent document of the Store order)."
  },
  "concepts/products/variable-dynamic-measurement-rations.html": {
    "href": "concepts/products/variable-dynamic-measurement-rations.html",
    "title": "Variable (dynamic) measurement ratios | ERP.net Tech Docs",
    "summary": "Variable (dynamic) measurement ratios Variable (dynamic) measurement ratios are a functionality that allows a compensation of stock differences. Stock differences occur if there are variances between the quantity in the base unit of measure and the quantity in the parallel unit of measure. Stock differences may, for example, be caused by natural weight variations in material withdrawals. The option ‘Allow variable measurement ratios’ is available in the product’s definition. When this option is checked, the base quantity could be edited in the receiving order and transaction’s lines. Thereby, the user has the opportunity to manually adjust the right base quantity in the particular situation. Otherwise, if in the product definition is not set that it is allowed to use variable measurement ratios, then the product dimensions must be followed properly while recalculating base quantity. Example: The client has ordered 1 pallet of a product. We know that one pallet theoretically weights 1000 kg and that information is set as a conversion ratio in the product dimensions. But we also know that this weight may vary, so the product is allowed to use Variable measurement ratios. The base quantity in the store transaction is calculated on a base of the conversion rate. But when the workers in the warehouse actually put the pallet on the scale it turns out that the pallet actually weights 1100 kg. In this case they can manually set the value for the base quantity. This will not only assure that the information in the system is correct, but also will allow the company to invoice the right amounts. Note When using Variable measurement ratios, there are certain prohibitions. For example, creating payment orders from sales orders involving products with this setting is not >allowed. The reason is, if those payment orders are created for uninvoiced amounts, the possible change of the quantity in the transaction and therefore in the invoice may cause >the generation of excess documents."
  },
  "includes/erpnet.html": {
    "href": "includes/erpnet.html",
    "title": "| ERP.net Tech Docs",
    "summary": "ERP.net"
  },
  "includes/name.html": {
    "href": "includes/name.html",
    "title": "| ERP.net Tech Docs",
    "summary": "ERP.net"
  },
  "includes/webclient.html": {
    "href": "includes/webclient.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Web Client"
  },
  "includes/webclientfull.html": {
    "href": "includes/webclientfull.html",
    "title": "| ERP.net Tech Docs",
    "summary": "ERP.net Web Client"
  },
  "includes/winclient.html": {
    "href": "includes/winclient.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Windows Client"
  },
  "includes/winclientfull.html": {
    "href": "includes/winclientfull.html",
    "title": "| ERP.net Tech Docs",
    "summary": "ERP.net Windows Desktop Client"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to the ERP.net Technical Documentation | ERP.net Tech Docs",
    "summary": "Welcome to the ERP.net Technical Documentation The Technical Documentation explains the business logic of ERP.net. It is targeted towards implementation consultants and power users. Topics Concepts - general concepts which apply to all modules Modules - business functions and capabilities of ERP.net's modules Advanced - documentation of advanced systems Reference - reference data for different topics More information Data model - reference information about entities, business rules, generations, etc. Developer documentation - information for developers"
  },
  "legacy/exchange/index.html": {
    "href": "legacy/exchange/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": "ErpNet Exchange ECOD COMARCH EDI"
  },
  "legacy/exchange/еcod-comarch-edi/business-logic/common/filter-by-custom-property.html": {
    "href": "legacy/exchange/еcod-comarch-edi/business-logic/common/filter-by-custom-property.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Филтриране по документна характеристика в задачите При експорт на фактури и стокови разписки в настроките на задачана има филтър по стойност на Документна характеристика. Тя определя, че ще се екпортират само тези документи, които имат такава стойност за избраната характеристика. В падащия списък за избор на характеристика се показват само тези документни характеристики, които са указани в дефиницията на някой тип документ за Фактури или Експедиции (в таблица \"Характеристики за тип документ\")."
  },
  "legacy/exchange/еcod-comarch-edi/business-logic/common/index.html": {
    "href": "legacy/exchange/еcod-comarch-edi/business-logic/common/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Общи Филтриране на документите по потребителска харктеристика"
  },
  "legacy/exchange/еcod-comarch-edi/business-logic/export-despatch-advice/desadv-iln-algorithm.html": {
    "href": "legacy/exchange/еcod-comarch-edi/business-logic/export-despatch-advice/desadv-iln-algorithm.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Алгоритъм за определяне на полетата BuyerILN, SellerILN, DeliveryPointILN и UltimateConsigneeILN при експорт на стокови разписки ЗАБЕЛЕЖКА: Този алгоритъм се използва, когато е отметната отметката \"Използване на Номер на локация на субект\". Ако не е отметната се гледат полетата GLN в субектите. 1. BuyerILN = Location Number в таблица Gen_Party_Location_Numbers., където Party Id е фирмата на която е обектът указан в полето \"Към субект\" в експедицията и Location Coding System = GLN. 2. SellerILN = Location Number в таблица Gen_Party_Location_Numbers, където: 2.1. Party Id = От направление / Party_Id Partner Location Number = BuyerILN от т.1 и Location Coding System = GLN. 2.2. Ако не се намери запис в т.2.1 то Party Id = От направление / Party_Id Partner Location Number = Null и Location Coding System = GLN. 2.3 Ако не се намери запис в т. 2.2 то Party Id = Собствената фирма Partner Location Number = BuyerILN от т.1 и Location Coding System = GLN. 2.4. Ако не се намери запис в т.2.3 то Party Id = Собствената фирма Partner Location Number = Null и Location Coding System = GLN. 3. DeliveryPointILN = Location Number в таблица Gen_Party_Location_Numbers, където: Party Id = Към субект и Location Coding System е GLN. 4. UltimateConsigneeILN = Location Number в таблица Gen_Party_Location_Numbers, където: Party Id = Към субект и Location Coding System е GLN."
  },
  "legacy/exchange/еcod-comarch-edi/business-logic/export-despatch-advice/index.html": {
    "href": "legacy/exchange/еcod-comarch-edi/business-logic/export-despatch-advice/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Експорт на стокови разписки Този тип задачи позволява експорт на Commarch-bg ECOD Despatch Advices xml файлове от ERP.net база данни. Данните се експортират от документ тип Експедиция. Алгоритъм за определяне на ILN полетата Активиране на Packing-Reference секцията за поддръжка на SSCC кодове"
  },
  "legacy/exchange/еcod-comarch-edi/business-logic/export-despatch-advice/packing-reference.html": {
    "href": "legacy/exchange/еcod-comarch-edi/business-logic/export-despatch-advice/packing-reference.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Активиране на Packing-Reference секцията за поддръжка на SSCC кодове Секцията Packing-Reference се активира, ако има попълнен поне един SSCC код, попълнен в свързаният ред от складова разписка. SSCC кодовете се дефинират, като потребитлска характеристика за редове на складова разписка с код Exch_SSCC_STL Ако няма референтен ред на складова разписка се приема, че няма SSCC код за този ред SSCC код се попълва от експорта в тага в секцията Packing-Reference Ако в един ред има попълнена SSCC код, то всички редове трябва да имат. Не се допуска само някой от редовете да имат."
  },
  "legacy/exchange/еcod-comarch-edi/business-logic/export-invoices/export-credit-note.html": {
    "href": "legacy/exchange/еcod-comarch-edi/business-logic/export-invoices/export-credit-note.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Експорт на кредитно известие, когато в системата няма данни за оригиналния документ При началото на използване на ERP.net, когато след внедряването е започне работа, оригиналните фактури не присъстват като документи в системата. Тогава полето Оригинална факткура в кредитното известие няма стойност. За да може експорта да се осъществи е необходимо да му се подадат Номер на оригинална фактура и Дата на оригинална фактура. Това се прави, като тези стойности се подават в характеристики за документ, както следва: Номер на оригинална фактура - Потребителска характеристика за документ с код Exch_InvoiceReferenceNumber Дата на оригинална фактура - Потребителска характеристика за документ с код Exch_InvoiceReferenceDate"
  },
  "legacy/exchange/еcod-comarch-edi/business-logic/export-invoices/index.html": {
    "href": "legacy/exchange/еcod-comarch-edi/business-logic/export-invoices/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Експорт на фактури Този тип задачи позволява експорт на Commarch-bg ECOD Invoices xml файлове от ERP.net база данни. Данните се експортират от документ тип Фактури. Алгоритъм за определяне на ILN полетата"
  },
  "legacy/exchange/еcod-comarch-edi/business-logic/export-invoices/invoice-iln-algorithm.html": {
    "href": "legacy/exchange/еcod-comarch-edi/business-logic/export-invoices/invoice-iln-algorithm.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Алгоритъм за определяне на полетата BuyerILN, SellerILN и InvoiceeILN при експорт на фактури от EnterpriseOne Определянето на BuyerILN, SellerILN и InvoiceeILN се прави по следния алгоритъм: ЗАБЕЛЕЖКА: Алгоритъм за определяне на полетата BuyerILN, SellerILN и InvoiceeILN при експорт на фактури от EnterpriseOne. Този алгоритъм се използва, когато е отметната отметката \"Използване на Номер на локация на субект\". Ако не е отметната се гледат полетата GLN в субектите. 1. BuyerILN = Location Number в таблица Gen_Party_Location_Numbers., където Party_Id е фирмата на Клиента указан в полето \"Клиент\" в във фактурата и Location Coding System = GLN. 2. SellerILN = Location Number в таблица Gen_Party_Location_Numbers, където: 2.1. Party Id = От направление / Party_Id Partner Location Number = BuyerILN от т.1 и Location Coding System = GLN. 2.2. Ако не се намери запис в т.2.1 то Party Id = От направление / Party_Id Partner Location Number = Null и Location Coding System = GLN. 2.3 Ако не се намери запис в т. 2.2 то Party Id = Собствената фирма Partner Location Number = BuyerILN от т.1 и Location Coding System = GLN. 2.4. Ако не се намери запис в т.2.3 то Party Id = Собствената фирма Partner Location Number = Null и Location Coding System = GLN. 3. InvoiceeILN = Location Number в таблица Gen_Party_Location_Numbers., където Party Id е фирмата на Клиента указан в полето \"Клиент\" в във фактурата и Location Coding System = GLN. 4. DeliveryLocationNumber = Location Number в таблица Gen_Party_Location_Numbers, където: Party Id = Към Субект Document Id е свързаната експедиция към тази фактура"
  },
  "legacy/exchange/еcod-comarch-edi/business-logic/import-orders/index.html": {
    "href": "legacy/exchange/еcod-comarch-edi/business-logic/import-orders/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Импорт на поръчки Този тип задачи позволява импортиране на Commarch-bg ECOD Order xml файлове в ERP.net база данни. Данните се импортират в документ тип Продажба. Алгоритъм за определяне на ILN полетата"
  },
  "legacy/exchange/еcod-comarch-edi/business-logic/import-orders/order-iln-algorithm.html": {
    "href": "legacy/exchange/еcod-comarch-edi/business-logic/import-orders/order-iln-algorithm.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Алгоритъм за определяне на субектите при импорт на поръчки от ECOD Алгоритъм за определяне на субектите в EnterpriseOne при импорт на поръчки от ECOD. Определянето на Клиент, Собствена фирма, От Направление, Към направление и Доставяне на клиент се прави по следния алгоритъм: ЗАБЕЛЕЖКА: Този алгоритъм се изпoлзва, когато е отметната отметката \"Използване на Номер на локация на субект\". Ако не е отметната се гледат полетата GLN в субектите. 1. Установява се Собствената фирма: 1.1. Търси се измежду собствените фирми фирма с Location Number = Seller ILN, Partner Location Number = Buyer ILN и Location Coding System = GLN. 1.2. Ако не намери фирма в т. 1.1. то търси фирма с Location Number = Seller ILN, Partner Location Number = Null и Location Coding System = GLN 1.3. Ако не намери фирма в т. 1.1. и 1.2. използва настройката в задачата за определяне на Собствена фирма по подразбиране. 2. Установява се Клиент - фирма, за която Location Number = Buyer ILN, Location Coding System = GLN и Собствена фирма от т.1. 3. Установява се \"От направление\". Това се прави в зависимост от Характеристика за клиент „ECOD_Company_Division ECOD попълване на направление“: 3.1. Ако характеристиката има стойност „Попълва се по CodeByBuyer“ то направлението се установява по Code (Код на направление) = CodeByBuyer таг в импортния файл. Ако не намери направление хвърля грешка. 3.2. Ако характеристиката има стойност „Попълва се по GLN“ то се издирва направлението по по Location Number = Seller ILN, Partner Location Number = Buyer ILN и Location Coding System е GLN. Ако не намери направление хвърля грешка. 4. Установява се \"Към направление\". Направлението се определя, като се търси направление на Клиент от т.2 със същия Код, като направлението от т.3. Ако в т.3 не е намерено направление – остава празно. 5. Установява се Доставяне а клиент в зависимост от опцията \"Определяне на Доставяне на клиент\" в задачата: 5.1. Ако стойността е „Dlivery Point“ се определя обект за който Location Number = DliveryPoint ILN и Location Coding System = GLN и след това Клиент обект в зависимост от собствената фирма от 1. 5.2. Ако стойността е „Order By“ се определя обект за който Location Number = OrderBy ILN и Location Coding System е GLNи след това Клиент обект в зависимост от собствената фирма от 1. Входните данни от файла са: Seller ILN, Buyer ILN, CodeByBuyer, DliveryPoint ILN, OrderBy ILN"
  },
  "legacy/exchange/еcod-comarch-edi/business-logic/index.html": {
    "href": "legacy/exchange/еcod-comarch-edi/business-logic/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Бизнес логика Общи Импорт на поръчки Експорт на стокови разписки Експорт на фактури"
  },
  "legacy/exchange/еcod-comarch-edi/data-compliance.html": {
    "href": "legacy/exchange/еcod-comarch-edi/data-compliance.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Съответствие на данните с ERP.net Описание на съответствията между експортните и импортните файлове от една страна и ERP.net от друга 1. Експорт на фактури Следващите тагове се взимат от свързаната Експедиция. <CodeBySeller>11223344</CodeBySeller> в секцията /Document-Invoice/Invoice-Parties/Buyer <CodeBySeller>\\ = General_PartyLocationNumber.LocationNumber WHERE Logistics_Shipment_Shipment.ShipToPartyContactMechanism.Party = General_PartyLocationNumber.Party And LocationCodingSystem = INT <Name>BUYER COMPANY</Name> в секцията /Document-Invoice/Invoice-Header/Delivery <Name> = Logistics_Shipment_Shipment.ShipToPartyContactMechanism.Party.. CompanyLocation.Company.PartyName (bg part) <StreetAndNumber>Main Street 1</StreetAndNumber> в секцията </Document-Invoice/Invoice-Header/Delivery <StreetAndNumber> - Logistics_Shipment_Shipment.ShipToPartyContactMechanism.Name - стринга след първата запетайка. <CityName>Sofia</CityName> в секцията </Document-Invoice/Invoice-Header/Delivery <CityName> - Logistics_Shipment_Shipment.ShipToPartyContactMechanism.Name - стринга преди първата запетайка. <PostalCode>1112</PostalCode> в секцията </Document-Invoice/Invoice-Header/Delivery <PostalCode> - Logistics_Shipment_Shipment.ShipToPartyContactMechanism.Party.Area.Code <Country>BG в секцията </Document-Invoice/Invoice-Header/Delivery <Country> - Logistics_Shipment_Shipment.ShipToPartyContactMechanism.Party.. CompanyLocation.Company.Country"
  },
  "legacy/exchange/еcod-comarch-edi/index.html": {
    "href": "legacy/exchange/еcod-comarch-edi/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": "ECOD COMARCH EDI Бизнес логика Настройки в ERP.net Съответствие на данните с ERP.net"
  },
  "legacy/exchange/еcod-comarch-edi/settings-in-erp/gln-codes.html": {
    "href": "legacy/exchange/еcod-comarch-edi/settings-in-erp/gln-codes.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Настройка на GLN номера в ERP.net за ECOD трансфери За осъществяване на интеграцията с ECOD посредством ERP.net Exchange е необходимо да се настрои разполагането на GLN номерата по определен начин. Тази настройка се използва, когато отметката \"Използване на Номер на локация на субект\" е отметната в дефиницията на задачата. GLN номерата се поставят таблица \"Номера на локации - субекти\" (Gen_Party_Location_Numbers) - има едноименни панели в дефиницията на субектите. За всеки субект може да има повече от един запис Обикновено субектите на на клиента - Клиент и Доставяне на клиент имат по един запис за GLN в таблицата с номера на локации. Във фирмата на собствената фирма трябва да има по един запис за всеки клиент, като се попълват полетата \"Номер на локация парньор\" и \"Субект партньор\". По този начин се указва за кой партньор се използва съответния GLN. За един клиент може да се използват повече от един GLN - ако клиента има няколко направления и във всяко едно нашата фирма е регистрирана като отделен клиент. За всяко направление на клиент трябва да се дефинира по едно направление на собствената фирма със същия код. В направлението на собствената фирма трябва да се направи един запис за GLN, като се попълнят и \"Номер на локация парньор\" и \"Субект партньор\", за да се укаже за кой партньор се използва този GLN. Пример за попълване на GLN в база данни с две собствени фирми, които имат Метро за клиент и обменят документи с него по ECOD: Нека имаме две собствени фирми Фирма1 и Фирма2, които продават на Метро в две направления - Храни и Козметика. Използват се следните GLN: Фирма Метро - 0000000000001 Метро Обект Люлин - 0000000000002 Фирма1 регистирана в направление Храни на Метро - 0000000000003. CodeByBuyer = 1001 Фирма1 регистрирана в направление Козметика на Метро - 0000000000004. CodeByBuyer = 1002 Фирма2 регистирана в направление Храни на Метро - 0000000000005. CodeByBuyer = 2001 Фирма2 регистрирана в направление Козметика на Метро - 0000000000006. CodeByBuyer = 2002 Дефиниране на Метро: Фирма Метро - един запис в Party Location Numbers : Субект = Метро Номер на локация = 0000000000001 Направление Метро храни Фирма1 - няма записи в Party Location Numbers - Код на направление = 1001 Направление Метро козметика Фирма1 - няма записи в Party Location Numbers - Код на направление = 1002 Направление Метро храни Фирма2 - няма записи в Party Location Numbers - Код на направление = 2001 Направление Метро козметика Фирма2 - няма записи в Party Location Numbers - Код на направление = 2002 Доставяне на клиент Метро Люлин - един запис в Party Location Numbers : Субект = Метро Люлин Номер на локация = 0000000000002 Дефиниране на Фирма1: Фирма Фирма1 - запис в Party Location Numbers : Субект= Фирма1 Номер на локация = 0000000000003 Субект Партньор = Метро Номер на локация на Партньор = 0000000000001 - запис в Party Location Numbers : Субект = Фирма1 Номер на локация = 0000000000004 Субект Партньор = Метро Номер на локация на Партньор = 0000000000001 Направление Фирма1 Метро храни - един запис в Party Location Numbers : Субект = Фирма1 Метро храни Номер на локация = 0000000000003 Субект Партньор = Метро Номер на локация на Партньор = 0000000000001 - Код на направление = 1001 Направление Фирма1 Метро козметика - един запис в Party Location Numbers : Субект = Фирма1 Метро козметика Номер на локация = 0000000000004 Субект Партньор = Метро Номер на локация на Партньор = 0000000000001 - Код на направление = 1002 Дефиниране на Фирма2: Фирма Фирма2 - запис в Party Location Numbers : Субект = Фирма2 Номер на локация = 0000000000005 Субект Партньор = Метро Номер на локация на Партньор = 0000000000001 - запис в Party Location Numbers : Субект = Фирма1 Номер на локация = 0000000000006 Субект Партньор = Метро Номер на локация на Партньор = 0000000000001 Направление Фирма2 Метро храни - един запис в Party Location Numbers : Субект = Фирма2 Метро храни Номер на локация = 0000000000005 Субект Партньор = Метро Номер на локация на Партньор = 0000000000001 - Код на направление = 2001 Направление Фирма2 Метро козметика - един запис в Party Location Numbers : Субект = Фирма2 Метро козметика Номер на локация = 0000000000006 Субект Партньор = Метро Номер на локация на Партньор = 0000000000001 - Код на направление = 2002"
  },
  "legacy/exchange/еcod-comarch-edi/settings-in-erp/index.html": {
    "href": "legacy/exchange/еcod-comarch-edi/settings-in-erp/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Настройки в ERP.net Първоначални настройки за работа с ERP.net Exchange Настройка на GLN номера в ERP.net за ECOD трансфери"
  },
  "legacy/exchange/еcod-comarch-edi/settings-in-erp/initial-setup.html": {
    "href": "legacy/exchange/еcod-comarch-edi/settings-in-erp/initial-setup.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Първоначални настройки за работа с ERP.net Exchange За работа с ERP.net Exchange са неоходими някои начални предпоставки: Необходимо е да се дефинират направления за собствената фирма и клиента Кодът на направлението е номерът на доставчик в направлението на клиента. Например, ако нашата собствена фирма е Демофирм и е доставчик на Метро, и метро има Направления Храни и Битова химия, то ние ще имаме два кода на доставчик при тях - например 5555 код на доставчик за направление Храни и 4444 код на доставчик за направление Битова химия. В такъв случай трябва да дефинираме следните направления: Направление 5555 Храни Метро - субект Метро Направление 5555 Храни Метро - субект Демофирм Направление 4444 Битова химия Метро - субект Метро Направление 4444 Битова химия Метро - субект Демофирм Тоест за всеки код на доставчик дефинираме по две направления - едно за клиента и едно за собствената фирма с един и същи код, който е Код на доставчик при съответния клиент. Необходимо е за всеки клиент, който използва ECOD да се попълни стойност на характеристика ECOD_Company_Division ECOD Попълване на направление В тази характеристика се указва как се определя направлението при импорт на поръчки - по Код на доставчик или по GLN За всяко направление може да се попълни и GLN, който да се използва от трансфера. Направленията са задалъжителен атрибут на документите които се импортират или експортират. За да се осъществи експорт на Фактури то тези факури трябва задължително да имат експедиция преди тях."
  },
  "modules/applications/data-warehouse/index.html": {
    "href": "modules/applications/data-warehouse/index.html",
    "title": "Data warehouse | ERP.net Tech Docs",
    "summary": "Data warehouse Data warehouse is a large storage of data coming from a wide range of company sources and used to guide management decisions. It helps in reporting and data analysis and is considered a core component of business intelligence. Currently, in the ERP.net platform, the following tools are implemented: data measures, grouped into data measure groups. data values, entered in for the different measures. Data measure groups are accompanying attributes, allowing data to be ordered by the users and structured in a hierarchy. Data measures are declared for a period. The period may be a day, month or year. It defines the allowed spread: a +/- percent by which the goal could be missed but still considered achieved. Data value is actually a fact. It represents the real value of a data measure for a specified date. Usually, this is the first day of the period of the data measure. It also holds a target value and an actual value. Data values support enterprise companies (for more information, see Multi-company). As all entities, Data measures and Data values support custom properties, which allows entering additional information. Values may be entered on a daily, monthly or yearly basis by the user, an application or other. They may also be entered by multiple sources at the same time. Data warehouse is after that used in the ERP.net BI or external BI solution. Further reference: Data measure groups business rules"
  },
  "modules/applications/enterprise-asset-management/index.html": {
    "href": "modules/applications/enterprise-asset-management/index.html",
    "title": "Asset Management | ERP.net Tech Docs",
    "summary": "Asset Management Enterprise asset management (EAM) involves the maintenance management of an organization’s physical assets throughout each asset's lifecycle. It is used to plan, optimize, execute, and track the needed maintenance activities with the associated priorities, skills, materials, tools, and information. This covers the design, construction, commissioning, operations, maintenance and decommissioning or replacement of plant, equipment and facilities. You can learn more about EAM here. In ERP.net, EAM deals with the maintenance and locations of the company assets. In the following sections, we will describe the different entity types comprising the EAM data model. Maintenance types When planning the required maintenance of an asset, you can schedule and perform different types of maintenance procedures. For example, if we have a car, we can plan: Insurance renewal - once per year Oil change - every 20,000 km Gearbox check - every 5 years OR 100,000 km Each of the above represents a different maintenance type which can be scheduled based on a date and a tracked parameter change. In an enterprise, there can be many different types of assets, each requiring its own maintenance type. Some maintenance types may be applicable to multiple asset types and others - unique for specific asset types. When a lot of maintenace types are present, they can be organized into Maintenance type groups. Asset type maintenance For each asset type, you can define what kind of maintenance is needed for its assets, as well as a default schedule. Examples: Car Insurance - Every 12 months Oil - Every 15,000 km Gearbox Heavy truck Insurance - Every 12 months Oil - Every 30,000 km Gearbox Refrigerating compartment check etc. Aircraft A-Check - Every 200 cycles B-Check - Every 6 months C-Check - Every 20 months D-Check - Every 80 months Note Although both cars and heavy trucks need oil change, the required mileage is different. In practice, every car and truck may have different mileage requirements. Managed asset types Depending on the management required by each asset, there can be different asset types. These are used to categorize the assets and the tracked parameters for each type. Examples: Car Heavy truck Aircraft Building Street lamp Computer Tracked parameters For each asset type, you can track different parameters. Examples: Car Mileage (in km) Heavy truck Mileage (in km) Cycles Airplane Flight hours Cycles The tracked parameters are used to track the usage and wearing out of the asset and hence plan the desired maintenance. Service centers When planning the maintenance of assets, maintenance procedures are executed by different service centers. This works when each maintenance schedule for an asset is assigned to a respective service center. The service center could be an authorized service center for the asset, but it may also be an employee executing the desired maintenance. Managed assets Managed assets are resources or items that an enterprise company owns or leases and keeps track of, such as equipment, vehicles, rental properties, or service tools. In ERP.net, these assets are organized and undergo maintenance planning and execution, location assignments tracking, etc. Examples: Car Peugeot 508, Y2016, Reg.No. CC0303PM Car Jeep Grand Cherokee, Y2017, Reg.No.YY0202PS Mobile Station 5011 AG Aircraft AT-502B Apartment 3B, 120 Main Street, Cityville Mobile Generator Unit 201 MRI Scanner Important Every fixed asset, rental asset, fleet vehicle, and service object can be linked to a managed asset through the Managed Asset field present in their definitions. When creating them, make sure to specify the appropriate managed asset they will be tied to. Defining assets as managed allows them to be tracked in one place - the definition of the managed asset they're related to. All you need to do is integrate them as panels, if they aren't already. That way, you will be able to see and access all of their important information. For additional convenience, you can also generate custom reports for all fixed assets, rental assets, fleet vehicles and service objects united under a common managed asset. Since there could be many managed assets, they can organized in a hierarchy of Managed asset groups. Maintenance schedules When an asset has a type defined for it, it inherits some default maintenance schedules. However, each asset may be of different age and wear and might have unique maintenance needs. That is why specific maintenance schedules for each managed asset are necessary. Examples: Car Peugeot 508, Y2016, Reg.No. CC0303PM Insurance - Every 12 months Oil - Every 18,000 km Car Jeep Grand Cherokee, Y2017, Reg.No.YY0202PS Insurance - Every 12 months Oil - Every 20,000 km Scheduled maintenances Maintenance schedules define the general plan for maintenance. However, you need to schedule each specific maintenance as well. Scheduling might be needed for different reasons: The time limit after the last maintenance was reached (by date). The mileage for the next maintenance was reached (by tracked parameter). The asset was purchased second hand and one initial maintenance should be scheduled after up to 20 days (manually planned). Each of the above represents a maintenance schedule which can be both manually entered or automatically planned. Note Emergency repair is not planned and it is not considered scheduled maintenance. Emergency repairs are directly processed through maintenance orders. Locations The EAM module allows for the tracking of asset assignments by different company locations and responsible persons. Assets can also be re-assigned multiple times (even within a month). Note Asset assignment can be used to determine the cost centers to which the depreciation will be distributed. Asset locations contain the following data about each assignment: Date of assignment Company location Responsible person Notes - for more precise location or other notes. Maintenance orders The maintenance order document is the final data piece in the EAM data model. It represents one specific appointment for a specific type of maintenance for one (or many) specific assets. Orders are created by the maintenance planner to denote the actual appointment with the service center. Document statuses correspond to the progress of the maintenance: Firm Planned - the maintenance is appointed with the service center for specific time and date. Released - the maintenance has started (used mostly for maintenances which are performed in-house) Completed - the maintenance was performed. Maintenance orders can create other sub-documents to represent the actual work (like service orders) or the materials requested and used (store order / store transaction), etc. Lines One maintenance order can appoint the maintenance of multiple managed assets. Each maintenance type for each asset is represented by one maintenance order line."
  },
  "modules/applications/index.html": {
    "href": "modules/applications/index.html",
    "title": "Applications | ERP.net Tech Docs",
    "summary": "Applications ERP.net contains various built-in applications: Enterprise asset management Rental Service Data warehouse MsSync"
  },
  "modules/applications/mssync/getting-started/home.html": {
    "href": "modules/applications/mssync/getting-started/home.html",
    "title": "Home | ERP.net Tech Docs",
    "summary": "Home The Home page offers a quick overview of MsSync’s current state. Here, you'll see details about the app’s sync jobs, including: all logs recorded by each job the latest time they synced with Office365 States The synchronization status indicates whether the connection between MsSync and Office365 is successful or failed. Possible scenarios include: Operational The connection is stable and there aren’t any operational issues. Error: Unauthorized or insufficient permissions When an error occurs, it indicates a potential problem with the permissions granted for Office365 to access and modify resources from ERP, or the other way around. To address this issue, please refer to our Service documentation. Sync jobs Within this panel, you'll discover details about your current synchronization jobs and their respective information. The Latest sync (UTC) timestamp indicates the most recent confirmed synchronization. Additiony, logs are available for all operations, including when a resource is retrieved from Office365 and when a resource is sent from ERP. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/applications/mssync/getting-started/index.html": {
    "href": "modules/applications/mssync/getting-started/index.html",
    "title": "Getting started | ERP.net Tech Docs",
    "summary": "Getting started First, ensure that your organization uses Azure Athentication and that the organization's domain is configured in ERP.net. Second, a website with the type \"Microsoft Sync\" must be set up in your ERP.net database. Third, an ERP.net admin needs to log in to MSSync and grant access to your Microsoft 365 resources using the Service menu. Finally, each user who wants to use synchronization must sign in to MSSync to activate it, following these steps: Login to the company's MSSync website. To access MSSync, it’s mandatory to sign in using the 'Sign in with Microsoft' button with the Microsoft account provided by your organization. To establish the link, you will need to read and accept the permissions MSSync needs to obtain. If you use local ERP credentials to log in, MsSync will still open, but will essentially deny you any kind of access to its resources. Warning You must log in via an existing Microsoft account in order to reference your Outlook calendar. Otherwise, MSSync would be unable to determine which calendar to link to. Then select your default enterprise company, location, and time zone and activate the desired synchronizations using the Setup menu. Main menu The MSSync app consists of three sections: Home Setup Service In Home, you'll find personal profile details, general information about the current state of your application, as well as the latest log data for your activated sync jobs. In Setup, you can see information about your enterprise company - the one that is currently linked to MSSync. Additionally, you can toggle synchronization for a specific sync job on or off. The Service section is meant for users with administrator access levels. It reveals more technical and sensitive details used in the communication between MSSync and Office365. From here, admins can securely connect their MSSync instance to their Microsoft Entra ID. This is essential for activating all synchronization-related functionalities. For more information about navigating, setting up, and configuring MsSync, see: Home Setup Service Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/applications/mssync/getting-started/service.html": {
    "href": "modules/applications/mssync/getting-started/service.html",
    "title": "Service | ERP.net Tech Docs",
    "summary": "Service The Service section is exclusively for ERP.net admins. Here, they can request permissions for accessing Microsoft 365 resources from an admin within their enterprise company. These permissions are essential for enabling synchronization between the company's Microsoft 365 account and the ERP.net Web Client. State In the Service section, you'll find the current state of the MsSync app. There are also logs detailing all state changes, similar to those found in the Setup section. Information panel This panel stores details about the Operation mode of the app, and reveals the Client Id, and Tenant Id, which play a role in establishing the two-way synchronization process. Connect to Microsoft Entra ID This button sends a request on behalf of ERP.net to access resources already available in your Microsoft 365 account. This permission not only enables modifications to existing resources but also allows the inclusion of new ones. Any changes made to resources in ERP.net are mirrored in Microsoft 365, and vice versa. Give permissions The \"Give Permissions\" ensures that the MsSync app has all the necessary permissions to function optimally. It's recommended that an admin user click the \"Give Permissions\" button after the very first start of the app. This action will automatically check and configure all required permissions specific to the various job types. This process is essential for activating all available features and ensuring a seamless user experience. -- Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/applications/mssync/getting-started/setup.html": {
    "href": "modules/applications/mssync/getting-started/setup.html",
    "title": "Setup | ERP.net Tech Docs",
    "summary": "Setup Within this section, you can find data about your default enterprise company - the one logged in MsSync, which includes details like location and time zone. This section also showcases the state of the app, as visible in Home. Below, there's a list of your sync tasks, with slider buttons built into them for toggling synchronization for on and off. Just under the state message, you'll find an additional log detailing the latest change which occured for MsSync's state. Company details There's a panel containing data about your company, including its name, location, and time zone. This information is automatically filled in by the system upon your login and is integral for the two-way synchronization process. For example, if you're creating an event through Outlook's Calendar, these details cannot be filled from there as they are not required by default. As long as the connection with MsSync is properly configured, the Outlook event that will appear in the ERP.net Calendar will automatically pick up your default enterprise company data. Note You can choose your enterprise company in your profile settings. A single profile can contain more than one company. Note If no enterprise company is specified, you will get a notification error indicating which sync job is affected. Sync jobs As in Home, there’s a panel representing your available sync jobs. Here, alongside the latest sync, you'll notice two extra buttons: one for sync jobs activation and deactivation and another for refreshing the module. Activate and deactivate synchronization This button enables or disables the sync job assigned to it. Simply toggle the slider button in the respective direction and the process will commence. On first-time activation, the system will sync data for the past two weeks and the upcoming year. Afterwards, synchronization will occur automatically every 15 minutes. Full refresh When you click on this button, synchronization for the respective job will refresh on-demand, reflecting the last two weeks and the upcoming year. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/applications/mssync/index.html": {
    "href": "modules/applications/mssync/index.html",
    "title": "Overview | ERP.net Tech Docs",
    "summary": "Overview MSSync is a website application designed to synchronize resources between ERP.net and Office 365. In this documentation, you'll find everything you need to get started and make the most out of MSSync: Getting Started: Learn about the app's user interface, how to navigate through the home page, set up MSSync, and configure the service settings. Initial MSSync configuration: A mandatory requirement for the first-time setup of MSSync, which must be performed by an admin. Sync Jobs: Detailed guides on the information, requirements, and specific steps for setting up and managing your sync jobs."
  },
  "modules/applications/mssync/pictures/index.html": {
    "href": "modules/applications/mssync/pictures/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/applications/mssync/sync-jobs/calendar.html": {
    "href": "modules/applications/mssync/sync-jobs/calendar.html",
    "title": "Calendar | ERP.net Tech Docs",
    "summary": "Calendar The Calendar Sync Job enables the synchronization of calendar events between Microsoft 365 and your ERP.net instance. This feature ensures that all calendar events created or updated in Microsoft 365 are automatically reflected in ERP.net as corresponding activities and vice-versa. System requirements Document Type Meeting for Activity Entity A document type with the code Meeting must exist for the Activity entity within ERP.net. If this document type does not exist, the MSSync service user must have permissions to create it. This is required when syncing Microsoft 365 calendar events that result in the creation of new activities in ERP.net. MSSync service user must be an admin When the default activity document type is secured with CanUpdate and/or CanVoid permissions, the service user must be able to grant these permissions to itself. Per user requirements Valid and enabled mailbox on Microsoft 365 side The calendar events are managed by the mailbox, so each user must have a valid and enabled mailbox in Microsoft 365. Only users with an active mailbox can have calendar events synchronized. Each user has default enterprise company and location This is required when creating new activities in ERP.net. Since an activity is essentially a document, each document requires the EnterpriseCompany and EnterpriseCompanyLocation properties to be filled. Initial sync (first-time synchronization) Only remote events (from Microsoft 365) occurring from today until one month later will be synchronized. In other words, MSSync will pull all Microsoft 365 events from today until the next month and create corresponding ERP.net activities. Considerations and specific scenarios ERP.net activities older than 1 day will not be synchronized. When an ERP.net activity is in read-only state (Released, Closed), all updates triggered from Microsoft 365 will fail. This will result in a synchronization conflict, and the Microsoft 365 activity will be marked accordingly. Recurring events are not supported. When an event is deleted in Microsoft 365, the corresponding ERP.net activity will be voided. Resources https://docs.erp.net/model/entities/General.Activities.Activities.html https://learn.microsoft.com/en-us/graph/api/resources/event?view=graph-rest-1.0"
  },
  "modules/applications/mssync/sync-jobs/index.html": {
    "href": "modules/applications/mssync/sync-jobs/index.html",
    "title": "Sync jobs | ERP.net Tech Docs",
    "summary": "Sync jobs Sync Jobs are at the heart of MSSync, enabling you to automatically keep your Microsoft 365 resources in sync with ERP.net. These jobs are responsible for handling different types of data, ensuring everything stays aligned across both platforms. What is a Sync Job? A Sync Job is a core functionality within MSSync that handles the synchronization of specific types of data between Microsoft 365 and ERP.net. Each sync job is responsible for a different category of data, ensuring that information in both systems remains consistent and up-to-date. For example, the Calendar Sync Job will synchronize calendar events from Microsoft 365 into corresponding activities in ERP.net, while the [Mail Sync Job] ensures that emails sent or received through Microsoft 365 are transferred into ERP.net. Sync jobs operate automatically once configured, keeping both systems in sync without requiring manual updates. Important considerations Each sync job in MSSync comes with its own set of requirements and conditions that must be met for it to function correctly. These considerations can include permissions, system settings, and configurations that are essential to ensure smooth synchronization between Microsoft 365 and ERP.net. All relevant details and setup instructions are provided on the respective pages for each sync job, guiding you through the specific steps needed for proper configuration. Sync job types Calendar Mail"
  },
  "modules/applications/mssync/sync-jobs/mail.html": {
    "href": "modules/applications/mssync/sync-jobs/mail.html",
    "title": "Mail | ERP.net Tech Docs",
    "summary": "Mail The Mail Sync Job enables the synchronization of emails between Microsoft 365 and your ERP.net instance. This ensures that emails sent or received in Microsoft 365 are automatically reflected in ERP.net, keeping your communication records aligned across both platforms. System requirements MSSync service user must be an admin Because the service user must obtain mail messages from all users using MSSync, it should have administrative privileges. Per user requirements Default local mailbox in ERP.net Each user must have a local mailbox marked as the default. Default local mailbox email The default local mailbox must have an email address that matches the principal name (i.e., the user's email address). No mailbox encryption The default local mailbox must not use encryption. Synchronizing with a mailbox that has encryption enabled in ERP.net is not supported. Initial sync (first-time synchronization) Only remote messages (from Microsoft 365) older than 7 days and up to the present will be synchronized. Only local messages (from ERP.net) older than 7 days and up to the present will be synchronized. Considerations and specific scenarios ERP.net mailbox encryption is not supported. Message attachments are currently not fully supported. When present, they are represented properly as attachments, but their content is specified as a URI. Resources https://docs.erp.net/model/entities/Applications.Mail.Boxes.html https://docs.erp.net/model/entities/Applications.Mail.BoxFolders.html https://docs.erp.net/model/entities/Applications.Mail.Messages.html https://learn.microsoft.com/en-us/graph/api/resources/message?view=graph-rest-1.0"
  },
  "modules/applications/rental/index.html": {
    "href": "modules/applications/rental/index.html",
    "title": "Rental | ERP.net Tech Docs",
    "summary": "Rental The Rental section is designed to oversee and control the leasing process of all owned and re-leased assets. Located in the Applications module, it is divided into various panels, each serving a specific function to ensure effective management of assets, documents, and transactions. By providing a structured approach as well as the ability to generate detailed reports, Rental offers a comprehensive aid to all rental-related processes and operations. Note Rental is referred to as Lease-Out Management in the ERP.net Desktop Client. For the purposes of this overview, screenshots and references will be used from the Desktop Client. Types There are two types of assets which you can create and manage through Rental: Rental assets Consumables In the context of a rental asset, a consumable typically refers to items or materials that are used up and need to be replaced regularly as part of the asset's operation or maintenance. Consumables are tied to a rental asset but are treated as products distinct from it. They are sold and not returned, while the rental asset itself is leased for a specific period of time, and is therefore expected to be returned in reusable condition. Note Each rental asset can also be categorized as a Managed Asset. Documents The Documents portion of Rental contains all essential transactions and contracts related to the leasing process. It provides a centralized repository for managing lease agreements and transaction records, ensuring their easy access and organization. Lease contract - the main lease document containing the rental asset/s and its consumables, if such are applicable; it also includes the lease time period negotiated for every rental asset Transaction (Deliver) - a protocol confirming the handover of the rental asset; it contains the start date of the negotiated lease period Transaction (Receive) - a protocol confirming the return of the rental asset; it contains the end date of the negotiated lease period Transaction (Write Off Not Returned) - a protocol confirming that the rental asset has not been returned by the leaser Transaction (Status Report) - a protocol describing the rental assets handed over to a leaser (can be used for inspection). Document flow A typical document flow for leasing out rental assets with consumables goes like this: Lease Contract --> Transaction (Deliver), Transaction (Receive), Sales Order (Rent), Sales Order (Consumable) Upon release, the lease contract will lead to the simultaneous generation of a transaction (deliver) protocol, a transaction (receive) protocol, a sales order accounting for the rent, and a sales order accounting for the consumable(s). Tip Like all other ERP.net modules, Rental allows you to set up a personalized document flow that meets the individual needs of your business or organization. Rent Lease Contracts Navigator This navigator contains all existing lease contract agreements issued for rental assets, including those for consumables, and offers the ability to create new ones. It is also equipped with a handful of filtering capabilities designed to speed up the process of extracting information in a convenient and systematized way. Note When creating a lease contract, you can include as many rental assets in it as needed, and additionally fill out necessary data for each. Transactions Navigator Gives access to all protocols following or associated with a lease contract. Like the Lease Contracts Navigator, it includes useful filtering capabilities through which you can quickly and easily summarize protocol data in a convenient format. Functions This section includes tools that facilitate the day-to-day management of lease activities. It offers functionalities that help you stay on track with key dates and schedules. Calendar The Calendar provides a quick overview of the occupancy of all rental assets for which there is a lease contract. It also shows: the lessees to which the assets were leased from when the assets have been leased and until when the status of the current lease contract agreement they are part of Reports Rental allows you to generate comprehensive reports summarizing your leasing activities. These include monitoring the status of assets, tracking lease contract details, and reviewing transaction history. Assets status report Provides a detailed overview of the state of all assets, revealing their current occupancy as well as the current date(s) on which they are available to lease. These dates can change based on the lease contracts a rental asset is part of, but this is always reflected by the report. You can also see the last date of the final lease contract a rental asset is currently part of. After that date, the asset will be completely available to lease and the report will not feature any occupancy periods. Lease Contracts – Lines Breaks down each lease contract into its lines, giving insights into contract terms and conditions. Transactions – Lines Contains detailed records of all transactions, ensuring transparency and accountability in rental asset management. Lease Contracts - Lines – Consumables Focuses on the consumables purchased with rental assets. Definitions The Definitions portion of Rental provides detailed information about all rentable assets, their classifications and consumables. It's here, for instance, that you can add new asset types and groups necessary for the creation of the rental asset itself. Note Certain definitions can also be created during the process of filling out the lease contract. All the information you provide for a rental asset in advance of creating a lease contract will be automatically added in that contract's lines when you select the respective rental asset. Rental Assets This is where rental assets are created and stored. Each has a code and a name and must first be defined a group with a type. It is necessary to associate it with an existing sales product for which a sales order will later be issued. You can also specify additional information for the rental asset, including tying it to a fixed asset. Asset Types Defines the various rental asset types which need to be tied to a rental asset group. Asset Groups Categorizes rental assets into hierarchies of larger groups. Assets – Consumables This is where consumables are created and information for existing ones can be previewed. Each consumable has a code and a name and must be defined a product with a certain quantity. One or more quantities of a particular consumable are always tied to one rental asset a time. Asset Types – Consumables Defines the different types of consumable items related to rental assets. Settings The Settings portion of Rental allows you to define or change individual properties and attributes of various asset types. This includes different user characteristics and ensures a more custom approach to how you structure your rental assets. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/applications/rental/time-period-types.html": {
    "href": "modules/applications/rental/time-period-types.html",
    "title": "Time period types | ERP.net Tech Docs",
    "summary": "Time period types When defining a rental asset, you can specify one of four time period types for it to determine the unit by which the periods of renting this asset will be measured. Clicking on the Time Period Type field expands it into a dropdown menu with the following options: Options Full Days Calculates the total number of complete days a rental asset is used, including the specified start and end date. It does not consider the receive and delivery hours specified in the respective Receive and Delivery transactions. 24-Hour Periods Calculates all started 24-hour periods, taking into account the receive and delivery times specified in the respective transactions. If no protocols are generated in addition to the contract, it functions like the Full Days setting. Overnight Stays Calculates the number of nights, or how many times the date in a specified period changes. Months Calculates the number of months full calendar months, taking into account months with 28, 29, 30 and 31 days. It is ideal for long-term rentals, providing an easy way to calculate monthly rental periods. Changing the Time Period Type Each rental asset you add to a lease contract will assume its default time period type value assigned during its definition. This value will be automatically reflected in the lease contract line the rental asset is added to. However, you can always change it at any point prior to releasing the document. Note The time period type of a rental asset specified in the lease contract lines is prioritised over the one provided in its definition. Number of periods Based on the Start and End date of the lease, as well as the Time Period Type specified for the asset, an additional Number of Periods field is automatically calculated. It reveals how many full days, 24-hour periods, overnight stays, or months the asset will be leased for. This automatic calculation applies for the lease contracts lines containing the respective rental asset(s), as well as for the lines of subsequently generated transaction protocols of type \"Receive\" and \"Write Off Not Returned\". Note The Number of Periods for a Receive transaction will be calculated only after the previously generated Deliver transaction from the same document flow is set to Released. In addition, once a lease contract is generated, the subsequently generated sales order accounting for the rent will base its Quantity field on the calculcated Number of Periods field. Warning If you modify the rental asset, as well as the Start and/or End date fields for a Lease contract, a Receive transaction, or a Write Off Not Returned transaction, the respective documents from the document flow will be re-generated, and the value of the Number of Periods field will be re-calculated. Examples for calculating Number of Periods in Lease contract lines The following examples show how the Number of Periods field is calculcated in the lease contract lines. Keep in mind that the hours for delivering and receiving the rental asset are not taken into account. Full Days Start Date: July 1, 2024 End Date: July 31, 2024 Number of Periods: 31 24-Hour Periods Start Date: July 1, 2024 End Date: July 31, 2024 Number of Periods: 31 Overnight Stays Start Date: July 1, 2024 End Date: July 31, 2024 Number of Periods: 30 Months Start Date: February 1, 2024 End Date: September 1, 2024 Number of Periods: 7 Examples for calculating Number of Periods in Receive transaction lines The following examples show how the Number of Periods field is calculcated in the receive transaction lines. Keep in mind that the hours for handing over and receiving the rental asset are taken into account. Full Days Start Date: July 1, 2024, 10:00 AM End Date: July 31, 2024, 9:15 AM Number of Periods: 31 OR Start Date: July 1, 2024, 10:00 AM End Date: July 31, 2024, 6:30 PM Number of Periods: 31 24-Hour Periods Start Date: July 1, 2024, 10:00 АM End Date: July 31, 2024, 9:15 АM Number of Periods: 30 OR Start Date: July 1, 2024, 10:00 AM End Date: July 31, 2024, 6:30 PM Number of Periods: 31 Overnight Stays Start Date: July 1, 2024, 10:00 АM End Date: July 31, 2024, 9:15 AM Number of Periods: 30 OR Start Date: July 1, 2024, 10:00 AM End Date: July 31, 2024, 6:30 PM Number of Periods: 30 Months Start Date: February 1, 2024, 10:00 AM End Date: September 1, 2024, 9:15 AM Number of Periods: 7 OR Start Date: February 1, 2024, 10:00 AM End Date: September 1, 2024, 6:30 PM Number of Periods: 7 Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/applications/service/index.html": {
    "href": "modules/applications/service/index.html",
    "title": "Service | ERP.net Tech Docs",
    "summary": "Service Non-agreed services and materials"
  },
  "modules/applications/service/non-agreed-services-and-materials.html": {
    "href": "modules/applications/service/non-agreed-services-and-materials.html",
    "title": "Non agreed services and materials | ERP.net Tech Docs",
    "summary": "Non agreed services and materials When a service activity creates store order, in order to invoice the used materials and the services which are performed, the sales orders have to include the non-agreed quantities of the materials and the services. The rest of the materials and services are covered by the guarantee, which is agreed in the service agreements. The current topic describes the calculation of the non agreed services and materials based on the data in a service activity. The agreed services and materials are listed in the service agreements, in the ServiceAgreementService and ServiceAgreementMaterial tables. After that the quantities which are listed in there are distributed through the service activities. When a service activity is released, what part of the agreed quantities has not been used by the previous service activities is calculated and the result (the remaining quantities) is distributed in the current document (only if the remaining quantities are not greater than the used quantities recorded in the current document). The distributed quantities are recorded in the Distributed Service Agreement Materials and Distributed Service Agreement Services tables. After all, the non-agreed materials and services are calculated by subtracting the quantities from those tables from the quantities in the current service activity. Non agreed materials For each Material line in the current service activity all records from Distributed Service Agreement Materials table which correspond the current line are derived. The amounts from the Agreed Quantity column are summed up (converted to the measurement unit of the material in the service activity line; the values in Agreed Quantity column are in measurement unit of the service agreement) and the sum is subtracted from the quantity in the current line (only if the sum is not greater than the quantity in the current line). This is the calculation: [**non-agreed material quantity**] = if [**Service Activity Material Quantity**] >= [**sum of distributed service agreement materials**] then [**Service Activity Material Quantity**] - [**sum of distributed service agreement materials**] else **0** Example 1: There is a service activity with three lines with materials: line #10, Material #1, 10PCS; line #20, Material #2, 13PCS; line #30, Material #3, 40PCS. Distributed Service Agreement Materials table has the following data: line #20 from the Service Activity, line #70 from Service Agreement #00007, 4PCS; line #20 from the Service Activity, line #30 from Service Agreement #00019, 11PCS; line #30 from the Service Activity, line #10 from Service Agreement #00007, 48KG. Thus, for line #10 from the Service Activity the distributed quantity is 0PCS, for line #20 from the Service Activity the distributed quantity is 15PCS, and if Material #3 has the following dimension: 3KG = 1PCS, than for line #30 the sum is 16 PCS. Thus, the non agreed quantities are calculated s follows: for line #10: [non agreed quantity of the material] = 10PCS - 0PCS = 10PCS; for line #20: [non agreed quantity of the material] = 0PCS (because 13PCS < 15PCS); for line #30: [non agreed quantity of the material] = 40PCS - 16PCS = 24PCS; Non agreed services The services are not invoices directly as they are not products, so to invoice them the information in service invoicing from the service definition is used. So, for each service activity line with service and for each record in service invoicing the following quantity of the product from the service invoicing records, is calculated: [**quantity to invoice**] = [**Service Activity Service Quantity**] * [**ServiceInvoicing.QuantityOfProduct**] / [**ServiceInvoicing.QuantityOfService**] The distributed quantities from the service agreements which correspond the current service line are subtracted from the described above quantity to invoice. But this is performed in two stages as in the service agreements there are two methods to describe agreements for services - one is to agree on a certain number of the service, and the second is to agree on certain number from the product from the service invoicing. Thus the non-agreed quantity of a specific product which invoices a specific service (i.e. a product listed in the Service Invoicing table of the service definition), happens by the following two formulas: At first, what quantity is not agreed by service agreements is calculated. This happens as all distributed quantities for the specified line listed in the Distributed Service Agreement Services table (but only records which are on specific service agreements where the service attribute is selected and service product attribute is null) are subtracted from the quantity from the Service Activity line. The following temporary value is calculated: [**preliminary quantity 1**] = if [**Service Activity Service Quantity**] >= [**sum of distributed service agreement services**] then [**Service Activity Service Quantity**] - [**sum of distributed service agreement services**] else **0** Using this preliminary quantity 1 for each product in service invoicing in the service definition a preliminary quantity for invoice is calculated: [**preliminary quantity** **2**] = [**preliminary quantity** **1**] * [**ServiceInvoicing.QuantityOfProduct**] / [**ServiceInvoicing.QuantityOfService**] And at the end, from the sum of distributed service agreement services which are for the same product and for which we have calculated the preliminary quantity, the calculated preliminary quantity 2 is subtracted. But only for quantities which are based on Service Agreements lines and which have empty service attribute and not null product attribute. Also, the distributed quantities are always converted to the measurement unit which is selected in the Service Invoicing record (as the measurement unit in the service agreement may be different). So: [**non agreed quantity of a product for invoicing**] = if [**preliminary quantity** **2**] >= [**sum of the distributed quantities of the product from Service Agreements**] then [**preliminary quantity** **2**] - [**sum of the distributed quantities of the product from Service Agreements**] else **0** Example 2: Lets have Service #1 with the following Service Invoicing data: 1 PCS of Service = 2 PCS of Product #1; 2 PCS of Service = 3 PCS of Product #2. And for Service #2, the invoicing products are: 1 PCS of Service= 4 PCS of Product #1; 1 PCS of Service= 10 PCS of Product #3. There is Service Activity with the following services: line #10, Service #1, 6PCS; line #20, Service #2, 8PCS. Distributed Service Agreement Services table contains the following: line #10 of the Service Activity, line #40 (with Service #1) from Service Agreement #00023, 2PCS; line #20 of the Service Activity, line #50 with Service #2) from Service Agreement #00023, 3PCS; line #20 of the Service Activity, line #30 (with Service Product #3) from Service Agreement #00037, 78KG. So the first preliminary quantity is calculated as follows: for line #10: [preliminary quantity 1] = 6PCS - 2PCS = 4PCS; for line #20: [preliminary quantity 1] = 8PCS - 3PCS = 5PCS. Then the preliminary quantity for invoicing is: for line #10 and Product #1: [preliminary quantity 2] = 4PCS * 2PCS / 1PCS = 8PCS; for line #10 and Product #2: [preliminary quantity 2] = 4PCS * 3PCS / 2PCS = 6PCS; for line #20 and Product #1: [preliminary quantity 2] = 5PCS * 4PCS / 1PCS = 20PCS; for line #20 and Product #3: [preliminary quantity 2] = 5PCS * 10PCS / 1PCS = 50PCS. And at the end, if the dimensions of Product #3 are 3KG = 1PCS, the final calculations are: for line #10 and Product #1: [non agreed quantity] = 8PCS - 0PCS = 8PCS; for line #10 and Product #2: [non agreed quantity] = 6PCS - 0PCS = 6PCS; for line #20 and Product #1: [non agreed quantity] = 20PCS - 0PCS = 20PCS; for line #20 and Product #3: [non agreed quantity] = 50PCS - 26PCS = 34PCS."
  },
  "modules/community/case-management.html": {
    "href": "modules/community/case-management.html",
    "title": "Case Management | ERP.net Tech Docs",
    "summary": "Case Management This module deals with the management of cases. It resembles both ticket management (like ZenDesk) and case management (like Jira and FogBugz). Currently under development."
  },
  "modules/community/digital-marketplace.html": {
    "href": "modules/community/digital-marketplace.html",
    "title": "Digital marketplace | ERP.net Tech Docs",
    "summary": "Digital marketplace A digital marketplace is where developers publish apps for the end-users. When an app is activated (installed) on a user device, it is granted certain permissions to access the device resources. The marketplace can, but not necessarily, include functionality for downloading and embedding the app on the device. It resembles the way iOS and Android provide apps and other content with access to your phone. The main entities are: Marketplace - a place where developers publish and end-users obtain (install) apps. Each marketplace operates only for a single device type (class). Marketplace app - a third-party app listed on a marketplace and published by an app developer. It manifests a set of permissions, which it might require in order to function. An app can have multiple media resources attached to it (through its data object). They can be used to display media to the end-user. Marketplace app permission - permission which an app might require. There are pre-installed permissions required before installation. Some permissions might be post-install and optional. Each app permission is of Marketplace Permission Type. Marketplace app review - a review and star rating coming from a user who has installed the app. Uses the Social Interactions module for comments and reactions. Marketplace app license type - a type of license which can be provided for an installed instance of an app. Some license types allow only a 0 or 1 license qty, while others allow multiple licenses (for example, for max users/max GB or any other max limit of the license). Marketplace permission type - permission which can be requested/granted to an installed application. Each permission type has a permission key - a unique string identifying the permission. User device - a device under the user's control. It can be a phone, computer, database, service, user account (in a social network) or anything else which allows secure access for apps to its resources. User device app - an app from a marketplace installed and granted permission to access a device. User device app permission - permission granted to a specific app for a specific user device. User device app license - a license granted to a user using an app on the device. The app can request its license data through an API call. It is up to the app to limit its usage, based on license information. App developer - a developer account. This is a third-party organization developing applications for a marketplace. Each marketplace has a different set of approved app developers. App developer users - user accounts which have access to an App Developer account. Users can be admins, developers (editing app resources) and moderators (interacting with app users). The user (and his role) can be for the whole developer account, or just for a single app. Note The digital marketplace is currently under development."
  },
  "modules/community/index.html": {
    "href": "modules/community/index.html",
    "title": "Community | ERP.net Tech Docs",
    "summary": "Community Community management is the management of the community of a company. This includes all sites, forums, ticketing and support systems, etc. as well as social interaction between all internal and external users. Case Management Digital marketplace Notification settings Notifications Social comments Social group members Social groups Social interactions Social posts Social reactions"
  },
  "modules/community/social-interactions/index.html": {
    "href": "modules/community/social-interactions/index.html",
    "title": "Social interactions | ERP.net Tech Docs",
    "summary": "Social interactions This module represents the social interactions between internal and external users, just like in social networks like Facebook. The users are joined to social groups. Each social post is made in a group. There is no personal space like in Facebook. Each post can contain social comments, replies and reactions. These can also be attached to any data object in the system. Notifications are special data records that contain information about a single notification for a user. Notification settings allow users to specify which notifications they want to receive. They can also specify whether the notifications should be sent in-app, by mail or by sms. For more information, refer to: Notification settings Notifications Social comments Social group members Social groups Social posts Social reactions"
  },
  "modules/community/social-interactions/notifications/index.html": {
    "href": "modules/community/social-interactions/notifications/index.html",
    "title": "Notifications | ERP.net Tech Docs",
    "summary": "Notifications Notification is a single notification of one user for one event. The event can contain multiple references to objects, definitions, etc. Although notification is an entity in the Social interactions module, a notification can be raised by any module in the system. A notification is most often \"transmitted\" by a real-time event. Each notification is persistent. It lives in the database (i.e. it has a corresponding record). Notifications MAY specify a data object. Note If a notification specifies a data object, this means that it's related to this data object. However, this attribute is not required and can be null. Notification interaction Often, the user can interact with a notification. The most common example when the notification appears as a toast- the user can click on it. In this scenario, if the notification is bound to a data object, it will be opened. A simple example: You're following a specific document. E.g., an offer. Someone writes a comment in its corresponding chatter control. If you're online, you'll receive a notification as a toast. If you click on the notification- you'll be navigated to the document (i.e. the offer). Note When a notification is displayed to a user, it is marked as read. This does not guarantee that the user has read or understood it. Note The UI in some apps might require the user to actually click on the notification in order to mark it as read. Notification classes Each notification has a class which specifies the type of the notification. Additionally, all notification classes are grouped for better classification. Also, most of the notifications are created automatically via business rules when the corresponding event occurs (e.g. when someone writes a comment). Notification class Group Business rule Description NT_DOC_STATE_IMPLICIT Document R33718 Document- Notify All Implicit Followers If a document changes its state and you're following an entity, related to this document (e.g. its customer, its document type, etc) you'll receive a notification. NT_SOC_REPLY Social R33428 SocialComment- Notify User Comment Replied There was a reply to your post or comment. NT_SOC_NEW_POST Social - New post in a group, in which you're a member. NT_SOC_MENTION Social R32943 SocialComment- Notify The Mentioned User You're mentioned in a post or comment. NT_SOC_REACTION Social R33427 SocialReaction- Notify User Comment Reaction There was a reaction to your post or comment. NT_NEW_COMMUNITY_USER Social R33153 Security Users- Notify Admins On Community User Creation New external (community) user '{Login}' is created. NT_SOC_GROUP_MEMBER_ADDED Social R37141 Social Group- Notify Group Members Changed You were added to the group '{Group.Name}'. NT_SOC_GROUP_MEMBER_REMOVED Social R37141 Social Group- Notify Group Members Changed You were removed from the group '{Group.Name}'. NT_WM_QTY_BELOW_MIN WMS - In WMS, when the qty in a tracked bin falls below the minimum. NT_SOC_NEW_COMMENT Social R33417 SocialComment- Notify All Object Followers New comment to an object you are following. NT_ALL_UPDATE All Entities R34361 All Entities - Notify All Object Followers Upon Update Create notification for all followers of each updated object. NT_ACT_REMINDER Activity Reminders - Activity reminder, within the next 15 minutes at the latest. NT_TODO_REMINDER Todo Reminders - Todo task reminder, within the next 15 minutes at the latest. NT_DOC_ASSIGNMENT Document R35922 Document - Notify Assigned To User Upon Assignment Notify user when a document has been assigned to them. NT_DOC_STATE_ASSIGN Document R35927 Document - Notify Assigned To User For State Change Notify the assigned user when the document state is changed. NT_DOC_UPDATE_ASSIGN Document R35940 Document - Notify Assigned To User For Update Notify the assigned user when the document is edited. NT_TODO_ASSIGNMENT To Do R35962 Task - Notify Assigned To User Upon Assignment Notify the assigned user when the To Do has been assigned to them. NT_TODO_UPDATE_ASSIGN To Do R35951 Task - Notify Assigned To User For Update Notify the assigned user when the To Do is edited. NT_LEAD_ASSIGNMENT Lead R35980 Lead - Notify Assigned To Sales Person Upon Assignment Notify the assigned sales person's user when the Lead has been assigned to them. NT_LEAD_UPDATE_ASSIGN Lead R35958 Lead - Notify Assigned To Sales Person For Update Notify the assigned sales person's user when the Lead is edited. NT_CASE_ASSIGNMENT Case R38379 Case - Notify Assigned To User On Assignment Notify the assigned user when the Case has been assigned to them. NT_CASE_UPDATE_ASSIGN Case R38389 Case - Notify Assigned To User For Update Notify the assigned user when the Case is edited. NT_ACTPARTICIPANTS_ASSIGN Activity R36471 Activity - Notify Activity Participants Upon Assignment Notify users when they are assigned as participants in the Activity. NT_COMPILATION_COMPLETION Compilation R36563 Compilation - Notify On Completion Notify the user who initiated the compilation when the compilation is finished. I don't care about notifications You can always mute the notification classes you're not interested in. Or you can mute all of them. This way you won't be notified of anything you don't want. For more information see our separate topic Notification settings Create notifications programmatically It's possible to create notifications programmatically via Domain API. For more information, check the dev topic https://docs.erp.net/dev/domain-api/common-tasks/create-notification.html"
  },
  "modules/community/social-interactions/notifications/settings.html": {
    "href": "modules/community/social-interactions/notifications/settings.html",
    "title": "Notification settings | ERP.net Tech Docs",
    "summary": "Notification settings These settings allow users to specify which notifications they want to receive. They can also specify whether the notifications should be sent in-app, by mail or by sms. A setting is for a single user, for a single notification class. Only whole notification classes can be set up. Currently, there is no support for muting specific notification types. A setting determines whether the user should receive: Notification - these are the in-app Notifications. Email - the user should receive email on their primary email. Sms - the user should receive SMS on their primary phone number. For more information about notification types and classes, see Notifications."
  },
  "modules/community/social-interactions/social-comments.html": {
    "href": "modules/community/social-interactions/social-comments.html",
    "title": "Social comments | ERP.net Tech Docs",
    "summary": "Social comments This represents a comment to a data object within the system. Social posts are data objects. This is the most common object to which comments can be added. Besides social posts, there are other objects which are frequent targets by comments: Marketplace products Documents Definitions Settings However, comments can be added to any data object within the system. Important attributes: Data object - the data object being commented. Reply to comment - the comment to which the current comment replies. If empty, the comment is a root comment to the data object. Тhe Data object always points to the root data object being commented (it does not point to a data object for a comment). Comment text - comment contents in clear text. Note It is planned that text will be allowed to contain some mark-down constructs in the future. Creation time Utc - automatically set by the server to the time of initial creation of the comment."
  },
  "modules/community/social-interactions/social-group-members.html": {
    "href": "modules/community/social-interactions/social-group-members.html",
    "title": "Social group members | ERP.net Tech Docs",
    "summary": "Social group members This entity represents one membership of a user in a group. Important attributes: Join time Utc - automatically set by the server."
  },
  "modules/community/social-interactions/social-groups.html": {
    "href": "modules/community/social-interactions/social-groups.html",
    "title": "Social groups | ERP.net Tech Docs",
    "summary": "Social groups The social groups are the primary areas (circles) where social interactions occur. Social groups have resemblance to Facebook groups. Unlike FB groups, social posts are always grouped. There is no personal space, unless a personal group is defined. Important attributes: Code - this is the unique code of the group. It is also used as a slug which forms part of the URL for the group, posts, etc. Name - the universal name of the group."
  },
  "modules/community/social-interactions/social-posts.html": {
    "href": "modules/community/social-interactions/social-posts.html",
    "title": "Social posts | ERP.net Tech Docs",
    "summary": "Social posts This represents a single social post. It resembles a Facebook post. Important attributes: Post text - this is a single-language text, containing the contents of the post in clear text. Note It is planned that the text will be allowed to contain some mark-down constructs in the future. Creation time Utc - automatically set by the server to the time of the initial creation of the post. Last interaction Utc - set by the server. The last interaction time with the post, including comments, replies, and likes. Тhis is updated each time a related comment, reply or reaction is added/updated."
  },
  "modules/community/social-interactions/social-reactions.html": {
    "href": "modules/community/social-interactions/social-reactions.html",
    "title": "Social reactions | ERP.net Tech Docs",
    "summary": "Social reactions Social reactions represent user reactions to social content. They resemble Facebook reactions. Important attributes: Data object - the root data object. A reaction can be attached to the data object itself, or to a comment of the data object. In any case, the data object contains the root data object, just like the comments. Social comment - when not null, it contains a comment to the same Data Object to which the reaction is attached. Reaction type - one of: LIKE LOVE HAHA WOW SAD ANGRY Creation time Utc - automatically set by the server to the time of initial creation of the reaction."
  },
  "modules/crm/clientcenter/grid-control.html": {
    "href": "modules/crm/clientcenter/grid-control.html",
    "title": "Grid control | ERP.net Tech Docs",
    "summary": "Grid control The Grid control comprises a collection of tools built-in within Client Center navigators. It offers functionalities like sorting, filtering, and summarizing information, which are collectively responsible for displaying and organizing data in a more intuitive, use-case-specific way. Total summary The Total summary option automatically calculates the Count (number) of documents and the total Sum of their amounts across all pages of a given navigator. Information is displayed at the bottom of the table, under the Document No and Amount columns, respectively. Filter and search Using the Column filter and the Search Box, you can easily filter your existing documents, as well as search for and find specific ones. Column filter The Column filter is accessible through the funnel button at the far-right of a column's title. Once you expand it, you can decide exactly how that particular column should filter the navigator's contents. For instance, you may filter the Date column to display documents only from a specific month of a year, or the Type name column to show records only from a given type. Search Box The Search Box allows you to input a word, letter, or number and then see items containing that input in any of the navigator's columns. Grouping and summarizing You can group a navigator's contents by their column headers in order to organize them in a more specific tree-like hierarchical structure. With the Group footer summary option, you can also see summarized information for each group, which includes counts for document numbers and sums for document amounts. To group, simply drag and drop a column header into the ”Drag a column header here to group by that column” row above the table. You can also group by multiple columns by dragging and dropping additional column headers next to the first one. Existing records will first be grouped by the initial column, and then by each subsequent one you include. Column chooser The Column Chooser option allows you to decide which columns to display in a navigator, as well as determine their order. To access it, click on the blue icon above the Search Box. Choose which columns will be displayed by checking the ones that you want to show. Save and restore layout However you modify your Client Center navigator layout, your last preferred view will be saved and restored the next time you log in, ensuring a personalized and consistent experience. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/crm/clientcenter/how-to/apply-platform-settings.html": {
    "href": "modules/crm/clientcenter/how-to/apply-platform-settings.html",
    "title": "How to apply platform settings | ERP.net Tech Docs",
    "summary": "How to apply platform settings Like all ERP websites, the Client Center can have its settings changed on an individual level. This includes specific visual and functional modifications. Configuration capabilities Below is a list of settings you can apply to the Client Center: The ability to reveal or hide the New Order button, allowing or restricting users to create new orders. By default, this button is hidden so as to prevent potential information leaks. You need to enable the functionality manually only when that’s necessary. The ability to define the sales order document type for new orders in the Client Center. You must input a valid SalesOrder.DocumentType ID. This could be quite helpful for separating orders made in the Client Center from those made in other modules. JSON format definition Client Center settings must be configured in a key-value pair JSON format. Prerequisites You need to navigate to your website's main environment, access the Client Center's details, and enter the website's settings. Editing mode must be active for all website-related fields. If the Settings field is not in view, use the Show/hide field button to toggle its visibility. Step-by-step process Inside the Settings field, input the following: { \"NewOrderDocumentType\": \"DocumentType.Id\", \"IsNewOrderEnabled\": true/false, \"IsOrdersEnabled\": true/false } where NewOrderDocumentType takes the valid ID value of a new (sales) order. IsNewOrderEnabled defines if the button for order creation will be shown or hidden to the users when they log into the system (true meaning visible, false meaning restricted). IsOrdersEnabled determines whether the \"Orders\" section will be present in the Client center. (true meaning visible, false meaning restricted). Apply the new settings. Troubleshooting Depending on how you define the settings, you can encounter the following scenarios: Both settings are set: \"NewOrderDocumentType\": \"07c7ef2f-abc1-47d9-9d40-bc1e0acd1e7c\", \"IsNewOrderEnabled\": true This results in the menu button allowing for the creation of a new order to be shown, and the document type to be set as a sales order. If the ID doesn’t match any document of type Sales order, you’ll get an error: 008 - Not well formatted json string You need to erase all inputted values, save your progress, refresh the website, and insert the correct values. Only one of the settings is set: \"IsNewOrderEnabled\": true Here, the system will generate another error: 009 – NewOrderDocumentType is set, but DocumentType is null No settings are set: In this scenario, both settings assume two values by default: \"NewOrderDocumentType\": \"CRM_SALES_ORDER.Id\", \"IsNewOrderEnabled\": false The button used for creating a new order will not be shown. If you try to use a link leading to the direct creation of an order, you’ll see the following message: You are not authorized to view this page. For more information, see the reference. Automatic tracking Whenever you apply or change settings for the Client Center, they’re tracked by the system in real-time and are reflected immediately. User-level security By default, the Client Center uses a system user known as System-Application-User. This user has rights to apply or change settings only in accordance with the normal functioning of the website. For better security, another more restricted user can be used. By default, the System-Application-User has System rights, but reflects used licenses as well. It’s automatically assigned whenever a new website is created and whenever a trusted application is added through the UI. Error visualization When you encounter a problem in the platform, a relevant, easy-to-read and interactive error message will be shown explaining its nature. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/crm/clientcenter/how-to/create-new-order.html": {
    "href": "modules/crm/clientcenter/how-to/create-new-order.html",
    "title": "How to create a new order | ERP.net Tech Docs",
    "summary": "How to create a new order To create an order in the Client Center, you need to have this feature enabled manually. Learn how to apply platform settings if you haven't already done that. As soon as you get access to the New Order functionality, you need to obtain all the necessary product codes to complete your order. Step-by-step process Click on the New Order button in the Client Center menu. Enter the respective product code(s) into the Product code field. Apply a quantity value if your order contains multiple instances of the same product. Click the plus button to add your product(s) in the order. Proceed to finalize the order by clicking the Order button. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/crm/clientcenter/how-to/define-a-new-cc.html": {
    "href": "modules/crm/clientcenter/how-to/define-a-new-cc.html",
    "title": "How to define a website of type Client Center | ERP.net Tech Docs",
    "summary": "How to define a website of type Client Center This article provides a step-by-step guide on creating a Client Center website through ERP.net. Prerequisites To define a website of Client Center type, navigate to the Web Sites panel within the Core section of the Setup module. Note You can observe and restart all sites through the Instance Manager. Website definition Upon accessing the New Web Site form, you need to enter relevant data into the provided fields. The only mandatory field is Web Site Type. In this case, it should be set to Client Center. Make sure you've selected the appropriate Enterprise Company. Additionally, you may change the Relative Url of the website, which is set to \"cc\" by default. Note You should define a distinct site with a unique Relative URL or Host for each Enterprise Company. It's necessary to create a trusted application to ensure the security and integrity of the new website. To do so, click on Run, select the Create/Update Trusted Application option, and confirm with OK. Once you complete this step, hit Save and reload. The new Client Center website will be created and you can access its internal application details through the form. If you've passed all the steps successfully, you may proceed to define users who can access the Client Center. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/crm/clientcenter/how-to/download-attachments.html": {
    "href": "modules/crm/clientcenter/how-to/download-attachments.html",
    "title": "How to download attached files from an invoice | ERP.net Tech Docs",
    "summary": "How to download attached files from an invoice This article provides a step-by-step guide on downloading attached files from an invoice through the Client Center. Prerequisites To be able to view and download file attachments from an invoice in the Client Center, you must configure its Access Permissions field through the Files panel of your ERP.net platform instance. Simply navigate to the respective invoice, expand the Files panel, open its Details and set the value of the Access Permissions field to Internal users + external users. This must be applied for every invoice attachment you wish to see and download from within your Client Center website. Step-by-step process in the Client Center Navigate to the Invoices panel of the Client Center menu. Open an invoice with attachments by clicking on its respective button. The invoice’s attachments will appear in a dedicated Files section. You can see their names, file extensions, and size. Click on a desired file once to immediately download and save it on your device. Warning File attachments whose Access Permission field is not set to Internal users + external users will not appear in the Files section. If none of the invoice’s attachments have this setting configured, the Files section will not appear at all. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/crm/clientcenter/how-to/index.html": {
    "href": "modules/crm/clientcenter/how-to/index.html",
    "title": "How To | ERP.net Tech Docs",
    "summary": "How To Here, you can find step-by-step guides that help you better understand processes within the Client Center. Define a website of type Client Center Define a user of a Client Center Apply platform settings Create new order Download attached files from an invoice"
  },
  "modules/crm/clientcenter/how-to/pictures/index.html": {
    "href": "modules/crm/clientcenter/how-to/pictures/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/crm/clientcenter/how-to/setup-a-new-user-account.html": {
    "href": "modules/crm/clientcenter/how-to/setup-a-new-user-account.html",
    "title": "How to define a user of a Client Center | ERP.net Tech Docs",
    "summary": "How to define a user of a Client Center This article provides a step-by-step guide on defining a new user and configuring their access to a Client Center website. If you haven't created such a website already, please refer to this guide. Prerequisites Before a user can be granted access to a Client Center by an administrator, they must first have issued a request for a local account. Required fields are Е-mail, Full Name, and Password. Set up a user account Once a customer has sent a request for an account, they will appear as an External Community User which you can begin to configure. Navigate to the Users panel within the Security section of the Setup module. Upon accessing the navigator, locate the user account and click on the Edit button located to the left of its Login details. Assign a person to the user. If such hasn't already been registered on the platform, you can create a new one on the spot. Either right-click on the Person field or click the three-dot button. In both cases, this will expand a dropdown menu where you need to select Create new. You will be redirected to a separate form for the creation of a new person. There are three critical fields: First Name, Last Name and Parent Party. Click on Save and reload to finish creating the new person. You will be brought back to the user definition form. Click on Save and reload again to apply all settings. Make sure that the Parent Party of the Person (the one in which they are employed) is a customer of the current Enterprise Company. To do so, open it from the Person form and locate its Customers panel. If it's not visible, add it through the Customize form option. In the Customers panel, verify that two fields are filled: Enterprise Company - the Parent Party is a customer of this company, for which the Client Center is created. Serviced By Enterprise Company Location - the respective Enterprise Company must be serviced by a particular location. Click on Save and reload to apply your changes. If any of the user configuration settings are not properly applied, a respective error message will be shown. If you've passed all the steps successfully, you may proceed to apply platform settings. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/crm/clientcenter/index.html": {
    "href": "modules/crm/clientcenter/index.html",
    "title": "Client Center | ERP.net Tech Docs",
    "summary": "Client Center The Client Center allows Erp.Net clients to assist their own clients by allowing them to chat with Customer Support, review due payments, access and download invoices, and create sales orders. It’s best used to provide faster support and increase speed of new orders. Currently, Client Center platforms are more suitable for businesses rather than individual users. You can build and host a CC instance from your global website environment, and access it using a custom relative url. Features and structure Within the Client Center, users with appropriate permissions can see and interact with four different panels. Each Client Center panel works with accurate and simplified data to implement a pleasant and up-to-date platform experience. Whether they use the shortcuts or the expandable menu on the left side of the screen, clients are able to look at all of their due payments, sales orders and invoices on-demand. Panels Home offers a direct communication channel and access to other pages. Using the chat panel, clients can reach out to a representative regarding any issue or question they're having. Due Payments contains a list of your due payments, available to be sorted. Orders contains a list of your current orders, with the ability to preview and sort them. Invoices keeps all of your invoices for completed orders. Note Depending on your business' size and reach, you can create and manage multiple Client Centers. This could be useful for departments dealing with unique sets of tasks and issues, as their customized version of the Client Center will remain completely tailored to the users they’re serving. Creating sales orders The Client Center gives users the ability to create new sales orders with just the click of a button. This feature is disabled by default for security reasons. Access should be granted only when it's necessary. For more information on how to define and set up Client Center, please refer to our step-by-step guides and the reference Actions Users are able to perform a couple of actions from within the Client Center to enhance their experience. Additional columns can be added to provide more information for due payments, past orders and invoices. In the Orders page, already issued sales orders from the Client Center can be cancelled before they're finalized. Generated invoices for any orders can be downloaded and previewed outside of the platform. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/crm/clientcenter/pictures/index.html": {
    "href": "modules/crm/clientcenter/pictures/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/crm/clientcenter/reference.html": {
    "href": "modules/crm/clientcenter/reference.html",
    "title": "Reference | ERP.net Tech Docs",
    "summary": "Reference This article contains reference points for specific procedures, concepts and error codes within the Client Center. IsNewOrderEnabled settings By default, the ability to preview and create new orders in the Client Center is disabled. To enable it, you have to apply JSON settings in the website's definition. Enter a value for the Settings field and restart the website using the Instance manager: {\"NewOrderDocumentType\": \"DocumentType.Id\",\"IsNewOrderEnabled\": true} Note DocumentType.EntityName must be equal to \"SalesOrders\" For example: {\"NewOrderDocumentType\": \"85493adb-ac4e-4b3c-89bc-590c4b22404c\",\"IsNewOrderEnabled\": true} If only one of the JSON settings is set or the ID doesn't match any sales order document type, an error exception code CC008 or CC009 will be displayed. IsOrdersEnabled settings By default, the Orders section of the Client Center is enabled. To disable it, you have to apply JSON settings in the website's definition. Enter a value for the Settings field and restart the website using the Instance manager: {\"IsOrdersEnabled\": false} If \"IsOrdersEnabled\" is not present in the settings, the Orders section will still be visible. HideLines settings: Lines are visible by default in both the Invoices and the Orders sections of the Client Center. To hide them, you have to apply JSON settings in the website's definition. Enter the following value for the Settings field and restart the website using the Instance Manager: {\"HideLines\": true} If \"HideLines\" is not present in the settings, lines will remain visible in both Invoices and Orders. Error exception codes CC002 The logged user is not defined as a Person. Please define Person object for this user to use the Client Center. CC003 Parent party of the logged user is empty. Please set parent party to the company on behalf of which the user is entering Client Center. CC004 The parent party is not defined as a customer. It should be customer in order to use Client Center. CC005 The Client Center is not setup correctly - Enterprise Company is not set in the definition of the web site. Please set Enterprise company accordingly. CC006 The parent party does not have customer agreement for the enterprise company of the Client Center. Create customer agreement for this party. CC007 ServicedByEnterpriseCompanyLocation is null. Please set ServicedByEnterpriseCompanyLocation to the asigned ParentParty.Customer for this user. CC008 Not well formatted JSON string. CC009 Incorrect setup of Client Center - the option NewOrderDocumentType is set, but DocumentType is null."
  },
  "modules/crm/contacts/index.html": {
    "href": "modules/crm/contacts/index.html",
    "title": "CRM Contacts and tasks | ERP.net Tech Docs",
    "summary": "CRM Contacts and tasks The Contacts and tasks module is used to manage parties and calendars. When used as part of the sales process, they can initiate the sales process flow: Activity → Opportunity → Offer → Sales order → Invoice order → Invoice Activities The activities are like calendar appointments on steroids. Activities Have related party reference, allowing to sort activities by party. Allow attachments of files. Support questionaries (through the use of user defined data attributes) And much more. Activities can be used to automatically create sales opportunities in the Presales module."
  },
  "modules/crm/index.html": {
    "href": "modules/crm/index.html",
    "title": "Customer relationship management (CRM) subsystem | ERP.net Tech Docs",
    "summary": "Customer relationship management (CRM) subsystem The CRM subsystem in ERP.net is used to manage customer relationships and other front-office activities of a company. General concepts and processes The main process in the CRM subsystem is: Activity → Opportunity → Offer → Sales order → Invoice order → Invoice Activity - generic activity, related to a party. Includes support for calendar appointments, reminders, questionnaires, etc. Can be used to represent appointments, scheduled meetings, visits, contracts and just about any generic document. Opportunity - sales opportunity, with expected revenue and probability. It does not have detail line items. Offer - sales offer (quote), with line items. It allows optional selection of some of the items, which the customer has accepted. Sales order - sales order from the customer. The main sales document. All documents before it are optional. The sales order initiates the logistics and financial processes, related to the sale. Invoice order - an order to issue an invoice. This is an internal document, which is used to track the invoices, which we have to issue. Invoice - legal and financial document, finalizing the sales process. Note The above diagram shows only the CRM part of the whole process. The full process involves many different modules of the ERP system. Modules There are many modules in the CRM subsystem. They are used to manage the different aspects of the CRM processes: Contacts and tasks - calendar appointments, party definitions, etc. Pre-sales - Opportunities management, quotation, etc. Sales - Sales orders, customers, etc. Invoicing - Invoicing process management, invoices and BI. Marketing - Marketing campaigns, activities, distribution channels, etc. Common concepts - Concepts related to pricing, line discount determination, etc. Client Center - a single platform to engage with customers POS - Manage point-of-sale activities in physical stores. Distribution - field sales, sales person targets management, etc. Product Configuration - create products based on specs for job shops (made-to-order and engineer-to-order environments). Products - manage products master data - products and product measurements, codes, variants, channel, pictures, groups, etc."
  },
  "modules/crm/invoicing/index.html": {
    "href": "modules/crm/invoicing/index.html",
    "title": "Invoicing - Invoicing process management, invoices and BI. | ERP.net Tech Docs",
    "summary": "Invoicing - Invoicing process management, invoices and BI."
  },
  "modules/crm/invoicing/invoicing-concepts/determine-payment-due-date-in-invoices.html": {
    "href": "modules/crm/invoicing/invoicing-concepts/determine-payment-due-date-in-invoices.html",
    "title": "Determine payment due date in invoices | ERP.net Tech Docs",
    "summary": "Determine payment due date in invoices Invoices in ERP.net are entered manually or they are created based on invoice orders. Determine payment due date when entering an invoice manually In this case the Payment Due Date is determined in the standard way - based on the data in the invoice customer definition. This is a default value and it can be changed by the user. Example 1: The user enters an invoice with a document date 15 Mar 2020. The customer definition says that its Default Payment Term Days is 7 days. Then the Payment Due Date in the invoice is 22 Mar 2020. Determine payment due date when entering an invoice based on invoice orders There is a Payment Due Date in the invoice orders. When the user enters Invoices based on invoice orders, the Payment Due Date is copied from the invoice order or from the Document Date of the invoice order (depending on which date is greater). This is also valid in the cases when the invoice is created with today's date. In this case the payment term is kept (as days count) as it is in the invoice order. Example 2: There is a sales order with Document Date 02 Nov 2020 and Payment Due Date 09 Nov 2020 (so the payment term is 7 days). These dates are copied to the invoice order from the sales order. Then in the client definition the Default Payment Term Days is changed from 7 days to 14 days. The user creates invoice with Document Date 22 Nov 2020 . The Payment Due Date in the invoice is 29 Nov 2020 (i.e. keeping the term from the Invoice Order), in spite of the difference in the terms according to the customer's definition. Example 3: The same case as in Example 2 , except for the Document Date of the invoice order. In the current example it is 11 Nov 2020 (this is possible if the invoice order is generated from shipments). Then when creating the invoice. Payment Due Date is considered to be 11 Nov 2020 (the greater date), which means that the payment term is actually 0 days (the difference between the document date and the effective payment due date). I.e. when entering an Invoice with Document Date 22 Nov 2020, its Payment Due Date is 22 Nov 2020. Payment Due Date in theiInvoice depends of how the Payment Due Date and the Document Date in the invoice o rder are determined. Determine the Payment Due Date and the Document Date in the invoice orders They are usually generated on sales orders and copy their term and date. There are two general document flows that create invoice orders: sales orders => invoice orders These are orders directly created from sales orders. They include products that cannot be shipped. These are also orders for sales orders for sales returns. sales orders => shipment orders => shipments => invoice orders These are orders for products and services that have to be shipped first. When directly creating invoice orders from the sales orders, Document Date and Payment Due Date are copied from the sales order. The second document flow contains different mechanisms. Here, the document date in the invoice order is copied from the shipment and the Payment Due Date is determined by a more complicated algorithm. This is because the shipment does not have information for the payment term and it is provided by the sales orders which the shipment is based on. The sales orders may be more than one. Then the Payment Due Date in the invoice order is determined by the earliest Payment Due Date in the sales orders (i.e. the smallest date) and if this term is later than the Document Date of the invoice order (copied from the shipment), then the Payment Due Date is saved. If the Payment Due Date is before the Document Date - then the Document Date is saved as a Payment Due Date."
  },
  "modules/crm/invoicing/invoicing-concepts/determine-unit-price-and-line-amount-in-invoice-orders.html": {
    "href": "modules/crm/invoicing/invoicing-concepts/determine-unit-price-and-line-amount-in-invoice-orders.html",
    "title": "Determine unit price and line amount in invoice orders | ERP.net Tech Docs",
    "summary": "Determine unit price and line amount in invoice orders The invoice orders and their lines are created to generate invoice documents with the aid of particular Sales Order lines are invoiced. For this reason, every Invoice Order lines points to and fulfils exactly one Sales order line. In some cases though, when the parent document is a Shipment, for example, the Unit price and Line amount could not be copied directly from the parent document. They could not be copied from the sales order as well, because the line might be broken down (by lots for example) during the goods issue and the Line amount will not be the same. Therefore those amounts must be calculated. Calculation Initially, when the invoice order and its lines are created, the Quantity is copied from the parent documents line, the Unit price and the discounts are copied from the parent Sales Order line. The quantity and unit price values are used for the calculation of the Line amount. The algorithm is as follows: [LineAmount] = Round([Quantity] * [Unit price] * (1 - [Line Standard Discount Percent]) * (1 - [Line Custom Discount Percent])) *The Line amount is rounded up to the second digit. Example: SalesOrderLine1: Quantity = 3 PCS , UnitPrice = 2.5694 EUR, LineStandardDiscountPercent = 0.00 %, LineCustomDiscountPercent = 25.00 %, LineAmount = 5.78 EUR ShipmentLine1: Quantity = 2 PCS ShipmentLine2: Quantity = 1 PCS InvoiceOrderLine1: Quantity = 2 PCS, UnitPrice = 2.5694 EUR, LineStandardDiscountPercent = 0.00 %, LineCustomDiscountPercent = 25.00 %, LineAmount = 22.5694(0.75) = 3.8541 ~ 3.85 EUR InvoiceOrderLine 2: Quantity = 1 PCS, UnitPrice = 2.5694 EUR, LineStandardDiscountPercent = 0.00 %, LineCustomDiscountPercent = 25.00 %, LineAmount = 12.5694(0.75) = 1.92705 ~ 1.93 EUR Then when saving the document the Discrepancy System (for more information see Discrepancy System) initializes а depletion of the rounded Line amount which leads to a recalculation of the Unit price: [Unit price] = Round([LineAmount] / (1 - [Line Standard Discount Percent]) / (1 - [Line Custom Discount Percent]) / [Quantity] ) *The unit price is rounded up to the fifth digit. Example: InvoiceOrderLine1: Quantity = 2 PCS, LineAmount = 3.85 EUR, LineStandardDiscountPercent = 0.00 %, LineCustomDiscountPercent = 25.00 %, UnitPrice = 3.85 / 0.75 / 2 = 2.5666666... ~ 2.56667 EUR InvoiceOrderLine2: Quantity = 1 PCS, LineAmount = 1.93 EUR, LineStandardDiscountPercent = 0.00 %, LineCustomDiscountPercent = 25.00 %, UnitPrice = 1.93 / 0.75 / 1 = 2.57333333... ~ 2.57333 EUR"
  },
  "modules/crm/invoicing/invoicing-concepts/index.html": {
    "href": "modules/crm/invoicing/invoicing-concepts/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/crm/marketing/bonus-programs/index.html": {
    "href": "modules/crm/marketing/bonus-programs/index.html",
    "title": "Bonus programs | ERP.net Tech Docs",
    "summary": "Bonus programs Bonus programs are a tool that automates including a bonus product or a discount on the sales order when the document meets certain conditions. Using bonus program automation reduces the chances that a mistake is made. For example, if the business model requires using a lot of bonuses, there is a high probability an employee would forget to include a free product or a discount, but using bonus programs ensures that if all conditions are met, the customer receives the bonus. Bonus programs define bonuses and conditions, which specify when the bonuses should be applied to the sales order. Conditions for the particular bonus programs are set in the ‘condition’ fields and are verified for the whole sales order. Bonus program conditions: Description: Active That’s the main condition if the bonus must be applied. The other conditions are verified only for active bonus programs. Priority from 1 (the lowest) to 5 (the highest) of the bonus program compared to the other bonus programs. Condition Customer Specifies that the bonus program must be applied only for the customer that is set in the field. If ‘Condition Customer = NULL’, then it’s applied for all customers. Condition Customer Filter XML Sets a custom filter for clients. The bonus program is only applied if the customer meets the specified criteria. Currently, only criteria from the related ’Customers’ and ‘Parties’ tables are supported. The filter can contain custom properties. Condition Ship To Customer Specifies that the bonus program must be applied only when shipping to the customer that is set in the field. If ‘Condition Customer = NULL’, then it’s applied to all customer’s company locations. Condition Ship To Customer Filter XML The bonus applies only when shipping to a customer that meets the specified criteria. Currently, only criteria from the related ’Customers’ and ‘Parties’ tables are supported. The filter can contain custom properties. Condition Product If there is no value in the field, then all other conditions must be evaluated for the whole sale order. Otherwise, the bonus only applies to the lines that contain the product. If the bonus program is valid for more than one product, then another condition product could be added in the panel 'Bonus program products'. Condition Product Group The bonus program only applies to products from the specific group or its subgroups. Currently, the condition for the product group can’t be used with conditions for Min and Max quantity. That’s because if the base measurement units of the products in the group are different, there is no way the right calculation is made and the bonus program won’t be applied Condition Min Quantity Specifies a condition for the minimum quantity of the condition product in the base measurement unit. If there is no condition product, then a minimum quantity can not be set for the current bonus program. If the condition products are more than one, then all of them have to use the same base measurement unit. Otherwise, there is no way the right calculation to be made and the bonus program won’t be applied. Condition Max Quantity Specifies a condition for the maximum quantity of the condition product in the base measurement unit. If there is no condition product, then a maximum quantity can not be set for the current bonus program. If the condition products are more than one, then all of them have to use the same base measurement unit. Otherwise, there is no way the right calculation to be made and the bonus program won’t be applied. Condition Min Amount Specifies a condition for the minimum sum of amounts of the sales order lines, for which the bonus is valid. Condition Max Amount Specifies a condition for the maximum sum of amounts of the sales order lines, for which the bonus is valid. Condition Document Currency The bonus program only applies if the document currency is the same as the currency in this field. Condition Document Currency is also required if any of the amount conditions are set. Condition From Date Starting date (inclusive) from which the bonus program is valid. Condition To Date End date (inclusive) to which the bonus program is valid. Condition Target Group Specifies that the bonus program only applies for the customers from the specified target group. Condition Distribution Channel Specifies that the bonus program only applies when the specified distribution channel is used in the document. Condition Distribution Channel Filter XML The bonus only applies when the distribution channel in the document meets the specified criteria. Note When forming the maximum and minimum quantity of products purchased with the particular sales order, the system sums a total quantity of all purchased products defined in the bonus program. For example, if a bonus program is valid for two products - product A and product B and the condition for minimum quantity is 5 pieces, the bonus program will be applied no matter what is the ratio between those two products (2 pcs of product A and 3 pcs of product B, 1 pcs of A and 4 of B, 0 pcs of A and 5 of B …). Currently, three types of bonuses are supported: Product – Аdds a sales order line with a free product. Works as follows: If all conditions are met, a new line with the bonus product is created. The quantity in the line is determined by the values of the bonus program fields For Each and Bonus Product Quantity. For Example: if there is a bonus program with a product 'Pencil', which is offered as a gift for each 10 ordered books, then if in the sale order there are 30 notebooks, a bonus row with 3 pencils will be created. The line amount is '0.00'. Discount – Sets a percentage discount that replaces the standard discount percent for a specific sales order line. Works as follows: To all sales order lines that meet the conditions, the standard discount percent is replaced by the value set in the Bonus Line Discount Percent field. Bonus programs do not apply to lines with zero quantity. Cascade discount – Sets a percentage discount that is applied after the standard discount percent for a specific sales order line. Works as follows: To all lines that meet the conditions, the value set in the Bonus Line Discount Percent field is applied after the standard discount percent. So, the standard discount percent is calculated as follows: Line Standard Discount Percent = 1 - (1 – Line Standard Discount Percent) * (1 - Bonus Line Discount Percent). Bonus programs do not apply to lines with zero quantity. In the sales order line field Bonus program there is information about the name of the bonus program that is currently applied. A bonus type is required for each bonus program. Bonus types can not be used simultaneously. Data fields: Description: Bonus Action Specifies the type of the bonus – a product, a discount or a cascade discount. Bonus Product The product that the customer receives for free, if the conditions of the bonus program are met. The field is required when there is value in Bonus Product. Bonus Product Quantity The quantity of the bonus product. The field is required if there is a value in Bonus Product. Bonus Product Quantity Unit The measurement unit of the bonus quantity of the product. The field is required if there is a value in Bonus Product. For Each Specifies an amount of the condition product, for which the bonus quantity is applied every time. For example, if we want to use the common form of sales promotion 'Buy X get Y for free' we should set the 'X' quantity in the field 'For Each'. This way if the customer buys 2Х quantity, then will receive 2Y bonus. Bonus Line Discount Percent The percent discount that is going to be applied in the rows."
  },
  "modules/crm/marketing/index.html": {
    "href": "modules/crm/marketing/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/crm/pos/configure-pos.html": {
    "href": "modules/crm/pos/configure-pos.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Настройки за работа с ПОС модула За да работи коректно POS модула са необходими първончални настройки. Дефиниране на POS Location ПОС локацията е дефиниция, която определя даден Enterpise Company Location, като ПОС обект. Трябва предварително да е дефиниран самия Enterpise Company Location. След дефиниране на POS Location към нея дефинират POS Operators и POS Terminals Дефиниране на POS Terminals Във всяка локация можем да дефинираме един и или повече POS Terminals. The POS Terminal е мястото, където се регстрира продажбата и където се дефинират различните POS Devices, които се използват там. Например фискални устрайства, платежни терминали, везни и други. Едно от POS Devices може да се укаже по подразбиране и то се зарежда при създаване на нова продажба на този термнал. Дефиниране на POS Devices POS устройствата се дефинират за конкретен POS Terminal. ​ В собствените фирми, които трябва да се работи с EnterpriseOne POS е необходимо да се укаже „Приложимо законодателство“ = „България“ Необходимо е за всеки Филиал, който е търговски обект да се дефинира съответна ПОС Локация. Веднъж зададена ПОС локацията не може да се изтрие или променя. Може само да се деактивира. Необходимо е да се дефинират ПОС роли – например Управител и Магазинер. За всяка ПОС локация се дефинират ПОС терминали и ПОС оператори В дефиницията на ПОС операторите трябва да се укаже потребител, който задължително е свързан с лице. По подразбиране номерацията на ПОС операторите започва от 0001 за всяка локация. Ако е необходимо обаче да се достъпват ФУ от други локации то номерата на операторите трябва да се направят уникални в рамките на собствената фирма. За терминалите, където е необходимо се дефинират Фискални устройства Тип устройство: Фискален принтер Регистрационен номер: Регистрационен номер на ФУ – с главни букви, тъй като някой устройства изискват точно главни букви. Протокол за връзка: FP Електронният адрес на ФУ се задава във формат: „http://Address:8001/printers/Printer Id“ Самата библиотека може да се свали от: https://github.com/erpnet/ErpNet.FP За всяко фискално устройство трябва да се дефинира една ПОС поредица – 7 цифров номер от който започва УНП – Например 0000001. В дефинициите на типовете продукти трябва да се укаже данъчна група. Ако не е указана по подразбиране се взима данъчна група 2. Съответствието с групите във фискалните устройства в България е: Група А – Група 1 Група Б – Група 2 Група В – Група 3 Група С – Група 4 В начините на плащане които изискват печат на ФУ трябва да се отбележи „Изисква фискален бон“ и „Системен начин на плащане“ В момента от еднократните начини на плащане за печат на ФУ се поддържат В брой, Чрез карта и С Чек Настройката е еднократна и не подлежи на промяна в последствие. В типа документ за връщане, в настройки за продажби да се отбележи \"Разрешени посоки\" = \"Връщане на продажба\". Това е критерият по който се разпознава дали една продажба е връщане или не е. За справките за НАП трябва да се направят следните настройки: - Да настрои ID сайт - Да се настрои Legal_BG сайт - Да се създаде външен потребител в ID сайта – създава се през интерфейса на сайта. - Да се дадат права на този потребител до Системни права / Достъп до справките в Legal_BG - Да се дадат права на този потребител до собствената фирма - За справките вътре в системата трябва да се създаде друг вътрешен потребител, който да има съответните права - най добре пълни до всички модули, без право за редакция на документи и без да е администратор. Необходимо е да се инсталира „EnterpriseOne POS“. Необходимо е базата да има лиценз за работа с EnterpriseOne POS Ако ще се печати от форма Продажба, трябва всички документи в потока да се генерират пуснати, защото след печат програмата завършва потока. Необходимо е в потока генерациите на Нареждане за фактуриране от продажба и Счетоводна статия от складовата разписка да се дефинират като Следващ документ, за да останат пуснати при завършване на потока. Това ще позволи да се направи корекция на себестойност на склада и създаване на фактури в последствие. Съответно генерацията на счетоводна статия трябва да се случва на Завършен статус за да се преосчетоводи при корекция. ​"
  },
  "modules/crm/pos/fiscal-receipt-template.html": {
    "href": "modules/crm/pos/fiscal-receipt-template.html",
    "title": "Overview | ERP.net Tech Docs",
    "summary": "Overview Receipt templates can provide businesses with a customizable solution that enhances their fiscal printing process. They serve as pre-designed formats that you can easily modify and apply on a document type level. By creating such templates, you gain the flexibility to incorporate personalized text using interpolated strings in different sections on the fiscal receipt itself. This includes the ability to define: Custom Header - refers to the text that will be printed at the top of the fiscal receipt, above the system header. Custom Row Header - refers to the text that will be printed before certain lines of the fiscal receipt. Custom Row Footer - refers to the text that will be printed after certain lines of the fiscal receipt. Custom Footer - refers to the text that will be printed at the bottom of the fiscal receipt, next to the system footer. It's possible to take fiscal receipt customization even further by defining interpolated strings: Before/after a sale Before/after a discount Before/after a subtotal Before/after payment By tailoring these elements to their specific needs, users can ensure that every receipt reflects the identity and values of their company, sending the right messages and ultimately enhancing customer experience. Creating a receipt template To craft a distinctive template tailored to your business needs, you need to follow a specific set of steps. Locate the Fiscal Receipt Templates panel within the POS section of the CRM module. Click on the panel's Plus button to initiate the creation of a new template. This takes you to a new page specifically designed for customizing the printouts of fiscal receipts, providing you with a comprehensive set of options to personalize a template according to your preferences. The first required step in crafting a new template is providing a distinctive name for it. You can do that by using the Template Name field. Decide whether to include the Print System Header and Print System Row Header options. This determines if custom headers and row headers will be printed as part of a fiscal receipt. To select these options, simply press on their respective check boxes. Click the three-dot button on any Custom field to open a separate window with several customization options. It is here that you can provide text as well as interpolated strings for defining what exactly will be written in each respective section. You can also locate and directly add system variables such as date, time, or location. Warning Keep in mind that writing interpolated strings comes with a few rules and limitations. The width of a line is considered a unique parameter for each cash register. Therefore, certain symbols need to be added when you want to align or fill out fiscal receipt lines. You should use the following operators to transfer interpolated strings to another line: \"\\r\\n\", \"\\n\", \"'\\r\", \"\\n\", \"\\r\". The string will be transfered into a new line as long as it contains symbols such as \" , , \" or a sequence of \"\\n\" or \"\\r\" symbols. To prevent receipts becoming too long in size, there is a limit in terms of how many symbols can be provided and how many new lines with interpolated strings can be created. Text on one line will be automatically trasferred on a new line if identical symbols are present to fill the entire new line. In that case, the line with identical symbols is considered \"separating\" and it will be scrapped, but whatever preceded it will be moved to a new line. Example: \"This is text+++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++ more text\" This will result in two lines: \"This is text\" \"+++++++++++++more text\" The length of each line depends on the cash register's capabilities. When you're ready building your fiscal receipt template, click Save and reload. Note Interpolated strings can include text, domain attributes, and system variables available in the respective document type (e.g. sales order) for which you are creating a fiscal receipt template. You can also import user-defined calculated attributes, which allow for various calculations of prices, amounts, discounts, and more, all of which are printed on the receipt. Defining a template for a document type Now that you've created a template, you are ready to link it to a document type. Navigate to a document, e.g. a sales order, and open its document type. Edit the document type definition and locate the Printouts panel. If it isn't already visible, add it through the Customize form feature. From the Fiscal Receipt Template field, select the fiscal receipt template you created. Click Save and reload to apply your changes. The fiscal receipt template will now be enforced for all documents of the respective document type. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/crm/pos/index.html": {
    "href": "modules/crm/pos/index.html",
    "title": "POS | ERP.net Tech Docs",
    "summary": "POS Fiscal receipt templates"
  },
  "modules/crm/presales/index.html": {
    "href": "modules/crm/presales/index.html",
    "title": "CRM Presales | ERP.net Tech Docs",
    "summary": "CRM Presales The presales module is used to manage the presales process. Deals (Opportunities) Activity → Opportunity → Offer → Sales order → Invoice order → Invoice The deals in the Crm.Presales.Deals Entity are used to manage sales opportunities to new or existing customers. Note Deal is synonymous to opportunity. The deals: Have appointed sales representative, managing the deal. Do not have line items. They are used to manage deals, which are still not clear enough to detail at this level. Have a percentage probability of success. The percentage is set by the sales representative, based on their own judgement. Have expected sales revenue. Have expected close date. Based on the data above, the team leaders and sales managers have instant and clear visibility over the sales processes. The deals are usually initially created based on @General.Contacts.Activities. However, once a deal is created, it can be used to create many more sub-activities to manage related tasks. Offers (quotes) Activity → Opportunity → Offer → Sales order → Invoice order → Invoice The deals documents can be easily transformed into Offers (quotes), which contain detailed line items. Entries in the Crm.Presales.Offers Entity allows the customer to be presented with optional items. After approving some or all of the optional items, the offer can generate Crm.Sales.SalesOrders Entity in the Sales module."
  },
  "modules/crm/pricing/determining-algorithms/determine-line-discount.html": {
    "href": "modules/crm/pricing/determining-algorithms/determine-line-discount.html",
    "title": "Determine line discount | ERP.net Tech Docs",
    "summary": "Determine line discount ERP.net allows multiple discounts at multiple levels to be defined. Typically, Level 1 discount is determined among the active discounts from level 1. This means that if we want to calculate Level 1 discount, we might not explicitly specify a Discount Level filter, because its default value is 1. For the discounts for all other levels, we need to specify a Discount Level filter that is equal to the level we are trying to calculate. When trying to determine a discount for each level, we have to specify some required conditions: Product Date Quantity List of customers and some not required: Discount level – default is 1, can be changed if we are calculating the discount for a higher level Enterprise company - Only in the specified Enterprise Company Enterprise company location - Only in the specified Enterprise Company location Price list - self-explanatory Distribution channel - self-explanatory Current line discount - The current discount should not be changed if it satisfies the conditions and has the same priority as the determined top discount. ERP.net filters all active discounts from the respective level that match these criteria. When a discount is defined with a blank value for the Customer, the discount applies to all customers. The same goes for Customer Type, Product, From Date To Date, MinQuantity, MaxQuantity, Enterprise Company, Price List, etc. Generally, the algorithm is the following: • ERP.net filters the active discounts from the respective level. • Among the remaining discounts, the one with the highest priority is selected. If there is more than one price within the same highest priority, the newer one is selected (the one with later From Date). • If a current line discount is provided and it satisfies the conditions and has the same priority as the selected one, then the current line discount is selected. So, after the selection process, one and only one discount is selected and applied to the document line. Filtering conditions Discount Is Active is true Discount Discount Level is equal to the specified level Discount From Date is empty or <= required Date Discount To Date is empty or >= required Date Discount Product is empty or equal to required Product Discount Min Quantity is empty or <= required Quantity Discount Max Quantity is empty or >= required Quantity Discount Customer is empty or it is in the required list of customers Discount Product Group is empty, the same as the product group or parent of the product group Discount Distribution Channel is empty or equal to required Distribution channel Discount Price List is empty or valid for the required Date The discount Target group is empty or at least one of the customers is a member of the target group Discount Customer type is empty or it is in the list of customer types, derived from the required customer’s list"
  },
  "modules/crm/pricing/determining-algorithms/determine-product-price.html": {
    "href": "modules/crm/pricing/determining-algorithms/determine-product-price.html",
    "title": "Determine product price | ERP.net Tech Docs",
    "summary": "Determine product price When trying to determine a product price, we have to specify some required conditions: Product Quantity QuantityUnit Date and some not required: Customer Ship to customer Enterprise company - Only in the specified enterprised company Enterprise company location - Only in the specified enterprise company location Distribution channel - self-explanatory Price list - self-explanatory Current product price - The current product price should not be changed if it satisfies the conditions and has the same priority as the determined top price. ERP.net filters all product prices for the given product that match these criteria. When a product price is defined with a blank value for the customer, the product price applies to all customers. The same goes for Ship To Customer, From Date, Thru Date and all not required parameters from the list above. Generally, the algorithm is the following: ERP.net filters the product prices. Each of the selected product prices is checked if min and max’s quantities are respectively less and greater than the provided quantity. The price ist of the product price is checked for validity according to the date. If Ship To Customer is provided, its party is considered a Target Party, else the customer's party is taken. If the product price has a target group specified, the target party should be a member of that group or null. Among the remaining product prices, the top priority price is selected considering the lowest Price Type's Ordinal Pos, the highest Priority and the newer From Date. If a Current Product Price is provided and it satisfies the conditions and has the same priority as the selected one, then the current product price is selected. So, after the selection process, one and only one product price is selected and applied to the document line. Filtering conditions From Date is empty or <= required Date Thru Date is empty or >= required Date Product is equal to required Product Customer is empty or it is equal to the required Customer Ship To Customer is empty or it is equal to the required Ship To Customer Min Quantity is empty or <= required Quantity Max Quantity is empty or >= required Quantity Enterprise Company is empty or equal to required Enterprise Company Enterprise Company Location is empty or equal to required Enterprise Company Location Distribution Channel is empty or equal to the required Distribution channel Price List is empty or valid for the required Date The target group is empty or the ship to the customer or the customer is a member of the target group"
  },
  "modules/crm/pricing/determining-algorithms/index.html": {
    "href": "modules/crm/pricing/determining-algorithms/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Determine line discount Determine product price"
  },
  "modules/crm/pricing/index.html": {
    "href": "modules/crm/pricing/index.html",
    "title": "Pricing | ERP.net Tech Docs",
    "summary": "Pricing When a user enters a sales order (or similar document), the system automatically assigns the appropriate sales price. Selecting the correct price is the main topic of the pricing. Product prices in reality Each product can have multiple prices associated with it. For example, product A can have 3 standard prices: 50.00 USD - open price, for everyone who asks. This price is defined as Standard. 48.00 USD - for regular customers 45.00 USD - for special customers Additionally, product A can have a special price for some customers: 44.00 USD for Customer X 43.50 USD for Customer Y Also, there might be a discount campaign: 42.00 USD for everyone, from 1/1/2021 till 2/2/2021. This price is defined as Promotion and it should be with higher priority than the Standard price. Entering product prices in ERP.net The following table shows how we can define the prices from the above example in ERP.net. Product Customer Price list From date To date Price type Priority Price Product A Standard 1 50.00 Product A Regular 2 48.00 Product A Special 2 45.00 Product A Customer X 3 44.00 Product A Customer Y 3 43.50 Product A 1/1/2021 2/2/2021 Promotion 5 42.00 How ERP.net determines the correct price The most important thing to note is the Price type field. The price type with the lowest Ordinal position is with highest priority. If the Price type field has a blank value, the first thing that is taken into consideration is the Priority field of the price. The higher the priority, the more likely the price will be selected. After the user specifies the customer, date and product, ERP.net filters all prices, that match this criteria. When a price is defined with blank value for Customer, the price is applicable to all customers. The same goes for Price list, From date, To date, etc. Only the Product field is required, it cannot be blank. If it could be blank, this means, that we can define the same price for ALL products. Generally, the algorithm is the following: ERP.net filters the prices, based on Product, Customer, Price list and all other conditional fields. If among the remaining prices, there are prices with defined price type, the one that has a price type with the lowest Ordinal position is selected *If there is more than one price within the same lowest Ordinal position, the one with the highest priority is selected If among the remaining prices, there are no prices with defined price type, the one with the highest priority is selected *If there is more than one price within the same highest priority, the newer one is selected (the one with later From date) So, after the selection process, one and only one price is selected and applied to the sales document. For a detailed description of the algorithm of the method determining the product price, see Determine product price topic. More conditional filtering fields ERP.net employs many more conditional fields, which allow fine-grained tuning of the product pricing strategy. All conditional fields work in the same basic way as described above. The following additional conditional fields further filter down the prices: Enterprise Company - for sales only in the specified enterprise company Min Quantity - for sales quantities above (or equal to) the specified Max Quantity - for sales quantities below (or equal to) the specified Target Group - for customers in the target group Ship To Customer - self explanatory Distribution Channel - self explanatory Customer Type - self explanatory Specifying the price The price is specified using the following fields: Price - the decimal part of the price Currency - the currency of the price Quantity - the quantity for which the price is specified Quantity Measurement Unit - the measurement unit in which the quantity is specified Examples: 5.00 USD for 1 pcs 10.00 EUR for 3 packs"
  },
  "modules/crm/pricing/multiple-line-discounts.html": {
    "href": "modules/crm/pricing/multiple-line-discounts.html",
    "title": "Multiple line discounts | ERP.net Tech Docs",
    "summary": "Multiple line discounts ERP.net allows multiple discounts at multiple levels to be defined. The discount level is specified in the discount’s definition. The discounts from each level can be applied to the sales order lines automatically, manually, or by using user business rules. For each level, you can select only one discount out of all discounts of the given level. The discount percentages from all levels are accumulated in cascade in the Line Standard Discount Percent field in the sales order lines. Applying multiple line discounts in sales orders Discounts from different levels are applied to the relevant fields of the sales order lines in three alternative ways: automatically – by calling the Determine line discount method manually – by selecting a discount from the drop-down list or from a navigator using user business rules. Note that, discounts from level 2 and above are applied automatically ONLY if a price list is set in the sales order. The level up to which discounts are applied automatically depends on the selected value in the Auto Apply Discount Level field in the price list’s definition. For example: if Auto Apply Discount Level = 1, then level 1 discount is applied if Auto Apply Discount Level = 2, then level 1 and level 2 discounts are applied if Auto Apply Discount Level = 3, then level 1, level 2 and level 3 discounts are applied. Note Increasing the auto apply discount level may have performance implications. Determine line standard discount percent The line standard discount percent is calculated by accumulating in cascade all level discount percentages that were specified in the line. The formula is as follows: [Line Standard Discount Percent] = 1 – ((1 - IIF([Level 1 Discount Percent] == NULL, 0.00, [Level 1 Discount Percent]) * (1 - IIF([Level 2 Discount Percent] == NULL, 0.00, [Level 2 Discount Percent]) * (1 - IIF([Level 3 Discount Percent] == NULL, 0.00, [Level 3 Discount Percent])) Example 1 : If there are no discounts in the line, then line standard discount percent is: [Line Standard Discount Percent] = 1 - ((1 - 0) * (1 - 0) * (1 - 0)) = 0.00%. Example 2 : If the line contains the following discounts - level 1 discount percent = 12%, level 2 discount percent = 5% and level 3 discount percent = 8%, then the line standard discount percent is: [Line Standard Discount Percent] = 1 - ((1 – 0.12) * (1 – 0.05) * (1 – 0.08)) = 23.088%. Multiple line discounts in reality For example, you can define three levels of discounts, and for each of them you can have multiple discounts: Level 1 – according to the customer type Wholesale customers, product group Foods - 10% Wholesale customers, product group Non-food items - 5% Retail customers, product group Foods - 8% Retail customers, product group Non-food items - 4% Level 2 – according to the current promotion All customers, product group Foods / Chocolate - 15% All customers in Sofia, product group Non-food items - 4% Level 3 - according to specific conditions If the lot has less than 20 days of expiration date remaining - 5% If the line amount is greater then 1000 BGN - 2% Then, you can choose Level 1 and Level 2 discounts to be applied automatically by setting up a price list in the sales order with auto apply discount level equal to 2. Level 3 discount can be applied automatically as well by defining a user business rule that should be triggered if some specific conditions are met."
  },
  "modules/crm/pricing/price-types.html": {
    "href": "modules/crm/pricing/price-types.html",
    "title": "Price types | ERP.net Tech Docs",
    "summary": "Price types Price types are used to set additional priority conditions for the prices. 5 is the highest priority level that can be selected in the Priority field of the price. To add an additional higher priority, a price type must be defined and selected as a price type of the price. Priorities among the different price types are set by filling a number in the ordinal position field in the definition of the price type – the lower the number, the higher the priority. Price types add additional priority under the following algorithm: If a price has a defined price type, this price will be with the highest priority among other prices - no matter their level of priority. If more than one price has a defined price type, the price with the price type that has the lowest ordinal position will be with the highest priority. If more than one price has a defined price type and their price types have equal ordinal positions, the price with the highest priority will be selected."
  },
  "modules/crm/pricing/promotional-packages.html": {
    "href": "modules/crm/pricing/promotional-packages.html",
    "title": "Promotional packages | ERP.net Tech Docs",
    "summary": "Promotional packages Promotional packages are packages of products which can be added into sales orders. The products from the package appear as sales order lines and their quantity is a multiple of the number of the sold packages. If a line is added from a promotional package, then the name of the promotional package is filled in the Promotional package field. A promotional package can be applied for a sales order only if it fulfills the conditions of the package: Promotional package fields Description Valid from date Starting date from which the promotional package is valid. Valid to date End date (inclusive) to which the promotional package is valid. Valid for price list Price list for which the promotional package is valid. Valid for customer Customer for which the promotional package is valid. Valid for target group Target group for which the promotional package is valid. Valid For Customer Filter XML Sets a custom filter for clients. The promotional package only applies if the customer fulfills this condition. Valid for Ship to customer Ship to customer for which the promotional package is valid. Valid for Ship to customer Filter XML The promotional package only applies if the customer, which is supplied, fulfills this condition. Valid for Distribution channel Distribution channel, for which the promotional package is valid. Valid for Distribution channel Filter XML The promotional package only applies if the distribution channel in the sales order fulfills this condition. Promotional package lines Promotional packages lines represent the products that are part of the particular package. Quantity and Standard discount percent adjust are required for each line. Promotional package line fields Description Line Number Line number Product Id Product code Quantity Product quantity Unit Price When filled sets the unit price of the product. Unit Price CurrencySpecifies the currency of the unit price Standard discount Percent Adjust Specifies the amount of change (in percentage points) of the standard discount. Standard discount Adjust Or Replace Specifies the type of change of the standard discount. Possible values: • Add – adds the percent set into the field ‘Standard Discount Percent Adjust’ to the already existing trade discount in the sales order lines: Standard Discount = Standard Discount + adjust, where ‘adjust’ is the value in the field ‘Standard Discount Percent Adjust’. • Replace – Saves the percent of the field ‘Standard Discount Percent Adjust’ in the standard discount for the line: Standard Discount = adjust • Mark Down – Applies after the standard discount and is calculated as follows: Standard Discount = 1 - (1 – Standard Discount) * (1 - adjust)"
  },
  "modules/crm/sales/create-order.html": {
    "href": "modules/crm/sales/create-order.html",
    "title": "Sales order creation | ERP.net Tech Docs",
    "summary": "Sales order creation To be updated."
  },
  "modules/crm/sales/definitions/define-customers.html": {
    "href": "modules/crm/sales/definitions/define-customers.html",
    "title": "Customer definition | ERP.net Tech Docs",
    "summary": "Customer definition For the purposes of creating a sales order, you must define and manage customers to whom you'll be selling your products. This involves adding various details about them which you can later make use of while creating the order. Below is a step-by-step guide on how to define customers and configure their settings. Navigation From the CRM module, click on Common. There, you'll find the Customers panel, where you can view all of the customers you have created, with details about each. Set up Before you can actually create a customer, it's necessary to set up a party, representing an entity not yet designated as a customer but recognized by the system as an entitiy that participates in business relations or transactions. Prior to customer creation, you can also consider adding a customer type, which can help organize customers based on common characteristics. Note The type you define can impact the customer creation process, potentially adding different fields for you to fill out. Create a customer There are two ways to create a customer, both ensuring consistency in the final result when selecting the same customer type. Navigate to the Create section within the Customers panel. Here, you'll find a list of various customer types. Upon selecting the respective type, a separate window will open, automatically reflecting the chosen customer type. You can proceed with the creation process by filling out the rest of the details. Use the New button found above the Customers list. Upon clicking this button, you can select a customer type from a dropdown menu. Then, you will be taken to the standard customer creation form and proceed to add the necessary details. New customer details Once you access the New Customer window, you can start adding all the necessary details for your customer. Most of the fields are optional. However, whatever information you provide at this point will simplify the process of creating a sales order document later, as it will automatically be added in the order creation form. The only mandatory field is Party. Once you've filled out all the desired fields, click the Save and reload button to complete the creation of the new customer. Most common fields Here's a summary of commonly used fields, along with those less frequently utilized: • Party – In this field, select a party that you wish to designate as a customer. • Active – This checkbox allows you to enable or disable a customer. When unchecked, the customer will no longer be visible in various places on the platform. • Date – You can specify the start and end dates of the sales contract using the From Date and Thru Date fields. • Credit Limit– If a sale has been made for a certain amount but payment has not been issued, the system will notify you that the customer has exceeded their credit limit. • Customer Status – You have two options for selling: If you're shipping directly to the customer that placed the order, check the Allow Use As Primary Customer box. If you've made a sale to one customer but are shipping products to another, check the Allow Use As Ship To Customer box. Note The Credit Limit field value can be overridden by authorized users. Assign defaults Fields starting with \"Default\" allow you to specify template information for customers. For example, if the Default Currency is set to BGN, all sales with that customer will be automatically conducted in that currency. You have the ability to modify each default value when creating the sales order itself. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/crm/sales/definitions/define-products.html": {
    "href": "modules/crm/sales/definitions/define-products.html",
    "title": "Product definition | ERP.net Tech Docs",
    "summary": "Product definition For the purposes of creating a sales order, you must define and manage products which you can sell to customers. This involves adding various details about them which you can later make use of while creating the order. Below is a step-by-step guide on how to define products and configure their settings. Navigation From the General module, click on Products. There, you'll find the Products panel. This section enables you to access a comprehensive overview of all created products, create new ones as needed, and review detailed information about each product. Set up Before you can actually create a product, you need to define a type and a group for it. Product types Types allow you to differentiate one kind of a product from another. It is a characteristic that makes products unique and yet strictly related to something. To create a new type, navigate to the Product Types panel and click on its \"+\" button to begin adding details about your new product type. You'll be taken to a window where you need to add the code assigned to the product type. Additionally, you can also specify a name for it. Several checkboxes allow you to further define the characteristics of the product. This can determine the type of documents and invoices generated when a sales order is placed. By selecting the appropriate checkboxes, you ensure that the generated documents accurately reflect the nature of the product and meet regulatory requirements. Note Products are not necessarily items; they can also be services. Product groups The purpose of placing products in groups is to categorize them and make them part of something bigger, with other products that share the same or similar features. To create a new group, navigate to the Product Groups panel and click on its “+” button. You are required to provide a unique name for the group in order to create it. The group's code will be created automatically, starting from 001, but you can always specify it manually. Within each product group, you can assign attributes such as a Next Part Number, a Next Serial Number, or a Default Measurement. Additionally, you have the ability to add notes and easily activate or deactivate them as needed. Create a product There are two methods for creating a product, both ensuring consistency in the final result when selecting the same product type. Navigate to the Create section within the Products panel. Here, you'll find a list of various product types. Upon selecting the respective type, a separate window will open, automatically reflecting the chosen product type. You can proceed with the creation process by filling out the rest of the details. Use the New button found above the Products list. Upon clicking this button, you can select a product type from a dropdown menu. Then, you will be taken to the standard product creation form and proceed to add the necessary details. New product details Once you access the New Product window, you can start adding all the necessary details for your product. Most of the fields are optional. However, whatever information you provide at this point will simplify the process of creating a sales order document later, as it will automatically be added in the order creation form. The mandatory fields for creating a new product include Product Group, Part Number, Name, Base Measurement category, and Measurement Unit. The Measurement Unit is especially important, as it will determine the standard unit of measuring the product in a warehouse, which is not the same as the measurement used for purchasing or selling purposes. Once you've filled out all the desired fields, click the Save and Reload button to complete the creation of a new Product. Most common fields Here's a summary of commonly used fields, along with those less frequently utilized: Is Serialized - Clicking this checkbox determines that a sales order cannot be fulfilled without a serial number. Standard Price Per Lot - This field allows you to define the standard price for one lot of the product. It is automatically applied during the sale. Use Lots - This option enables the product to be stored in lots. You can choose to allow, not allow, or even require this feature. Customize view From the window settings, you have the option to include additional detail panels such as Lots, Serial Numbers, Product Prices, and more. This allows you to view existing information and add new options as necessary. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/crm/sales/definitions/index.html": {
    "href": "modules/crm/sales/definitions/index.html",
    "title": "Sales order definitions | ERP.net Tech Docs",
    "summary": "Sales order definitions Here, you will find more information about how to define various integral components of a sales order. Customers Products"
  },
  "modules/crm/sales/definitions/pictures/index.html": {
    "href": "modules/crm/sales/definitions/pictures/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/crm/sales/images/file.html": {
    "href": "modules/crm/sales/images/file.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/crm/sales/index.html": {
    "href": "modules/crm/sales/index.html",
    "title": "Sales | ERP.net Tech Docs",
    "summary": "Sales The Sales module plays a pivotal role in documenting sales operations within ERP.net. It is through here that you can preview, create and release different kinds of sales orders. Consisting of one panel, Sales consolidates essential functionalities for creating and managing sales orders and their related entities. It also makes use of previously specified sales order definitions that are necessary for the creation of the respective documents. Orders panel This panel serves as the central hub of the Sales module, allowing you to access all of your existing sales orders as well as instantly begin creating new ones. It consists of three main sections: Create, Sub Entities, and Related Entities. To see your sales order documents, simply click on the panel's title. This takes you to the Orders page containing all sales orders related to your enterprise company. From here, you can preview each and every one of them, filter the table to show entries matching specific criteria, and create new orders on-demand. Create You can use this section of the Orders panel to begin creating various types of sales orders. Options include Direct Sale Orders, POS Sales Orders, Return Orders, and more. Sub entities This section allows you to preview already created definitions that take part in the final sales order document. It includes seeing promotional packages, payment plans, and sales order lines. Related entities In this section, you can track various operations associated with sales orders. This includes monitoring state changes, prints, parties, line amounts, and order fulfillment. Learn more about Sales here: Common concepts Definitions Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/crm/sales/sales-concepts/amount-to-pay.html": {
    "href": "modules/crm/sales/sales-concepts/amount-to-pay.html",
    "title": "Amount to pay | ERP.net Tech Docs",
    "summary": "Amount to pay Amount to pay is part of the sales orders and invoices. It is the final amount that the customer has to pay on the current document (sales order or invoice). It is calculated as the sum of the row amounts and all additional amounts in the current document which has checked in the Add To Customer attribute in their definitions. Example 1: There is an invoice with two rows: Row #10 - Product 1, LineAmount: 2 PCS x 12 EUR = 24 EUR Row #20 - Product 2, LineAmount: 3 PCS x 7 EUR = 21 EUR The document has an additional amount paid by the customer: VAT, Amount Percent: 20% of the line amount of the rows = 0.2 x 45 EUR = 9 EUR So the Amount To Pay is: 54 EUR = 24 EUR + 21 EUR +9 EUR. Relation To Tax Base And VAT (Invoices) In most cases, the amount to pay matches the sum of tax base and VAT, like in Example 1, but a difference is possible. It is possible if there are Additional Amounts that are paid by the customer but are not set as base amounts for VAT additional amount. Example 2 : There is an invoice with a line amount of 45 EUR and two Additional Amounts which are paid by the customer: VAT, amount: 20% of 45 EUR = 9 EUR Penalty Interest - not a VAT base amount, Amount: 20 EUR So the Aount To Pay is 74 EUR while the sum of Tax Base and VAT is 54 EUR. Example 3: The additional amount VAT (special cases) is set that its base amount type is Tax Base, Add To Customer and Base On Lines are True. Tax Base is not paid by the customer. There is an invoice with two rows: Row #10 - Product 1, LineAmount: 2 PCS x 12 EUR = 24 EUR Row #20 - Product 2, LineAmount: 3 PCS x 7 EUR = 21 EUR and Additional Amounts as follows: Tax Base, Amount: 30 EUR VAT, Amount Percent 20% of 30 EUR = 6 EUR In this case, the Amount To Pay is 45 EUR while the sum of Base Tax and VAT is 36 EUR."
  },
  "modules/crm/sales/sales-concepts/deferred-payments-options.html": {
    "href": "modules/crm/sales/sales-concepts/deferred-payments-options.html",
    "title": "Deferred payments options | ERP.net Tech Docs",
    "summary": "Deferred payments options Some companies may apply the sales policy of selling with deferred payment. And sometimes there are additional requirements needed to be met, so the deferred payment is allowed. In ERP.net, there is an option to set a minimal total amount on a sales order in order to use deferred payments. The minimal amount may be set for each Enterprise company separately in the specified currency. If a sales order is set with a minimal deferred payment amount, there are certain system validations that ERP.net requires. The first option for the user is to have a sales order with Amount to pay greater than the sales order minimal deferred payment amount. If this is not true, the current sales order may be processed if: there are no payment plans; the Payment Due Date is not greater than the document date; the payment type system type is in cash or card."
  },
  "modules/crm/sales/sales-concepts/determining-algorithms/determine-line-amount-in-sales-orders.html": {
    "href": "modules/crm/sales/sales-concepts/determining-algorithms/determine-line-amount-in-sales-orders.html",
    "title": "Determine line amount in sales orders | ERP.net Tech Docs",
    "summary": "Determine line amount in sales orders The line amount in a sales order is formed by the following fields: Quantity, Unit Price, Line Standard Discount Percent and Line Custom Discount Percent. The fields Unit Price, Line Standard Discount Percent and Line Custom Discount Percent represent the trade conditions in the row. They may be managed/filled as a nomenclature - as product prices, discounts, bonus programs and promotions. The formula of the field line amount is rounded up to the second digit and is as follows: [LineAmount] = Round([Quantity] * [Unit Price] * (1 - [Line Standard Discount Percent]) * (1 - [Line Custom Discount Percent])) Example 1 : In the row there is quantity 7 PCS and unit price 0.15472 EUR and no discounts, then the line amount is: [Line Amount] = Round(7 * 0.15472 * (1 - 0) * (1 - 0)) = Round(1.08304) = 1.08. Example 2 : In the row there is quantity 27 PCS and unit price 0.15472 EUR, the discounts are 19% and 7%, then the line amount is: [Line Amount] = Round( 27 * 0.15472 * (1 - 0.19) * (1 - 0.07)) = Round(1.08304) = 1.08. There are also other row amount types which meaning and calculation are different than those of amount saved in the field LineAmount. For more information, see Amount to pay."
  },
  "modules/crm/sales/sales-concepts/determining-algorithms/determine-payment-account-in-sales-order.html": {
    "href": "modules/crm/sales/sales-concepts/determining-algorithms/determine-payment-account-in-sales-order.html",
    "title": "Determine payment account in sales orders | ERP.net Tech Docs",
    "summary": "Determine payment account in sales orders The algorithm for the determination of the payment account in the sales order is the following: SalesOrder.PaymentAccount is set to one of the following (in order of their precedence): If the ShipToCustomer.DefaultPaymentType = SalesOrder.PaymentType AND the ShipToCustomer.PaymentAccount is not null => it is taken. If the Customer.DefaultPaymentType = SalesOrder.PaymentType AND the Customer.PaymentAccount is not null => it is taken. If the PaymentType.DefaultPaymentAccount is not null => it is taken. No changes are applied. The rationale, expected setup and usage Initially, the user chooses a customer. The payment type and the payment account of the customer would be copied to the sales order. Note It is important, that the customers' payment type IS set to some non-null value! The following events happen: The user selects a customer. The payment type of the customer is loaded in the sales order. Since the payment type of the sales order is the same as the customers, the customer’s payment account is copied to the sales order. If however, the user chooses a different payment type, the default account of this new payment type is selected. For example, the customer usually pays cash and has a cash payment account specified. But now he chose to pay by credit card. In this case, the system loads the payment account of the 'Credit Card' payment type. The event order is the following: The user selects a customer The payment type of the customer is loaded in the sales order. The user selects different payment types. Since the payment type of the sales order is no longer the same as the customers', the payment account of the sales order is now copied from the definition of the payment type."
  },
  "modules/crm/sales/sales-concepts/determining-algorithms/determine-tax-groups.html": {
    "href": "modules/crm/sales/sales-concepts/determining-algorithms/determine-tax-groups.html",
    "title": "Tax groups determining algorithm | ERP.net Tech Docs",
    "summary": "Tax groups determining algorithm This algorithm is used to define the tax group specified in a fiscal device print of a sale, invoice or payment document. When we sell a product both in and outside of Bulgaria, in the product settings, the tax group in the product type must be 0 (zero). That gives us 2 options to define the tax group in the Sales Order depending on the country where the product will be delivered: In the Sales order lines in the Line deal type field for sales/deliveries in Bulgaria, we can apply groups from 1 to 4; In the Sales order lines in the Line deal type field for sales/deliveries outside of Bulgaria, which require the issuance of a fiscal receipt, we can apply group 1. How it works The final tax group is set to depend not only on the tax group of the product type (default), but on the deal type specified in the sales lines. To actually apply the effects of the algorithm, you need to configure the deal type's TaxCode field. As a result, one and the same product can now be assigned a foreign or a national tax group in accordance with the location its sale has been made in. Specifics There are four scenarios you may stumble upon while using the tax group defining algorithm. When the product type has a tax group equal to zero (0), the tax group is based on the TaxCode field of the deal type. Make use of the following code: IF Product.ProductType.TaxGroups.TaxGroup (Where ApplicableLegislation = 'BG') <> 0 THEN taxGroup = Product.ProductType.TaxGroups.TaxGroup (Where ApplicableLegislation = 'BG') When the product type has a tax group different from zero and the applicable legislation is ''BG'', the tax group is going to be the same tax group. Use the code: IF Product.ProductType.TaxGroups.TaxGroup (Where ApplicableLegislation = 'BG') = 0 AND LineDealType.Country = 'BG' THEN When the product type has a tax group equal to zero and the applicable legislation is ''BG'', the tax group is defined by the tax code of the deal type. Use the following scheme: IF LineDealType.TaxCode = \"STD\" THEN taxGroup = 2 IF LineDealType.TaxCode = \"RED\" THEN taxGroup = 4 IF LineDealType.TaxCode = \"SPR\" THEN taxGroup = 1 IF LineDealType.TaxCode = \"INT\" THEN taxGroup = 1 IF LineDealType.TaxCode = \"EXM\" THEN taxGroup = 1 IF LineDealType.TaxCode = \"NS\" THEN taxGroup = 1 In the previous three cases, expect a rate to be printed in accordance with the Bulgarian legislation. IF Product.ProductType.TaxGroups.TaxGroup (Where ApplicableLegislation = 'BG') = 0 AND LineDealType.Country <> 'BG' THEN When the product type has a tax group equal to zero, the applicable legislation is ''BG'' and the country specified in the deal type of the sale lines is different from ''BG'', the tax group is once again based on the tax code of the deal type. However, the scheme is different: IF LineDealType.TaxCode = \"STD\" THEN taxGroup = 1 IF LineDealType.TaxCode = \"RED\" THEN taxGroup = 1 IF LineDealType.TaxCode = \"SPR\" THEN taxGroup = 1 IF LineDealType.TaxCode = \"INT\" THEN taxGroup = 1 IF LineDealType.TaxCode = \"EXM\" THEN taxGroup = 1 IF LineDealType.TaxCode = \"NS\" THEN taxGroup = 1 In this scenario, expect a document to be printed for tax group 1 - export."
  },
  "modules/crm/sales/sales-concepts/determining-algorithms/index.html": {
    "href": "modules/crm/sales/sales-concepts/determining-algorithms/index.html",
    "title": "Determining algorithms | ERP.net Tech Docs",
    "summary": "Determining algorithms Here is a list of determining algorithms, each explained in a separate article: Determine line amount in sales orders Determine payment account in sales orders Determine tax groups"
  },
  "modules/crm/sales/sales-concepts/index.html": {
    "href": "modules/crm/sales/sales-concepts/index.html",
    "title": "Sales concepts | ERP.net Tech Docs",
    "summary": "Sales concepts Here, you will find detailed information about common sales-related concepts that will help you use and understand sales in ERP.net better. Sales order row types Amount to pay Sales order payment plan Deferred payments options Minimal sales price Minimal sales quantity VAT deviation Determining algorithms"
  },
  "modules/crm/sales/sales-concepts/minimal-sales-price.html": {
    "href": "modules/crm/sales/sales-concepts/minimal-sales-price.html",
    "title": "Minimal sales price | ERP.net Tech Docs",
    "summary": "Minimal sales price There are two ways to set a minimal sales price of a product: In the product definition. It is a price for one standard lot and in the costing currency of the product. The minimum is enforced upon releasing a sales order. If not set, this means that there is no minimum sales price enforcement. In the product distribution channel definition. It is also a price for one standard lot and in costing currency of the product. It describes the minimum sales price of this product through the current channel. If it is set in the product definition, the restriction takes place in every sales order. If it is set in the product distribution channel, then it validates the sales order release, only if the distribution channel is selected in the document header. If there are two minimal sales prices for a product - one in its definition and one set by the product distribution channel, then the more restrictive price is taken into account. Note The minimal price constraint does not take effect when the user enters a sales return. The restriction is not directly applied to the unit price in the sales order. As the unit price in the sales order lines does not reflect discounts, the restriction calculates the final unit price through the line amount and is applied to the calculated results. Example 1 : Product A has a minimal sales price of 9.00 EUR. The product costing currency is EUR and standard lot size base is 1 PCS. There is a sales order with the following line: Line No = 10, Product = Product A , Unit Price = 9.20 EUR, Line Custom Discount Percent = 5%; Quantity Base = 3 PCS; Line Amount = 26.22 EUR. When the user tries to release the sales order, he will receive an error message, that the unit price is less than the minimum unit price of the product. This is because the unit price with the calculated discount is as follows: [Line Amount] / [Quantity Base] = 26.22 EUR / 3 PCS = 8.74 EUR. In this case, because of the custom discount the user has entered, the unit price of the product goes under the minimum sales price of the product. Example 2 : Let’s use the product from Example 1. The product is also part of the distribution channel DC#1. Product A also has a minimal sales price defined in the product distribution channel of 9.40 EUR. The user enters a sales order with the DC#1 set in its header and the following line: Line No = 10, Product = Product A , Unit Price = 9.20 EUR, Quantity Base = 1 PCS. In this case, the sales order release will also return an error because of a minimum sales price violation. This is because the more restrictive minimal sales price is taken into account and it is 9.40 EUR. In this case, if the product is sold through the DC#1 distribution channel and it cannot be sold for less than 9.40 EUR per unit."
  },
  "modules/crm/sales/sales-concepts/minimal-sales-quantity.html": {
    "href": "modules/crm/sales/sales-concepts/minimal-sales-quantity.html",
    "title": "Minimal sales quantity | ERP.net Tech Docs",
    "summary": "Minimal sales quantity There are two ways to set a minimal sales quantity of a product: In the product definition. It is a minimal base quantity that has to be specified in any sale. The minimum is enforced upon releasing a sales order. If not set, this means that there is no minimum sales quantity enforcement. In the product distribution channel definition. It is also a base quantity that has to be specified in any sale. It describes the minimal sales quantity of this product through the current channel. If it is set in the product definition, the restriction takes place in every sales order. If it is set in the product distribution channel, then it validates the sales order release, only if the distribution channel is selected in the document header. If there are two minimal sales quantities for a product - one in its definition and one set by the product distribution channel, then the more restrictive one is taken into account. Note The minimal quantity constraint does not take effect when the user enters a sales return. The restriction is applied on the Quantity Base field in the Sales Order Lines. When such restriction exists it is applied to the calculated quantity in the base measurement unit. Note The restriction also calculates the total quantity base of the product in the Sales Order Lines, meaning that if the user enters the product in more than one line and the total quantity base covers the minimal sales quantity base, then the user would be able to release the sales order. Example 1: Product A has a minimal sales quantity base of 3 PCS. The product base measurement unit is PCS. It is declared that 1 KG of Product A is equal to 2 PCS. In the product definition a minimal sales quantity base of 3.00. There is a sales order with the following line: Line No = 10, Product = Product A, Quantity = 1.40 KG, Quantity Base = 2.80 PCS. When the user tries to release the sales order, he will receive an error message, that the quantity in the current document lines is less than the minimal sales quantity. Example 2: If in the sales order from Example 1 the user adds 3 more lines as follows: Line No = 20, Product = Product B, Quantity = 10 KG, Quantity Base = 10 KG. Line No = 30, Product = Product C, Quantity = 3 PCS, Quantity Base = 3 PCS. Line No = 40, Product = Product A, Quantity = 0.20 pcs, Quantity Base = 0.20 PCS. In this case, the user will be able to release the sales order because Line No 10 and Line 40 has a total quantity base of 3.00 PCS, which covers the minimal sales quantity base restriction, defined in the product definition. Example 3: Product P is part of distribution channel DC#1. Its base measurement unit is PCS. Product P has a minimal sales quantity base in its definition of 3.00 PCS. Product P also has a minimal sales quantity base defined in the product distribution channel of 2.80 PCS. The user enters a sales order with the DC#1 set in its header and the following line: Line No = 10, Product = Product P, Quantity = 2.90 PCS, Quantity Base = 2.90 PCS. In this case, the sales order release will also return an error because of a minimal quantity violation. This is because the more restrictive minimal sales quantity (the one in the product definition) is taken into account."
  },
  "modules/crm/sales/sales-concepts/sales-order-payment-plan.html": {
    "href": "modules/crm/sales/sales-concepts/sales-order-payment-plan.html",
    "title": "Sales order payment plan | ERP.net Tech Docs",
    "summary": "Sales order payment plan The sales order payment plan determines how the amount of the given sales order is paid (with how many instalments and their individual amounts). For each instalment, there are two main attributes - a method for determining the amount and a method for determining the due dates (the payment term). Methods for determining the amount (specified by the Amount Percent, Amount and Remainder fields): an indication of a fixed amount that does not depend on other factors; the amount of the instalment is a percentage of the total amount of the transaction; the amount is the remainder that is not covered by the other instalments. It is mandatory that in every plan there must be exactly one instalment marked as a Remainder (usually this is the last instalment in the plan). It is necessary to have such an instalment because it 'picks up' all of the small inaccuracies and differences of rounding (if there are other instalments whose amounts are determined by a percentage). It can also 'pick up' the changes in the total amount happening due to changes in the terms of trade in the invoices (see Example 3 below). There are two main fields with values that need to be determined in order to define the payment term - Payment Due Start Date (a.k.a Execution Date) and Payment Due Date. Payment Due Start Date (a.k.a Execution Date) is the date when the payment becomes due/executable and payment due date is the last day of the payment term. Due date form methods according to which the payment term is calculated: Specify the date explicitly: the payment due start date is determined by adding 'Payment term days' to the 'Explicit payment due date' and the due date is 'Explicit execution date' added with 'Execution term, days'; Use sales order due date: Due start date/Execution date and Payment due date are copied directly from the sales order header fields *Payment Due Start Date ' and Payment Due Date; Use sales order date: the dates are calculated using the sales order document date added with the number of days entered in 'Execution term, days' (for the calculation of the payment start due date) or 'Payment Term days' (for the calculation of the due date); Use invoice due date: Due start date/Execution date and Payment due date are copied directly from the invoice header fields Payment Due Start Date and Payment Due Date; Use invoice date: the dates are calculated using the invoice document date added with the number of days entered in 'Execution term, days' (for the calculation of the payment start due date) or 'Payment term days' (for the calculation of the due date); The last two methods use the delivery invoice dates. If they are not yet issued, then the dates are calculated according to the values inserted in the Sales Order header. If there is no indicated payment plan for the particular sales order at all, then it is considered that there is a plan that consists of only one instalment. This instalment is not numbered (see the Create payment orders section below) and is for total amount to pay of the sales order. In a 'service' instalment the method of determining the payment term depends on whether the Payment orders for the invoiced amounts will be created from the sales order or not (this depends on the setting of the Payment order generation procedure). If the payment orders for invoiced amounts will be generated from the sales order, then for the 'Due date form Method' the 'Use invoice due date' method is used, otherwise the 'Use Sales order Due date' method is used. Determining the total payment amount In order to determine the amount of each instalment, it is first necessary to determine what is the total / final amount that has to be paid for this transaction. This is done using the data from several documents - the Sales order with which the transaction is reflected and all Invoices for this sale (both for the advance and for delivery). For this purpose, two types of Amounts are calculated separately – Sales order amounts and Invoice amounts, which are then summed to obtain the final amount. Invoice amounts are the Amounts to pay (see topic Amount to pay) of the delivery invoices. And the sales orders amounts are the paid advances and the remaining part of the Amount to pay (see topic Amount to pay) of the sales order, which is not covered by an advance or delivery. To determine the last amount (the remaining part of the amount to pay of the sales order), the following formula is used: [remaining part] = [Amount to Pay of the Sales order] - [advances paid] - [invoiced part of the Sales order] The invoiced part is calculated by determining how much of the Amount to pay of the sales order is covered by the delivery invoices. This is done for each line of invoices in two alternative methods: through the Covered amount field of the Invoice lines; or through the quantities in the Invoice lines (this is used for the lines in which the Covered Amount is not filled in). Finally, the results of all lines of delivery invoices for current sales order are summed into [invoiced part of the Sales order]. It does not matter what the final amount to pay for the invoice is. The reason why the final amount to pay of the invoice is not to be considered is that there may be a change in the trading conditions (prices, discounts, etc.). This should not change the ratio - what part of the sales order is covered by this invoice. The first method is based on how much of the basе of the sales order (the Line Amount field of the Sales Order line) is covered by the value of the Sales Order Amount field in the line of the invoice. This relationship determines what part of the Sales Order line has been invoiced. For example, if the Sales Order lines is for 100.00 BGN and we have 20.00 BGN VAT (ie the amount to pay of the sales order is 120.00 BGN) and there is one Invoice line in which the covered sales order amount is 70.00 BGN, then the invoiced part of the sales order line is 120.00 * 70.00 / 100.00 = 84.00 BGN. The second method works on the same principle, but the relationship is made between the quantities of the Sales order line and the Invoice line. For example, if in the Sales Order line there is aqQuantity = 10 pcs with a total Amount to pay = 90.00 BGN and there is only one Invoice line for quantity = 7 pcs then the invoiced part of the Sales Order line is 90.00 BGN * 7 pc / 10 pc = 63.00 BGN. If there also is an advance deduction in the invoice, this deduction is also subtracted from the invoiced part (because advances are aggregated in [advances paid]). If in the example described above there is an advance deduction of 15.00 BGN in the Invoice, then the invoiced part of the Sales order is (90.00 BGN * 7 pcs / 10pcs) – 15.00 BGN = 48.00 BGN. Example 1: There is a sales order with quantity = 10 pcs for a total Amount to pay of 90.00 BGN, there already is a paid advance of 15.00 BGN and two delivery Invoices (in which the field*'Sales Order Amount* is not filled in): one for quantity = 3 pcs in which we deduct the advance and therefore we have an amount to pay of the invoice 12.00 BGN = (27.00 BGN – 15.00 BGN); one for quantity = 4 pcs, in which trade conditions are changed and so we have an amount to pay of the invoice 41.00 BGN (instead of the expected 36.00 BGN). The result is: [invoiced part of Sales order] = (90.00 BGN * 3 pss / 10 pcs) + (90.00 BGN * 4 pcs / 10 pcs) – 15.00 BGN = 48.00 BGN; [remaining part] = 90.00 BGN – 15.00 BGN – 48.00 BGN = 27.00 BGN; Thus, we receive two Invoice Amounts – 12.00 BGN and 41.00 BGN - and two Sales order amounts – 15.00 BGN (advance) and 27.00 BGN. The final payment amount is: [total Amount to pay] = 12.00 BGN + 41.00 BGN + 15.00 BGN + 27.00 BGN = 95.00 BGN In principle, (and from Example 1) we see that the total Amount to pay practically is the amount to pay of the sales order summed with the increases/decreases that occurred due to a change in the terms of trade in the invoices. The reason behind the using of such a breakdown of individual (smaller) amounts in the calculation is to avoid a (technical) complex analysis of how exactly the trade terms of the Invoices have changed and how this changes and affects the total amount. Also, these individual amounts help with the creation of Payment orders. Determination of the instalments amounts The instalments are calculated by computing the total amount to pay and applying the method of determining the instalment amount. Here are two examples: Example 2: There is a sales order with a total amount to pay 95.00 BGN. For this sales order, there is a payment plan with three instalments: the first for 33.30 %, the second for 33.70 % and the third is marked as a 'Remainder'. Thus, we get the following instalments: [Instalment 1] = 95.00 BGN * 33.30 % = 31.635 ~ 31.64 BGN; [Instalment 2] = 95.00 BGN * 33.70 % = 32.015 ~ 32.02 BGN; [Instalment 3] = 95.00 BGN - 31.64 BGN - 32.02 BGN = 31.34 BGN; Example 2 shows that when using a percent-based instalment and we have a change (increase/decrease) in the Amount to pay because of changing the terms of trade in the invoices, this change is evenly distributed among the instalments. It also illustrates the usefulness of the 'Remainder' instalment. If it was, instead, 33.00 %, then the total amount of the three instalments (after determining the percentages after the rounding) would be 95.05 BGN and not 95.00 BGN! Example 3: There is a sales order with a total amount to pay 95.00 BGN. For this sales order, there is a payment plan with three instalments: the first for an exact amount of 30.00 BGN, the second for an exact amount of 40.00 BGN and the third is marked as a 'remainder'. Thus, we get the following instalments: [Instalment 1] = 30.00 BGN (fixed amounts do not change); [Instalment 2] = 40.00 BGN (fixed amounts do not change); [Instalment 3] = 95.00 BGN – 30.00 BGN – 40.00 BGN = 25.00 BGN; This example illustrates the other benefits of the 'Remainder' instalment. When there are only fixed amounts in the previous instalments and there is change of the trade terms in the invoices, then this change is reflected in the last instalment. Create payment orders When we create payment orders by a sales order payment plan, first we have to determine the amount (as described above) and the due dates for any of the plan instalments. Thereafter, individual sales order and invoices amounts (those from which the total amount is formed) are determined. We make an additional breakdown of the instalments and the instalments are exhausted in the order of creation of the individual amounts. Example 4: Let's use the situation of Example 1 and the payment plan of Example 3. We get the following breakdown: 15.00 BGN - from [instalment 1] and because of the advance amount of the Sales order; 12.00 BGN - from [instalment 1] and because of the amount of the first Invoice; 3.00 BGN - from [instalment 1] and because of the amount of the second invoice; 38.00 BGN - from [instalment 2] and because of the amount of the second invoice; 2.00 BGN - from [instalment 2] and because of the remaining part amount of the sales order; 25.00 BGN - from [instalment 3] and because of the remaining part amount of the sales order. More examples of payment orders generated by sales order payment plans there are in topic Transitional documents. Note In the usual case, the sales and invoice amounts will match the instalments amounts, in fact, the resulting breakdown will match the payment plan (none of the >instalments will be 'broken down'). Then, for each Amount the resulting breakdown can create a separate Payment order. Whether it will be created or not depends on the settings of the generation procedure. If in the Settings it is indicated that the Payment orders have to be created for the invoiced amounts, then for the relevant Invoice amounts (these are amounts of 12.00 BGN, 3.00 BGN and 38.00 BGN from the example above) separate Payment orders will be created. Otherwise, no Payment orders are going to be created for those amounts. The same is valid for the non-invoiced amounts (amounts 15.00 BGN, 2.00 BGN and 25.00 BGN from above) with the only difference that the setting of the generation procedure has another name. The due start date (Amount.DueStartdate) and the due date (Amount.Duedate)are the determined dates for the current instalment (from which the amount has been broken down) according to its method. The fields for reference invoice data ('Invoice amount', 'Referent invoice document type', ' Referent invoice number', etc. ...) are filled in depending on whether the amount of the breakdown has been calculated according to the sales order or invoice amount. The Party (Amount.Party) in the payment order is inherited from the customer and the location party is inherited from the Ship To Customer field in the sales order. The instalment number (Amount.InstallmentNumber) in the Payment order is filled in according to the corresponding field in the instalment from which the amount has been broken down. If the instalment is 'service' (i.e. no payment plan has been entered in the sales order), then the field for the instalment number in the payment order remains blank. The payment account (Amount.PaymentAccount) and the payment type (Amount.PaymentType) in the payment order are inherited from the corresponding instalment from the plan. If they are not filled in in the instalment or the instalment is 'service' then they are inherited from the Sales Order header. Additionally, if the payment type is not filled in both places but the amount is an invoice amount and payment type is filled in in the invoice, then it is inherited from the invoice. The document notes (Amount.DocumentNotes) in the Payment order are a combination of the document notes of the parent document and the notes of the corresponding in the plan. If both are filled in – then they are concatenated, separated by a space (or a new line). And if only one of them is filled in – it is the only one that is inherited."
  },
  "modules/crm/sales/sales-concepts/sales-order-row-types.html": {
    "href": "modules/crm/sales/sales-concepts/sales-order-row-types.html",
    "title": "Sales order row types | ERP.net Tech Docs",
    "summary": "Sales order row types The classification of the Sales Order rows describes three main row types - Normal sale, Sales return and Neutral operation. The row type is important for some generation procedures from sales order. Types The row type is defined by the signs of the quantity value and the amount in it. These criteria are chosen because it is most common and natural. For example, it is possible to define if a Sales Order row is for stock return or not by the values in the Return For Sales Order Line field in the lines or the header field - ReturnForSalesOrder. But it is also possible for the user to enter a sales order for stock to directly return negative values in the quantity and/or amount fields without using tools such as ReturnForSalesOrderLine or ReturnForSalesOrder. Thus, the signs of the values in the Quantity and Line Amount fields are the most common and natural criterion to determine the row type. Thus, according to the signs of the quantity and the amount, there are three main types of Sales Order rows: normal sale - rows with quantity > 0 or amount > 0; sales return - rows with quantity < 0 or amount < 0; neutral operation - rows with quantity == 0 and amount == 0. Why defining row type is important? The types, listed above, are used in the generation procedures of store orders and shipment orders from sales orders and the row type is important. For example, if the row type is sales return, then if the product is shippable or not doesn’t matter - the store orders and invoicing orders are generated always directly from the sales order. If the row type is a normal sale - then if the product is shippable or not is important and it defines if shipment order has to be created or store order and invoice order directly from the sales order. The rows with neutral operation do not participate in these generation procedures as for a row with zero quantity and zero amount there is no point of creating nor store orders, nor invoice orders. Row data validations and rules To avoid ambiguity when defining the type of a Sales Order row, certain restrictions are required when entering data in the sales orders. For example, quantity < 0 is not allowed with amount > 0 in one row as this row would be normal sale and return sale at the same time, which would lead to double Store Orders and Invoice Orders generation for the current row. These are all restrictions in the data in the sales orders, related to the row types definition: the quantity and the amount in the row must be with the same signs (for example, one is > 0 and the second is < 0); if the quantity and the amount in the row are positive then the ReturnForSalesOrderLine, ReturnForInvoiceLine and HistoricalUnitCost must be null; the header fields \"ReturnForSalesOrder and ReturnForInvoice must be also null; if one of the quantities or the amount in the row is negative and the product is not stocked then the HistoricUnitCost must be null; if one of the quantities or the amount in the row is negative and the product is stocked, then exactly one of the fields must have value - ReturnForSalesOrderLine and HistoricUnitCost. These restrictions are also required because they maintain the overall validity of the data in the sales order according to the business logic of the fields being part of the constraints. Validation is not only applied when the data is entered in the row, it may also appear and during the execution of a generation procedure."
  },
  "modules/crm/sales/sales-concepts/vat-deviation.html": {
    "href": "modules/crm/sales/sales-concepts/vat-deviation.html",
    "title": "VAT Deviation | ERP.net Tech Docs",
    "summary": "VAT Deviation VAT Deviation is a term used in sales orders and invoices. It is used in POS/store sales and their sales invoices. VAT deviation is the difference between the amount of the document that is obtained, when value added tax is calculated on the total amount of the document (which is the standard method of calculation in ERP.net) and the amount that is obtained when value added tax is charged on each Unit price in the document separately (which is the case for Store sales). Usage VAT Deviation is used in store sales and their sales invoices when in those documents the VAT and/or discounts are not applied directly to the line amounts. Then the total amount of payment that ERP.net will calculate (value [Standard Amount]) may differ, usually by a few cents, from the amount the client actually pays (value [POS Amount]). In these cases, VAT deviation is calculated as an additional amount in the Sales order / Invoice that is paid by the customer and serves as an adjustment to the standard ERP.net way of calculating a payment amount. The additional VAT deviation can be used for accounting purposes as well, in order to make a transition between the standard amounts and the POS amounts. Calculation If we denote the value of the two amounts of the document by [POS Amount] and [Standard Amount] then the formula would be: [VAT Deviation] = [POS Amount] - [Standard Amount]. The difference between [POS Amount] and the [Standard amount] is that when calculating the [POS Amount] VAT is applied to the line amount for each line separately (taking into consideration the standard and specific discounts and then rounding off the result to a second decimal sign before calculating the amount of the line). Whereas while calculating [Standard Amount] the value added tax is applied to the entire amount of all lines (the rounding is performed on the total amount). [POS Amount] and [Standard Amount] are calculated as follows: [Standard Amount] = Round ([Line Amount_Line1] + [Line Amount_Line2] + ... + [Line Amount_LineN]) * (1 + [VAT Rate])) [POS Amount] = [POS Line Amount_Line1] + [POS Line Amount_Line2] + ... + [POS Line Amount_LineN], where Line1, Line2, ... LineN are all lines in the Sales / Invoice (the formula of the Line Amount is described it the topic Determine Line Amount in Sales Orders), and the POS Amount for each line is calculated as follows: [POS Line Amount] = Round ([Quantity] * [POS Unit Price], [POS Unit Price] = Round ([Unit Price] * [1 - [Standard Discount]) * (1 - [Custom Discount]) * (1 + [VAT Rate])). The rounding made to a second decimal place. It is also considered that all percentages - [VAT rate], [Standard Discount] and [Custom Discount] - are fractional numbers between 0 and 1. Example: Let's have a sales order with two lines: in the first one we have 7 pcs with a Unit Price - 7.37 (without VAT) and in the second one we have 0.354 kg with a Unit Price of 3.58 (VAT excluded). The VAT rate is 20% (i.e. [VAT rate] = 0.2). So we can calculate that: [LineAmount_Line1] = Round (7 * 7.37) = 51.59; [LineAmount_Line2] = Round (0.354 * 3.58) = Round (1.26732) = 1.27; [Standard Amount] = Round ((51.59 + 1.27) * (1 + 0.2)) = Round (63.432) = 63.43; [POS Unit Price_Line1] = Round (7.37 * (1 + 0.2)) = Round (8.844) = 8.84; [POS Unit Price_Line2] = Round (3.58 * (1 + 0.2)) = Round (4.296) = 4.30; [POS Line Amount_Line1] = Round (7 * 8.84) = 61.88; [POS Line Amount_Line2] = Round (0.354 * 4.30) = Round (1.5222) = 1.52; [POS Amount] = 61.88 + 1.52 = 63.40; [VAT Deviation] = 63.40 - 63.43 = -0.03."
  },
  "modules/express/crm/common.html": {
    "href": "modules/express/crm/common.html",
    "title": "Common | ERP.net Tech Docs",
    "summary": "Common This module allows you to preview your customers, product prices and discount policies for sales documents. You can also define as many new ones of these as needed. Add new To create a new customer, product price or line discount, simply click on its + button. This will open the respective creation form that you need to fill. Once ready, click the Save and reload button to finish adding the new entity. Customize form You can decide which definitions appear on the page. To do that, click the button at the top-right corner and select Customize form. In the window that opens, you will see two tabs: Items Click the sliders on the left of an item to hide or reveal the respective panel from the page. Reorder You can change the order of the items' categories by dragging them up and down. This would not be applicable if there's only one item category (e.g. Definitions). Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/express/crm/index.html": {
    "href": "modules/express/crm/index.html",
    "title": "CRM | ERP.net Tech Docs",
    "summary": "CRM The Customer Relationship Management module helps you manage and track your interactions with customers and prospects. It is composed of the following sub-modules: Common Marketing Presales Sales Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/express/crm/marketing.html": {
    "href": "modules/express/crm/marketing.html",
    "title": "Marketing | ERP.net Tech Docs",
    "summary": "Marketing This module allows you to preview your campaigns, competitors, and marketing solutions. You can also create new ones on-demand, or remove existing entities which are no longer needed. The module features the ability to set up company size classes and industries. These may be useful for different definitions. Add new To create a new campaign, competitor or marketing solution, simply click on its + button. This will open the respective creation form that you need to fill. Once ready, click the Save and reload button to finish adding the new entry. Customize form You can decide which definitions appear on the page. To do that, click the button at the top-right corner and select Customize form. In the window that opens, you will see two tabs: Items Click the sliders on the left of an item to hide or reveal the respective panel from the page. Reorder You can change the order of the items' categories by dragging them up and down. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/express/crm/presales.html": {
    "href": "modules/express/crm/presales.html",
    "title": "Presales | ERP.net Tech Docs",
    "summary": "Presales This module allows you to monitor your leads, identify potential opportunities, and create offers for sales of products. It includes both definitions and documents as part of its structure. Add new To create a new lead, offer or opportunity, simply click on its + button. This will open the respective creation form that you need to fill. Once ready, click the Save and reload button to finish adding the new entry. Customize form You can decide which definitions appear on the page. To do that, click the button at the top-right corner and select Customize form. In the window that opens, you will see two tabs: Items Click the sliders on the left of an item to hide or reveal the respective panel from the page. Reorder You can change the order of the items' categories by dragging them up and down. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/express/crm/sales.html": {
    "href": "modules/express/crm/sales.html",
    "title": "Sales | ERP.net Tech Docs",
    "summary": "Sales This section allows you to create new sales orders and lines. It also features the ability to preview all sales orders that your company has made. Add new To create a new sales order, click the respective Sales Order button. You need to fill the creation form with data essential for the order. Once ready, click the Save and reload button. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/express/general/contacts.html": {
    "href": "modules/express/general/contacts.html",
    "title": "Contacts | ERP.net Tech Docs",
    "summary": "Contacts In this module, you can manage people (persons), companies and their locations, as well as different kinds of parties. These are all the company and business-related relationship entities which you can define on-demand. Add new To create a new person, company or location, simply click on its + button. This will open the respective creation form that you need to fill. Once ready, click the Save and reload button to finish adding the new entry. Customize form You can decide which definitions appear on the page. To do that, click the button at the top-right corner and select Customize form. In the window that opens, you will see two tabs: Items Click the sliders on the left of an item to hide or reveal the respective panel from the page. Reorder You can change the order of the items' categories by dragging them up and down. This would not be applicable if there's only one item category (e.g. Definitions). Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/express/general/index.html": {
    "href": "modules/express/general/index.html",
    "title": "General | ERP.net Tech Docs",
    "summary": "General This module allows you to create and find all the people and companies you work with on a daily basis. You can also manage your products and their groups. General consists of the following sub-modules: Contacts Products Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/express/general/products.html": {
    "href": "modules/express/general/products.html",
    "title": "Products | ERP.net Tech Docs",
    "summary": "Products In this module, you can find all of your products and their product groups. It also allows you to define and manage these entities on-demand. Add new To create a new product, simply click on its + button. This will open the creation form that you need to fill. Once ready, click the Save and reload button to finish adding the new product. Customize form You can decide which definitions appear on the page. To do that, click the button at the top-right corner and select Customize form. In the window that opens, you will see two tabs: Items Click the sliders on the left of an item to hide or reveal the respective panel from the page. Reorder You can change the order of the items' categories by dragging them up and down. This would not be applicable if there's only one item category (e.g. Definitions). Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/express/index.html": {
    "href": "modules/express/index.html",
    "title": "Express | ERP.net Tech Docs",
    "summary": "Express Express is a system which seamlessly unites team collaboration with business operations, allowing you to increase your productivity and achieve better workflow organization. Its intuitive interface and flexible customization capabilities can be used on-demand, as soon as the need for a meeting to be scheduled or a task to be set arises. Main features You can take advantage of several core functionalities in order to better navigate the Express system. Search bar Use it to locate specific panels or document creation forms belonging to one or more menu elements. For example, if you want to create a product group, instead of using the menu to find it, simply write what you need in the search bar. Notifications When something related to the system or a favorite item occurs, you will receive a notification for it. Click the bell icon at the top-right corner to learn what happened. Menu Click the button at the top-left corner of the page to expand the main menu. Express consists of three main modules which are further divided into sub-modules. My CRM General Menu customization Any menu element you don’t need can be hidden on-demand. You can alternatively reveal more elements than the ones you see by default. Click the gear button to reveal your options. You can configure which items are visible in each of the main modules, as well as rearrange their order. Within the Items tab, click on a slider to hide or reveal an item in the menu. To change the order of the items in the menu, drag them up or down from the Reoder tab. Pin If you want to adjust the reach of the Express menu, click once on the Pin button. It can also be used to completely collapse the menu. Get started Click any of the available modules below to learn more. My CRM General Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/express/my/calendar.html": {
    "href": "modules/express/my/calendar.html",
    "title": "Calendar | ERP.net Tech Docs",
    "summary": "Calendar This is a personal environment which contains all individual events or tasks you've scheduled for yourself. Furthermore, it includes group activities from all the social groups you're participating in. Such events will appear in your calendar as long as you’re set as a responsible person, organizer, or participant in a group activity. Within the Calendar, you can: create a new event change the view in which all events appear (Workweek, Month) navigate to past or future dates access any of your scheduled personal or group events. Time period To change the view of the Calendar, use the dropdown menu on the right and select either \"Month\" or \"Workweek\". To get to specific weeks or months, use the left and right arrows. Depending on the view, you can also select a specific week or month from the blue-colored navigator. Create an event To add a new event to the Calendar, use the Create button. You’ll be taken to a separate page where you need to fill necessary information about the activity and the potential participants in it. When ready, click Save and reload, and the activity will be added to your Calendar. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/express/my/dashboard.html": {
    "href": "modules/express/my/dashboard.html",
    "title": "Dashboard | ERP.net Tech Docs",
    "summary": "Dashboard The Dashboard allows you to build a space in accordance with your preferences by adding, removing, or rearranging panels as needed. It's entirely customizable, giving you the freedom to prioritize what matters most to you, without any mandatory elements. It includes easy access to panels from sub-modules such as To Do and Calendar, as well as many other items you can choose to add into it. Customize To determine what goes into the Dashboard and where, click on the button at the top-right corner of the page and select Customize form. In the window that opens, you'll find two tabs: Items Click on the sliders to show or hide widget panels in your Dashboard. Reorder Change the order in which widgets appear on the Dashboard by dragging them up and down. Interact Different widgets allow you to perform a variety of actions on-demand. Take advantage of them to create tasks, schedule meetings, preview your tiles, and much more! Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/express/my/favorites.html": {
    "href": "modules/express/my/favorites.html",
    "title": "Favorites | ERP.net Tech Docs",
    "summary": "Favorites You can build your own list of favorites by adding different items of interest. This includes the compaines, produts or any other entities that you follow. Once they’re marked as favorite, you will receive notifications for relevant events that happen to them. If you mark a specific document as a favorite, it automatically includes all of its related documents. This way, you can stay informed about important actions others may take on the documents. Add a favorite To add a new item to your favorites, simply click on its star button at the top-right corner. This could be any customer, document, campaign, lead, and much more. Edit To limit the number of favorite items you have, click the button at the top-right corner of the page and select Edit. Click on a red cross at the top-right corner of a favorite to remove it. You'll be asked to confirm the action. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/express/my/groups.html": {
    "href": "modules/express/my/groups.html",
    "title": "Groups | ERP.net Tech Docs",
    "summary": "Groups This module contains all the social groups you're involved in. Each is equipped with a range of productivity tools designed to enhance teamwork between members. Within a group, you can find the following features: Chat Engage in instant communication with colleagues belonging to the same group. The group Chat allows you to text, react to messages, and import images. Calendar This is a shared environment which includes scheduled events and tasks belonging to colleagues within the group. You can create new events for yourself and others, and change the view of the group Calendar directly from here. To Do All group members’ tasks are kept in this panel. You can create new To Dos for the group, as well as see which of them are New, In progress, Waiting or Completed. Files Access to different files related to the group is granted here. You can add new files to share them with your team, or delete them if they’re no longer needed. Members Here, you can see the membership status of each group participant, as well as access their personal profiles. Admins can add or remove team members on-demand. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/express/my/index.html": {
    "href": "modules/express/my/index.html",
    "title": "My | ERP.net Tech Docs",
    "summary": "My This is a personalized space which houses all the information and tools you need to optimize your daily activities. It includes several integral components of the Express system: Dashboard Groups Calendar To Do Tiles Favorites Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/express/my/tiles.html": {
    "href": "modules/express/my/tiles.html",
    "title": "Tiles | ERP.net Tech Docs",
    "summary": "Tiles This module features useful statistics on some of your business activities. It allows for additional customization to better fit your business needs. Tile actions Click the button the top-right corner of the page in order to Edit, Reload or Customize the view of this page. Edit This action allows you to remove a tile by clicking on the red cross button at its top-right corner. You'll be asked to confirm the action. Reload This action refreshes the information on the tiles so that the most up-to-date data is displayed. Customize view This action allows you to reveal or hide tiles from the page, as well as change their order. It opens a separate window with two tabs: Items Click on the sliders next to an item to add or limit access to the respective tile. Reorder Change the order in which tiles appear by dragging them up and down. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/express/my/todo.html": {
    "href": "modules/express/my/todo.html",
    "title": "To Do | ERP.net Tech Docs",
    "summary": "To Do Within this module, you have the ability to create personal tasks. These can be useful for reminders or meetings, allowing you to stay in touch with everything related to your work. Depending on their completion status, tasks are categorized as New, In Progress, and Completed. When creating a task within a social group, you also have the ability to assign it to another member of that group. Create a task To begin adding a new task, click the circular + button. You can include both a reminder and a due date for the task. To finish adding your task, click the Create button. It will be placed in the New category. Complete a task To complete a task, click on the circular button on its left to mark it as done. It will be placed in the Completed category. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/financials/VAT/defining-vat-and-base-for-vat-entries.html": {
    "href": "modules/financials/VAT/defining-vat-and-base-for-vat-entries.html",
    "title": "Defining VAT and base for VAT Entries | ERP.net Tech Docs",
    "summary": "Defining VAT and base for VAT Entries The current article describes how the numeric values are defined - base and VAT, which are saved in the VAT Entries when this document is created automatically from other documents in ERP.net. Currently, the documents which create VAT Entries are: Invoices (they create records in the VAT sales ledger entries Sales ledger entries); Transactions (they create records in the VAT sales ledger entries) The calculations are performed in three stages: 1.Defining which document rows participate in the calculation. 2.Defining the deal types for each row. 3.Defining the base and the VAT for each deal type. 1. Defining the participating rows Which rows participate in the calculation of the base and the VAT is defined for each document individually. The set of rows also depends on that if the document creates VAT sales or purchases ledger entries. In invoices, all rows participate in the calculation. In purchase invoices which create VAT purchases ledger entries, all rows participate, too. In purchase invoices which create VAT sales ledger entries there are two cases: if the document header has value in the Sale Deal Type field, then all rows participate in the calculation; if the document header has no value in the Sales Deal Type field, then only the rows which have value in the Sale Line Deal Type field (this is the same field but in the document rows). In transactions, all rows participate in the calculation. 2. Defining the deal types For each row that participates in the calculation, unique identification of the deal type of the row must be defined. If for any of the rows this definition is impossible, the calculation process is interrupted and an error message is displayed. The deal type definition for a row depends on the document which it is part of and on that if the document creates VAT sales or purchases ledger entries. For invoice row - if the row has value in the Line Deal Type field, then the deal type is defined by this value. Otherwise, the value in the document header is used. For purchase invoice (which creates VAT purchases ledger entries) row - the principle is the same as in the Invoice rows - if the row has value in Line Deal Type field, the deal type is defined by this value, otherwise - the Deal Type from the document header is used. For purchase invoice (which creates VAT sales ledger entries) row - the same combination of corresponding fields from the rows and the document header is used, except the fields here are Sales Line Deal Type (in the rows) and Sales Deal Type (in the document header). In transactions, all rows use a specific property of the document flow - Deal Type field from table \"Transaction Entry Template\". There are no specified fields in the document rows and header for the Deal Type. 3. Defining base and VAT for each Deal Type All bases and VAT amounts are calculated only in base currency. For all deal types, defined in stage 2, two values are calculated - [base] and [VAT]. To calculate them for the current deal type the rows, which have such deal type defined in stage 2, are used. Example 1: There is an Invoice with 7 rows: row #10, Line Deal Type = \"DealType1\", LineAmount = 32 EUR; row #20, Line Deal Type = \"DealType2\", LineAmount = 17 EUR; row #30, Line Deal Type = \"DealType3\", LineAmount = 41 EUR; row #40, Line Deal Type = \"DealType1\", LineAmount = 45 EUR; row #50, Line Deal Type = \"DealType3\", LineAmount = 55 EUR; row #60, Line Deal Type = \"DealType3\", LineAmount = 29 EUR; row #70, Line Deal Type = \"DealType1\", LineAmount = 24 EUR. Thus, in the previous stage for the rows three ideal types are defined - DealType1, DealTyope2 and DealType3. Thus, three bases and three VATs must be calculated - [DealType1:base], [DealType2:base], [DealType3:base], [DealType1:VAT], [DealType2:VAT], [DealType3:VAT]. To calculate base and VAT for DealType1 the data from row #10, row #40 and row #70 are used. For the base and VAT of DealType2 only row #20 is used, and for DealType3 - row #30, row #50 and row# 60. The VAT additional amount is set in the ERP.net definition (see Additional amounts) of the current document. If the document does not contain the specified VAT additional amount (or there is no such in the ERP.net company definition), the calculation is interrupted by an error message. The distributed additional amount on the rows is used in the calculation of the VAT amounts. And to calculate the bases amounts - the distributed VAT additional amounts which are added to the base and also the line amounts (but only if in the VAT additional amount Base On Lines is true). The bases and VAT’s calculations are performed in three steps: The amounts for each deal type is formed. The rest of the VAT is processed. VAT, which is calculated/distributed incorrectly, is re-distributed. Step 1 For each deal type, two values are calculated - base and VAT. So a list of couples is formed, which has as many elements as deal types there are. This is processed only if the VAT in the document is distributed by the current document (it is possible to distribute on other documents - if so, this step is skipped; it is possible to distribute both on the current document and different documents - then this step is performed). If the step is skipped, then the list is empty. So, for each deal type all rows, which have the specified deal type, are summed up and from each row, the distributed VAT is extracted, the distributed amounts which are added to the Base also, and the line amounts if the VAT is based on lines. The value of [VAT] for the current deal type is the sum of the distributed VAT for all rows with this deal type. And the value of [base] is the sum of the distributed amounts which are added to the VAT base and the line amounts (if the VAT is based on lines). Example 2: Let's use the Invoice from Example 1. There is an additional amount VAT, which is 32.32 EUR and it is based on the line amounts and the second additional amount \"Loyal Customer Discount\". The discount amount is 40 EUR and the distribution of both additional amounts is as follows: row #10, distributed discount -7 EUR, distributed VAT 5 EUR; row #20, distributed discount -1 EUR, distributed VAT 1.12 EUR; row #30, distributed discount -14 EUR, distributed VAT 0 EUR; row #40, distributed discount 0 EUR, distributed VAT 9 EUR; row #50, distributed discount -11 EUR, distributed VAT 0 EUR; row #60, distributed discount -3 EUR, distributed VAT 5.2 EUR; row #70, distributed discount -4 EUR, distributed VAT 4 EUR. Also, the VAT amount is distributed not only on the current document but on another document row which has no other additional amounts and line amount of 40 EUR and the distributed VAT is 8 EUR. Then the following calculations for base and VAT for the different deal types of the current document are received: [DealType1: base] = 32 EUR + -7 EUR + 45 EUR + 0 EUR + 24 EUR + -4 EUR = 90 EUR; [DealType2: base] = 17 EUR + -1 EUR = 16 EUR; [DealType3: base] = 41 EUR + -14 EUR + 55 EUR + -11 EUR + 29 EUR + -3 EUR = 97 EUR; [DealType1: VAT] = 5 EUR + 9 EUR + 4 EUR = 18 EUR; [DealType2: VAT] = 1.12 EUR; [DealType3: VAT] = 0 EUR + 0 EUR + 5.2 EUR = 5.2 EUR; Step 2 If any of the following is true: the list of couples of values from Step 1 is empty (this is possible if the VAT is not distributed on the current document); or the VAT is distributed on other documents also or either not the whole VAT is used when forming the VAT amounts in step 1 or not the whole VAT base is used when forming the bases. then the creation of a new couple of values is necessary - base and VAT. The deal type for this couple is extracted from the deal type field in the document header (and if the document is Transaction - then it is extracted from the document flow). In the base and VAT for this deal type the remaining values from the base and VAT, which are not distributed in Step 1 from the other deal types, are recorded. Example 3: Let's use the data from Example 2 and the Invoice has a deal type in its header - DealType4. The VAT in the document is 32.32 EUR, and [DealType1: VAT] + [DealType2: VAT] + [DealType3: VAT] = 24.32 EUR. So there are 8 EUR remaining. Also the total VAT base (from both documents) is 243 EUR, and [DealType1: base] + [DealType2: base] + [DealType3: base] = 203 EUR. So the remaining base is 40 EUR. So a new couple of values is formed for DealType4: [DealType4: base] = 40 EUR [DealType4: VAT] = 8 EUR Step 3 In the end, there is a newly formed list of couples of values - base and VAT - for several deal types. If one of those deal types does not support VAT and its calculated VAT in the list is not a zero, then a need for correction of those VATs and bases calculated by now appears. The correction is performed by resetting the VATs of all deal types, which VAT is distributed incorrectly in the documents, and these VATs are distributed amongst the other deal types, proportionally to their bases (if after this redistribution there is remaining amount because of roundings, then this small amount is distributed to the last deal type which supports VAT). Example 4: Let’s use the data from the previous examples and DealType1, DealType2 and DealType4 support VAT, and DealType3 does not. So there is incorrectly distributed VAT of [DealType3:VAT] = 5.2 EUR. So the 5.25 EUR must be relocated to the rest of the deal types - the following correction is achieved: [DealType3: VAT] = 0 EUR; [DealType1: VAT] = 18 EUR + 5.2 EUR * 90 EUR / (90 EUR + 16 EUR + 40 EUR) = 21.21 EUR; [DealType2: VAT] = 1.12 EUR + 5.2 EUR * 16 EUR / (90 EUR + 16 EUR + 40 EUR) = 1.69 EUR; [DealType4: VAT] = 8 EUR + 5.2 EUR * 40 EUR / (90 EUR + 16 EUR + 40 EUR) = 9.42 EUR."
  },
  "modules/financials/VAT/index.html": {
    "href": "modules/financials/VAT/index.html",
    "title": "VAT | ERP.net Tech Docs",
    "summary": "VAT Defining VAT and base for VAT Entries"
  },
  "modules/financials/accounting/index.html": {
    "href": "modules/financials/accounting/index.html",
    "title": "Accounting | ERP.net Tech Docs",
    "summary": "Accounting Operations"
  },
  "modules/financials/accounting/operations/currency-revaluation.html": {
    "href": "modules/financials/accounting/operations/currency-revaluation.html",
    "title": "Currency revaluation algorithm | ERP.net Tech Docs",
    "summary": "Currency revaluation algorithm This topic describes the currency revaluation algorithm of accounts have balances in a currency other than the base currency when the revalution is performed using accounting operations. Input data an accounting Operation document a list of Accounts - it is derived from the accounts indicated in the lines of the accounting template set up for the Operation document, where \"Amount Column Name\" == \"Debit Exchange Difference\" OR \"Credit Exchange Difference\" Date of revaluation - it is derived from the Document Date of Operation Currency directory - it is derived from the Currency Directory set in Operation Accounting vouchers The algorithm action: Get all currencies included in the Currency directory Calculate Balance и BalanceBase for the Date of revaluation for each Account, Currency, Item Key, CostCenter, ProfitCenter and ReferencedDocument. 1.1. If CurrencyValuationMethod != Balance_Reference_Document. Then data is grouped by Account, Currency, Item Key, CostCenter, ProfutCenter. (ReferencedDocument = NULL). 1.2. If CurrencyValuationMethod = Balance_Reference_Document Then data is grouped by Account, Currency, Item Key, CostCenter, ProfutCenter and ReferencedDocument. Calculate the Amount in base currency of the Exchange difference for each group Amount = RoundAmount(BaseCurrency, Balance * CurrencyDirectoryLine.RateMultiplier / CurrencyDirectoryLine.RateDivisor) - BalanceBase) NOTE: If (templateline.AmountColumnName == Debit_Exchange_Differenc && Amount > 0) OR (templateline.AmountColum_Name == Credit_Exchange_Difference && Amount < 0), then it is considered that Amount = 0 Create an Accounting voucher with the calculated base currency amounts of the differences for each group. Amount (Currency, Account, ItemKey, CostCenter, ProfitCenterI, ReferencedDocument)"
  },
  "modules/financials/accounting/operations/index.html": {
    "href": "modules/financials/accounting/operations/index.html",
    "title": "Operations | ERP.net Tech Docs",
    "summary": "Operations Algorithm of Currency revaluation"
  },
  "modules/financials/cost-accounting/add-production-function.html": {
    "href": "modules/financials/cost-accounting/add-production-function.html",
    "title": "Add production function | ERP.net Tech Docs",
    "summary": "Add production function This function is used in the Cost distribution document. When used, it adds the production from the specified period and store to the document. How does it work? The function selects all store transaction lines, filtered by the following conditions: They are part of a document which is at least Released and non-voided. They are part of a document with the same enterprise company as the one of the cost distribution document. They are part of a store transaction with a store equal to the one in the cost distribution header (if specified); if the store of the cost distribution header is empty, then the current filter is not applied. The store transaction's movement type is \"Receipt\"; Their Transaction Timestamp is in the period specified in the document header. Their quantity base is not 0. The ParentStoreOrderLine is not null. The store order specified in the ParentStoreOrderLine field has output order as a parent document. When the set of store transaction lines is ready, it is loaded in the Outputs panel of the cost distribution document. The fields in the panel are filled as follows: Line No - unique, consecutive line number. The field is AutoNumber; Cost Object - the id of the store transaction line; Weight Coefficient - the function sets the Line Base Cost Corrections as a coefficient. The line base cost corrections equals the sum of [LineBaseCost] (in the current store transaction line) and the sum of [BaseCostAdjustment] of all cost correction lines which are non-voided and at least released and referring the current store transaction lines. When the data is filled in the cost distribution outputs table, the Cost distribution document is saved."
  },
  "modules/financials/cost-accounting/calculate-distribution-function.html": {
    "href": "modules/financials/cost-accounting/calculate-distribution-function.html",
    "title": "Calculate distribution function | ERP.net Tech Docs",
    "summary": "Calculate distribution function The function is used in the Cost distribution document. When used, it calculates the distributed amounts for each output and for each cost type and fills the Results table with the calculations. How does it work? The function performs the following steps: Calculate the sum of the weight coefficients of all outputs. For each output and for each cost type the distributed amount is calculated by the following algorithm: at first, it is assumed that a proportion of the distributed cost amounts is defined, so the distribution is executed. If we have n outputs which we have to distribute cost amounts on, for every row (a row is a combination of output and cost type) a weight is defined - [k1], [k2] ... [kn]. So if the amount of the coefficients is [S] (i.e. [S] = [k1] +[k2] + ... + [kn]) and this amount is not equal to 0, than the i-row the proportion is [ki]/[S]: [distribution to row i] = ROUND([cost type amount] [ki] / [S], 2); This is a standard distribution algorithm. Specific cases are when [S] is 0. Usually, in those cases the cost amount is distributed evenly through the row, using the following formula: [row i distribution] = ROUND([cost type amount] / [rows count], 2); Sometimes the cost amount may not be able to be distributed exactly through the rows. In these cases, an attempt is made to allocate the balance through the rows which the amount is distributed to. Normally, it is impossible to distribute an equal part of the balance to all rows (otherwise there will be no balance). So the balance is distributed by the first several rows starting with the row with the largest amount. Also, in this balance distribution we cannot distribute less than: [minimal balance distribution on a row] = 1 / 10[Round Scale]. (the round scale for line amounts is always 2 (currently), so we cannot distribute cost amount of less than 1/102 = 0.01) In the Results table, the results of step 2 are saved and for each combination of output and cost type, a new row is added. Example 1 Let's say there is a cost distribution document with two cost types with the following data: Cost Type: CT1; Distributed Cost Amount: 100; Cost Type: CT2; Distributed Cost Amount: 500; In the Outputs table, the following rows are present: LineNo: 10; Cost Object: StoreTransactionLine1; Weight Coefficient: 15.00; LineNo: 20; Cost Object: StoreTransactionLine2; Weight Coefficient: 13.00; LineNo: 30; Cost Object: StoreTransactionLine3; Weight Coefficient: 10.11; LineNo: 40; Cost Object: StoreTransactionLine4; Weight Coefficient: -0.50; LineNo: 50; Cost Object: StoreTransactionLine5; Weight Coefficient: 29.99. So [S] in the example is: 15.00 + 13.00 + 10.11 + -0.50 + 29.99 = 67.60. When the calculate distribution function is started, the results table is filled with the following data: OutputLineNo = 10; Cost Type: CT1; Distributed Amount Base: 22.19; DistributedAmountBase = ROUND([kOutput[LineNo=10]] / [S] * [Cost Type Amount] ; 2) = ROUND(15.00 / 67.60 * 100; 2) = 22.19; OutputLineNo = 20; Cost Type: CT1; Distributed Amount Base: 19.23; Calculation steps: DistributedAmountBase = ROUND(13.00 / 67.60 * 100 ; 2) = 19.23; OutputLineNo = 30; Cost Type: CT1; Distributed Amount Base: 14.96; Calculation steps: DistributedAmountBase = ROUND(10.11 / 67.60 * 100 ; 2) = 14.96; OutputLineNo = 40; Cost Type: CT1; Distributed Amount Base: -0.74; Calculation steps: DistributedAmountBase = ROUND(-0.50 / 67.60 * 100 ; 2) = -1.09; OutputLineNo = 50; Cost Type: CT1; Distributed Amount Base: 44.36; Calculation steps: DistributedAmountBase = ROUND(29.99 / 67.60 * 100 ; 2) = 44.36; OutputLineNo = 10; Cost Type: CT2; Distributed Amount Base: 110.95; Calculation steps: DistributedAmountBase = ROUND(15.00 / 67.60 * 500 ; 2) = 110; OutputLineNo = 20; Cost Type: CT2; Distributed Amount Base: 96.15; Calculation steps: DistributedAmountBase= ROUND(13.00 / 67.60 * 500 ; 2) = 96.15; OutputLineNo = 30; Cost Type: CT2; Distributed Amount Base: 74.78; Calculation steps: DistributedAmountBase = ROUND(10.11 / 67.60 * 500 ; 2) = 74.78; OutputLineNo = 40; Cost Type: CT2; Distributed Amount Base: -3.70; Calculation steps: DistributedAmountBase = ROUND(-0.50 / 67.60 * 500 ; 2) = -3.70; OutputLineNo = 50; Cost Type: CT2; Distributed Amount Base: 221.82; Calculation steps: DistributedAmountBase = ROUND(29.99 / 67.60 * 500 ; 2) = 221.82. Example 2 Let's see an example where the sum of the DistributedAmountBase of a cost type is not the cost type distributed cost amount. A cost distribution document is present with one cost type CT1 with amount of 100.93. In the Outputs table, the following rows are present: LineNo: 10; Cost Object: StoreTransactionLine1; Weight Coefficient: 15.11; LineNo: 20; Cost Object: StoreTransactionLine2; Weight Coefficient: 0.00; LineNo: 30; Cost Object: StoreTransactionLine3; Weight Coefficient: 10.00; LineNo: 40; Cost Object: StoreTransactionLine4; Weight Coefficient: 20.00; LineNo: 50; Cost Object: StoreTransactionLine5; Weight Coefficient: 15.11. So the [S] in the examples is 15.11 + 0 + 10 + 20 + 15.11 = 60.22. When the calculate distribution function is started, the results table is filled with the following data: OutputLineNo = 10; Cost Type: CT1; Distributed Amount Base: 25.32; DistributedAmountBase = ROUND([kOutput[LineNo=10]] / [S] * [Cost Type Amount] ; 2) = ROUND(15.11 / 66.22 * 100.93; 2) = 25.32; OutputLineNo = 20; Cost Type: CT1; Distributed Amount Base: 0.00; Calculation steps: DistributedAmountBase = ROUND(0.00 / 66.22 * 100.93 ; 2) = 0.00; OutputLineNo = 30; Cost Type: CT1; Distributed Amount Base: 16.76; Calculation steps: DistributedAmountBase = ROUND(10.00 / 66.22 * 100.93 ; 2) = 16.76; OutputLineNo = 40; Cost Type: CT1; Distributed Amount Base: 33.52; Calculation steps: DistributedAmountBase = ROUND(20.00 / 66.22 * 100.93 ; 2) = 33.52; OutputLineNo = 50; Cost Type: CT1; Distributed Amount Base: 25.32; Calculation steps: DistributedAmountBase = ROUND(15.11 / 66.22 * 100.93 ; 2) = 25.32; Now the DistributedAmountBase sum is 22.32 + 0.00 + 16.76 + 33.52 + 22.32 = 100.92 and there is difference of 0.01 between the distributed cost amount of the CT1 as it is 100.93. The difference of 0.01 meets the requirement of [minimal balance distribution on a row] = 1 / 10[2] =0.01. The balance distribution amount is 0.01 and it should be distributed on the row with largest amount, the row with the Output [LineNo=40]. The final Results now would be as follows: OutputLineNo = 10; Cost Type: CT1; Distributed Amount Base: 25.32; OutputLineNo = 20; Cost Type: CT1; Distributed Amount Base: 0.00; OutputLineNo = 30; Cost Type: CT1; Distributed Amount Base: 16.76; OutputLineNo = 40; Cost Type: CT1; Distributed Amount Base: 33.53; (the balance is distributed here) OutputLineNo =50; Cost Type: CT1; Distributed Amount Base: 25.32. Note If the balance distribution amount in Example 2 was 0.02, it would be distributed on OutputLineNo = 40 and OutputLineNo = 10 as these are the first two largest >amounts through the rows."
  },
  "modules/financials/cost-accounting/cost-distribution.html": {
    "href": "modules/financials/cost-accounting/cost-distribution.html",
    "title": "Cost distribution | ERP.net Tech Docs",
    "summary": "Cost distribution The cost distribution document is used to distribute costs. Users may enter one or more cost types and their amounts. The cost distribution may be performed manually or automatically by using the integrated functions. How to use the document? At first, the user has to enter the dates and (if necessary) store, where they are distributing costs. The period of the cost distribution is specified in the cost distribution table by the following fields: Start Date - starting date of the period for which the current document distributes costs. The field cannot be empty and it is entered manually by the user. End Date - end date of the period for which the current document distributes costs. The field cannot be empty and it is entered manually by the user. Store - specifies the store in which the cost is distributed. In the distribution cost types table, the user enters the cost types and their amounts. Note The cost type amounts are entered in enterprise company base currency! The Distributed Cost Amount field accepts decimal values. Then, the user has to enter/load the outputs on which they are distributing the specified amounts and cost types. This is performed in the outputs table. The fields are: Line No - this is the consecutive line number in the document, unique within the document. Cost Object - the ID of the cost object for which costs will be distributed. The domain of the cost object is determined by the distribution document type. Weight Coefficient - the field is mandatory. This is a weight coefficient for the cost distribution on the current row. Manual data entering in the outputs table is not available. The document has a function which automatically loads the outputs for the specified period (and store, if entered). For more information see Add production function. After the production is filled in the document, the cost distribution calculation may be performed manually or automatically. The table cost distribution results contains the amounts calculated for distribution on the outputs data. In the results table, there are the following fields: Output Id - the distribution output over which we are distributing the cost (the amount in the current row); Cost Type - the cost type for which the distribution in the current row is calculated; Distributed Amount Base - the amount (in base currency) of the distributed cost. The amount is calculated for the combination of output and cost type. The data in the results table has a function that calculates distributed amounts on each output. The amount is the total amount (distributed to the current output) of all cost types which are set for distribution. For more information, see Calculate Distribution Function."
  },
  "modules/financials/cost-accounting/index.html": {
    "href": "modules/financials/cost-accounting/index.html",
    "title": "Cost Accounting | ERP.net Tech Docs",
    "summary": "Cost Accounting Add production function Calculate distribution function Cost distribution Distribution business rules Distribution generation procedures"
  },
  "modules/financials/excise/country-specific/bulgaria/excise-administrative-document-e-add-export.html": {
    "href": "modules/financials/excise/country-specific/bulgaria/excise-administrative-document-e-add-export.html",
    "title": "Export of e-ADD file BG1015 | ERP.net Tech Docs",
    "summary": "Export of e-ADD file BG1015 The xml file of e-ADD is exported from the Excise administrative document. https://docs.erp.net/model/entities/Finance.Excise.ExciseAdministrativeDocuments.html The table below lists the sources for the tags of the e-ADD xml file: e-ADD tags Excise Product Code Header DocumentNumber Document.DocumentNumber DocumentDate Document.DocumentDate IsDelayedReporting IsDeferredSubmission IsExciseNote @Exc_Purpose TotalAmountOfExciseDuty SUM(Lines.ExciseAmount) PlaceOfIssue Region TaxWarehouse.First(Store.@Exc_Region) Municipality TaxWarehouse.First(Store.@Exc_Municipality) PostCode TaxWarehouse.First(Store.ContactMechanism(ContactMechanismType=P)) City TaxWarehouse.First(Store.@Exc_City) District TaxWarehouse.First(Store.@Exc_District) Street TaxWarehouse.First(Store.@Exc_Street) StreetNumber TaxWarehouse.First(Store.@Exc_StreetNumber) PersonalDetails Name ReportingPerson.PartyName EGN ReportingPerson.NationalNumber ConsignorTrader Bulstat EnterpriseCompany.Company.RegistrationNumber TraderName EnterpriseCompany.Company.PartyName TraderExciseNumber TaxWarehouse.TraderExciseNumber TaxWarehouseExciseNumber TaxWarehouse.TaxWarehouseExciseNumber AddressDetails Country EnterpriseCompany.Company.@Exc_Country Region EnterpriseCompany.Company.@Exc_Region Municipality EnterpriseCompany.Company.@Exc_Municipality PostCode EnterpriseCompany.Company.ContactMechanism(ContactMechanismType=P) City EnterpriseCompany.Company.@Exc_City District EnterpriseCompany.Company.@Exc_District District = Right(@Exc_District,2) Street EnterpriseCompany.Company.@Exc_Street ConsigneeTrader IsForeigner If(OtherParty.Company.Country.Code='BG',False,True) IdentifyNumber OtherParty.Company.RegistrationNumber TraderName OtherParty.PartyName AddressDetails Country OtherParty.@Exc_Country Region OtherParty.@Exc_Region Municipality OtherParty.@Exc_Municipality PostCode OtherParty.ContactMechanism(ContactMechanismType=P) City OtherParty.@Exc_City District OtherParty.@Exc_District Street OtherParty.@Exc_Street TransportDetails TransportType TransportationVehicle.TransportationMode.Code VehicleRegNo TransportationVehicle.Vehicle.VehicleRegistrationNumber TransporterTrader IsForeigner If(TransportationCarrier.Supplier.Company.Country.Code='BG',False,True) IdentifyNumber TransportationCarrier.Supplier.Company.RegistrationNumber TraderName TransportationCarrier.Supplier.Company.PartyName TransporterCertificateNumber TransportationCarrier.@Exc_TransporterCertificateNumber CertificateDateOfIssue TransportationCarrier.@Exc_TransporterCertificateDateOfIssue CertificateExperationDate TransportationCarrier.@Exc_TransporterCertificateExperationDate Driver Name @Exc_Driver.Description EGN @Exc_Driver.Value DeliveryPlaceDetails IsOTTGObject FALSE DeliveryPlace Country If(DeliveryParty != Null, DeliveryParty.@Exc_Country, OtherParty.@Exc_Country) Region If(DeliveryParty != Null, DeliveryParty.@Exc_Region, OtherParty.@Exc_Region) Municipality If(DeliveryParty != Null, DeliveryParty.@Exc_Municipality, OtherParty.@Exc_Municipality) PostCode If(DeliveryParty != Null, DeliveryParty.ContactMechanism(ContactMechanismType=P), OtherParty.ContactMechanism(ContactMechanismType=P)) City If(DeliveryParty != Null, DeliveryParty.@Exc_City, OtherParty.@Exc_City) District If(DeliveryParty != Null, DeliveryParty.@Exc_District, OtherParty.@Exc_District) Street If(DeliveryParty != Null, DeliveryParty.@Exc_Street, OtherParty.@Exc_Street) eADDGoods eADDGood BrandName Product.ExciseProductType @Exc_BrandName.Value TradeMark Product.ProductName APCode ExciseProduct.Code CNCode Product.ExciseProductType.CommodityCode.CommodityCodeField AdditionalCode If(Product.ProductCodes. ProductCodeField(Where CodingSystem. Name=”ExciseAdditionalCode”) != Null, Product.ProductCodes. ProductCodeField(Where CodingSystem. Name=”ExciseAdditionalCode”) , Product.PartNumber) QuantityOfGoods ExciseQuantity MissingLabelsCnt Null OtherMeasure ExciseQuantityUnit.Code Degree ExciseAlcoholicStrengt Pieces Product.ExciseProductType.Capacity NumberOfPackages Quantity TotalAmountPrice Quantity*Product.@Exc_LabelPrice TaxBase ExciseAmountBase ExciseDuty ExciseDutyRateValue DutyAmount ExciseAmount Payment @Exc_Payment Purpose ExcisePurposeCode.Code MeasureValues ControlPoint MeasuringTransaction.MeasuringDeviceCode TransactionNumber MeasuringTransaction. Transaction number DocumentType IIF(ExciseAdministrativeDocumentLine.@Exc_InputDocumentTypeLine != NULL AND ExciseAdministrativeDocumentLine.@Exc_InputDocumentTypeLine != \"\", ExciseAdministrativeDocumentLine.@Exc_InputDocumentTypeLine, ExciseAdministrativeDocument.@Exc_InputDocumentType) DocumentNumber IIF(ExciseAdministrativeDocumentLine.@Exc_InputDocumentNumberLine != NULL AND ExciseAdministrativeDocumentLine.@Exc_IInputDocumentNumberLine != \"\", ExciseAdministrativeDocumentLine.@Exc_InputDocumentNumberLine, ExciseAdministrativeDocument.@Exc_InputDocumentNumber) The symbol \".\" is used to indicate that a field or data type is being referenced. The symbol \"@xxxx\" is used to indicate a custom property with the code \"xxxx\". If no field reference is specified after it, the custom property's value is used. The symbol \"*\" denotes multiplication."
  },
  "modules/financials/excise/country-specific/bulgaria/excise-declaration-alcohol.html": {
    "href": "modules/financials/excise/country-specific/bulgaria/excise-declaration-alcohol.html",
    "title": "Акзцизна декларация за алкохол и алкохолни изделия | ERP.net Tech Docs",
    "summary": "Акзцизна декларация за алкохол и алкохолни изделия Акцизната декларация е документът, с който се отчита определен период пред митническите органи. https://docs.erp.net/model/entities/Finance.Excise.ExciseDeclarations.html 1. Първоначални настройки 1.1. Дефинира се отделен тип документ за декларацията за алкохол 1.2. Дефинират се следните потребителски характеристики за типа документ и те са задължителни: @Exc_TypeOfDeclaration Тип на акцизна декларация Стойност по подразбиране: EXC002BG @Exc_KindOfDeclaration Вид на акцизна декларация Стойност по подразбиране: EXC00 1. Въвеждане на Акцизна Декларация Въвеждат се следните основни полета: DocumentDate – Дата на съставяне на декларацията. DocumentType – Вид на документа. DocumentNo – Пореден номер на документа. TaxWarehouse – Данъчен склад, за който се изготвя справката. ReportingPerson – Лице, подаващо декларацията. FromDate – Начална дата на периода, за който се подава декларацията. ToDate – Крайна дата на периода, за който се подава декларацията. 2. Експорт на Акцизна Декларация Експортът на XML файл се извършва от уеб панела в акцизния документ на следния адрес: {$rooturl}/legal/customs/excdecl/{Id} Където /legal е относителният URL на Legal BG уебсайта. За експортиране на e-ADD файлове е необходимо наличието на активен Legal BG уебсайт."
  },
  "modules/financials/excise/country-specific/bulgaria/excise-declaration-electricity.html": {
    "href": "modules/financials/excise/country-specific/bulgaria/excise-declaration-electricity.html",
    "title": "Акцизна декларация за електричество | ERP.net Tech Docs",
    "summary": "Акцизна декларация за електричество Акцизната декларация е документът, с който се отчита определен период пред митническите органи. https://docs.erp.net/model/entities/Finance.Excise.ExciseDeclarations.html 1. Първоначални настройки 1.1. Дефинира се отделен тип документ за декларацията за алкохол 1.2. Дефинират се следните потребителски характеристики за типа документ и те са задължителни: @Exc_TypeOfDeclaration Тип на акцизна декларация Стойност по подразбиране: EXC001BG @Exc_KindOfDeclaration Вид на акцизна декларация Стойност по подразбиране: EXC00 1. Въвеждане на Акцизна Декларация Въвеждат се следните основни полета: DocumentDate – Дата на съставяне на декларацията. DocumentType – Вид на документа. DocumentNo – Пореден номер на документа. TaxWarehouse – Данъчен склад, за който се изготвя справката. ReportingPerson – Лице, подаващо декларацията. FromDate – Начална дата на периода, за който се подава декларацията. ToDate – Крайна дата на периода, за който се подава декларацията. 2. Експорт на Акцизна Декларация Експортът на XML файл се извършва от уеб панела в акцизния документ на следния адрес: {$rooturl}/legal/customs/excdecl/{Id} Където /legal е относителният URL на Legal BG уебсайта. За експортиране на e-ADD файлове е необходимо наличието на активен Legal BG уебсайт."
  },
  "modules/financials/excise/country-specific/bulgaria/excise-document-alcohol.html": {
    "href": "modules/financials/excise/country-specific/bulgaria/excise-document-alcohol.html",
    "title": "Акцизен документ за Алкохол и алкохолни напитки | ERP.net Tech Docs",
    "summary": "Акцизен документ за Алкохол и алкохолни напитки За отчитане на приходите и разходите в данъчния склад се използва формата Акцизен данъчен документ. https://docs.erp.net/model/entities/Finance.Excise.ExciseAdministrativeDocuments.html Тук ще опишем как се въвевеждат най често използваните документи за отчитане към митничиските власти. 1. Изготвяне на e-ADD 1.1. В Типа документ @Exc_AAD_Type = 60 @Exc_EntryMethod = 02 1.2. Данни в шапката на Акцизен документ AdministrativeReferenceCode - Референтен код, който се връща от митниците, когато документът се изнася до тях, или референтен код в получени документи - UCN. Попълва се с колекция на документа след като сме получили този номер след експорта. TaxWarehouse - Нашият лицензиран Данъчен склад, за което докладваме на митническите органи. Direction = Issue. Посоката на движение на стоките. Определя дали стоките влизат или излизат от Данъчния склад. AccrueExciseDuty = True. Поле за отметка, което указва, че митническите задължения се начисляват при изписване на стоките от Данъчния склад. IsDeferredSubmission - Означава дали движението е започнало на хартиен административен документ. OtherParty - Другата страна, получаваща стоките. DeliveryParty - Указва субекта, където стоките се изпращат. Празното поле означава, че това е същата страна като \"OtherParty\". TransportationCarrier - Превозвачът, използван за транспортирането на стоките. TransportationVehicle - Превозното средство, използвано за транспортиране на стоките. ReportingPerson - Това е лицет, подаващо документа. **@Exc_Driver.Value** - ЕГН на водача на превозното средстно **@Exc_Driver.Description** - Име на водача на превозното средтво **@Exc_Purpose** - Предназначениe на E-ADD. Номенклатура CL200 **@Exc_InputDocumentType** - Стойността за тага DocumentType в раздела MeasureValues на експортния файл. Условно. **@Exc_InputDocumentNumber** - Стойността за тага DocumentNumber в раздела MeasureValues на експортния файл. Условно. 1.3. Данни в линиите на Акцизен документ Product - Продуктът, който изписваме от данъчния склад. Копира се от складовия документ. Lot - Партида на продукта, ако има. Копира се от складовия документ. Quantity - Количество в мерна единица от складовия документ. Копира се от генериращия складов документ. QuantityUnit - Мерна единица от складовия документ. Например брой бутилки, кашони и други. Може да се избира в логистичните документи според необходимостта. QuantityBase - Кобичество в Базова мерна единица. Основната мерна единица в която се отчитат наличностите в склада. Задава се в дефиницията на продукта. Изчислява се автоматично. ExciseQuantity - Количество в Акцизната мерна единица. Изчислява се автоматично. ExciseQuantityUnit - Акцизна мерна единица. Това е мерната единица, в която се отчитат акцизните продукти пред митническите власти. Определя се от дължавата и зе задава в Тип акцизен продукт. MeasuringTransaction - Транзакция за вход или изход на продукт, измерена със специализирано измервателно устройство за цели на акцизното облагане. Зарежда се автоматично при генериране на партидата в складовата разписка. ExciseProduct - Кодът на Акцизния продукт, дефиниран от данъчните и митническите органи. Той е зададен в типовете на акцизните продукти, които са част от дефиницията на продукта. Зарежда се автоматично при избор на продукта, но може да бъде променен ръчно. ExcisePurposeCode - Предназначението определя различните цели, признати от органите за определяне на ставката на акциза. Задължително. ExciseAlcoholicStrength - Алкохолният градус, който ще се използва за цели на акцизното облагане. Ако е зададена Измервателна транзакция, то Алкохолният градус се взема автоматично от нея при избор на продукта. Ако не е, то Алкохолният градус се взема от типовете на акцизните продукти, които са зададени в дефиницията на продукта. Може да се променя ръчно. ExciseAmountBase - Основата, върху която се изчислява ставката на акциза. Автоматично се изчислява чрез алгоритъм, дефиниран в категориите на акцизните продукти. Категориите на акцизните продукти са част от дефиницията на акцизния продукт. ExciseDutyRate - Справка към конкретната ставка в таблицата за акцизни ставки ExciseDutyRates, която се определя въз основа на избраните Акцизни Продукти, Предназначение и Акцизни мерни единици. ExciseDutyRateValue - Стойността на определената ставка на акциза ExciseDutyRate. ExciseAmount - Изчислената стойност на акциза въз основа на ExciseAmountBase и ExciseDutyRateValue. **@Exc_Payment** - Код на плащането. Задължително. **@Exc_InputDocumentTypeLine** - Тип на входния документ. Стойност за етикета DocumentType в секцията MeasureValues в експортния файл. Ако е празно, се използва Exc_InputDocumentType от заглавието на акцизния документ. Условно поле. **@Exc_InputDocumentNumberLine** - Номер на входния документ. Стойност за етикета DocumentNumber в секцията MeasureValues в експортния файл за eADD. Ако е празно, се използва Exc_InputDocumentNumber от заглавието на акцизния документ. Условно поле. 1.4. Parties Полета в избраните субекти - Собствена фирма, Данъчен склад, Отсрещна страна и Субект за доставка: ContactMechanisms.PostalCode - Пощенски код. **@Exc_Country** – Държава **@Exc_Region** – Район **@Exc_Municipality** – Община **@Exc_City** – Град **@Exc_District** – Квартал **@Exc_Street** – Улица, Номер Субектът на данъчния склад е Складът с най малък Номер на субект измежду складовете в този данъчен склад. 1.5. TransportationCarrier **@Exc_TransporterCertificateNumber** - Номер на сертификат **@Exc_TransporterCertificateDateOfIssue** - Дата на издаване на сертификат **@Exc_TransporterCertificateExperationDate** - Валидност на сертификат 1.6. TransportationVehicle TransportationMode.Code - Типът транспорт Vehicle.VehicleRegistrationNumber - Регистрацианният номер на автомобила 1.7. Експорт на e-ADD файл ​ Експорта на e-ADD файл се прави от WEB панел в Акцизния документ със следния адрес: ​ {$rooturl}/legal/customs/exciseduties/{Id} ​ Където /legal e относителният URL на сайта Legal BG. ​ Необходимо е да има активен Legal BG сайт за да може да се прави експорт на e-ADD файлове. 2. Изготвяне на E-ADD за непристигнали и липсващи изпратени с e-AD Когато се изпратят стоки в друг данъчен склад с e-AD, ако има липси при получаването или стоките не са пристигнали в законнопоределения срок, то следва да се издаде e-ADD за разликата. В този слумай стоките вече са напуснали данъчния склад и съответният Акцизен документ няма да участва при формирането на движение и наличност. 2.1. При установени липси при получаване При установени липси освен посочените в т.1 неща следва да са попълнят следните полета: Попълва се съответно **@Exc_Purpose** за този вид операция. **@Exc_EAD_For_Difference** - това поле се попълва в линията на акцизния документ с Реда от e-AD с което е изпратена стоката. Реда от e-AD е текстов стринг в следния формат: eAD:C02138:10, където eAD - е кода на типа документ C02138 - е номера на документа 10 - е номера на реда Съответно в Акцизната декларация се попълват следните полета за съответнотто e-AD в секцията ***** RemovedGood Difference - количеството от съответния ред в e-ADD за липси. ADDNoForDifference - Номер на съответното e-ADD ADDDateForDifference - Дата на съответното e-ADD 2.2. При непристигнали в 45 дневен срок При непристигнали в 45 дневен срок освен посочените в т.1 неща следва да са попълнят следните полета: Попълва се съответно **@Exc_Purpose** за този вид операция. **@Exc_EAD_For_Not_Received** - това поле се попълва в линията на акцизния документ с Реда от e-AD с което е изпратена стоката. Реда от e-AD е текстов стринг в следния формат: eAD:C02138:10, където eAD - е кода на типа документ C02138 - е номера на документа 10 - е номера на реда ​ Съответно в Акцизната декларация се попълват следните полета за съответнотто e-AD в секцията ***** RemovedGood ​ PaidAkcizQuantity - Количеството от съответния ред в e-ADD за непристигнали ​ PaidAkcizDocument - Дата на съответното e-ADD ​ PaidAkcizDocDate - Дата на съответното e-ADD ​ 2.3. При Кредитно за непристигнали в 45 дневен срок ​ При кредитно за непристигнали в 45 дневен срок освен посочените в т.1 неща следва да са попълнят следните полета: Попълва се съответно **@Exc_Purpose** за този вид операция. **@Exc_EAD_For_Not_Received** - това поле се попълва в линията на акцизния документ с Реда от e-AD с което е изпратена стоката. Реда от e-AD е текстов стринг в следния формат: eAD:C02138:10, където eAD - е кода на типа документ C02138 - е номера на документа 10 - е номера на реда ​ Съответно в Акцизната декларация се попълват следните полета за съответнотто e-AD в секцията ***** RemovedGood ​ PaidAkcizQuantity - Сумата от количествата от съответните редове от e-ADD за непристигнали и кредитно за тях. Трябва да е нула след кредитно ​ PaidAkcizDocument - Не се визуализира, ако PaidAkcizQuantity = 0 ​ PaidAkcizDocDate - Не се визуализира, ако PaidAkcizQuantity = 0 3. Въвеждане на е-AD при получаване Получените е-AD не се експортират и затова са необходими данни само за да влязат в Дневник на складовите наличности. 3.1. В Типа документ @Exc_AAD_Type = 100 @Exc_EntryMethod = 01 3.2. Данни в шапката на Акцизен документ AdministrativeReferenceCode - Референтен код от митниците - APK. TaxWarehouse - Нашият лицензиран Данъчен склад, за което докладваме на митническите органи. Direction = Receipt. Посоката на движение на стоките. Определя дали стоките влизат или излизат от Данъчния склад. AccrueExciseDuty = False. Поле за отметка, което указва, че митническите задължения се начисляват при изписване на стоките от Данъчния склад. OtherParty - Другата страна, изпращаща стоките. 3.3. Данни в линиите на Акцизен документ Product - Продуктът, който изписваме от данъчния склад. Копира се от складовия документ. Lot - Партида на продукта, ако има. Копира се от складовия документ. Quantity - Количество в мерна единица от складовия документ. Копира се от генериращия складов документ. QuantityUnit - Мерна единица от складовия документ. Например брой бутилки, кашони и други. Може да се избира в логистичните документи според необходимостта. QuantityBase - Кобичество в Базова мерна единица. Основната мерна единица в която се отчитат наличностите в склада. Задава се в дефиницията на продукта. Изчислява се автоматично. ExciseQuantity - Количество в Акцизната мерна единица. Изчислява се автоматично. ExciseQuantityUnit - Акцизна мерна единица. Това е мерната единица, в която се отчитат акцизните продукти пред митническите власти. Определя се от дължавата и зе задава в Тип акцизен продукт. MeasuringTransaction - Транзакция за вход или изход на продукт, измерена със специализирано измервателно устройство за цели на акцизното облагане. Зарежда се автоматично при генериране на партидата в складовата разписка. ExciseProduct - Кодът на Акцизния продукт, дефиниран от данъчните и митническите органи. Той е зададен в типовете на акцизните продукти, които са част от дефиницията на продукта. Зарежда се автоматично при избор на продукта, но може да бъде променен ръчно. ExcisePurposeCode - Предназначението определя различните цели, признати от органите за определяне на ставката на акциза. Задължително. ExciseAlcoholicStrength - Алкохолният градус, който ще се използва за цели на акцизното облагане. Ако е зададена Измервателна транзакция, то Алкохолният градус се взема автоматично от нея при избор на продукта. Ако не е, то Алкохолният градус се взема от типовете на акцизните продукти, които са зададени в дефиницията на продукта. Може да се променя ръчно. 4. Изготвяне на вътрешно складови документи за производство Вътрешно складовите документи от производство за разход и приход не се експортират и затова са необходими данни само за да влязат в Дневник на складовите наличности. Вътрешно складовите документи, , като Стокови транфери, които не преобразуват продукти, а само се местят вътре в рамките на Данъчния склад няма нужда да се рапортуват и да влизат в Акцизен документ. 4.1. В Типа документ @Exc_AAD_Type = 40 @Exc_EntryMethod = 02 - Използва се само при приход. При разход не се гледа. 4.2. Данни в шапката на Акцизен документ TaxWarehouse - Нашият лицензиран Данъчен склад, за което докладваме на митническите органи. Direction Посоката на движение на стоките. Определя дали стоките влизат или излизат от Данъчния склад. AccrueExciseDuty = False. Поле за отметка, което указва, че митническите задължения се начисляват при изписване на стоките от Данъчния склад. OtherParty - Другата страна, изпращаща стоките. Избира се субекта на Собствената фирма. 4.3. Данни в линиите на Акцизен документ Product - Продуктът, който изписваме от данъчния склад. Копира се от складовия документ. Lot - Партида на продукта, ако има. Копира се от складовия документ. Quantity - Количество в мерна единица от складовия документ. Копира се от генериращия складов документ. QuantityUnit - Мерна единица от складовия документ. Например брой бутилки, кашони и други. Може да се избира в логистичните документи според необходимостта. QuantityBase - Кобичество в Базова мерна единица. Основната мерна единица в която се отчитат наличностите в склада. Задава се в дефиницията на продукта. Изчислява се автоматично. ExciseQuantity - Количество в Акцизната мерна единица. Изчислява се автоматично. ExciseQuantityUnit - Акцизна мерна единица. Това е мерната единица, в която се отчитат акцизните продукти пред митническите власти. Определя се от дължавата и зе задава в Тип акцизен продукт. MeasuringTransaction - Транзакция за вход или изход на продукт, измерена със специализирано измервателно устройство за цели на акцизното облагане. Зарежда се автоматично при генериране на партидата в складовата разписка. ExciseProduct - Кодът на Акцизния продукт, дефиниран от данъчните и митническите органи. Той е зададен в типовете на акцизните продукти, които са част от дефиницията на продукта. Зарежда се автоматично при избор на продукта, но може да бъде променен ръчно. ExciseAlcoholicStrength - Алкохолният градус, който ще се използва за цели на акцизното облагане. Ако е зададена Измервателна транзакция, то Алкохолният градус се взема автоматично от нея при избор на продукта. Ако не е, то Алкохолният градус се взема от типовете на акцизните продукти, които са зададени в дефиницията на продукта. Може да се променя ръчно. 5. Изготвяне на E-AD за изпращане E-AD, които се изпращат влизат в Акцизна декларация и може да се експортират към Митническите власти. За целите на декларацията се попълват следните неща. 4.1. В Типа документ @Exc_AAD_Type = 100 4.2. Данни в шапката на Акцизен документ AdministrativeReferenceCode - Референтен код, който се връща от митниците, когато документът се изнася до тях, или референтен код в получени документи - APK. Попълва се с колекция на документа след като сме получили този номер след експорта. TaxWarehouse - Нашият лицензиран Данъчен склад, за което докладваме на митническите органи. Direction = Issue. Посоката на движение на стоките. Определя дали стоките влизат или излизат от Данъчния склад. AccrueExciseDuty = True. Поле за отметка, което указва, че митническите задължения се начисляват при изписване на стоките от Данъчния склад. Ще влезе в секцията ExciseGoods. OtherParty - Другата страна, получаваща стоките. **@Exc_Purpose** - Предназначениe на E-ADD. Задължително. 4.3. Данни в линиите на Акцизен документ Product - Продуктът, който изписваме от данъчния склад. Копира се от складовия документ. Lot - Партида на продукта, ако има. Копира се от складовия документ. Quantity - Количество в мерна единица от складовия документ. Копира се от генериращия складов документ. QuantityUnit - Мерна единица от складовия документ. Например брой бутилки, кашони и други. Може да се избира в логистичните документи според необходимостта. QuantityBase - Кобичество в Базова мерна единица. Основната мерна единица в която се отчитат наличностите в склада. Задава се в дефиницията на продукта. Изчислява се автоматично. ExciseQuantity - Количество в Акцизната мерна единица. Изчислява се автоматично. ExciseQuantityUnit - Акцизна мерна единица. Това е мерната единица, в която се отчитат акцизните продукти пред митническите власти. Определя се от дължавата и зе задава в Тип акцизен продукт. MeasuringTransaction - Транзакция за вход или изход на продукт, измерена със специализирано измервателно устройство за цели на акцизното облагане. Зарежда се автоматично при генериране на партидата в складовата разписка. ExciseProduct - Кодът на Акцизния продукт, дефиниран от данъчните и митническите органи. Той е зададен в типовете на акцизните продукти, които са част от дефиницията на продукта. Зарежда се автоматично при избор на продукта, но може да бъде променен ръчно. ExcisePurposeCode - Предназначението определя различните цели, признати от органите за определяне на ставката на акциза. Задължително. ExciseAlcoholicStrength - Алкохолният градус, който ще се използва за цели на акцизното облагане. Ако е зададена Измервателна транзакция, то Алкохолният градус се взема автоматично от нея при избор на продукта. Ако не е, то Алкохолният градус се взема от типовете на акцизните продукти, които са зададени в дефиницията на продукта. Може да се променя ръчно. ExciseAmountBase - Основата, върху която се изчислява ставката на акциза. Автоматично се изчислява чрез алгоритъм, дефиниран в категориите на акцизните продукти. Категориите на акцизните продукти са част от дефиницията на акцизния продукт. ExciseDutyRate - Справка към конкретната ставка в таблицата за акцизни ставки ExciseDutyRates, която се определя въз основа на избраните Акцизни Продукти, Предназначение и Акцизни мерни единици. ExciseDutyRateValue - Стойността на определената ставка на акциза ExciseDutyRate. ExciseAmount - Изчислената стойност на акциза въз основа на ExciseAmountBase и ExciseDutyRateValue. **@Exc_Payment** - Код на плащането. Задължително."
  },
  "modules/financials/excise/country-specific/bulgaria/excise-document-electricity.html": {
    "href": "modules/financials/excise/country-specific/bulgaria/excise-document-electricity.html",
    "title": "Акцизен документ за Електричество | ERP.net Tech Docs",
    "summary": "Акцизен документ за Електричество За отчитане на приходите и разходите в данъчния склад се използва формата Акцизен данъчен документ. https://docs.erp.net/model/entities/Finance.Excise.ExciseAdministrativeDocuments.html Тук ще опишем как се въвевеждат най често използваните документи за отчитане към митничиските власти. 1. Първоначални настройки 1.1. В Категория акцизни продукти в Алгоритъм за изчисление се указва Количество 1.2. Трябва да се дефинира данъчен склад, дори и регистрацията да не е Данъчен склад. В данъчния склад се записват основните дефиниции на регистрираното лице: Акцизен номер на търговеца Акцизен номер на данъчния склад - попълва се същия, като на търговеца, ако регистрацията не е за данъчен скрлад Тип на лицето - това на типа на регистрацията на търговеца. Митническо управление - това е кода на митническото управление 1.3. Дефитиране на Тип акцизен продукт Акцизен продукт - Акцизен продукт спорен номенкатурата. Най често това е E12 Мерна единица – Акцизна мерна единиза от номенклатурата на митниците. Мерна единица с код KWH. Хармонизиран стоков код – Код по КН от номенклатурата на митниците. Вместимост - оставя се празно Търговско наименование - незадължително. 2. Изготвяне на e-ADD 2.1. Данни в шапката на Акцизен документ AdministrativeReferenceCode - Референтен код, който се връща от митниците, когато документът се изнася до тях, или референтен код в получени документи - UCN. Попълва се с колекция на документа след като сме получили този номер след експорта. TaxWarehouse - Нашият лицензиран Данъчен склад, за което докладваме на митническите органи. Direction = Issue. Посоката на движение на стоките. Определя дали стоките влизат или излизат от Данъчния склад. AccrueExciseDuty = True. Поле за отметка, което указва, че митническите задължения се начисляват при изписване на стоките от Данъчния склад. IsDeferredSubmission - Означава дали движението е започнало на хартиен административен документ. OtherParty - Партито на собствената фирма DeliveryParty - Празно TransportationCarrier - Празно TransportationVehicle - Празно ReportingPerson - Това е лицет, подаващо документа. **@Exc_Purpose** - Предназначениe на E-ADD. Номенклатура CL200 2.2. Данни в линиите на Акцизен документ Product - Продуктът, който изписваме от данъчния склад. Копира се от складовия документ. Quantity - Количество в мерна единица от складовия документ. Копира се от генериращия складов документ. QuantityUnit - Мерна единица от складовия документ. Например брой бутилки, кашони и други. Може да се избира в логистичните документи според необходимостта. QuantityBase - Кобичество в Базова мерна единица. Основната мерна единица в която се отчитат наличностите в склада. Задава се в дефиницията на продукта. Изчислява се автоматично. ExciseQuantity - Количество в Акцизната мерна единица. Изчислява се автоматично. ExciseQuantityUnit - Акцизна мерна единица. Това е мерната единица, в която се отчитат акцизните продукти пред митническите власти. Определя се от дължавата и зе задава в Тип акцизен продукт. MeasuringTransaction - Транзакция за вход или изход на продукт, измерена със специализирано измервателно устройство за цели на акцизното облагане. Зарежда се автоматично при генериране на партидата в складовата разписка. ExciseProduct - Кодът на Акцизния продукт, дефиниран от данъчните и митническите органи. Той е зададен в типовете на акцизните продукти, които са част от дефиницията на продукта. Зарежда се автоматично при избор на продукта, но може да бъде променен ръчно. ExcisePurposeCode - Предназначението определя различните цели, признати от органите за определяне на ставката на акциза. Задължително. ExciseAmountBase - Основата, върху която се изчислява ставката на акциза. Автоматично се изчислява чрез алгоритъм, дефиниран в категориите на акцизните продукти. Категориите на акцизните продукти са част от дефиницията на акцизния продукт. ExciseDutyRate - Справка към конкретната ставка в таблицата за акцизни ставки ExciseDutyRates, която се определя въз основа на избраните Акцизни Продукти, Предназначение и Акцизни мерни единици. ExciseDutyRateValue - Стойността на определената ставка на акциза ExciseDutyRate. ExciseAmount - Изчислената стойност на акциза въз основа на ExciseAmountBase и ExciseDutyRateValue. **@Exc_Payment** - Код на плащането. Задължително. 1.4. Parties Полета в избраните субекти - Собствена фирма, Данъчен склад: ContactMechanisms.PostalCode - Пощенски код. **@Exc_Country** – Държава **@Exc_Region** – Район **@Exc_Municipality** – Община **@Exc_City** – Град **@Exc_District** – Квартал **@Exc_Street** – Улица, Номер Субектът на данъчния склад е Складът с най малък Номер на субект измежду складовете в този данъчен склад. Тоест задължително трябва да се направи склад, въпреки, че електричеството не се складира. 1.7. Експорт на e-ADD файл ​ Експорта на e-ADD файл се прави от WEB панел в Акцизния документ със следния адрес: ​ {$rooturl}/legal/customs/exciseduties/{Id} ​ Където /legal e относителният URL на сайта Legal BG. ​ Необходимо е да има активен Legal BG сайт за да може да се прави експорт на e-ADD файлове."
  },
  "modules/financials/excise/country-specific/bulgaria/excise-stamp-operation.html": {
    "href": "modules/financials/excise/country-specific/bulgaria/excise-stamp-operation.html",
    "title": "Excise stamp operation | ERP.net Tech Docs",
    "summary": "Excise stamp operation Excise stamp operation e документ с който се отчита движение на бандероли предоставени от Митническите власти на отчитания данъчен склад."
  },
  "modules/financials/excise/country-specific/bulgaria/index.html": {
    "href": "modules/financials/excise/country-specific/bulgaria/index.html",
    "title": "Bulgaria | ERP.net Tech Docs",
    "summary": "Bulgaria Excise stamp operation Export of Excise Declaration file Export of e-ADD file BG1015 Initial Setup Акзцизна декларация за алкохол и алкохолни изделия Акцизен документ за Алкохол и алкохолни напитки Акцизен документ за Електричество Акцизна декларация за електричество"
  },
  "modules/financials/excise/country-specific/bulgaria/setup.html": {
    "href": "modules/financials/excise/country-specific/bulgaria/setup.html",
    "title": "Initial Setup | ERP.net Tech Docs",
    "summary": "Initial Setup 1. System attributes 1.1. Measurement units The measurement units codes of Excise Measurement Unit in Excise Product Type should be defined according the CL1 nomenclature. Base Measurement Unit could be any. 1.2. Excise Product Type In the products must be defined Excise Product Type and the measurement unit in the Excise Product Type must be measurement unit used in article 28 and article 29 from law on excises and tax warehouses 1.3. Code system ”ExciseAdditionalCode” It is used for Additional code. 3. Custom properties It must be defined custom attributes with the following codes 3.1. ExciseProductType Exc_BrandName - Allowed values from CL175 nomenclature. Limited to allowed values 3.2. Documents Exc_Purpose - Allowed values from the CL200 nomenclature. Limited to allowed values. Used in the Excise Document. Mandatory. Exc_Driver - In the Property Value field, the national number of the vehicle is entered, and in the Property Description field, the name of the driver is entered. Used in the Excise Document. Mandatory. Exc_InputDocumentType - The value for the DocumentType tag in the MeasureValues section of the export file. Conditional. Exc_InputDocumentNumber - The value for the DocumentNumber tag in the MeasureValues section of the export file for eADD. Conditional. Exc_RefNumberOfCorrectedDeclaration - The number of the corrected declaration. Used in the Excise Declaration. Not mandatory. Exc_DelayReferenceNumber - The number of the resolution for delay. Used in the Excise Declaration. Not mandatory. Exc_KindOfDeclaration - Kind of declaration. Allowed values from the CL166 nomenclature. Exc_TypeOfDeclaration - Type of declaration. Allowed values from the CL132 nomenclature. Exc_Protocol_Date - Protocol date - Used for Excise Labels findings. Exc_Protocol_Number - Protocol Number - Used for Excise Labels findings. 3.3. ExciseAdministrativeDocumentLines Exc_Payment - Allowed values are from the CL163 nomenclature and are limited to the allowed values. Mandatory field. Exc_InputDocumentTypeLine - Type of the input document. Value for tag DocumentType in section MeasureValues in the export file. If empty, Exc_InputDocumentType from the header of the excise document is used. Conditional field. Exc_InputDocumentNumberLine - Number of the input document. Value for tag DocumentNumber in section MeasureValues in the export file for eADD. If empty, Exc_InputDocumentNumber from the header of the excise document is used. Conditional field. The following two characteristics: Exc_EAD_For_Difference - Number of e-AD for differences. Conditional field. Exc_EAD_For_Not_Received - Number of e-AD for not received. Conditional field. are used to fill in the following tags from the RemovedGood section of the Excise Declaration: ​ Difference ​ ADDNoForDifference ​ ADDDateForDifference ​ PaidAkcizDocument ​ PaidAkcizDocDate ​ PaidAkcizQuantity The purpose is to indicate in the current e-ADD for differences or not received for which e-ADDs it is issued. 3.4. Parties Exc_Country – Allowed values from CL8 nomenclature Exc_Region – Allowed values from CL1101 nomenclature Exc_Municipality – Allowed values from CL1102 nomenclature Exc_City – Allowed values from CL1103 nomenclature Exc_District – Allowed values from CL1104 nomenclature Exc_Street – Street, Number – Text 3.5. DocumentTypes Exc_AAD_Type - За тага DocumentType в ***** RemovedGood и ***** StoredGood в WarehouseStockLog. Номенклатура CL164. Exc_EntryMethod - За тага GoodsEntryMethod в ***** StoredGood в WarehouseStockLog. Номенклатура CL165. 3.6. Stores Exc_LegalReports - If Exc_LegalReports = 1 then include Store in Logistic Reports for Customs 3.7. TransportationCarrier Exc_TransporterCertificateDateOfIssue - Transporter Certificate Date OfIssue Exc_TransporterCertificateExperationDate - Transporter Certificate Experation Date Exc_TransporterCertificateNumber - Transporter Certificate Number 3.8. Tax Warehouse Exc_Legal_Entity - Legal Entity. Номенклатура CL131. 4. Custom attributes for e-AD 4.1. Parties Exc_Trader_Excise_Number - Excise number of the trader Exc_EORI - EORI number Exc_StreetNumber - Number Exc_Nad_Lng - Language code Exc_Tax_Warehouse_Excise_Number - Excise number of the tax warehouse Exc_Custom_Office - Number of the customs office Exc_Member_State_Code - Code of the member state Exc_Certificate_Of_Exemption - Serial number of the certificate of exemption for the organization 4.2. Documents Exc_Commercial_Seal_Identification - Identification of commercial seal Exc_TD_Complementary_Information - Transport complementary information Exc_TD_Complementary_Information_LNG - Language of transport complementary information Exc_Seal_Information - Seal information Exc_Seal_Information_LNG - Language of seal information Exc_Invoice_Number - Invoice number Exc_Invoice_Date - Invoice date Exc_Origin_Type_Code - Code of origin type Exc_Date_Of_Dispatch - Date of dispatch Exc_Time_Of_Dispatch - Time of dispatch Exc_Import_SAD_Number - Customs declaration number for import Exc_Destination_Type_Code - Code of destination type Exc_Journey_Time - Duration of transport Exc_Transport_Arrangement - Code of transport arrangement organization Exc_TM_Complementary_Information - Transport type complementary information Exc_TM_Complementary_Information_LNG - Language of transport type complementary information Exc_Guarantor_Type_Code - Code of the type of guarantor Exc_EAD_LNG - Language of e-AD Exc_Dispatch_Import_Office - Code of import customs office Exc_Certificate_Document_Type - Certificate document type Exc_Certificate_Document_Reference - Certificate document number Exc_Certificate_Document_Description - Certificate document description Exc_Certificate_Reference_Of_Document - Certificate reference of document Exc_Tax_Warehouse_Other_Party - Tax warehouse counterparty Exc_Guarantor - Merchant providing the guarantee Exc_Transport_Arranger - Merchant Transport Organizer ​ 4.3. ExciseAdministrativeDocumentLines Exc_Gross_Weight - Gross weight Exc_Net_Weight - Net weight 4.4. ExciseProductType Exc_Kind_Of_Packages - Code of the kind of packaging Exc_Wine_Product_Category - Category of wine product Exc_Wine_Growing_Zone_Code - Code of the wine-growing zone Exc_Third_Country_Of_Origin - Third country of origin Exc_Wine_Operation_Code - Code of wine operation. 4.5. TransportationVehicles Exc_Transport_Units_Code - Transport unit code"
  },
  "modules/financials/excise/country-specific/bulgaria/еxcise-declaration-export.html": {
    "href": "modules/financials/excise/country-specific/bulgaria/еxcise-declaration-export.html",
    "title": "Export of Excise Declaration file | ERP.net Tech Docs",
    "summary": "Export of Excise Declaration file The xml file of Excise Declaration is exported from the Excise declaration. https://docs.erp.net/model/entities/Finance.Excise.ExciseDeclarations.html The table below lists the sources for the tags of the Excise declaration xml file: Excise declaration tags Source Declaration KindOfDeclaration IF (@Exc_KindOfDeclaration != Null, @Exc_KindOfDeclaration, \"EXC00\") TypeOfDeclaration IF (@Exc_TypeOfDeclaration != Null, @Exc_TypeOfDeclaration, \"EXC002BG\") IsCorrectionDeclaration IF (RefNumberOfCorrectedDeclaration != Null, True, False) RefNumberOfCorrectedDeclaration @Exc_RefNumberOfCorrectedDeclaration IsDelayedReporting IF(@Exc_DelayReferenceNumber != Null, True, False) DelayReferenceNumber @Exc_DelayReferenceNumber PreparationDate ExciseDeclaration.DocumentDate CustomsOffice ExciseDeclaration.TaxWarehouse.CustomsOffice TotalAmountOfExciseDuty SUM ExciseGoods ( If Payment = 10, DutyAmount; If Payment = 40, - DutyAmount; IF Payment<> 10 and 40, 0) Customer LegalEntity ExciseDeclaration.TaxWarehouse.@Exc_Legal_Entity ExciseNumber ExciseDeclaration.TaxWarehouse.TaxWarehouseExciseNumber SIC MISSING NotificationNumber MISSING Declarer Name ExciseDeclaration.ReportingPerson.PartyName.GetLanguageStringOrAny(\"bg\") EGN ExciseDeclaration.ReportingPerson.NationalNumber ReportingPeriod ReceivingDate MISSING TaxPeriod Start ExciseDeclaration.FromDate End ExciseDeclaration.ToDate AppliedDocuments AppliedDocument DocumentType 10 PurposeOfeAD MISSING Description MISSING DocumentNumber EXC102BG DocumentDate ExciseDeclaration.ToDate ExciseGoods ExciseGood BrandName ExciseDeclarationLine.Product.ExciseProductType.@Exc_BrandName.Value Trademark ExciseDeclarationLine.Product.Name APCode ExciseDeclarationLine.ExciseProduct.Code CNCode ExciseDeclarationLine.Product.ExciseProductType.CommodityCode.CommodityCodeField Measure ExciseDeclarationLine.ExciseQuantityUnit.Name AdditionalCode If(ExciseDeclarationLine.Product.ProductCodes. ProductCodeField(Where CodingSystem. Name=”ExciseAdditionalCode”) != Null, ExciseDeclarationLine.Product.ProductCodes. ProductCodeField(Where CodingSystem. Name=”ExciseAdditionalCode”) , ExciseDeclarationLine.Product.PartNumber) QuantityOfGoods ExciseDeclarationLine.ExciseQuantity IntendedUseOfProduct ExciseDeclarationLine.Document.@Exc_Purpose.Value Purpose ExciseDeclarationLine.ExcisePurposeCode.Code DutyAmount ExciseDeclarationLine.ExciseAmount Payment ExciseDeclarationLine.@Exc_Payment.Value + \"-\" + ExciseDeclarationLine.@Exc_Payment.Description PaidDuty IF(PaidDuty = 10 or PaidDuty = 40, ExciseDeclarationLine.ExciseAmount, \"0.00\") Pieces ExciseDeclarationLine.Product.ExciseProductType.Capacity NumberOfPackages ExciseDeclarationLine.Quantity Degree If (ExciseDeclarationLine.ExciseAlcoholicStrength is not Null, ExciseDeclarationLine.ExciseAlcoholicStrength, 0) TaxBase ExciseDeclarationLine.ExciseAmountBase WarehouseStockLog WarehouseGoods WarehouseGood BrandName Product.@Exc_BrandName.Value TradeName Product.ProductName CNCode Product.IntrastatCommodityCode.CommodityCodeField AdditionalCode If(ExciseDeclarationLine.Product.ProductCodes. ProductCodeField(Where CodingSystem. Name=”ExciseAdditionalCode”) != Null, ExciseDeclarationLine.Product.ProductCodes. ProductCodeField(Where CodingSystem. Name=”ExciseAdditionalCode”) , ExciseDeclarationLine.Product.PartNumber) APCode ExciseProduct.Code Degree AverageDegree = If (InitialQuantity + QuantityInPeriod) == 0 Then ExciseProductType.AlcoholicStrength Else (InitialDegree + AverageDegreeInPeriod)/(InitialQuantity + QuantityInPeriod) Where InitialDegree = (IF ExciseAdministrativeDocument.Direction = \"R\" AND ExciseAdministrativeDocument.DocumentDate < FromDate THEN SUМ(ExciseQuantity*ExciseAlcoholicStrength) IF ExciseAdministrativeDocument.Direction = \"I\" ExciseAdministrativeDocument.DocumentDate < FromDate THEN SUМ(ExciseQuantity*ExciseAlcoholicStrength)) InitialQuantity = (IF ExciseAdministrativeDocument.Direction = \"R\" AND ExciseAdministrativeDocument.DocumentDate < FromDate THEN SUМ(ExciseQuantity) IF ExciseAdministrativeDocument.Direction = \"I\" ExciseAdministrativeDocument.DocumentDate < FromDate THEN SUМ(ExciseQuantity)) AverageDegreeInPeriod = IF ExciseAdministrativeDocument.Direction = \"R\" AND ExciseAdministrativeDocument.DocumentDate >= FromDate AND ExciseAdministrativeDocument.DocumentDate <= ToDate THEN SUМ(ExciseQuantity*ExciseAlcoholicStrength) QuantityInPeriod = IF ExciseAdministrativeDocument.Direction = \"R\" AND ExciseAdministrativeDocument.DocumentDate >= FromDate AND ExciseAdministrativeDocument.DocumentDate <= ToDate THEN SUМ(ExciseQuantity) Pieces IF EXISTS(MeasurementUnit((IsDefaultUnit == True) && (MeasurementCategory == ExciseAdministrativeDocumentLine.Product.BaseMeasurementCategory) && (MeasurementUnitCode == \"PCE\")) THEN ExciseDeclarations.WarehouseGoods.Pieces = ExciseAdministrativeDocumentLine.Product.ExciseProductTypes.Capacity and is exported ELSE NOT exported Measure ExciseQuantityUnit.Code InitialAmount SUM(QuantityBase) WHERE For Each Product - ExciseAdministrativeDocument.DocumentDate < ExciseDeclaration.FromDate - ExciseAdministrativeDocument is Non Voided And Status >= 30 - If ExciseAdministrativeDocument.Direction = \"I\" THEN SUM(-QuantityBase) FinalAmount SUM(ExciseQuantity) WHERE For Each Product - ExciseAdministrativeDocument.DocumentDate <= ExciseDeclaration.ToDate - ExciseAdministrativeDocument is Non Voided And Status >= 30 - If ExciseAdministrativeDocument.Direction = \"I\" THEN SUM(-QuantityBase) -(ExciseAdministrativeDocumentLine.@Exc_EAD_For_Difference <> NULL OR \"\") AND (ExciseAdministrativeDocumentLine.@Exc_EAD_For_Not_Received <> NULL OR \"\") IntroducedAmount SUM(QuantityBase) WHERE For Each Product - ExciseAdministrativeDocument.DocumentDate >= ExciseDeclaration.FromDate - ExciseAdministrativeDocument.DocumentDate <= ExciseDeclaration.ToDate - ExciseAdministrativeDocument is Non Voided And Status >= 30 - ExciseAdministrativeDocument.Direction = \"R\" RemovedAmount RemovedAmount = SUM(QuantityBase) WHERE For Each Product - ExciseAdministrativeDocument.DocumentDate >= ExciseDeclaration.FromDate - ExciseAdministrativeDocument.DocumentDate <= ExciseDeclaration.ToDate - ExciseAdministrativeDocument.@Exc_Purpose <> 27,90 or 97 (all others except these three) - ExciseAdministrativeDocument is Non Voided And Status >= 30 - ExciseAdministrativeDocument.Direction = \"I\" -(ExciseAdministrativeDocumentLine.@Exc_EAD_For_Difference <> NULL OR \"\") AND (ExciseAdministrativeDocumentLine.@Exc_EAD_For_Not_Received <> NULL OR \"\") TransportationLosses 0 StorageLosses 0 StoredGoods StoredGood DeclaredGoodsQuantity ExciseQuantity ActualStoredGoods ExciseQuantity DocumentType ExciseAdministrativeDocument.DocumentType.@Exc_AAD_Type DocumentNumber If AdministrativeReferenceCode is not NULL THEN DocumentNumber = ExciseAdministrativeDocument.AdministrativeReferenceCode ELSE DocumentNumber = ExciseAdministrativeDocument.DocumentNumber DocumentDate If ReferenceDate is not NULL THEN DocumentDate = ExciseAdministrativeDocument.ReferenceDate ELSE DocumentDate = ExciseAdministrativeDocument.DocumentDate ControlPoint ExciseAdministrativeDocumentLine.MeasuringTransaction.MeasuringDeviceCode TransactionNumber ExciseAdministrativeDocumentLine.MeasuringTransaction.TransactionNumber RealDateIn ExciseAdministrativeDocument.DocumentDate GoodsEntryMethod ExciseAdministrativeDocument.DocumentType.@Exc_EntryMethod GoodProperty 0 OwnerShip Null NumberOfPackages IF ExciseAdministrativeDocumentLine.Product.BaseMeasurementCategory.DefaultMeasurementUnits.Code = \"PCE\" THEN NumberOfPackages = „QuantityBase\" IF Product.BaseMeasurementCategory.DefaultMeasurementUnits.Code <> \"PCE\", THEN NumberOfPackages = Null RemovedGoods RemovedGood QuantityToRemove ExciseQuantity DocumentType ExciseAdministrativeDocument.DocumentType.@Exc_AAD_Type DocumentNumber ExciseAdministrativeDocument.DocumentNumber DocumentDate ExciseAdministrativeDocument.DocumentDate ControlPoint ExciseAdministrativeDocumentLine.MeasuringTransaction.MeasuringDeviceCode TransactionNumber ExciseAdministrativeDocumentLine.MeasuringTransaction.TransactionNumber ProductPurpose ExciseAdministrativeDocument.@Exc_Purpose GoodProperty 0 PaidAkcizQuantity PaidAkcizQuantity = SUM(ExciseAdministrativeDocumentLines.QuantityToRemove) WHERE ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.AccrueExciseDuty = True ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.Direction = \"I\" DetermineLine(ExciseAdministrativeDocumentLines.@Exc_EAD_For_Not_Received) = Current(ExciseAdministrativeDocumentLine) OwnerShip Null DocumentReturnDate Null Difference Difference = SUM(ExciseAdministrativeDocumentLines.QuantityToRemove) WHERE ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.AccrueExciseDuty= True ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.Direction = \"I\" DetermineLine(ExciseAdministrativeDocumentLines.@Exc_EAD_For_Difference) = Current(ExciseAdministrativeDocumentLine) ADDNoForDifference ADDNoForDifference = FIRST(ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.DocumentNumber) WHERE ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.AccrueExciseDuty = True ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.Direction = \"I\" DetermineLine(ExciseAdministrativeDocumentLines.@Exc_EAD_For_Difference) = Current(ExciseAdministrativeDocumentLine) ADDDateForDifference ADDDateForDifference = FIRST(ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.DocumentDate) WHERE ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.AccrueExciseDuty = True ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.Direction = \"I\" DetermineLine(ExciseAdministrativeDocumentLines.@Exc_EAD_For_Difference) = Current(ExciseAdministrativeDocumentLine) PaidAkcizDocument PaidAkcizDocument = FIRST(ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.DocumentNumber) WHERE ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.AccrueExciseDuty = True ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.Direction = \"I\" DetermineLine(ExciseAdministrativeDocumentLines.@Exc_EAD_For_Not_Received) = Current(ExciseAdministrativeDocumentLine) PaidAkcizDocDate PaidAkcizDocDate = FIRST(ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.DocumentDate) WHERE ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.AccrueExciseDuty = True ExciseAdministrativeDocumentLines.ExciseAdministrativeDocument.Direction = \"I\" DetermineLine(ExciseAdministrativeDocumentLines.@Exc_EAD_For_Not_Received) = Current(ExciseAdministrativeDocumentLine) NumberOfPackages IF ExciseAdministrativeDocumentLine.Product.BaseMeasurementCategory.DefaultMeasurementUnits.Code = \"PCE\" THEN NumberOfPackages = „QuantityBase\" IF Product.BaseMeasurementCategory.DefaultMeasurementUnits.Code <> \"PCE\", THEN NumberOfPackages = Null DocumentNumberForReducedRate Null ExciseLabels ExciseLabel LabelType ExciseStampOperationLines.ExciseStampType.Category CNCode ExciseStampOperationLines.ExciseProductType.CommodityCode.CommodityCodeField APCode ExciseStampOperationLines.ExciseProductType.ExciseProduct.Code TradeName ExciseStampOperationLines.ExciseProductType.@Exc_BrandName MeasureUnit ExciseStampOperationLines.ExciseProductType.MeasurementUnit Capacity ExciseStampOperationLines.ExciseProductType.Capacity AlcoholicStrength ExciseStampOperationLines.ExciseProductType.AlcoholicStrength AvailableNotGluedBeginningCount Box1_Availabulity_Begin = SUM(ExciseStampOperationLines.Quantity if ExciseStampOperation.ExciseStampOperationType.Box1Effect = 'Plus' And ExciseStampOperation.DocumentDate < ExciseDeclarations.FromDate And ExciseStampOperation.State >=30 And ExciseStampOperation.Void = False + ExciseStampOperationLines.Quantity*(-1) if ExciseStampOperation.ExciseStampOperationType.Box1Effect = 'Minus' And ExciseStampOperation.DocumentDate < ExciseDeclarations.FromDate And ExciseStampOperation.State >=30 And ExciseStampOperation.Void = False) AvailableNotGluedEndCount Box1_Availabulity_End = SUM(ExciseStampOperationLines.Quantity if ExciseStampOperation.ExciseStampOperationType.Box1Effect = 'Plus' And ExciseStampOperation.DocumentDate <= ExciseDeclarations.ToDate And ExciseStampOperation.State >=30 And ExciseStampOperation.Void = False + ExciseStampOperationLines.Quantity*(-1) if ExciseStampOperation.ExciseStampOperationType.Box1Effect = 'Minus' And ExciseStampOperation.DocumentDate <= ExciseDeclarations.ToDate And ExciseStampOperation.State >=30 And ExciseStampOperation.Void = False) AvailableGluedBeginningCount Box2_Availabulity_Begin = SUM(ExciseStampOperationLines.Quantity if ExciseStampOperation.ExciseStampOperationType.Box2Effect = 'Plus' And ExciseStampOperation.DocumentDate < ExciseDeclarations.FromDate And ExciseStampOperation.State >=30 And ExciseStampOperation.Void = False + ExciseStampOperationLines.Quantity*(-1) if ExciseStampOperation.ExciseStampOperationType.Box2Effect = 'Minus' And ExciseStampOperation.DocumentDate < ExciseDeclarations.FromDate And ExciseStampOperation.State >=30 And ExciseStampOperation.Void = False) AvailableGluedEndCount Box2_Availabulity_End = SUM(ExciseStampOperationLines.Quantity if ExciseStampOperation.ExciseStampOperationType.Box2Effect = 'Plus' And ExciseStampOperation.DocumentDate <= ExciseDeclarations.ToDate And ExciseStampOperation.State >=30 And ExciseStampOperation.Void = False + ExciseStampOperationLines.Quantity*(-1) if ExciseStampOperation.ExciseStampOperationType.Box2Effect = 'Minus' And ExciseStampOperation.DocumentDate <= ExciseDeclarations.ToDate And ExciseStampOperation.State >=30 And ExciseStampOperation.Void = False) AvailableOutsideCountryBeginningCount Box3_Availabulity_Begin = SUM(ExciseStampOperationLines.Quantity if ExciseStampOperation.ExciseStampOperationType.Box3Effect = 'Plus' And ExciseStampOperation.DocumentDate < ExciseDeclarations.FromDate And ExciseStampOperation.State >=30 And ExciseStampOperation.Void = False + ExciseStampOperationLines.Quantity*(-1) if ExciseStampOperation.ExciseStampOperationType.Box3Effect = 'Minus' And ExciseStampOperation.DocumentDate < ExciseDeclarations.FromDate And ExciseStampOperation.State >=30 And ExciseStampOperation.Void = False) AvailableOutsideCountryEndCount Box3_Availabulity_End = SUM(ExciseStampOperationLines.Quantity if ExciseStampOperation.ExciseStampOperationType.Box3Effect = 'Plus' And ExciseStampOperation.DocumentDate <= ExciseDeclarations.ToDate And ExciseStampOperation.State >=30 And ExciseStampOperation.Void = False + ExciseStampOperationLines.Quantity*(-1) if ExciseStampOperation.ExciseStampOperationType.Box3Effect = 'Minus' And ExciseStampOperation.DocumentDate <= ExciseDeclarations.ToDate And ExciseStampOperation.State >=30 And ExciseStampOperation.Void = False) The symbol \".\" is used to indicate that a field or data type is being referenced. The symbol \"@xxxx\" is used to indicate a custom property with the code \"xxxx\". If no field reference is specified after it, the custom property's value is used. The symbol \"*\" denotes multiplication. The symbol \"<>\" means different from. The \" <=\" symbol means less than or equal to. The \" >=\" symbol means greater than or equal to."
  },
  "modules/financials/excise/country-specific/index.html": {
    "href": "modules/financials/excise/country-specific/index.html",
    "title": "Country-specific | ERP.net Tech Docs",
    "summary": "Country-specific Bulgaria Excise stamp operation Export of Excise Declaration file Export of e-ADD file BG1015 Initial Setup Акзцизна декларация за алкохол и алкохолни изделия Акцизен документ за Алкохол и алкохолни напитки Акцизен документ за Електричество Акцизна декларация за електричество"
  },
  "modules/financials/excise/definitions/excise-categories.html": {
    "href": "modules/financials/excise/definitions/excise-categories.html",
    "title": "Excise product categories | ERP.net Tech Docs",
    "summary": "Excise product categories EU Excise product categories Excise Product Categories Excise Product Category code Manufactured tobacco products T Beer B Wine and fermented beverages other than wine and beer W Intermediate products I Ethyl alcohol and spirits S Energy products E https://ec.europa.eu/taxation_customs/dds2/seed/help/seedhpep.jsp?callbackuri=CBU-3&Lang=en"
  },
  "modules/financials/excise/definitions/excise-products.html": {
    "href": "modules/financials/excise/definitions/excise-products.html",
    "title": "Excise products | ERP.net Tech Docs",
    "summary": "Excise products EU Excise products Excise Products Excise Product Code Cigarettes T200 Cigars and cigarillos T300 Fine-cut tobacco for the rolling of cigarettes T400 Other smoking tobacco T500 Beer B000 Still wine and still fermented beverages other than wine and beer W200 Sparkling wine and sparkling fermented beverages other than wine and beer W300 Alcohol - intermediate products I000 Spirituous beverages S200 Ethyl alcohol S300 Partially denatured alcohol S400 Other products containing ethyl alcohol S500 Vegetable and animal oils (energy products) Products falling within CN codes 1507 to 1518, if these are intended for use as heating fuel or motor fuel E200 Mineral oils (energy products) Products failing within CN codes 2707 10, 2707 20, 2707 30, and 2707 50 E300 Leaded petrol E410 Unleaded petrol E420 Gasoil, unmarked E430 Gasoil, marked E440 Kerosene, unmarked E450 Kerosene, marked E460 Heavy fuel oil E470 Products failing within CN codes 2710 11 21, 2710 11 25, 2710 19 29 in bulk commercial movements E480 Products failing within CN codes 2710 11 to 2710 19 69, not specified above E490 Liquefied petroleum gases and other gaseous hydrocarbons (LPG) E500 Saturated acyclic hydrocarbons E600 Cyclic hydrocarbons E700 Methanol (methyl alcohol) E800 Mixture of acyclic hydrocarbons - \"FAMAE\" E910 Mixture of acyclic hydrocarbons - others E920 https://ec.europa.eu/taxation_customs/dds2/seed/help/seedhpep.jsp?callbackuri=CBU-3&Lang=en"
  },
  "modules/financials/excise/definitions/index.html": {
    "href": "modules/financials/excise/definitions/index.html",
    "title": "Definitions | ERP.net Tech Docs",
    "summary": "Definitions Excise product categories Excise products Other excise definitions"
  },
  "modules/financials/excise/definitions/other-excise-definitions.html": {
    "href": "modules/financials/excise/definitions/other-excise-definitions.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Other Excise Definitions Tax Warehouses Tax Warehouses are a basic nomenclature in the Excise module. It reflects the licensed tax warehouses of the trader. A Tax Warehouse is associated with one or more warehouses from the Inventory module. This way, the movements in these warehouses trigger the creation of excise documents for the tax warehouse. The following are specified in the definition of Tax Warehouse: Tax Warehouse Excise Number - The excise identification number of the tax warehouse issued by the competent authorities. Trader Excise Number - The excise identification number of the owner of the Tax Warehouse. Customs Office - The customs office to which the warehouse is headed. Even if goods that do not require a licensed tax warehouse are taken into account, the definition of Tax Warehouse must be present because it specifies the Trader Excise Number. https://docs.erp.net/model/entities/Finance.Excise.TaxWarehouses.html Excise Purpose Codes Excise Purpose Codes are used to specify the different purposes recognized by authorities when determining the excise rate. Along with the Excise Product, Purpose Codes play a role in calculating the excise rate based on the Excise Duty Rate table issued by the competent authorities. https://docs.erp.net/model/entities/Finance.Excise.ExcisePurposeCodes.html Excise Duty Rate Duty rates are specified by the taxation and customs authorities. They are the basis for the calculation of the excise amount (based on the calculation algorithm, specified in the Product Category). Duty rates are determined based on Excise Products, Excise Purpose Codes, and Excise Measurement Units. https://docs.erp.net/model/entities/Finance.Excise.ExciseDutyRates.html Excise Product Types Excise Product Type is a definition that describes the attributes of products related to the excise module. An Excise Product Type can be used in many products if they have the same excise properties. The main excise attributes are: Category - Specifies the excise product category of the excise stamp - alcohol, tobacco, and others. ExciseProduct - Excise product according to the EU nomenclature for products subject to excise duty. ExciseMeasurementUnit - The unit of measure in which the product is reported. CommodityCode - Code from The Combined Nomenclature used within the European Union countries. AlcoholicStrength - Percentage of pure alcohol used in excise duty reporting. Capacity - Package capacity - number of cigarettes or volume of alcohol in liters. ExciseAmountPerStamp - The excise duty, which is charged with one excise label. Excise Stamp Operation Types Excise Stamp Operation Types define the operation with excise stamps and how it reflects on the three summing boxes - Box1 Effect, Box2 Effect, and Box3 Effect. The definition of Excise Stamp Operation Types sets the specific operation to either add the Quantity to the corresponding Box, subtract it, or leave it unchanged. The summing boxes, Box1 Effect, Box2 Effect, and Box3 Effect, indicate the available quantities of excise stamps in the respective reporting centers required by the customs authorities. If the \"Is Whole Lot\" checkbox is selected for the Excise Stamp Operation Type, then when selecting an Excise Stamp Lot in Excise Stamp Operation Line, the entire quantity from the Excise Stamp Lot is copied into the quantity field. If the \"Track Sequence\" checkbox is selected for the Excise Stamp Operation Type, then when recording ExciseStampOperation, it checks whether the sequence of numbers has been preserved. This means there are no skipped numbers compared to the already entered numbers for this batch and this type of operation. If there are skipped numbers, a Warning is raised. If the \"Require product\" checkbox is selected for the Excise Stamp Operation Type, then when changing the status to Released or higher, it checks that the product in the lines is filled in. https://docs.erp.net/model/entities/Finance.Excise.ExciseStampOperationTypes.html Excise Stamp Lots The Excise Stamp Lots are a series of stamps that are obtained from customs authorities. When received, the Quantity, Start Number and End Number, the Batch number, which describes the attributes of the issue by the customs authorities, and the Purchase batch, which provides a unique identifier for each receipt in the tax warehouse, are recorded. With excise stamp operations, the movement of each batch is tracked in the relevant reporting centers, including the quantity, initial and final number. https://docs.erp.net/model/entities/Finance.Excise.ExciseStampLots.html Commodity Codes Contains the approved commodity codes for each period from The Combined Nomenclature used within the European Union countries. They are used for reporting Intrastat and Excise. https://docs.erp.net/model/entities/Finance.Intrastat.CommodityCodes.html"
  },
  "modules/financials/excise/documents/excise-administrative-document.html": {
    "href": "modules/financials/excise/documents/excise-administrative-document.html",
    "title": "Excise Administrative Document | ERP.net Tech Docs",
    "summary": "Excise Administrative Document The Excise Administrative Document or Excise Document is the primary document that describes the movement of excise goods in the tax warehouse for reporting purposes to the customs authorities. It describes the receipts and issues in the tax warehouse, movements within the tax warehouse, as well as the calculation of the excise duty that needs to be paid to the customs authorities. It is also the basis for generating the necessary data for reporting purposes and for preparing the excise declaration for the period. The following data are filled in the header: Administrative ReferenceCode - The reference code, returned the customs authorities, when the document is exported to them or reference code in received documents. TaxWarehouse - Our licensed tax warehouse for which we report to the customs authorities. Direction - The direction of the movement of goods. It determines whether the goods are entering or leaving the tax warehouse. AccrueExciseDuty - A checkbox that indicates that excise duty is accrued when the goods are removed from the tax warehouse. ReferenceDate - The date of the reference document when it is issued by an external organization. It is used mainly when receiving goods into the tax warehouse. ReferenceDocumentNo - The number of the reference document when it is issued by an external organization. It is used mainly when receiving goods into the tax warehouse. IsDeferredSubmission - Indicates whether the movement has begun under the cover of a paper administrative document. OtherParty - The other party, sending or receiving the goods. DeliveryParty - Indicates the party where the goods are send/received. null means it is the same as Other Party. TransportationCarrier - The carrier used for the transportation of the goods. TransportationVehicle - The vehicle, used for the transportation of the goods. ReportingPerson - This is the person submitting the declaration. https://docs.erp.net/model/entities/Finance.Excise.ExciseAdministrativeDocuments.html The following data is filled in the rows: Product - The product that is input or output from the excise warehouse. Lot - The stock batch with which the corresponding product is booked in or out. It is copied from the parent stock receipt and is used to trace the movement in the warehouse - which batch was involved in which receipt and issue documents. Quantity - Quantity in the unit of measure of the stock transaction in the Warehouse Management module. QuantityUnit - Unit of measure of the stock transaction from the Warehouse Management module. QuantityBase - Quantity in the base unit of measure of the product. The inventory is managed in the base unit of measure in the Warehouse Management module. ExciseQuantity - Quantity in the Excise unit of measure. ExciseQuantityUnit - Excise unit of measure. The record-keeping to the customs authorities is in this unit of measure. It is specified in the Excise Product Types, which is set in the product definition. MeasuringTransaction - Transaction of product input or output, measured with specialized measuring device for excise purposes. ExciseProduct - The Excise product code defined by the taxation and customs authorities. It is specified in the Excise Product Types, which is set in the product definition. It is loaded automatically upon product selection, but can be changed manually. ExcisePurposeCode - The Purpose codes specify the different purposes recognized by the authorities for determining the excise rate. ExciseAlcoholicStrength - The alcoholic strength, which will be used for Excise reporting purposes. If a Measuring Transaction is specified, it is taken automatically from it upon product selection. If not, it is taken from the Excise Product Types, which is set in the product definition. It can be changed manually. ExciseAmountBase - The base on which the excise rate is calculated. It is automatically calculated using an algorithm defined in Excise Product Categories. Excise Product Categories are part of the definition of ExciseProduct. ExciseDutyRate - A reference to the specific rate in the table ExciseDutyRates, which is determined based on the selected Excise Products, Excise Purpose Codes, and Excise Measurement Units. ExciseDutyRateValue - The value of the determined excise rate ExciseDutyRate. ExciseAmount - The calculated amount of excise based on ExciseAmountBase and ExciseDutyRateValue. https://docs.erp.net/model/entities/Finance.Excise.ExciseAdministrativeDocumentLines.html"
  },
  "modules/financials/excise/documents/excise-declaration.html": {
    "href": "modules/financials/excise/documents/excise-declaration.html",
    "title": "Excise Declaration | ERP.net Tech Docs",
    "summary": "Excise Declaration The excise declaration is the document that reports a certain period to the customs authorities. 1. Entering Excise Declaration The following basic fields are entered: DocumentDate - Date of declaration preparation. DocumentType - Type of document. DocumentNo - Serial number of the document. TaxWarehouse - Tax warehouse for which the report is made. ReportingPerson - The person submitting the declaration. FromDate - Start date of the period for which the declaration is made. ToDate - End date of the period for which the declaration is made. https://docs.erp.net/model/entities/Finance.Excise.ExciseDeclarations.html"
  },
  "modules/financials/excise/documents/excise-stamp-operation.html": {
    "href": "modules/financials/excise/documents/excise-stamp-operation.html",
    "title": "Excise Stamp Operations | ERP.net Tech Docs",
    "summary": "Excise Stamp Operations An Excise Stamp is a government-issued security document that certifies the payment of the required excise duty for goods released for consumption. It is a paper strip with permanent markings. Only licensed manufacturers and traders—importers with special permits—are entitled to purchase Excise Stamps. The Excise Stamps Operation documents are intended to organize the accountability when working with Excise Stamps for the registered trader. With its help, all operations required by the authorities can be tracked, such as receiving, affixing to products, discarding, transferring to another tax warehouse, returning, and more. Key elements: Document Data: This includes the document type, document number, document date, the trader’s company, and other fields that are typically completed in documents. Tax Warehouse: The tax warehouse where the Excise Stamps are provided to release the excise goods for consumption. Excise Stamp Operation Type: These are the operations for which records are kept for the authorities. The nomenclature is provided by the relevant state authorities. Examples include Receiving from the authorities, Affixing, Returning, and others. Excise Product Type for which the Excise Stamps are Tracked: This is a definition related to the excise characteristics of the products that are defined. Excise Stamp Lot: This refers to the series of Excise Stamps provided in a package and includes relevant attributes—Quantity, Starting Number, Ending Number, and Description. The description can define other characteristic attributes, if any—Year, Series, and others. Product: The product is not a mandatory attribute, but it is necessary if Excise Stamp Operations are generated from other documents in the system. There are several checks when entering Excise Stamp operations that facilitate the process and minimize errors. Excise Stamp operations can be integrated into overall workflows, generated from a inventory transaction. For some operations, such as Affixing, they can be created automatically for the respective quantities, requiring only the lots and starting number to be filled in."
  },
  "modules/financials/excise/documents/index.html": {
    "href": "modules/financials/excise/documents/index.html",
    "title": "Documents | ERP.net Tech Docs",
    "summary": "Documents Excise Administrative Document Excise Declaration Excise Stamp Operations"
  },
  "modules/financials/excise/index.html": {
    "href": "modules/financials/excise/index.html",
    "title": "Excise | ERP.net Tech Docs",
    "summary": "Excise According to EU legislation, certain products like alcoholic beverages, beer, energy and cigarettes are subject to excise tax whenever they leave a tax warehouse. The Excise module is designed to assist businesses in meeting their legal duties to regional custom agencies or other institutions requiring excise taxes. Using its resources, you can create and generate all the necessary documents and definitions related to your excise payments. At the end of each month, they are all included in a final excise declaration. Note The EU Excise legislation is applicable to all member states and affects all excise products, but there are regional differences in how documents are filled and submitted. The main process flow in Excise goes like this: Tax Warehouse → Issue/Receipt Transactions → Excise Stamp Operations → Excise Declaration Tax warehouse To use this module, you first need to define a digital tax warehouse. Its purpose is to store all of your manufactured and imported products which are registered under the common Excise law. It requires a name and special numbers for validation, provided by your customs agency. Note Tax warehouses are linked to a specific geographic location, but they can encompass more than one inventory store defined in the software. Issue/Receipt transactions Owning a tax warehouse obligates you to generate transaction documents for everything that happens to your excise products. By law, these documents must be exported and sent over to the customs office and/or your regional tax-collecting agency. Example: If a product enters your tax warehouse, receipt transactions need to be created to reflect the excise tax for this operation. If a product is sold or leaves your tax warehouse for another, generating the respective issue transactions will be necessary. When products are imported from or exported to another tax warehouse, the electronic administrative document (e-AD) allows you to report each transaction. If operations are limited to your tax warehouse, you must fill an electronic excise tax document (e-ADD) instead. Definitions You can take advantage of a variety of system and custom definitions. Excise allows you to both use and create new excise product types, categories, and other entities required for transaction documents. Note Some excise-related definitions are auto-generated while others need to be manually set-up. It is not possible to submit a document without defining a excise product type for all of your excise products. Once you fill a transaction document, you must export it as an XML file and send it to your taxing authority and/or customs office. Excise stamp operations When excise products are manufactured, imported or exported from a tax warehouse, they need to have a stamp placed on them. In the case of alcoholic beverages, for example, every bottle must have a excise stamp. You can create new excise stamps and relate them to specific operation types such as: Received from the customs Placed on the bottles within the tax warehouse Returned unused In most cases, excise stamps are provided by the customs office and placed on every bottle of alcohol. Reporting all the stamps you have used is a compulsory section of the final excise declaration. Note Excise stamps have unique serial numbers, emission and date of placement. When creating a excise stamp report, you generate another transaction document which includes the excise operation type, related products and number of used stamps. It is possible for fewer stamps to be placed than originally received. Excise declaration As a legal requirement, all of your monthly transactions are automatically included in a final excise declaration. It unites the transaction documents you have reported for the month, summarizes your product availability and excise payments, and includes a excise stamping report. Note Customs offices may have the legal authority to electronically monitor the movement of products in and out of your tax warehouse. A typical excise declaration has the following sections: Excise amount owed and paid for each issue/receipt transaction within the tax warehouse Past and current availability of each excise product in the tax warehouse, including incomes and expenses Excise stamping report covering each banderol operation At any time, you can visualize this declaration and correct any mistakes before officially submitting. When ready, you need to export it as an XML file and send it to the respective taxing authority. Note Customs or other taxing authorities may need direct access to your ERP.net system in order to observe your tax warehouse. In the case of Bulgarian clients, for example, there's a separate environment offering the ability for custom agencies to generate reports and see which products are available in a tax warehouse for a specific period of time. Post-excise If your declaration meets all legal requirements, the excise tax is settled and products can be moved freely from one store to another. Learn more about Excise in the following articles: Definitions Documents Country specific"
  },
  "modules/financials/fixed-assets/depreciation-methods/depreciation-functions.html": {
    "href": "modules/financials/fixed-assets/depreciation-methods/depreciation-functions.html",
    "title": "Depreciation functions | ERP.net Tech Docs",
    "summary": "Depreciation functions"
  },
  "modules/financials/fixed-assets/depreciation-methods/index.html": {
    "href": "modules/financials/fixed-assets/depreciation-methods/index.html",
    "title": "Depreciation methods | ERP.net Tech Docs",
    "summary": "Depreciation methods Depreciation functions Period determination methods"
  },
  "modules/financials/fixed-assets/depreciation-methods/period-determination-methods.html": {
    "href": "modules/financials/fixed-assets/depreciation-methods/period-determination-methods.html",
    "title": "Period determination methods | ERP.net Tech Docs",
    "summary": "Period determination methods From next month to last month From current month to last but one month By days Method of calculation First, the quota for each month is calculated: Month quota = Depreciable amount / Int(Month(Depreciation End Date - Depreciation Start Date -1)) For the first month: First month Depreciation = Month quota * ((Number of Days in First month - Depreciation Start Date)/Number of Days in First month) For every next month but last one: Depreciation = Month quota For the last month: Depreciation = Month quota - First month Depreciation Example: Asset with Useful life = 6 months and Depreciable amount = 120 Depreciation Plan = 14.01 - 14.07 Month quota = 120 / 6 months = 20 First month Depreciation = 20 * ((31-14)/31) = 10.97 For 2,3,4,5 and 6th month Depreciation = 20 Last month Depreciation = 20 - 10.97 = 9.03"
  },
  "modules/financials/fixed-assets/index.html": {
    "href": "modules/financials/fixed-assets/index.html",
    "title": "Fixed assets | ERP.net Tech Docs",
    "summary": "Fixed assets Depreciation methods"
  },
  "modules/financials/index.html": {
    "href": "modules/financials/index.html",
    "title": "Finance | ERP.net Tech Docs",
    "summary": "Finance Accounting VAT Fixed assets Cost accounting Payments Excise"
  },
  "modules/financials/overview.html": {
    "href": "modules/financials/overview.html",
    "title": "ERP.net Financials | ERP.net Tech Docs",
    "summary": "ERP.net Financials Accounting Cost Accounting Fixed Assets Intrastat Payments VAT"
  },
  "modules/financials/payments/advance-amounts-determination/advance-amount-calculation-algorithm.html": {
    "href": "modules/financials/payments/advance-amounts-determination/advance-amount-calculation-algorithm.html",
    "title": "Advance amount calculation algorithm | ERP.net Tech Docs",
    "summary": "Advance amount calculation algorithm 1. Determination of the rows containing advances Advance amounts are considered the amounts from all rows where the party in the payment order is the same as the party in the payment transaction and the payment order has no value in the Referent Invoice Number field. The condition in the Referent Invoice Number field is appropriate for sales orders and purchase orders because there we expect that after the invoice or the purchase invoice is released, the payment orders are (re)generated with data from the invoice and the Referent Invoice Number field would be filled in. Note So the payment order with no Referent Invoice Number, created before the invoice and its payment releases, is a payment before the invoice release and is considered an advance. Example 1: There is a payment transaction where the Party is Company 1 and it consists of 10 rows: row #10, Covered Amount = 20 BGN, Amount = 20 EUR, Payment Order = PO #1; row #20, Covered Amount = 38 BGN, Amount = 38 EUR, Payment Order = PO#2; row #30, Covered Amount = 50 BGN, Amount = 50 EUR, Payment Order = PO #3; row #40, Covered Amount = 20 BGN, Amount = 20 EUR, Payment Order = PO #4; row #50, Covered Amount = 35 BGN, Amount = 35 EUR, Payment Order = PO #5; row #60, Covered Amount = 30 BGN, Amount = 30 EUR, Payment Order = PO #6; row #70, Covered Amount = 25 BGN, Amount = 25 EUR, Payment Order = PO #7; row #80, Covered Amount = 40 EUR, Amount = 80 BGN, Payment Order = PO #8; row #90, Covered Amount = 25 EUR, Amount = 50 BGN, Payment Order = PO #9; row #100, Covered Amount = 20 EUR, Amount = 40 BGN, Payment Order = PO #9. For each of the nine payment orders the following data is available: PO #1: Party = Company 1, Reference Invoice Number = null; PO #2: Party = Company 1, Reference Invoice Number = null; PO #3: Party = Company 1, Reference Invoice Number = \"1100056\"; PO #4: Party = Company 1, Reference Invoice Number = \"10700149\"; PO #5: Party = Company 1, Reference Invoice Number = null; PO #6: Party = Company 1, Reference Invoice Number = null; PO #7: Party = Company 1, Reference Invoice Number = null; PO #8: Party = Company 2, Reference Invoice Number = null; PO #9: Party = Company 1, Reference Invoice Number = null; So from these 10 rows, the following rows would be separated - row #10, row #20, row #50, row #60, row #70, row #90 and row #100, and they will be used for the calculation of the advance amounts. 2. Grouping the rows The Payment Transaction rows, determined in step 1, are grouped by the fields ERP.net Location, Total Amount Currency and Ref Document from the referred payment orders. Thus, for each combination of values from these three fields, a group is formed from the Payment Transaction rows that meet this data. Example 2: Let’s use the data from Example 1 and the payment orders has the following values in the ERP.net Location, Total Amount Currency and Ref Document values: PO #1, ERP.net Location = \"ERP.net Location 1\", Total Amount Currency = BGN, Ref Document = null; PO #2, ERP.net Location = \"ERP.net Location 1\", Total Amount Currency = BGN, Ref Document = null; PO #5, ERP.net Location = \"ERP.net Location 1\", Total Amount Currency = BGN, Ref Document = \"Sales Order 20001052\"; PO #6, ERP.net Location = \"ERP.net Location 1\", Total Amount Currency = BGN, Ref Document = \"Sales Order 20001052\"; PO #7, ERP.net Location = \"ERP.net Location 1\", Total Amount Currency = BGN, Ref Document = \"Sales Order 20001052\"; PO #8, ERP.net Location = \"ERP.net Location 1\", Total Amount Currency = EUR, Ref Document = \"Sales Order 20001052\"; Thus in these seven separated rows, three groups are formed: Group 1: row #10, row #20 (for \"ERP.net Location 1\", BGN and null ref document); Group 2: row #50, row #60, row #70 (for \"ERP.net Location 1\", BGN and \"Sales Order 20001052\" ref document); Group 3: row #90, row #100 (for \"ERP.net Location 1\", EUR and \"Sales Order 20001052\" ref document). 3. Determining the advance amount for each group For each group from step 2, an advance amount is calculated, which meets the parameter [Is Amount With VAT]. The amounts are summed up from all rows (the values in the Covered Order Amount field), where the Is Amount With VAT has the same value as the parameter [Is Amount With VAT]. When summing the amounts from the rows the following condition should be considered - if the direction of the payment order is different than the direction of the payment transaction, then the value in the Covered Order Amount field should be multiplied by -1 before adding it into the total. *** Example 3***: Let’s use the data from Example 1 and Example 2 and the [Is Amount With VAT] parameter is True and in all payment orders, the Is Amount With VAT field is True, except for PO #5 and PO #6. Also, the direction of the Transaction is Income and all payment orders are income, except for PO #1, PO #5 and PO #7, which direction is Expense. So for each group, the following calculations are performed: for Group 1: [advance amount] = -1 * 20 BGN + 38 BGN = 18 BGN; for Group 2: [advance amount] = 30 BGN + -1 * 25 BGN = 5 BGN (the amount from PO #5 is skipped as it does not meet the [Is Amount With VAT] parameter; for Group 3: [advance amount] = 0 EUR, as the payment orders from all rows do not meet the [Is Amount With VAT] parameter. In the end, the collection of advance amounts which meet the [Is Amount With VAT] parameter consists of two amounts - 18 BGN and 5 BGN (the last one with 0 EUR is skipped). Defining the remaining amount In the end, the values from the Amount fields in all group rows are summed up where the value in the Is Amount With VAT field is different from the [Is Amount With VAT] parameter. All these values are not included in the calculations in the previous step. They form the remaining amount. In the current calculation, the amount should be multiplied by -1 if the payment order direction differs from the payment transaction direction. Example 4: Using the data from Example 1, Example 2 and Example 3, the remaining amount is formed by the amounts from PO #5 and PO #9 as they do not meet the [Is Amount With VAT] parameter. So the result is: [remaining amount] = -1 * 35 BGN + 50 BGN + 40 BGN = 55 BGN."
  },
  "modules/financials/payments/advance-amounts-determination/index.html": {
    "href": "modules/financials/payments/advance-amounts-determination/index.html",
    "title": "Advance amounts determination | ERP.net Tech Docs",
    "summary": "Advance amounts determination The current article describes the algorithm which defines what part of the amounts of a given payment is paid in advance. This algorithm is applicable both in income payments and expense payments so it can determine the advance amounts in both sales orders and purchase orders. Input algorithm data: Payment transactions which contains the advance amounts; [Is Amount With VAT] - a parameter that may be True or False and defines if the amounts include VAT or not. Output algorithm data: Collection of the advance amounts found in the payment transaction, which meets the parameter [Is Amount With VAT]; The total remaining advance amount does not meet the parameter [Is Amount With VAT]. The advance amounts are extracted from the payment yransaction rows and their calculation depends on the data in the payment orders which are referred to in the rows. The algorithm uses the following schema: Determine the rows containing advance amounts. Grouping the rows from step 1. For each group, a total amount is determined, which meets the [Is Amount With VAT] parameter, and this total amount is added to the collection of advance amounts. All rows (from all groups), which contain advance amounts and do not correspond to [Is Amount With VAT], are summed up and they define the remaining amount. For a more detailed explanation of the algorithm, see Advance amount calculation algorithm."
  },
  "modules/financials/payments/index.html": {
    "href": "modules/financials/payments/index.html",
    "title": "Payments | ERP.net Tech Docs",
    "summary": "Payments Advanced amount determination"
  },
  "modules/general/documents/document-print-images.html": {
    "href": "modules/general/documents/document-print-images.html",
    "title": "Document print images | ERP.net Tech Docs",
    "summary": "Document print images Document print images contain the data of a printout of a document as it was obtained at the moment of printing. This data is used as a history in order to review the visual representation of the printed document. Delete old images Document print images often take the most space in customer databases. One means of managing them is to delete the more obsolete records periodically. This can be done with the Deletе old document print images system job. However, there is a way to not even track print images records in the first place - for further details, please refer to the Enable or disable print images tracking section. Enable or disable print images tracking A setting is available to control the tracking of print images for all documents of a specific type. This functionality is configured through the \"Track Print Images\" field within the Document Type definition. The available settings are: Do not track - prevents print images of all documents of the respective type from being automatically stored. This can be useful for scenarios where print image tracking is unnecessary or unwanted. Save source data (compressed) - enables the tracking of visual representations of printed documents of the respective type. These images are compressed for efficient storage and are available for preview within the system."
  },
  "modules/general/documents/index.html": {
    "href": "modules/general/documents/index.html",
    "title": "Documents | ERP.net Tech Docs",
    "summary": "Documents Document print images"
  },
  "modules/general/folders.html": {
    "href": "modules/general/folders.html",
    "title": "File manager | ERP.net Tech Docs",
    "summary": "File manager The File manager is where you can create and store folders with different files inside. It follows a hierarchical tree order, similar to the one found in Product groups. With the help of the ribbons, you are able to peek inside a complex structure without getting lost. Each folder can have an unlimited number of subfolders, the order of which is decided by pre-defined filters. You can view the contents of a folder if you right-click it and select the Definition command. The contents of the folder can be seen in the window that opens. There are also options to rename, remove, or create a new subfolder within the selected folder. Moreover, ERP.net allows important documents (such as contracts and statistics) to be embedded, from one to dozens at a time. Currently, it is possible to embed a file only in the [New] window, where \"[New]\" is the folder's name. To do so, right-click inside the panel and select Insert new file -> Embedded File. You can create individual folders folders by right-clicking anywhere inside the Tree panel and selecting the New command. This triggers Edit Mode, where a window outside of the File Manager pops up and allows for the creation of the new forder. Parent Folder - whatever you select from the dropdown will make the new folder its subfolder. Folder Name - this is the name of the folder or subfolder. Notes - these are optional details characterising the new folder or subfolder. Storing files into folders allows for flexibility and security when working with sensitive documents. You will need to select the documents from the location that you store them. Once uploaded, they become part of the folder and are subject to the management capabilities of the File Manager. The quickest way to open a file is by double-clicking it. Its contents will be revealed straight away. You can also see files in different viewing modes, ranging from extra large icons to tables with detailed rows."
  },
  "modules/general/index.html": {
    "href": "modules/general/index.html",
    "title": "General | ERP.net Tech Docs",
    "summary": "General Documents File manager Products"
  },
  "modules/general/products/coding-systems.html": {
    "href": "modules/general/products/coding-systems.html",
    "title": "Coding systems | ERP.net Tech Docs",
    "summary": "Coding systems Coding Systems group together multiple product codes according to different criteria. All product codes are grouped in coding systems. Product codes are codes other than the part numbers that bring meaning to the company such as supplier codes, customer codes, barcodes and more. A default measurement unit could also be specified in coding systems. If a product code relating to a coding system with a default measurement unit is selected, then this unit must load in the document instead of the product's default unit. For example, if in the products definition \"Measurement Unit = Pcs\" is set, and for this product there is also a product code that relates to a coding system with a \"Default Measurement Unit = Package\", then we expect the following behavior: When a product in the sales order is selected through product code via barcode, then: Product’s part number loads in the Product field in the particular sales order line; \"Quantity Unit = Package\", which corresponds to the default measurement unit in the coding system’s definition; \"Unit Price\" must be recalculated according to the product dimensions."
  },
  "modules/general/products/index.html": {
    "href": "modules/general/products/index.html",
    "title": "Products | ERP.net Tech Docs",
    "summary": "Products Products are goods which are the object of a company’s business activities. Products can be tangible or intangible. A tangible product is a physical object that can be perceived by touch such as a building, vehicle, gadget, or clothing. An intangible product is a product that can only be perceived indirectly such as services. In ERP.net, all product-specific data is kept in the product’s definition. Product’s definition includes the information required for specific business processes and other basic data that describes and categorizes the product, for example: product name; part number; product type; measurement unit; costing currency and others. Different panels can also be visualized in the product’s definition, allowing the user to have access to all of the product related information such as product dimensions, current stock holds, serial numbers, lots, product prices and others. All products are grouped in user defined product groups (e.g. goods, materials, services …) according to different criteria. For more information, see Product groups. Coding systems Product codes Product dimensions Product pictures Products - business rules Product types Serial numbers Variable (dynamic) measurement ratios"
  },
  "modules/general/products/product-codes.html": {
    "href": "modules/general/products/product-codes.html",
    "title": "Product codes | ERP.net Tech Docs",
    "summary": "Product codes Product codes are mechanisms that allow products to be selected not by their part number (indicated in the product definition), but by alternative codes for this product. For example, using this mechanism, products are selected via barcode. Product codes are used for the creation of new codes for existing products in the database. All product codes are grouped in coding systems. This mechanism is applied in the lines of logistics documents. It is implemented through a special field for the product code in the table and is a foreign key to the product codes table. By selecting the number from the drop-down list box you actually select the product for which the code is set. The field is commonly used when the documents are created manually by the user. When the documents are created automatically by the system (through procedures, for example) values in this field are carried by parental documents to sub-documents (if set), but are not automatically filled by the system (if not set). There are certain relations between the fields Product, Product Code and Quantity Unit:** If the field Product Code has a value or the value in the field is changed, then the value of the Quantity Unit is taken from the definition of coding system (if set) to which the code belongs; If the value in the field Product is changed, then the field Product Code must be empty, because the product is no longer selected through this mechanism. Suggestion: Avoid Overlapping Product Codes (e.g., no inclusion of codes like 12345 and 12345A) To ensure clarity and prevent errors during product identification, product codes within the same coding system should be unique and not overlap with one another. For example, avoid using codes that are substrings or variations of each other, such as \"12345\" and \"12345A.\" Overlapping codes can lead to confusion, misidentification of products, and potential system errors when processing logistics documents or scanning barcodes. A clear distinction between codes will prevent misassignments and ensure smoother data handling. Benefits of Proper Product Code Numbering: Improved Accuracy and Efficiency: Unique product codes minimize the risk of misinterpretation or conflicts when selecting products manually or through automated processes. This leads to fewer errors in stock management, inventory tracking, and order fulfillment. Enhanced System Integrity: Avoiding overlapping product codes prevents data corruption or mismatch issues during document processing. It ensures that product details, such as quantity and unit, are correctly associated with the product. Optimized Barcode Scanning: Clear, non-overlapping product codes facilitate faster and more accurate barcode scanning in logistics operations. This reduces the risk of incorrect product selection or delays in warehouse operations. Better Scalability and Code Management: By adhering to a strict non-overlapping product code format, businesses can more easily scale their coding systems, introduce new products, and update existing ones without the need for complex code restructuring. For best practices, consider referencing guidelines such as GS1 standards for product numbering and barcoding, which emphasize the use of globally unique identifiers and non-overlapping codes to ensure accuracy and traceability across supply chains."
  },
  "modules/general/products/product-dimensions/index.html": {
    "href": "modules/general/products/product-dimensions/index.html",
    "title": "Product Dimensions | ERP.net Tech Docs",
    "summary": "Product Dimensions Product Dimensions are used for conversion between different units of measurement for the same quantity. In order to make this possible, product dimensions must be set for the products as a ratio between multiplier and divider to the base unit. The formula for calculation of quantity base in the documents lines is as follows: Quantity Base = Quantity * Product Dimension Dest Quantity / Product Dimension Source Quantity Required fields Description Quantity The quantity in the non-base unit. Source Quantity Unit The non-base unit for which the conversion ratio is specified. Dest Quantity The quantity in some of the base units. Dest Quantity Unit The measurement unit of the dest quantity. Should be one of the units of the base measurement category of the product. Measurement Category The measurement category of the source quantity unit. For each product, only one conversion ratio can be specified for a measurement category. Example: We need to load two pallets of a product. But we know that each pallet contains 15 pieces. So the total pieces that we need to load are 30. This means that if we want to automate this calculation, we need to insert the following information to create a conversion ratio in the product dimensions: Source Quantity - 1.00 Source Quantity Unit - Pallet Dest Quantity - 15.00 Dest Quantity Unit - Pcs Measurement Category - Complectation (e.g.)"
  },
  "modules/general/products/product-groups/index.html": {
    "href": "modules/general/products/product-groups/index.html",
    "title": "Product groups | ERP.net Tech Docs",
    "summary": "Product groups Product groups form a hierarchical tree structure of the products. ERP.net allows multiple groups with different names and characteristics to be created. Each product group can contain an unlimited number of products which are grouped together according to different criteria. It is strongly recommended that products are grouped in a meaningful way, as they could inherit certain properties from the groups. Product groups could also facilitate the creation of the individual products. For example, in their definition, it could be set: Next part number – a part number to be auto assigned to the products created in the group or the sub-group; Default measurement unit - a measurement unit to be auto assigned to the products created in the group or the sub-group; Product name mask – specifies a mask for the name of the products created in the group or the sub-group. The function allows creation of more accurate names that follow a certain pattern. Product groups could also contain other important settings, such as 'Product group required properties', 'Principal recipes', 'Product supply', etc."
  },
  "modules/general/products/product-types/index.html": {
    "href": "modules/general/products/product-types/index.html",
    "title": "Product types | ERP.net Tech Docs",
    "summary": "Product types Product types - business rules"
  },
  "modules/general/products/serial-numbers/index.html": {
    "href": "modules/general/products/serial-numbers/index.html",
    "title": "Serial numbers | ERP.net Tech Docs",
    "summary": "Serial numbers Serial numbers are a way of identifying the different pieces of a product. They may be used for equipment, software, assets and more. With the Serial numbers the user can follow what happens with objects, which are otherwise identified by the system with one product definition (i.e. one Product_Id). The Serial numbers are also important for identification when providing guarantee and support. For example, in a sales order, the user may enter a row with three pieces which will have to be shipped separately (1 piece at a time). But (in the sales order) the user cannot mark which one of the three pieces is shipped first, which one is shipped second and etc. In the sales order, three Serial numbers are entered, but in the Shipments, the user may specify by Serial numbers which one is shipped each time and which Shipment exactly refers to it. Implementation The Serial numbers are recorded in a separate table where each record is an individual Serial number. Additional information is specified as Product, Lot (eventually), Availability (is the current piece blocked), Serial number card data and more. This way of implementation is preferred instead of the initial idea of defining number groups. In this implementation, the numbers in each group cannot be identified by something other than the symbols of their record. This is not very helpful because there are cases with fundamental differences between two Serial numbers which may be entered in one document row. For example, one of them may be blocked for future usage, and the second one - not. Other than that, visually, it looks better when the different Serial numbers are displayed in different document rows. This corresponds with the fact that we treat the products with different Serial numbers as different products. Also, the current implementation considerably eases the entering of Serial numbers by barcode scanner. Tracking of the current availability is easier as well as the tracking of the product with a specified serial number. Usage in documents Whether a product should be used with or without Serial numbers, is a property set in its definition - Is Serialized field. If a product is not serialized, Serial numbers are forbidden when working with this product. If it is serialized, than serial number usage is required in Transactions and Reconciliations, and in the other documents it is allowed, but not required. Usually, Serial numbers are entered in the transactions and reconciliations. In the previous documents (Receiving orders, Sales orders etc.) the user is able to enter a serial number but such kind of usage is rare. If the serial number is not entered, for example in the Receiving order, the user may enter just one row with the quantity of 10 PCS and breaking down this row to 10 separated rows with different Serial numbers and quantity of 1 PCS happens in the Transaction. The main way to break down one row to several with different Serial numbers happens through the Barcode commands panel for Store orders execution. Data entry validation The serial number is specified in the documents rows by selecting it from a dropdown list. When the value in this field changes, the following validations should be performed: if the row is a Transaction row or a Reconciliation row - then the value should be different than null only if the product is serialized; if the row is a different document row (not a Transaction or a Reconciliation) - then the value may (but not necessarily) be not-null only if the product is serialized. If it is not serialized, then null value is required; If there is a serial number in the row, then the quantity in the row must be 1, 0 or -1 and the measurement unit must be pieces ; if the entered value in the Serial Number field is different from null, then the product from the current row must be the same as the product in the serial number definition. Easy entry/selection Entering new Serial numbers and selecting an already entered one should be as easy as possible. For this purpose, when entering a serial number and in a dropdown list a number ( nonexistent in the database for the current product) is selected, then a record with this value is created in the database automatically. This will have the greatest effect when working with the Barcode commands panel. This panel has a working mode which creates new Serial numbers and it is available only when receiving goods in the store. If the user issues goods, they can choose only Serial numbers, which are already entered in the database. Also, there are modes for quick entering/selection of a list of Serial numbers. By them, the user may enter directly the numbers separated by commas (for example - \"KHC4500071, KHC4500072, KHC4500073, KHC4500074, KHC4500075, KHC4500076, KHC4500077\"), or they may set a range of numbers (in the previous example list, the user may enter just \"KHC4500071\" and \"KHC4500077\"). For more information about the Barcode panel's serial number modes, see Barcode Panel Modes and its subtopics. Availability And product tracking The products availability (both current and at a specified date) for serialized products is detailed to serial number level. The same is valid for the stock movements reports. By them, the user is able to track the movements of specified products and their Serial numbers. Such tracking is always executed by store documents (i.e. store movements) and if there comparing operations from specialized modules is required, then a link between the Transactions and the documents from the specified module is used (for example - links as [Parent Document] <-> [Sub-Document]). For example, in purchasing orders Serial numbers will rarely be entered (except for returns) and the Serial numbers will show up in the transactions. So if the user wants to see when a specified serial number is bought, then they would use stock movements and follow the link to the Purchasing orders (for example - through the parent document of the Store order). Also sее: Serial numbers business rules"
  },
  "modules/general/products/variable-dynamic-measurement-rations.html": {
    "href": "modules/general/products/variable-dynamic-measurement-rations.html",
    "title": "Variable (dynamic) measurement ratios | ERP.net Tech Docs",
    "summary": "Variable (dynamic) measurement ratios Variable (dynamic) measurement ratios are a functionality that allows a compensation of stock differences. Stock differences occur if there are variances between the quantity in the base unit of measure and the quantity in the parallel unit of measure. Stock differences may, for example, be caused by natural weight variations in material withdrawals. The option ‘Allow variable measurement ratios’ is available in the product’s definition. When this option is checked, the base quantity could be edited in the receiving order and transaction’s lines. Thereby, the user has the opportunity to manually adjust the right base quantity in the particular situation. Otherwise, if in the product definition is not set that it is allowed to use variable measurement ratios, then the product dimensions must be followed properly while recalculating base quantity. Example: The client has ordered 1 pallet of a product. We know that one pallet theoretically weights 1000 kg and that information is set as a conversion ratio in the product dimensions. But we also know that this weight may vary, so the product is allowed to use Variable measurement ratios. The base quantity in the store transaction is calculated on a base of the conversion rate. But when the workers in the warehouse actually put the pallet on the scale it turns out that the pallet actually weights 1100 kg. In this case they can manually set the value for the base quantity. This will not only assure that the information in the system is correct, but also will allow the company to invoice the right amounts. Note When using Variable measurement ratios, there are certain prohibitions. For example, creating payment orders from sales orders involving products with this setting is not >allowed. The reason is, if those payment orders are created for uninvoiced amounts, the possible change of the quantity in the transaction and therefore in the invoice may cause >the generation of excess documents."
  },
  "modules/index.html": {
    "href": "modules/index.html",
    "title": "ERP.net Internal modules | ERP.net Tech Docs",
    "summary": "ERP.net Internal modules The internal modules in ERP.net are divided in application groups. To learn more about the apps in a group, use the following list: My CRM Finance General Logistics Applications System Community Express Note Your ERP instance might contain external applications which might not be documented here. External applications are tightly integrated in the User menu. Sometimes, external apps replicate the visuals of the internal apps and might be indistinguishable."
  },
  "modules/logistics/common/index.html": {
    "href": "modules/logistics/common/index.html",
    "title": "Common | ERP.net Tech Docs",
    "summary": "Common This submodule allows you to define logistics units and their types. These units are subsequently employed across other submodules, ensuring consistency and efficiency in all logistics-related processes. Logistics unit types Before you set up a logistics unit, you can optionally define its type. This is a predefined category that specifies the characteristics of the unit that will be used in the handling and transporting of goods, such as pallets, containers, or crates. Logistics units Regardless of whether you have a type set, you can define as many logistic units as your warehouse needs. One unit represents a combination of products designated for transportation and/or storage within the supply chain. Learn more about Common in the following articles: Logistic Unit Types Logistic Units Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/logistics/common/logistic-unit-types.html": {
    "href": "modules/logistics/common/logistic-unit-types.html",
    "title": "Logistic unit types | ERP.net Tech Docs",
    "summary": "Logistic unit types A unit type is a custom category that specifies the characteristics of logistics units used in the handling and transportation of products. Examples of logistic unit types include pallets, containers, and crates. They ensure standardized handling and compatibility across all logistics-related operations. New logistic unit type To create a new logistic unit type, click on the circular \"+\" button on the Logistic Unit Types panel. Alternatively, click the title of the panel and then the New button at the top-left corner of the unit types table. You'll be taken to a separate page where you need to fill out several fields: Code - Input a unique code for the logistic unit type (required). Name - Provide a descriptive name for the logistic unit type (required). Notes - Any additional notes or details can be added here. When you are ready, click on the Save and reload button to finish the creation process. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/logistics/common/logistic-units.html": {
    "href": "modules/logistics/common/logistic-units.html",
    "title": "Logistic Units | ERP.net Tech Docs",
    "summary": "Logistic Units A logistic unit represents the composition of products designated for transportation and/or storage within the supply chain. Once defined, it can be used to specify units across other Logistics submodules. New logistic unit To create a new logistic unit, click on the circular \"+\" button located on the Logistic Units panel or select one of the logistic unit types under the Create button. Alternatively, you can click the title of the panel and then the New button located at the top-left corner of the units table. Note Choosing a logistic unit type remains optional. You can create a unit without one. Once you've completed the previous steps, a separate page will open, where you need to fill out several fields: Serial Code - Serial code of the unit (required). Logistic Unit Type - If you've selected a unit type, it will be automatically specified here. Expected Weight - This is the expected weight of the unit in the measurement unit specified in its type. Measured Weight - This is the actual weight of the unit in the measurement unit specified in its type. Cargo Type - General type of the cargo that will be used for the unit. Select one from the drop-down menu. Notes - Additional notes can be added here. Represented As Product - When the logistics unit is also a tradeable item, this field specifies the product used to trade the unit. Active Status - Check this box to make the logistic unit active. When you are ready, click on the Save and reload button to finish the creation process Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/logistics/common/pictures/index.html": {
    "href": "modules/logistics/common/pictures/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/logistics/concepts/goods-cost/cost-correction/basic-algorithm-for-cost-correction-calculation.html": {
    "href": "modules/logistics/concepts/goods-cost/cost-correction/basic-algorithm-for-cost-correction-calculation.html",
    "title": "Basic algorithm for cost correction calculation | ERP.net Tech Docs",
    "summary": "Basic algorithm for cost correction calculation This algorithm is applied to multiple records: either transaction rows or accumulated records for goods cost (most often opening a balance for а specified period). The algorithm has two stages: The records are ordered chronologically. The cost of the rows that do not include accumulated information is recalculated one by one. The cost of transaction rows in multiple records is recalculated instead of the accumulated data. The mismatch between the newly calculated and the current actual cost is saved in the document cost correction. With the release of cost correction, the costs in the transaction rows are updated. Multiple records are generated when all transaction operations for a period (as well as the opening balance at the start of the period) are loaded. It is of great importance for all transaction operations and opening balances to be loaded during the operation. Any of them missing may lead to incorrect cost correction (during stage 2 of the algorithm). Stage 1: Chronological sorting of the records The following criteria is used to order the records chronologically: In case two records share the same enterprise company, store, product, and lot (only if the product has a separate cost for each lot), the records with a shorter transaction timestamp are placed before the ones with a greater transaction timestamp. If the transaction timestamps are equal, the receipt goes before the issue operation. If the records have the same movement type, it is assumed that the operations have happened at the same time. If two records - part of a transfer or a production process - have opposite movement types, then an issue transaction is performed before a receipt transaction (only if the transaction timestamp of the issue transaction is smaller than or equal to the receipt transaction). Enterprise company, store, product, and lot do not affect the order here. The criteria above can’t provide thorough sorting of the records. That is why a topological sorting is applied. Any topological sorting may be used - more than one for a specific partial sorting. The result in the next stage is the same regardless of the sorting method used. Stage 2: Recalculating the sorted records When the records are ordered in the previous stage, the cost accumulated from the starting period (average) is calculated. Then, the cost of each record is recalculated. Finally, the recalculation of the next record begins (if there is one in the first place). The recalculation of the record cost is performed as follows: If the record is for accumulated data (opening balance), the record is not recalculated. If the record is an issue transaction, then the cost is calculated according to the average accumulated cost. If the record is a receipt transaction and is part of a transfer or a production process, then its cost is recalculated according to the algorithm from articles Calculating cost for produced products, Calculating cost for transferred products, and Calculating cost for returned products. If the record is a receipt transaction and is not part of a transfer or a production process, the record is not recalculated. Example 1: There are two stores and three products, the first two of which are provided by external suppliers. The third is internally produced. A recalculation of the cost for January 2020 is needed. This is the data for the first store. The second store has no movements recorded (including the current period): Store #1, Product #1, Opening Balance, before 01 Jan 2020 00:00, 10 PCS, total cost: 100; Store #1, Product #2, Opening Balance, before 01 Jan 2020 00:00, 10 PCS, total cost: 150; Store #1, Product #1, receipt transaction, Transaction Timestamp 05 Jan 2020 17:27, 10 PCS, total cost: 140; Store #1, Product #2, receipt transaction, Transaction Timestamp 05 Jan 2020 17:27, 10 PCS, total cost: 190; On 16 Jan 2020, a certain quantity from the third product is manufactured and added in the other store: Store #1, Product #1, issue transaction, Transaction Timestamp 16 Jan 2020 10:12, 4 PCS, total cost: 48; Store #1, Product #2, issue transaction, Transaction Timestamp 16 Jan 2020 10:25, 6 PCS, total cost: 102; Store #2, Product #3, receipt transaction, Transaction Timestamp 16 Jan 2020 14:47, 2 PCS, total cost: 150. Then, on 19 Jan 2020, part of the produced quantity is moved to the first store and the transport costs 7: Store #2, Product #3, issue transaction, Transaction Timestamp 19 Jan 2020 11:32, 1 PCS, total cost: 75; Store #1, Product #3, receipt transaction, Transaction Timestamp 16 Jan 2020 11:50, 1 PCS, total cost: 82. It turns out that there was a receipt transaction on 11 Jan 2020 which is not entered in the system on time: Store #1, Product #1, receipt transaction, Transaction Timestamp 11 Jan 2020 13:44, 5 PCS, total cost: 85; Store #1, Product #2, receipt transaction, Transaction Timestamp 11 Jan 2020 13:44, 6 PCS, total cost: 44. The cost of all other store Transactions during this month is incorrect (except the first two receipts on 05 Jan 2020) and has to be recalculated. When executing the algorithm with the previous data, the following order of records will be completed after the first stage: Store #1, Product #1, Opening Balance, before: 01 Jan 2020 00:00; Store #1, Product #2, Opening Balance, before: 01 Jan 2020 00:00; Store #1, Product #1, receipt transaction, Transaction Timestamp: 05 Jan 2020 17:27; Store #1, Product #2, receipt transaction, Transaction Timestamp: 05 Jan 2020 17:27; Store #1, Product #1, receipt transaction, Transaction Timestamp: 11 Jan 2020 13:44; Store #1, Product #2, receipt transaction, Transaction Timestamp: 11 Jan 2020 13:44; Store #1, Product #1, issue transaction, Transaction Timestamp: 16 Jan 2020 10:12; Store #1, , Product #2, issue transaction, Transaction Timestamp: 16 Jan 2020 10:25; Store #2, Product #3, receipt transaction, Transaction Timestamp: 16 Jan 2020 14:47; Store #2, Product #3, issue transaction, Transaction Timestamp: 19 Jan 2020 11:32; Store #1, Product #3, receipt transaction, Transaction Timestamp: 19 Jan 2020 11:50. After the recalculation in the second stage for the last five transactions, the following actual costs will be calculated: Store #1, Product #1, issue transaction, Transaction Timestamp: 16 Jan 2020 10:12, recalculated cost: 52; Store #1, Product #2, issue transaction, Transaction Timestamp: 16 Jan 2020 10:25, recalculated cost: 96; Store #2, Product #3, receipt transaction, Transaction Timestamp: 16 Jan 2020 14:47, recalculated cost: 148; Store #2, Product #3, issue transaction, Transaction Timestamp: 19 Jan 2020 11:32, recalculated cost: 74; Store #1, Product #3, receipt transaction, Transaction Timestamp: 19 Jan 2020 11:50, recalculated cost: 81. This means that in the cost correction document, 5 rows will be created, one for each of thе operations with cost changed, and the rows will save the mismatches: 52 - 48 =4, 96 - 102 = -6, 148 - 150 = -2, 74 - 75 = -1 and 81 - 82 = -1."
  },
  "modules/logistics/concepts/goods-cost/cost-correction/index.html": {
    "href": "modules/logistics/concepts/goods-cost/cost-correction/index.html",
    "title": "Cost correction | ERP.net Tech Docs",
    "summary": "Cost correction The current article describes the calculation (and recalculation) of the actual cost. The article Original cost calculation describes how the original cost is calculated. Those calculations are accurate as long as the store transactions are entered in their original chronology. If the order is incorrect, so will be the cost. Example 1: There are two receipt transactions and one issuing transaction entered in the system: receipt, Timestamp: 05 Jan 2020 12:45, 4 PCS, total cost: 100 EUR; receipt, Timestamp: 05 Jan 2020 17:27, 3 PCS, total cost: 75 EUR; According to the original cost calculation for average cost, the issuing transaction should be: issue, Timestamp: 08 Jan 2020 11:29, 5PCS, total cost: 5 * (175/7) = 125 EUR; There is another receipt transaction not entered on time. It happened on 07 Jan 2020 and was entered on 08 Jan 2020: receipt, Timestamp: 07 Jan 2020 23:59, 3PCS , total cost: 105 EUR; If the third receipt transaction is entered on time, then the unit cost on 08 Jan 2020 would be 280/10 = 28, not 25, as it was originally calculated in the issuing transaction. This is happening due to the late entering of the transaction in the system. The cost of the issuing transaction is incorrect and a recalculation is needed. The effect of the incorrect cost from example 1 may influence not only issuing transactions. If the issuing operation was about ingredient consumption from the Production module, for example, then the cost of the production output would be incorrect as well. This leads to incorrect cost when issuing the production output. If you don't enter the transactions in the system on time, there will be negative consequences. To correct them, there is a basic algorithm for cost correction calculation. This algorithm changes the costs as if they were entered on time. There is a document named cost correction, where the results from this calculation should be saved. Тhe rows of the document show how the cost is changed (base cost, product cost, store cost, and document cost) for each Transaction row affected. Cost corrections allow the original cost to be changed. In each transaction row the fields are as follows: [actual/corrected cost] = [original cost] + [adjustment cost] where: [original cost] = the product, store, document, and base cost saved in the transaction row; [adjustment cost] = the sum of all product, store, document, and base cost values saved in the rows of all the released, non-voided cost corrections referring to the current transaction row. For more specific information, see: Basic algorithm for cost correction calculation Models for maintaining the actual cost Specific procedures of cost corrections"
  },
  "modules/logistics/concepts/goods-cost/cost-correction/models-for-maintaining-the-actual-cost.html": {
    "href": "modules/logistics/concepts/goods-cost/cost-correction/models-for-maintaining-the-actual-cost.html",
    "title": "Models for maintaining the actual cost | ERP.net Tech Docs",
    "summary": "Models for maintaining the actual cost There are two main models to keep the goods cost up-to-date. Right from the start, when we enter (and release) the transactions, the actual cost is recalculated. The costs of all existing store transactions affected by the current transaction are also calculated. This leads to a perfect situation where all transactions are correctly calculated no matter when they are entered in the system. In addition, the calculation is performed by the system and the user does not have to control it. The disadvantage of this model is the additional calculations for creating and releasing a transaction, especially when that transaction is old. This may lead to slow performance of the Logistics module. The corrections are created periodically by a user instead of immediately for each transaction. This model provides the easier daily creation of a transaction with a risk for incorrect costs not covered by cost correction (this happens only when store transactions are entered in a non-chronological manner). Dynamic cost correction Maintaining the actual cost at all times with the first model is accomplished by using two specific procedures for generating cost correction from every transaction. They have to be created when the transaction is released and the generation of the cost correction updating the cost of the current transaction is performed first. Thus, when the transaction is released, it will have its original cost, and the first generation will correct its values if necessary. We assume that the cost of all existing released transactions before the creation of the current transaction are correct (as the cost of the current transaction may be affected by them). Once the first generation corrects the cost of the newly entered transaction, the second generation corrects the cost of all other transactions that depend on the current transaction. Thus, after its release, the cost of all transactions in the system will be actual no matter the date they are entered. The older the transaction, the slower the performance of the two generation procedures will be (this means that more transactions will be affected by the current transaction). Periodical cost correction The second model for cost correction does not use automatic generation procedures for the cost corrections. Instead, the user manually enters documents for a specified period (month, quarter, etc.) and starts the basic algorithm for cost correction calculation for all transactions in the specified period. For example, if cost corrections are performed monthly, the user creates a new cost correction document and sets the period from the first date to the last date of the month. Then, he starts the function Recalculate the corrections for the period, which loads all store transactions where transaction timestamp is in the specified period. The function then adds the opening balances at the beginning of the period, and this data is executed by the basic algorithm for cost correction calculation . So, the actions of the user are limited to entering the start and end dates, starting the function and releasing the document. This is performed for past periods (i.e. not for the current month) for which there will be no more new transactions, and in which the cost corrections are already calculated and released. Otherwise, there may be incorrect cost in the current-period transactions. The recalculation of the cost of all transactions in a specified period may take more time than if the first model is used, but it eases the daily Transactions release significantly. Also, for periodical cost correction, a more appropriate execution time may be picked (for example, during the night)."
  },
  "modules/logistics/concepts/goods-cost/cost-correction/specific-procedures-of-cost-corrections.html": {
    "href": "modules/logistics/concepts/goods-cost/cost-correction/specific-procedures-of-cost-corrections.html",
    "title": "Specific procedures of cost corrections | ERP.net Tech Docs",
    "summary": "Specific procedures of cost corrections Apart from the standard method of cost correction - loading the store transaction for a specified period (plus the opening balances) and filling in the rows for the correction by the basic algorithm for cost correction calculation, there are two more ways to create a cost correction document. They use generation procedures available in the transaction document. Cost correction generation procedure for the actual cost of the current transaction This generation procedure updates the cost of the store transactions in the current transaction document. For each row, the following actions are applied: Loading the actual cost by the current moment (i.e. this is the sum of the original cost from the transaction row and the addition cost in the row, generated by already created cost corrections). This is a sum [current cost]; Then, the actual cost for the row is calculated - the sum [actual cost] as usual: a. if the transaction is issuing, the cost is calculated by the average accumulated cost; b. if the record is a receipt transaction and is part of a transfer or production process, its cost is recalculated according to the algorithm from articles Calculating cost for produced products, Calculating cost for returned products and Calculating cost for transferred products; c. if the record is a receipt transaction and is not part of a transfer or production process, the original cost is considered the actual cost. To make valid calculations, the cost of all store transactions affecting the current transactions should be recalculated correctly. At the end, the difference [actual cost] - [current cost] is calculated. Provided that it is different than zero, a new row is added in the cost correction sub-document for the current transaction row, which contains the difference. Cost correction generation procedure for the current transaction results This generation procedure updates the costs of all transactions that depend on the current transaction rows. The following actions are executed: Loading all store transactions (with the opening balances if needed) which depend on the current document; Тhe basic algorithm for cost correction calculation is applied over the loaded set of records; For each store transaction from the set of records, the difference between the algorithm result and the actual cost valid before the creation of the current transaction, is calculated. If it is a non-zero result, a new row in the cost correction is added. Loading the records is performed iteratively. Before the first iteration, the following is created: [current set of records] = the transactions in the current Transaction document; [current Movement Type] = Movement Type of the current transaction; [result] = [current set of records] + the opening balances for the current store of the current products from the transactions of the [current set of records] (the opening balances are for the Transaction timestamp date) Then, a cycle of iterations is performed, and for each iteration, the following is executed: if the [current Movement Type] = receipt, a new set of records is loaded; [new set of records] = all transactions for the stores and the products (and the lots, if the product keeps separated cost for each lot) from the [current set of records] whоse Transaction Timestamp is greater than or equal to the Transaction Timestamp in the [current set of records]. If the[current Movement Type ]= issue and the [current set of records] has records that are part of a transfer/production process, then the [new set of records] is as follows: [new set of records] = all receipt transactions from the specified transfer/production processes, whose transaction timestamps are greater than or equal to the transaction timestamps in the [current set of records]. The result is updated and the current set of records becomes: [result] = [result] U [new set of records] (the opening balances are added for every new store which is part ot [new set of records] but is not part of [current set of records]); [current set of records] = [new set of records]. At the end, if [current Movement Type ] = receipt, then [current Movement Type] is set to issue and if it was [current Movement Type] = issue,[current Movement Type] is set to receipt. These iterations are performed until an iteration has a [new set of records] that is empty."
  },
  "modules/logistics/concepts/goods-cost/costing-methods.html": {
    "href": "modules/logistics/concepts/goods-cost/costing-methods.html",
    "title": "Costing methods | ERP.net Tech Docs",
    "summary": "Costing methods The costing methods are used to determine the exact cost price of products, which is essential for: Pricing: Knowing the cost price helps companies set competitive and profitable prices for their products. Cost control: By analyzing the cost price, companies can identify and reduce unnecessary expenses. Planning and budgeting: Accurate cost price is the basis for effective financial planning and budgeting. and others. In ERP.net, costing methods can be configured both globally at the Enterprise Company level and individually for each Product. The application priorities are as follows: If a method is specified in both the Product definition and the Enterprise Company definition, the one from the Product is with higher priority; If no method is specified in the Product definition, the one from the Enterprise Company is used. Since the costing method is a mandatory field for the Enterprise Company, it will always have a defined value. NOTE: Regardless of where the method is specified, the cost price is calculated in the same way. ERP.net supports multiple costing methods to accommodate diverse business needs. The available costing methods include: 1. Average cost for the whole product: The most commonly used method, given that not all products have lots. It is used when lots are not assigned to the product or when tracking cost price by lots is unnecessary. The cost is calculated by taking the value of all available products, regardless of whether they have lots or not, and averaging it. Click here so see the Example: Product X has 100 units in stock - 50 units were bought at 8 BGN each, and 50 units were bought at 10 BGN each. To calculate the average cost: Total cost = (50 * 8) + (50 * 10) = 400 BGN + 500 BGN = 900 BGN. Average cost per unit = 900 BGN / 100 units = 9 BGN per unit. In this case, the cost is averaged across all units, regardless of whether they have lots assigned to them. 2. Separate cost for each lot: Used when products have unique lots and it is important to calculate the cost price of each separately (due to different acquisition prices, regulatory requirements, or other reasons). The cost is calculated by taking the value of all available products by lots and averaging it for each lot. If for the same product, there are availabilities without a lot, then the cost for them is calculated by assuming that all are a part of a single, unified lot. Click here so see the Example: **Product Y** has two lots: - **Lot 1:** 100 units in stock - 50 units were bought at 8 BGN each, and 50 units were bought at 10 BGN each. - **Lot 2:** 100 units in stock - 50 units were bought at 4 BGN each, and 50 units were bought at 6 BGN each. To calculate the cost for each lot separately: Lot 1 cost: Total cost = (50 * 8) + (50 * 10) = 400 BGN + 500 BGN = 900 BGN. Average cost per unit = 900 BGN / 100 units = 9 BGN per unit. Lot 2 cost: Total cost = (50 * 4) + (50 * 6) = 200 BGN + 300 BGN = 500 BGN. Average cost per unit = 500 BGN / 100 units = 5 BGN per unit. If there are another 100 units of Product Y available without a lot, they are considered part of a single, unified lot. No lot: 100 units in stock - 50 units were bought at 2 BGN each, and 50 units were bought at 4 BGN each. Total cost = (50 * 2) + (50 * 4) = 100 BGN + 200 BGN = 300 BGN. Average cost per unit = 300 BGN / 100 units = 3 BGN per unit. Each lot has its own cost calculated separately, and products without a lot are treated as part of a unified cost group. 3. Average, partitioned by Reserved for document: Used in situations where it is necessary to separate the cost of specific lots related to a given document (e.g., sales order, purchase order, or other). The cost is calculated as follows: For lots reserved for the same document, the cost price is determined by averaging the cost of all available quantities within those lots. For the remaining lots not reserved for any document, the cost is calculated by treating all of them as part of a single, unified lot and averaging the cost across all these lots. Click here so see the Example: **Product W** has four lots: - **Lot 1:** 10 units in stock at 5 BGN each (Reserved for a sales order). - **Lot 2:** 20 units in stock 6 BGN each (Reserved for the same sales order). - **Lot 3:** 15 units in stock 7 BGN each (Not reserved for any document). - **Lot 4:** 25 units in stock 8 BGN each (Not reserved for any document). To calculate the cost: **For the reserved lots (Lot 1 and Lot 2):** These lots are reserved for the same sales order, so their costs are calculated by averaging the cost for both (all) of them: Total cost = (10 * 5) + (20 * 6) = 50 BGN + 120 BGN = 170 BGN. Average cost per unit = 170 BGN / 30 units = 5.67 BGN per unit. For the unreserved lots (Lot 3 and Lot 4): These lots are not reserved for any document, so they are treated as a single unified lot: Total cost = (15 * 7) + (25 * 8) = 105 BGN + 200 BGN = 305 BGN. Average cost per unit = 305 BGN / 40 units = 7.63 BGN per unit."
  },
  "modules/logistics/concepts/goods-cost/index.html": {
    "href": "modules/logistics/concepts/goods-cost/index.html",
    "title": "Goods Cost | ERP.net Tech Docs",
    "summary": "Goods Cost Currently, the goods cost in ERP.net is calculated by the store transactions documents. For each transaction, the cost is defined either automatically when the document is released or by the parent document. This is determined by the Cost Source field. It has two possible values: ‘Store’ - this value sets out that the cost in the transaction is defined when releasing the document by the accumulated cost in the store. This is used when issuing transactions are executed. ‘Document’ - the cost is defined by the data in the transaction rows (Unit Cost and Line Cost fields). This data is usually inherited by the parent document and used when receipt operations are executed (the only exception is when the receipt operation comes from ‘Reconciliation’ - then, the value in Cost Source is ‘Store’). ‘Store orders’ enable other modules to set the cost of goods. They contain not only the quantity but in specific cases, what the goods cost should be. This cost is copied to the transactions. The Cost Source is set to Document in the transactions executing the specific Store Order. This is how they participate in the cost definition. For each store transaction (i.e. transaction document) changing the cost, a specific Timestamp is saved. It indicates the time the operation starts influencing the cost. The field in the transaction rows is called transaction timestamp. Generally, the transactions should be entered into the system in the right chronology. Usually, the transaction timestamp is set either by the ‘transaction release’, or by the ‘store orders’ as follows: in the parent store order, a specific transaction timestamp is set. This value is inherited by the transaction that executes the ‘store order’'; if the parent store order has no transaction timestamp and the transaction has today's date or future date, then the transaction timestamp is set to the current date and time; if the parent store order has no transaction timestamp and the transaction has past date, then the transaction timestamp is set to XX.XX.XXX 23:59:00, where XX.XX.XXXX is the document's date. If necessary, the transaction timestamp may be set manually by the user, although there are certain limitations. For example, if the quantity in the row is 0, the date in Document Date should be no different than the one in transaction timestamp. For more information, see the Setting transaction timestamp article. Cost types When the transactions are not entered into the system on time and damage the right chronology, this may generate incorrect costs. To fix this, ERP.net has developed a Cost correction system, recalculating the cost as if it was entered in the right chronological order. There are two types of goods costs: Original cost - defined right when entering the document. Depends on the entry order. Cost adjustment – for the definition of this cost, a special recalculation is used. It compensates for the wrong chronology of the transactions. Cost currency In the transactions, the cost comes in four currencies: base cost, product cost, store cost, and document cost. For each row, the cost is calculated independently. The base currency comes from the Enterprise Company definition of the current transaction. Product currency is part of the product definition and if there is no currency, then the base cost is used. Store currency is in the store definition; if there is no currency - the base currency is used. The document currency is set in the Document Currency field. For each store transaction, the cost is calculated in all four currencies when defined automatically. Costing methods ERP.net supports multiple costing methods to accommodate diverse business needs. For more information, see the Costing methods topic. For more specific information about cost calculations see the following articles: Costing methods Original cost calculation Cost correction"
  },
  "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-inventory-reconciliation.html": {
    "href": "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-inventory-reconciliation.html",
    "title": "Calculating cost for inventory reconciliation | ERP.net Tech Docs",
    "summary": "Calculating cost for inventory reconciliation The cost of the issue and receipt store transactions, which are the result of an inventory reconciliation, are calculated according to the current availabilities in the store, as on the date of the inventory reconciliation. Since some of the products may not be available, the calculation is performed according to the following algorithm: The current availability of the product on the date of the inventory reconciliation is calculated. If the current availability is different from 0, the average cost is taken. If the current availability is 0, the unit cost of the last issue store transaction is taken. If there is no previous issue store transaction, the standard cost is taken (from the product definition)."
  },
  "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-produced-products.html": {
    "href": "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-produced-products.html",
    "title": "Calculating cost for produced products | ERP.net Tech Docs",
    "summary": "Calculating cost for produced products In the production process, some materials (issued from one or multiple stores) are transformed into a certain output (entered into the store). The cost of the issue transactions has to be transferred to the receipt transactions. This is similar to the transfer and return of goods (see Calculating cost for transferred products and Calculating cost for returned products). However, the calculations are different. During production, the receipt store orders are generated by output orders. There are two stages for calculating the cost in the receipt store orders: Comparison between the rows in the consumption orders and the rows in the output orders. For each row in the output orders, that comparison defines which materials are used for the production of the product in the current row. For each row in the consumption orders, the cost of the issue transactions of the current row is distributed by its relevant output orders rows from stage 1. In the end, it is provided that on each output order row, the distributed amount comes only from the materials that are used for the produced products in the current row. This distributed amount is written as a specifically set cost in the receipt store order, which is generated by the output order. Stage 1: Comparison of the rows in the consumption and output orders Released, non-voided consumption orders and output orders that are sub-documents of a given work order are taken into account. For each row of an output order, the following is defined: what part of the materials is used to produce the specified row and from which consumption order rows the materials are taken. This data is saved in a Distributed material consumptions table (part of the output order data). The output orders may get materials only from consumption orders released before the output order. In other words, the release order for consumption and output orders defines how the quantities in their rows will be compared. When a user creates a new output order and releases it, the distributed materials are recalculated. This is true for corrections as well. For each output order row, the following is executed: All rows for released, non-voided consumption orders for the current work order item are filtered (their quantities need to be taken into account). The consumption orders are released before the current output order. From the quantities of the rows in step 1, quantities of materials distributed on the same work order item by output orders (released before the current one) are removed. From what's left of the materials, the necessary quantities for the current row of the output order are distributed. They are defined by the Recipe in the work order. For the current row, they cannot be distributed in bigger quantities than they are allowed to. Exception is made only for the last output orders from each work order item or for the output order rows marked as Finished. The rest of the materials are distributed on Finished rows. When releasing new consumption orders or voiding released consumption orders, these steps are executed again for each output order from the current work order. This keeps the distributions for these output orders up-to-date. Example 1: There is a work order producing 3 PCS of a product. The materials are 9 PCS from Material #1 and 12 PCS from Material #2. The materials are consumed in two stages: Consumption order CO#1, which has 8 PCS from Material #1 and 8 PCS from Material #2 Consumption order CO#2, which has 1 PCS from Material #1 and 4 PCS from Material #2 Both consumption orders are released and the first output order is created for 2 PCS of the work order item. When this output order is released, the following materials distribution is calculated: Product, CO#1, Material #1, 6 PCS; Product, CO#1, Material #2, 8 PCS. Then, the user creates and releases an output order for the rest 1 PCS of the work order item. It distributes the following: Product, CO#1, Material #1, 2 PCS. Product, CO#2, Material #1, 1 PCS. Product, CO#2, Material #2, 4 PCS. In the current stage, it is possible that no issue/receipt store transactions have been released yet. Therefore, this distribution is used to reserve materials for work order items. When the store transactions begin, the cost of the issue transactions is transferred to the receipt transactions (Stage 2) using the already calculated distribution. Sometimes the remaining non-distributed materials from an output order are less than what is ordered by the recipe in the current output order. In this case, the output order is distributed in fewer than the technologically defined quantities. The remaining excess (if, of course, this is requested by following consumption orders) will be distributed to the last output order of the current work order item (or to a row marked as \"Finished\"). Let's take a look at such an example. Example 2: We have the same work order as in Example 1. First, CO#1 is released with 5 PCS of Material #1 and 6 PCS of Material #2. Then, an output order is released for the 2 PCS of the work order item. According to the recipe, 6 PCS of Material #1 and 8 PCS of Material #2 should be distributed. By now, no consumption orders with such quantities have been released. As a result, the output order takes fewer quantities (from CO#1): Work order item, CO#1, Material #1, 5 PCS; Work order item, CO#1, Material #2, 6 PCS. Then, CO#2 is released with the rest of the materials quantities - 4 PCS and 6 PCS, respectively. When the second output order is released for the remaining 1 PCS, more materials per unit will be distributed than in the first output order: Work order item, CO#2, Material #1, 4 PCS; Work order item, CO#2, Material #2, 6 PCS. There are cases when non-distributed materials remain even after the release of the last output order on one work order. Usually, this happens if consumption orders are released after all output orders. As a final result, an output order with 0 quantity is released. Such output orders are called completing output orders and all remaining materials are distributed to them. Sometimes these orders are not only released, but come before the last output order with non-zero quantities. This is done when there are non-distributed materials, though the next output orders will not be released soon. The completing output orders (also known as intermediate) \"collect\" all the remaining material quantities without having to release the next output order. The two examples above describe production processes where each material from a Work Order is assigned to exactly one work order item. There are materials which cannot be assigned to a specific work order item (the work order item field in the ingredients table is empty). Instead, the quantity of the material is distributed to all work order items in the current Work Order. This distribution may be achieved by two methods (different values in the Distribute By field): by Standard Price - the current Standard Price Per Lot of the products from the work order rows (the work order items) is used. The price is then multiplied by the quantities in the rows and the result becomes a coefficient for materials distribution; by Measurement - the quantities from the work order rows are used as coefficients. Each quantity is converted into a measurement category, which is specified in the material row. All products must have defined product dimensions for the specified category. After the coefficients are defined by one of the methods, the quantities from the consumption order are distributed to an output order as follows: All rows of released, non-voided Consumption Orders are filtered. The consumption orders are released before the current output order. The quantities from p.1 are decreased by the material quantities distributed to output orders which are released before the current one. The entire remaining materials quantity is distributed by the coefficients among all rows of the current output order. To define the coefficients, the quantities from the current output order are used. Note If all work order items have a Standard Price Per Lot of 0 (zero), the coefficients would also be 0. In that case, the cost of all materials from p.2 is distributed equally among the work order items. As a result, cost loss is avoided. Example 3: There is a Work Order with 295 PCS of a given material, which is distributed by standard price among four work order items of the work order: Product #1 (standard price is 17 EUR), Product #2 (standard price is 9 EUR), Product #2 (standard price is 12 EUR), and Product #4 (standard price is 20 EUR). For each work order item, 2 PCS are produced. First, CO #1 is released for 189 PCS of the material. Then, OO #1 is released with the following: 2 PCS of Product #1, 1 PCS of Product #2 and 1 PCS of Product #4. The coefficients for distribution in the current output order are: 2 * 17 : 1 * 9 : 1 * 20 = 34 : 9 : 20. According to these coefficients, the following distribution is achieved: Product #1, CO#1, Material, 189 * 34 / (34 + 9 + 20) = 102 PCS; Product #2, CO#1, Material, 189 * 9 / (34 + 9 + 20) = 27 PCS; Product #3, CO#1, Material, 189 * 20 / (34 + 9 + 20) = 60 PCS. Then, a new CO #2 is released for the rest 106 PCS, and the last output order is released for the rest of the work order items. It has the following coefficients: 1 * 9 : 9 * 12 : 1 * 20 = 9 : 24 : 20. The distribution is calculated as follows: Product #2, CO#2, Material, 106 * 9 / (9 + 24 + 20) = 18 PCS; Product #3, CO#2, Material, 106 * 24 / (9 + 24 + 20) = 48 PCS; Product #4, CO#2, Material, 106 * 20 / (9 + 24 + 20) = 40 PCS. Stage 2: Issue transactions cost distribution Once Stage 1 is completed, the cost of the issue transactions is transferred to the receipt transactions. This operation can be explained with the quantity distribution of the materials from the consumption orders and the work order items from the output orders. The distributions are used to form proportions which help distribute the cost of the consumption order transactions among the output orders. This distribution is also saved in the \"Distributed Material consumptions\" table (in the output order document) and then it is used to set the cost of the receipt store transactions correctly. When new issue transactions appear from consumption orders, an update of the distributions in all output orders (from one work order) is executed again. The quantity distributions are complemented by the cost distributions. Let's examine this particular case: There is a row from a consumption order which contains 15 PCS, 5 PCS of which are distributed to one output order and the rest 10 go to another output order. If there are several store transactions to issue all 15 PCS at a cost of 371 EUR, then one-third of it is distributed to the first output order and the rest is distributed to the second one. A detailed example follows. Example 4: There is a work order producing 3 PCS of a product. The materials are 9 PCS from Material #1 and 12 PCS of Material #2. The materials are consumed in two stages: Consumption order CO#1, which has 8 PCS from Material #1 and 8 PCS from Material #2 Consumption order CO#2, which has 1 PCS from Material #1 and 4 PCS from Material #2 There is an output order for 2 PCS of the work order item with the following distribution: Product, CO#1, Material #1, 6 PCS; Product, CO#1, Material #2, 8 PCS. The second output order is for 1 PCS from the work order item with the following distribution: Product, CO#1, Material #1, 2 PCS; Product, CO#2, Material #1, 1 PCS; Product, CO#2, Material #2, 4 PCS. If the issue cost is 40 EUR for Material #1 and 71 EUR for Material #2 from CO#1 and 7 EUR for Material #1 and 39 EUR for Material #2 from CO#2, then a distribution is calculated where the quantity comparisons are filled with costs. The first output order has the following: Product, CO#1, Material #1, 6 PCS, 40 * 6 / 8 = 30 EUR; Product, CO#1, Material #2, 8 PCS, 71 * 8 / 8 = 71 EUR. And the cost of the produced product from this output order is 30 + 71 = 101 EUR. For the second output order, there is the following: Product, CO#1, Material #1, 2 PCS, 40 * 2 / 8 = 10 EUR; Product, CO#2, Material #1, 1 PCS, 7 * 1 / 1 = 7 EUR; Product, CO#2, Material #2, 4 PCS, 39 * 4 / 4 = 39 EUR. And the total cost of the produced product is 10 + 7 + 39 = 56 EUR. Issue and receipt balance Similarly to store transfers and sales, there is a receipt limitation in the production - it cannot exceed the issue. Unlike store transfers and sales, the validation is a bit more complicated because the product in the issue transactions is different from the product in the receipt transactions. The materials are not the same as the produced product. As a result, the total quantities of issue and receipt transactions cannot be compared directly. The limitation is applied on all store transactions that are caused by a Work Order. For each transaction timestamp, the following is executed: All issues (the materials) are summed up with a transaction timestamp less than or equal to the current. By their receipts from the work order, it is defined what is the largest quantity that is available for production from these materials; All receipts (the produced products) are summed up with a transaction timestamp less than or equal to the current; A validation is performed to check if the maximum quantity of the product from p.1 is bigger than or equal to the receipt total from p2. For more information about the validation, see Receipt and issue balance validation in store transfers."
  },
  "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-returned-products.html": {
    "href": "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-returned-products.html",
    "title": "Calculating cost for returned products | ERP.net Tech Docs",
    "summary": "Calculating cost for returned products The current article describes how the product cost is formed when returning sold products. This is a receipt returning. This process is very similar to the product transferring (see Calculating cost for transferred products). However, there’s а difference: instead of transferring the products from one store to another in the current enterprise company, the products are taken out of the store and given to the customer. After that, the customer returns them to the same store. So, the receipt cost (on each row) is defined by the following formula: [receipt cost] = proportional part of the [issue cost] A proportional part of the issue cost is required as not all products can be returned after being sold. The proportion is defined by the ratio between sold and returned quantity. Example 1: A customer buys 10 PCS on 05 Jan 2020 and a few days later returns 3 PCS. The issue transaction is: issue, Timestamp: 05 Jan 2020 11:14, 10 PCS, document cost: 90. Then, in the receipt store order generated by the returning sale order, the following is saved: 3 PCS, document cost: 90 * 3 / 10 = 27 The data for the issue transactions is retrieved as follows: The value in Return for sales order line is taken into account - it connects us to the original line. For this line, the system finds all store orders rows referring to it. For each store order row, the respective non-voided executions are loaded (transactions rows) - the store transactions. The document cost is copied from the Line document cost field in the transactions rows. There are some specific cases when the calculations from the example described above are not possible. Here, it is necessary to enter the original sale orders lines in the rows of the returning sales order. Sometimes this is not possible and the original sales order does not exist in the system. If a company started working on ERP.net recently and the original sales order had happened before the shift to ERP.net, the Historical Unit Cost field from the returning sales order is used for the definition of the unit cost in the receipt transaction. The formula is as follows: [receipt cost] = [returned quantity] * [historical unit cost] Example 2: There is a product return from a customer for 3 PCS and the original sales order does not exist in ERP.net. The Historical Unit Cost field in the returning sales order has to be filled in. If its value is 8, then the receipt store order will have the following: 3 PCS, document cost: 3 * 8 = 24. Receipt and issue cost balance As with store transfers, when returning products, the quantity returned can’t be greater than the quantity sold. This is true for the original sale document and all the sales orders for the products returned. Every store transaction for the sales orders is gathered and for each transaction timestamp, validation is performed as in the store transfers: The costs from all issue transactions with transaction timestamp smaller or equal to the current are summed up; The costs from all receipt transactions with transaction timestamp smaller or equal to the current are summed up; The system checks if the issue total is greater or equal to the receipt total. For more details about this validation, see Receipt and issue balance validation in store transfers."
  },
  "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-transferred-products.html": {
    "href": "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-for-transferred-products.html",
    "title": "Calculating cost for transferred products | ERP.net Tech Docs",
    "summary": "Calculating cost for transferred products Store Transfers create two parallel sub-document flows - receipt and issue flow. The cost of the issue store transactions is calculated by the average cost in the store, while the one in the receipt store transactions - specifically by the store transfer. It is formed by the following two components: Issue cost (of the issued goods); Additional amounts in the store transfer, added to the products (representing increased goods cost e.g because of transport taxes). For each store transfer the following must be valid: [receipt cost] = [issue cost] + [Additional amounts for cost] Each store transaction row is calculated separately (so [Additional amounts for cost] is the additional amount distributed to the current row). These calculations are executed when the receipt store order is generated and the calculated cost is saved in the Line Cost field in the rows of the store order. So if the generated store order receipt follows the generation of the issue documents (orders and their executions, providing the issue cost), then the issue cost may be copied to the receipt orders. Example 1: There is a store transfer with two rows - row #1 with Product 1 for 10 PCS and row #2 with Product 2 for 12 PCS. At first, there are two issue transactions: issue, Product 1, Timestamp: 01 Dec 2020 13:50, 8 PCS, document cost: 88; issue, Product 2, Timestamp: 01 Dec 2020 13:50, 6 PCS, document cost: 90. Afterwards, store orders receipt will be created with the same quantities and set costs in the rows: row #10, Product 1, 8 PCS, line cost: 88; row #20, Product 2, 6 PCS, line cost: 90. When executing this store order, the result is transactions receipt for 8 PCS and 6 PCS with cost of 88 and 90, respectively. And when the rest of the transfer quantities are issued: issue, Product 1, Timestamp: 07 Dec 2020 10:05, 2 PCS, document cost: 20; issue, Product 2, Timestamp: 01 Dec 2020 10:05, 6 PCS, document cost: 102. a new receipt store order will be created with rows as follows (the store transfer will try to create a new store order for the whole issued cost from the four issue transactions. However, a store order for the first two issues already exists, so the Discrepancy system will create new order only for the second issues): row #10, Product 1, 2 PCS, line cost: 20; row #20, Product 2, 6 PCS, line cost: 102. When executing this store order, the receipt cost will be equal to the issue cost. The next example describes the calculations when there is an additional amount for the transport added to the goods cost. Continuation of Example 1: There is an additional transport amount of 66 (in document currency) distributed in the two rows as follows: 30 on the first row and 36 on the second row. These amounts will be added to the row costs in the generated store orders, proportionally to their quantities. So their rows become: Store Order #1, row #10, Product 1, 8 PCS, row cost: 88 + 30 * (8 / 10) = 112; Store Order #1, row #20, Product 2, 6 PCS, row cost: 90 + 36 * (6 / 12) = 108; Store Order #1, row #10, Product 1, 2 PCS, row cost: 20 + 30 * (2 / 10) = 26; Store Order #1, row #20, Product 2, 6 PCS, row cost: 102 + 36 * (6 / 12) = 120; The standard generation of store orders receipt from store transfers always creates a store order receipt for the exact quantity already issued by transactions. The user may change the quantities (only decreasing them - see the end of the current article) in the receipt documents or enter them manually (the cost in the receipt documents has to be proportional to the one calculated by the system). Example 1 (alternative case): If due to correction or manual work the receipt store order #1 is as follows: row #10, Product 1, 5 PCS, row cost: 55; row #20, Product 2, 4 PCS, row cost: 60; then, the rest of the cost – 33 for row #10 and 30 for row #20, will be added along with the quantities in the second receipt order: row #10, Product 1, 5 PCS, row cost: 53; row #20, Product 2, 8 PCS, row cost: 132; Issue and receipt cost balance In the examples above, it is possible to receive only less quantity than the issued - the rest will come later. The receipt value in a document cannot be more than the issued’s. It is not possible to receive more than the amount issued from the first store when transferring stocks. Although these cases are just theoretical, they may lead to incorrect cost (especially after cost correction, as discrepancies may appear). Example 2: In Store 1, where 5 PCS are available from a product, cost: 100, and in Store 2, there are 10 PCS from the same products with the cost of 200. A transfer from Store 2 to Store 1 for 3 PCS is executed. At first, 1 PCS is issued from Store 2, then immediately all 3 PCS are received. The total availability in both stores is 8 + 9 = 17 instead of 15. There will also be an artificial cost increase. If this availability and cost condition is kept for some time, there may be incorrect cost calculations of the store transactions. Limitations for what is possible to be entered in the target store from a store transfer are required. They are applied when releasing or voiding the released transactions from the transfer. A limitation could be: For each transaction timestamp on all transactions of the current transfer, the following must be true: The sum of the issues up to this timestamp (including the timestamp) is larger or equal to the sum of the receipts up to this timestamp (including the timestamp). Example 3: If we use the store transfer of 3 PCS from Store 2 to Store 1 from Example 2, the first issue is as follows: issue, Timestamp: 10 Dec 2020 17:04, 1 PCS, cost: 20; Now, the user is not able to make a transaction receipt for 3 PCS. The user is able to enter up to 1 PCS: in Store 1. receipt, Timestamp: 10 Dec 2020 17:27, 1 PCS, cost: 20; The user is not able to change the transaction timestamp to a value less than 10 Dec 2020 17:04. After releasing the transaction receipt, the user is not able to void the issue transaction because on 10 Dec 2020 17:27 there will be a total issue of 0 PCS, which is less than the total receipt of 1PCS. For more information about the validation, see Receipt and issue balance validation in store transfers."
  },
  "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-when-returning-rented-assets.html": {
    "href": "modules/logistics/concepts/goods-cost/original-cost-calculation/calculating-cost-when-returning-rented-assets.html",
    "title": "Calculating cost when returning rented assets | ERP.net Tech Docs",
    "summary": "Calculating cost when returning rented assets"
  },
  "modules/logistics/concepts/goods-cost/original-cost-calculation/index.html": {
    "href": "modules/logistics/concepts/goods-cost/original-cost-calculation/index.html",
    "title": "Original cost calculation | ERP.net Tech Docs",
    "summary": "Original cost calculation This article describes how the original cost is defined for each store transaction (i.e., for each row of a transaction). There are two ways to define it: by average cost and by specifying the cost in the parent document. Which way will be used is determined by the business process (procurement, production, transfer, sale) the transaction is created for. It depends on other modules and their respective documents, which are the main documents in the transaction flow. The Cost source field defines which method is used. For more information, see Goods cost. Average cost It is used when the Cost source field is set to store. These are usually the issue transactions in the store. The only receipt transactions with this source are generated by Reconciliations. Тo define the cost of the current transaction, the following is performed: All valid store transactions are gathered. They are non-voided or (at least) released transactions and contain the same product, store and enterprise company which date to before the current transaction. The order of the transactions is defined by the transaction timestamp. If there are multiple transactions with the same transaction timestamp, the receipt transactions are ordered before the issue transactions. The unit cost is defined in all currencies (see Goods cost) from p.1. The unit cost is multiplied by the quantity in the row and the result is saved as a cost in the current transaction (in all currencies). Example 1: For a specified product, store and enterprise company, there are transactions listed below. For issue transactions, the average cost method is used. In the beginning, there are two receipt transactions: receipt, Timestamp: 01 Dec 2020 12:45, 4 PCS, total cost: 100; receipt, Timestamp: 01 Dec 2020 17:27, 3 PCS, total cost: 61. These two transactions define the unit cost as (100 + 61) / (4 + 3) = 23. The result is used in the next issue transaction: issue, Timestamp: 03 Dec 2020, 11:29, 5 PCS, total cost: 5 * 23 = 115; Then, there is a receipt transaction: receipt, Timestamp: 04 Dec 2020 15:33,6 PCS, total cost: 146; The average cost is (100 + 61 - 115 + 146) / (4 + 3 - 5 + 6) = 24. This cost is used in the next issue transactions. Note that the first issue transaction happens at the same time as the receipt transaction, but the receipt transaction is considered before the issue transaction. Because of this, the cost of the issue transaction is affected: issue, Timestamp: 04 Dec 2020 15:33, 2 PCS, total cost: 2 * 24 = 48; issue, Timestamp: 07 Dec 2020 09:54, 1 PCS, total cost: 1 * 24 = 24. This example illustrates a case where the product cost is not affected by the presence or absence of a lot. Even if different lots exist in the transactions, the cost is an average. There are products required to have individual costs for each lot (this is described in the product's definition). The principle above is then changed, and in p.1 we take into account transactions that also have a matching lot field. An empty value (no lot) is considered a valid/separate lot. Example 2: There is a receipt transaction with two lots (so there are two receipt store transactions): receipt, lot #1, Timestamp: 01 Dec 2020 13:15, 10 PCS, total cost: 120; receipt, lot #2, Timestamp: 01 Dec 2020 12:15, 8 PCS, total cost: 96. The unit cost for both lots is 12. Then come the following issue transactions: issue, lot #1, Timestamp: 01 Dec 2020 14:28, 3 PCS, total cost: 3 * 12 = 36. The next receipt transaction is only for lot #1: receipt, lot #1, Timestamp: 02 Dec 2020 10:30, 7 PCS, total cost: 98; Now lot #1 has a unit cost of (120 - 36 + 98) / (10 - 3 + 7) =13, while the second lot has a unit cost of 12. issue, lot #1, Timestamp: 05 Dec 2020 17:20, 4PCS, total cost: 4 * 13 = 52; issue, lot #2, Timestamp: 05 Dec 2020 11:12, 5 PCS, total cost: 5 * 12 = 60. Specifying the cost explicitly This is used when the cost source is set to \"Document\". This is the source of all receipt transactions, except for the ones generated by Reconciliation. For each receipt transaction, the cost is calculated separately and according to a formula/calculation that is specific to the current business process. The method involves calculating a number in the document currency (the cost is in only one currency). Then, this number is converted into the rest of the cost currencies (see Goods cost). A more complicated example is when the cost of the goods is defined by the issue transaction cost of other goods available in the same enterprise company. It is not required to receive the goods from the same store. When transferring goods from one store to another, the issue transaction has a standard average cost. However, the goods received in the second store have to be entered with a cost equal to the one from the first store issue (a greater cost may be set if there are transport or other expenses). The same principle is applied when returning sold goods from a client or receiving back a rented asset. Another example is the production, where the cost of the produced products is formed by the costs of the ingredients, salary expenses, and more. Further reading: Calculating cost for inventory reconciliation Calculating cost for produced products Calculating cost for returned products Calculating cost for transferred products Calculating cost when returning rented assets"
  },
  "modules/logistics/concepts/index.html": {
    "href": "modules/logistics/concepts/index.html",
    "title": "Common concepts | ERP.net Tech Docs",
    "summary": "Common concepts Here, you will find common logistics concepts and operations explained in detail: Goods cost Lots issue Standart quantity base Setting transaction timestamp"
  },
  "modules/logistics/concepts/lots-issue.html": {
    "href": "modules/logistics/concepts/lots-issue.html",
    "title": "Lots issue | ERP.net Tech Docs",
    "summary": "Lots issue The current article describes the principles of lots issue when goods are issued from the store. Lots issue is actually the obligation to issue products from certain lots before others. The lots are prioritized and the priority is mandatory when goods are issued from the store (i.e. when store transactions are released). This priority is at least advisable when lots are entered before the store transaction documents (store orders, shipment orders, sales orders and more). The final goal is the lots selection in the document lines to be executed in the correct order. Example 1: In the document line, 10 Pcs of the product have to be sold/shipped/issued and the lot is not specified. The lot with the highest priority (let’s name it [Lot 1#]) has 17 Pcs available. So following the principle of lots issue, the user has to select/be offered [Lot 1#] in the line. There are cases when the first lot does not have enough available quantity to fulfill the whole line quantity. Then, more than one lot has to be used. The quantity in the line has to be divided into several lines and in each line the lot has to be specified with its quantity. Again, the lots order defines their priority in the lots issue. Example 2: If there are 30 Pcs in the line and no lot is selected, and the three top priority lots - [Lot 1#], [Lot 2#], and [Lot 3#] - have available quantities of 17, 8, and 12Pcs, then the quantity in the line would be divided into the following lines: - [Lot #1],17 Pcs*; - [Lot #2],8 Pcs*; - [Lot #3],5 Pcs*. *These are the total quantities of each one of the three lots. The document may be saved in other forms, for example - the 17 Pcs of the first lot may be entered as 17 separated lines, each line with quantity of one [Lot #1]. This may be necessary if the product is serialized, each line must have a serial number specified, and the quantity has to be 1. Actually, it can be said that there is always line breakdown. In еxample 1 there is trivial breakdown into only one lot [Lot #1],10 Pcs. Defining lots may appear in earlier documents that precede the store transactions - store orders, shipment orders, sales orders, etc. In this stage, specifying the lot is recommended. If lots are selected in such a document, they are passed to the next document and may be changed. In some cases, a change may not be recommended and following documents have to keep the selected lots (for example, the customer in the sales order requires to receive the lots which are specified in the sales order; then, those lots have to be issued from the store). Specifying lots in the store transactions is final and mandatory. If it has not happened in previous documents, it has to happen in the store transaction. The lots cannot be changed in following documents. Store transactions differ from the other documents with their limits according to the quantities which may be selected for each lot. In the store transactions, quantities are limited to the current stock holds. In other documents, there may be more precise restrictions - the “available to promise” (for specified lot). This is a method used to reserve lots. For example, if a sales order reserves the whole available quantity of one lot but there is no store transaction yet (so the current stock hold is unchanged), it would be wrong if another sales order called for quantities from the same lot. Selecting lots in a document line happens only if the line has no selected lots. If the lot is already specified and there are enough stock holds (with no assurance that the selected lot has the highest priority), only the quantity is validated. Such validation is applied in the store transactions, but it is possible to appear earlier (in preceding documents) so the user is warned earlier that he has to select another lot. Lots issue methods There are three main lots issuing methods - FIFO (First in, first out), FEFO (First expire, first out), LIFO (Last in, first out). They set the lots priorities. Each product uses a lots issuing method for itself. This is specified in the product definition. The product setting may be specified or null. If it is null, there is no sequence in the product's lots and there are no restrictions which lot should be selected (or the product does not use lots). In such cases, the lot is not mandatory even in the store transactions. The priority may be defined by sorting the lots by the date of their first receipt or by the date when they expire: for the FIFO method - the lots are sorted in an ascending order by the date of first receipt; for the FEFO method - the lots are sorted in an ascending order by their expiring dates (if no expiration date is specified, the null date is considered the largest date); for the LIFO method - the lots are sorted in a descending order by the date of first receipt. Example 3: There are 30 Pcs in a document line and lots of the product in the line have the following details (lot, available quantity/current stock hold, date of first receipt, expiry date): [Lot #1], 11 Pcs, 01.12.2021, 05.01.2022; [Lot #2], 17 Pcs, 03.12.2021, 03.01.2022; [Lot #3], 14 Pcs, 07.12.2021, null. This document line is divided into two or three document lines with quantities from different lots depending on the lots issuing method of the product: when FIFO is selected: -[Lot #1],11 Pcs*; -[Lot #2],17 Pcs*; -[Lot #3],2 Pcs*. when FEFO is selected: -[Lot #2],17 Pcs*; -[Lot #1],11 Pcs*; -[Lot #3],2 Pcs*. when LIFO is selected: -[Lot #3],14 Pcs*; -[Lot #2],16 Pcs*. *Again, additional lines breakdown may be necessary if the product uses serial numbers or other information for the current transaction. If the quantity of Example 3 is 5 Pcs and not 30 Pcs, then no line breakdown would be necessary (to be more precise - the trivial breakdown into one line would happen) and the lot would just be selected in the line depending on which lots issuing method the product uses. When the current stock holds of the product have records for both quantity from a specific lot and quantity with no lot, then the no-lot records have the least priority (because, for example, they may be held for planned receipts which have not arrived yet, and the quantities are only available without being part of the current stock holds; in that case, it would be better if they were used as late as possible while the current stock holds with specified lots are exhausted first). So, for each lots issuing method, the priorities are defined as follows: FIFO: the records with lots whose receipt date has value - highest priority (sorted ascending by this date); the records with lots with null receipt date (they are considered to arrive in the store as late as possible); the records with no lots. FEFO: the records with lots whose expiry date has value - highest priority (sorted ascending by this date); the records with lots with null expiry date (they are considered to expire last); the records with no lots. LIFO: the records with lots with null receipt date - highest priority (they are considered to arrive in the store as late as possible); the records with lots whose receipt date has value (sorted descending by this date); the records with no lots. Lots issue ways Lots issue may be done in the following manners: - manually (through the interface - using a panel, list, others); - automatically (by starting a function by the user or a document event - state change). Manual lot issue In these cases, the system suggests to the user a list of lots sorted according to the lot issue method (by the date of first receipt or the expiry date). The user selects the lots and their quantities (his choice is limited to the available quantity). The most direct approach is the order (sorting) to be shown in the dropdown list of the lot attribute in the line. Thus, the user does the lots breakdown by selecting a lot, editing the quantity (if necessary) and adding a new line with the same product, where he/she can select the next lot and its quantity. In this case, only lots with available quantity are shown in the dropdown list. Another approach is the sorted list with available lots to be placed in a separated panel/screen. There are fields where the user can enter the quantity for each lot. Thus, the user sees the list and enters the whole breakdown of the line at once instead of entering it line by line. The panel/screen would contain only available lots. In both cases, it is useful for the lists to contain additional information: current stock holds, available quantity (for each lot), date of first receipt, expiry date (as date and duration), notes, etc. Automatic lot issue Automatic lot issue is executed by the system when the user starts it or when an event happens. The automatic lot issue uses the same sorted list of the lots as the manual lot issue. The difference is that the lots are always issued strictly in the order of the list. In the manual lot issue, the user has the option not to issue a specific lot and to skip its turn and use another lot. Calculation of the quantity in the last lot In the lot issue process, it is important to keep in mind that the quantities are entered in the measurement unit of the line. Every quantity fulfillment in the examples is done in the base measurement unit because the current stock holds and the available quantities are always shown in that unit. So, in the examples above, the Quantity Base attribute is used. To enter quantity in the Quantity field (where the measurement unit may differ from the base measurement unit of the product), the Product Dimensions would be used. The problem is that if product dimensions are used for all quantities in the breakdown of the line, the total Quantity might be different from the initial Quantity. This may lead to differences in the quantities in the child and the parent documents and as a result new documents may be created. Example 4: There is a document line with Quantity of 16 l and 30 kg Quantity Base (the product dimension is 1 l = 1.875 kg). The three lots with highest priorities for this product ([Lot #1], [Lot #2] and [Lot #3]) have current stock holds/available quantities of 10 kg, 10 kg, and 18 kg . In the breakdown of the initial document line, there would be 10 kg of each lot. If we apply the product dimension for each lot to see the quantity in liters, we would have the following: - [Lot #1], Quantity Base = 10 kg, Quantity = 10 / 1.875 = 5.33333l; - [Lot #2], Quantity Base = 10 kg, Quantity = 10 / 1.875 = 5.33333l; - [Lot #3], Quantity Base = 10 kg, Quantity = 10 / 1.875 = 5.33333l; But the total quantity would be 15.99999 l and not 16 l as expected. This problem is solved by using the remainder and not product dimensions for the last document line ([initial quantity]-[already used quantity]). This algorithm would make the breakdown of Example 4 as follows: - [Lot #1], Quantity Base = 10 kg, Quantity = 10 / 1.875 = 5.33333l; - [Lot #2], Quantity Base = 10 kg, Quantity = 10 / 1.875 = 5.33333l; - [Lot #3], Quantity Base = 10 kg, Quantity = 16 - 5.33333 - 5.33333 = 5.33334 l. Example 5: The same approach for calculating the quantity in the last line from the breakdown is applied in cases of trivial breakdowns (when there is only one lot). Then, the only quantity in the breakdown is the last line. For example, if the line has Quantity of 2 l and Quantity Base of 0.66667 kg (3 l = 1 kg), and the first lot (with highest priority) has current stock holds/available quantity of 10 kg, then the only breakdown is not supposed to be multiplied by 3 to have the quantity in liters (as it would make 0.66667 * 3 = 2.00001 l). The calculation should be 2 - 0 = 2 l (this is the initial quantity minus the already used quantity - 0)."
  },
  "modules/logistics/concepts/setting-transaaction-timestamp/index.html": {
    "href": "modules/logistics/concepts/setting-transaaction-timestamp/index.html",
    "title": "Creating a duplicate document and a new document from current | ERP.net Tech Docs",
    "summary": "Creating a duplicate document and a new document from current The current article describes the principles and some specifics in creating a duplicate of an existing document. Also different usages of the algorithm are presented. Basic principles Creating a duplicate of a given document is actually creating a new document which contains identical business data with the original one, meaning that in the duplicate all substantial and meaningful data is copied from the original document and there is an exception for some technical data (such as internal identification numbers - Primary Keys, IDs of reference links between different parts of one document and more). This is the common algorithm used when creating a duplicate of a given document: A new document is created with the same document type and in its headers the substantial data from the original document is copied: a. the substantial data from the original document header is copied to the new document header; b. in each of the specific headers in the new document only the substantial data from the corresponding specific headers of the original documents is copied. If the original document has rows - for each row a new row is created in the duplicate document and the substantial data from the original row is copied to the new one. If the original document has rows of the rows (i.e. a document row has dependent records in different part of the document) - for each main row from the original document its duplicate row in the new document is fixed and for each of its sub-rows of the main row a new sub-row in the duplicate document is created and from the original sub-row only the substantial data is copied. If the original document has rows of the rows of the rows, the same procedure is applied until the original document structure is covered. Thus, the new document - the duplicate - must contain the same number of records (headers, rows, rows of rows etc.) as the original document and these records must have the same structure as they are in the original document. As document rows are considered not only the standard rows which most of the documents have, but also the document properties and the Additional amounts. Also, if the specific document header has its own properties, then they are considered document rows. The records in ‘Document amount referenced documents’ panel are considered rows of rows (rows of the additional amounts). Also, the records in ‘Document line amounts’ are considered as such (they are rows of the standard document rows). Currently, the attached files are not copied when creating a duplicate of a document."
  },
  "modules/logistics/concepts/setting-transaaction-timestamp/transaction-stamp/index.html": {
    "href": "modules/logistics/concepts/setting-transaaction-timestamp/transaction-stamp/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/logistics/concepts/setting-transaction-timestamp/index.html": {
    "href": "modules/logistics/concepts/setting-transaction-timestamp/index.html",
    "title": "Setting transaction timestamp | ERP.net Tech Docs",
    "summary": "Setting transaction timestamp The current article describes the principles for defining a transaction timestamp in the transactions rows. A timestamp is essential for goods cost definition. It represents the exact moment when a specific transaction starts affecting the goods cost. For more information, see Goods cost and its sub-articles. Usually, transaction timestamps are set automatically with no need for user intervention. This is executed in two general ways: On transaction release, if there is no transaction timestamp, then it is set automatically by the date of the transaction and/or by the current date and time. When the automatic set of the timestamp in the transaction release does not set the correct date and time in accordance with to the business process, a transaction timestamp is defined in the store orders (or another document generating transactions, such as Reconciliations). Thus, another module which controls and executes the orders is available to set a specific transaction timestamp defined by its business logic. Users can change the transaction timestamp in one of two ways: By editing the store orders (their transaction timestamps will be copied to the executing transactions). By editing the transactions directly (before their release or afterwards by adjustment documents). No matter how the timestamp is set, it has to comply with the following restrictions: if the quantity in the transaction row is different from 0, then the Document Date should match the date of the transaction timestamp. More detailed description of the logic behind the automatic set of the transaction timestamp may be found in the following articles: More specific cases of setting the transaction timestamp Setting transaction timestamp by store orders Setting transaction timestamp in reconciliations Setting transaction timestamp on transaction release"
  },
  "modules/logistics/concepts/setting-transaction-timestamp/more-specific-cases-of-setting-the-transaction-timestamp.html": {
    "href": "modules/logistics/concepts/setting-transaction-timestamp/more-specific-cases-of-setting-the-transaction-timestamp.html",
    "title": "More specific cases of setting the transaction timestamp | ERP.net Tech Docs",
    "summary": "More specific cases of setting the transaction timestamp When generating cost transactions from receiving orders, there is a specific way of getting the transaction timestamps. It is wrong because of the irregular generation procedure: direct transaction creation from another module is not supposed to happen, as the other modules are not supposed to work with internal module operations. In this transaction generation, only the cost is filled in (all quantities are 0). It is the cost coming from the purchase invoices, for the quantities which are already entered in the store by the receiving order. To have correct time and date for the cost, the generated transaction should have a specific transaction timestamp equal to the transaction timestamp with which the quantities enter the store. If the cost is entered later, the products will turn out with zero cost. For examples and more detailed information about goods cost when purchasing, see Setting cost when purchasing goods."
  },
  "modules/logistics/concepts/setting-transaction-timestamp/setting-transaction-timestamp-by-store-orders.html": {
    "href": "modules/logistics/concepts/setting-transaction-timestamp/setting-transaction-timestamp-by-store-orders.html",
    "title": "Setting transaction timestamp by store orders | ERP.net Tech Docs",
    "summary": "Setting transaction timestamp by store orders Sometimes, the algorithm for automatic set of transaction timestamps on transaction release may not choose the best possible dates and times. This is usually because of the specific logic of the business process of ordering store transactions which are unknown to the Logistics module. It is possible to set transaction timestamps for the ordered transactions in the store orders. The module that contains the specific business logic helps setting better and more accurate times and dates in the store orders. When the orders are fulfilled, these transaction timestamps will be copied to the transactions and will remain unchanged on transaction release. The current article describes some specific cases which require setting the transaction timestamp by the store orders. In transitional store orders For more information about transitional documents, see Transitional documents. When a store order is transitional, all its rows are filled in with the creation date and time of the parent document. The logic here is as follows: If the store order is set to transitional, then it is considered that it will happen automatically along with the parent document. So, the transaction timestamps will inherit the creation date and time of the parent document. Example 1: There is a work order where all documents except for the transactions (consumption orders, output orders and store orders) are transitional. On release, the store orders generate released transactions, i.e. the process is completely automatic. At first, the work order has the following technological ratio: producing 1 PCS of a product, the materials are 1 PCS of material #1 and 1 PCS of material #2. On work order release, all sub-documents are created, and the materials are issued with a transaction timestamp of [19 Jan 2020 14:00:07] and the produced product has a transaction timestamp of [19 Jan 2020 14:00:09]. Also, because of the quick creation and release of all sub-documents, these are the transaction timestamp for creating the producing sub-documents (the consumption order is created on [19 Jan 2020 14:00:07] and the output order - on [19 Jan 2020 14:00:09]. Then, on 22 Jan 2020 the Work Order is adjusted and the quantity of the first material is changed from 1 PCS to 2 PCS. If in the transitional Store Orders the transaction timestamp fields are left blank, when releasing the new transaction for the additional 1 PCS of material #1, its transaction timestamp would be [19 Jan 2020 23:59:00] because it was released later than its Document Date. In this case, we would have the following chronology: 1 PCS of material #1, issue, 19 Jan 2020 14:00:07; 1 PCS of material #2, issue, 19 Jan 2020 14:00:07; 1 PCS of produced product, receipt, 19 Jan 2020 14:00:09; 1 PCS of material #1, issue, 19 Jan 2020 23:59:00 At 14:00:09 there will be a receipt of 1 PCS of the product for which 2 PCS of material #1 are needed. By now, only 1 PCS is issued (the other piece is issued later). This leads to failure in the issue and receipt balance validation (see Receipt and issue balance validation in store transfers and Calculating cost for produced products because of incorrect time of the last issue transaction. When the Store Orders are transitional, the transaction timestamp is equal to the time and date of creation of the parent document, so the last issue transaction will also have transaction timestamp [19 Jan 2020 14:00:07] and the problem with the issue/receipt balance would not appear again. In store orders created from completing output orders When completing output orders are generated from the work order document form, specific date and time are set as a transaction timestamp in the rows of the output order. For each row in the output order, the greatest or the last transaction timestamp of all timestamps marking the moment the production has entered the store, is set as a transaction timestamp (this is the maximum date and time in all receipt transaction rows created by the current work order row, which has quantity different from 0). After that, the transaction timestamp from the completing output order are passed to the store orders and copied to the transaction rows. The completing output orders actually distribute the cost of the materials which are not issued on time. As a standard, it is considered that later issues of materials are distributed to the last manufactured products. This is why the greatest transaction timestamp of all non-zero receipt transactions for the specified product is set as a transaction timestamp. In store orders created by consumption orders for material In the generation procedure of store orders by consumption orders, there is also a specific way of setting the transaction timestamp in the store orders rows. It appears only if the quantity in the specified row is negative and the greatest transaction timestamp from all material issue transactions in the generated store order is used as a transaction timestamp. The consumption order rows with negative quantities return unnecessary (exceeding) materials. This process has to be entered in the store with the same cost, as issued. If the material is issued in more than one transaction, the issue transaction preceding the return of the materials is unknown, so the last issue is used as a reference. In store orders created by shipment orders for products return This case is similar to the return of materials to the production. If the quantity of the current shipment order row is negative, the greatest transaction timestamp from the relevant store order row (of all issue transactions happening by now) is set as a transaction timestamp."
  },
  "modules/logistics/concepts/setting-transaction-timestamp/setting-transaction-timestamp-in-reconciliations.html": {
    "href": "modules/logistics/concepts/setting-transaction-timestamp/setting-transaction-timestamp-in-reconciliations.html",
    "title": "Setting transaction timestamp in reconciliations | ERP.net Tech Docs",
    "summary": "Setting transaction timestamp in reconciliations In Reconciliations, transaction timestamps which are about to be generated in the store transactions rows are calculated the same way as on Release. In the reconciliation document form, when the current availability of the products is calculated and stored in the rows, transaction timestamps are filled in as follows: If the Reconciliation has a present or future document date, then the transaction timestamp in the row has the current date and time. if the Reconciliation has a past document date, then the transaction timestamp is XX.XX.XXXX 23:59:00, where XX.XX.XXXX is the document date. The same principle is used for reconciliation release, in case there are rows with empty transaction timestamps. When the reconciliation creates transactions for discrepancies, the dates and times already set in the Reconciliation are copied to the newly created store transactions. Thus, the transaction timestamps in the transactions are defined by the current creation time or Reconciliation release and not by the current release time (of the store transaction)."
  },
  "modules/logistics/concepts/setting-transaction-timestamp/setting-transaction-timestamp-on-transaction-release.html": {
    "href": "modules/logistics/concepts/setting-transaction-timestamp/setting-transaction-timestamp-on-transaction-release.html",
    "title": "Setting transaction timestamp on transaction release | ERP.net Tech Docs",
    "summary": "Setting transaction timestamp on transaction release On first release of the document, the transaction timestamp is set automatically in each transaction row that has no value. If the transaction has inherited some specific dates and times from the store orders or the user has entered them manually, these values will remain unchanged and the new dates and times will be set only in the rows with no values for transaction timestamp. When releasing the transaction, the values in the rows with no transaction timestamps are set according the following business rules: If the transaction's document date is today's date or a future date, the transaction timestamp for all rows is the current date and time. If the transaction's document date is in the past, then the transaction timestamp is XX.XX.XXXX 23:59:00, where XX.XX.XXXX is the document date. When a transaction is released with a past date, the time is set to 23:59:00 because it is unknown when exactly the transaction happened. It is assumed that it happened after all the other transactions which were released in time. In other words, late transactions are listed at the end of the selected date. If they are too late or cannot be ordered correctly among the other transactions from the same day, then the user may change the time manually - by adjustment documents. The time \"23:00:00\" follows the same principles because it helps the user manage late transactions from a given date more easily. For example, if it is necessary for a transaction to come after another one, the user should adjust it in the remaining minute of the current day. If the selected time was \"23:59:59:999\", that would not be possible."
  },
  "modules/logistics/concepts/standard-quantity-base.html": {
    "href": "modules/logistics/concepts/standard-quantity-base.html",
    "title": "Standard Quantity Base | ERP.net Tech Docs",
    "summary": "Standard Quantity Base In Version 2018.2, we added a new dimension to measure the quantity in logistics documents - Standard Quantity Base (SQB). SQB represents the theoretical quantity in the base measurement unit according to the current dimensions of the product. The main objective is to improve algorithms for exhaustion and clear traceability of the execution of the ordered quantity. More details Quantity (Q) and Quantity Base (QB) were used for the exhaustion of the quantities between parent and generated (child) documents. Variable measurement ratios allowed the editing of QB. It no longer tracks the exhaustion between a parent and a child document. Example: PRODUCT (2 pcs = 1 kg standard) SALES ORDER (Q = 100 pcs, QB = 50 kg) STORE TRANSACTION (Q = 100 pcs, QB = 49 kg) The QB in the STORE TRANSACTION is 49 because that quantity has been measured in the store. QB in the SALES ORDER is 50 kg because this is the theoretical (standard) quantity in the base measurement unit. Although QB in the STORE TRANSACTION is 49 kg, the ordered quantity is fully exhausted. The example above shows that QB can no longer be used to monitor exhaustion, at least in the case of products with a variable ratio of units of measurement. This led to the need of adding a new measure - SQB (quantity in a standard unit of measure). SQB is the theoretical quantity in Base Measurement Unit which will be calculated if QB remains read-only, unchangeable by the user. Example: PRODUCT (2 pcs = 1 kg) SALES ORDER (Q = 100 pcs, QB = 50 kg, SQB = 50 kg) STORE TRANSACTION (Q = 100, QB = 49 kg (measured), SQB = 50 kg) Here, it is clear that if we use SQB, we can easily and accurately determine whether the document is exhausted or not. This made the SQB Metric the main generation procedure indicator as to deciding whether the quantity of the parent document is fully exhausted or not. It does not mean that Q and QB will no longer be taken into account. An exhaustion of Q and QB will continue to be performed - otherwise, the algorithms won’t be able to solve problems with rounding when we are partially executing the ordered quantity. The difference is that they will not determine whether a new child record must be created. For more information, see Metrics. SQB also allows for exhaustion monitoring and the unification not only of all generation procedures but also of all functional navigators. A record/line in functional navigators will be available for execution only if there is а remaining SQB that hasn’t been thoroughly fulfilled by the child documents. When using exhaustion by SQB, all functionalities will also work for non-VMR products while preserving resilience in terms of manual change in the measurement ratios. General SQB purposes In Conclusion, the new SQB dimension allows: QB exhaustion even when we are using VMR; QB and SQB exhaustion for non-VMR products; solving problems with rounding when we are partially executing the ordered quantity; clear traceability of how much of the ordered quantity is exhausted; implementation of the same algorithm for executing and exhausting quantities for all functional navigators."
  },
  "modules/logistics/index.html": {
    "href": "modules/logistics/index.html",
    "title": "Logistics | ERP.net Tech Docs",
    "summary": "Logistics The Logistics module serves as a cornerstone of efficient warehouse management and product availability control within your business infrastructure. It is designed to streamline operations and optimize processes across all aspects of your warehouse operations, offering a comprehensive suite of functionalities. From procurement to shipment, through inventory control and warehouse management, Logistics offers a robust set of tools and features to meet the demanding needs of your business. Structure Logistics consists of several submodules dedicated to the purchase, shipment, delivery and other processes made by warehouses on a daily basis. Most of them allow for the creation and release of respective documents and transactions. Common This is where you can define and preview logistical units, including their types, in order to use them across other submodules. Procurement This is where you can make purchase orders for your warehouse. With the ability to define suppliers, initiate purchase requests, and manage internal requisitions, you gain full control over your procurement processes. Inventory This submodule offers advanced capabilities and allows for the creation and release of documents related to both inventory control and warehouse management. From defining store locations and making reconciliations to tracking warehouse lots and serial numbers, Inventory provides the tools you need to maintain accurate records and ensure product traceability. In addition, you can also take advantage of its simplified and intuitive Inventory Control application. Shipment Here, you can streamline the various shipping processes initiated by your warehouse. By creating shipment orders and transactions, you can effectively coordinate and track the movement of goods from your warehouse to your customers. WMS The Warehouse Management System works as its own separate module dedicated to the more complex managed warehouse operations. It allows you to create warehouse documents, requisitions and transactions, as well as fulfill orders efficiently using the integrated WMS Worker application. Learn more about Logistics: Common Inventory Procurement Shipment Warehouse management (WMS) Concepts Planning concepts and operations Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/logistics/inventory/concepts/available-to-promise/atp-algorithm.html": {
    "href": "modules/logistics/inventory/concepts/available-to-promise/atp-algorithm.html",
    "title": "| ERP.net Tech Docs",
    "summary": "ATP Algorithm The current stock holds are added to the unfulfilled store orders chronology. Thus, save for the physical availability, store orders which are not fulfilled, but planned to be on a specific date, are taken into account (the Planned Release Date field indicates this date). Besides physical availability, other already planned stock movements are taken into account. The calculated quantities for each date from the new chronology are reviewed and the smallest value is selected. This is the ATP quantity for the specified parameters. We use the smallest value. If on a date when we have the smallest value a greater value is entered as ATP quantity, and this quantity is used for a new issuing operation, it will not be enough for all ordered operations. The minimum quantity in the new chronology actually shows the greatest value we can use for the date specified as a parameter without violating other issuing store processes. Let’s apply that to the example from available to promise: After adding the physical availability to the chronology, we have: Date Physical availability Start quantity Receipt quantity Issue quantity End quantity 2021/10/01 8 3 - - 11 2021/10/03 8 - - 2 9 2021/10/04 8 - 16 4 21 2021/10/07 8 - - 8 13 2021/10/09 8 - - 7 6 2021/10/14 8 - 8 - 14 2021/10/16 8 - 4 9 9 2021/10/19 8 - - 2 7 Here is the graphical chart for the new chronology: After reviewing the value column (or following the lowest values in the graphical chart), you can see that the lowest value is 6 pcs. This is the available to promise quantity for 2021/10/01. Total clculations (for a period) When calculating the ATP for a whole period (more than one date), the data gathering, as well as the combination of the chronology and the current stock holds, is executed the way we described earlier. After that, for every date in the period greater than or equal to the date specified as a parameter, the ATP is defined as follows: The minimum quantity value for the whole period is defined - let's call it min1. Then, we pick the last (greatest) date for this value - date1. For every date from the starting to date1 (including), the ATP is min1. If there are dates in the chronology after date1, the minimum quantity value for the period after date1 is min2. The last date which has this value is date2. From the date after date1 and before date2 (including), the ATP is min2. This is repeated until all dates in the chronology are covered. The period we are making calculations for is divided into several sub-periods (at least one, and at most - equal to the number of dates in the chronology). In the first sub-period, there is a minimum value for the ATP. For each subsequent sub-period, the ATP is greater than the ATP for the previous sub-period. For example, let's have have the following chronology for the period between 01.10 and 06.10, calculated after adding the current physical availability to the data from the unexecuted sore oders. Date Physical availability Start quantity Receipt quantity Issue quantity End quantity 2021/10/01 12 8 - - 20 2021/10/03 12 - 2 - 22 2021/10/08 12 - 5 - 27 2021/10/09 12 - 2 19 10 2021/10/12 12 - - 7 3 2021/10/15 12 - 28 6 25 2021/10/16 12 - - 7 18 2021/10/20 12 - 6 9 15 2021/10/21 12 - - 3 12 2021/10/24 12 - 24 5 31 2021/10/30 12 - - 6 25 2021/10/31 12 - - 5 20 After reviewing the chronology, we establish that the period from 2021/10/01 to 2021/10/06 is divided to three sub-periods: one from 2021/10/01 to 2021/10/14, another from 2021/10/15 to 2021/10/23 and a third from 2021/10/24 to 2021/11/06. For the first period, the minimum value (hence the ATP) is 3 pcs. For the second period, it is 12 pcs, and for the last period, the ATP is 20 pcs. These calculations are represented by a graphic: Modifications in the agorithm iplementation There are some specific changes in the ATP calculation for algorithm implementation. When using the unexecuted store orders chronology instead of starting with an opening balance for a defined period, the definition of the start quantity for the unexecuted stre oders is not really effective. All store movements - the unexecuted by now store orders - are used without limits for date and without calculation for the starting value. These movements calculate the ATP for sub-periods. To calculate the ATP for a specific date, we simply take into account the periods before this date and the minimum value from the last period. This method is effective enough. However, problems appear when we want to calculate the ATP for a date before all existing unexecuted store orders. There is no sore oders chronology for this date and as the opening balance is not calculated (it would be zero), the previously mentioned principle for ATP calculation cannot be applied. When the date for which we calculate the ATP is before the earliest unexecuted store orders,the following principle is applied: All unexecuted store orders after the specified date are taken into account, and the ATP is calculated according to their chronology. This is a value projected available balance. The current available physical quantity is calculated - value [Current Stock Holds] If there are future unexecuted store orders, (i.e., if [projected available balance] is not null), then: [ATP] = min([projected available balance], [Current Stock Holds]) Otherwise, [ATP] = [Current Stock Holds] For example, if the current physical availability is 10 pcs and there are the following unexecuted Store Orders: 2021/10/09 - 2 pcs, receipt; 2021/10/13 - 7 pcs, issue; 2021/10/16 - 6 pcs, receipt. the ATP for the dates from 2021/10/09 to 2021/10/15 (including) is 5 pcs. After this date, it is 11 pcs. If we have the same data from the previous example, but the issue for 2021/10/13 is 1 pcs, then the ATPs would be as follows: before 2021/10/09: 10 pcs (this is the smaller value from the current physical availability and the projected available balance after 2021/10/09); from 2021/10/09 to 2020/10/15 (including): 11 pcs; from 2021/10/16 onward: 17 pcs."
  },
  "modules/logistics/inventory/concepts/available-to-promise/atp-reports.html": {
    "href": "modules/logistics/inventory/concepts/available-to-promise/atp-reports.html",
    "title": "ATP Reports | ERP.net Tech Docs",
    "summary": "ATP Reports In Version 2018.2, we introduced two new reports – Available to promise and Available to promise (by lots). These reports show the quantities available to promise (ATP) (by product or by product lot) from a current or future date, but not only as a calculated number. The reports allow us to see the separate records for all planned movements and therefore the projected available balance (PAB) for the different dates. Using it, we can see which numbers are behind the value of (ATP) and how it is calculated for the different periods. Details The ATP available on a given date is the quantity that can be promised to orders scheduled for shipment (for more information, see available to promise) from that date to the date of the next planned movement. That is why the ATP in the reports is calculated from each scheduled date. In ERP.net, this is the planned release date of the store orders. The records represent the chronology of the unfulfilled parts of non-voided store orders, which has statuses from planned to released included. There is a separate record for each combination of date, product, enterprise company and store. In the available to promise (by lots) report, the records are also separated by a lot. The calculation of ATP is based not only on the data of the chronology of the store orders which are not executed, but also on the information of the current stock holds (see available to promise). However, for the particular product or store, there may not be any unfulfilled shipments or deliveries and therefore those records won’t exist in the reports. For this reason, the reports start with an auxiliary line with a fictive “From date” which is equal to 01.01.2000 and contains the information for the starting availability, i.e. the current availability. As mentioned above, the rest of the records represent the chronology of the store orders which are not executed. They contain information for: Movements base - The sum of the quantity of all planned stock movements (issue and receipt) on this date in base measurement unit. Movements to date base - A running total of the quantity of all planned stock movements (issue and receipt) until this date (inclusive) in base measurement unit. Projected availability - Projected Availability in base measurement unit on a particular date. A running total of the projected/expected available quantity calculated by adding supply or subtracting demand in chronological order in base measurement unit. The value includes all expected stock movements (issue and receipt) until this date (inclusive) and the current availability. ATP Base - Indicates the promissory amount in base unit valid from a specified date to the date of the next stock movement. This is the minimum quantity available for use for future issuing operations (sales, use in production, etc.), and which will not violate the planned issue operations."
  },
  "modules/logistics/inventory/concepts/available-to-promise/index.html": {
    "href": "modules/logistics/inventory/concepts/available-to-promise/index.html",
    "title": "Available to promise | ERP.net Tech Docs",
    "summary": "Available to promise The available to promise (ATP) for a product and a date is the minimum quantity available for use in future issuing operations (sales, production, etc). It will not interfere with the issue operations, including this product, no matter if they are already planned, finished, or being executed just now. The calculation of the ATP is made by dates and it has meaning for the present or future dates. There is no use calculating it for past periods. Even more, the ATP algorithm, which is used for the calculation, is based on the fact that the ATP quantities are calculated for a date greater than or equal to today's date. This is because the current stock holds are used instead of their movements chronology. The parameters, data, and ATP algorithm used for the ATP calculation are shown below. We will try to calculate the ATP for a specific date. Then, there is a detailed example of an ATP calculation for a long period (more than one date). Parameters The main/required parameters are product, own company, and date. The ATP calculation is executed from the date and for the specified product and own company. Additional parameters can be set as store and lot. If a store is specified, the calculation will be executed only for this store. Otherwise, the data is collected from all stores (as though it is limited by the product, the own company, and the date). The lot specification is similar. Data For a standard ATP calculation, two types of data are used: 1. Current stock holds: It shows the availability of the product selected in the specified own company. If a store and a lot are provided, the data is filtered by them. 2. Chronology of the store orders which are not executed: It loads the chronology of the unfulfilled parts of non-voided store orders, with statuses ranging from \"Planned\" to \"Released\". The data is filtered by the parameters entered for a product, own company, store, and lot. The chronology is sorted by the Planned Release Date field. The data in this field is fundamental for ATP calculations. For example, let's assume that we have specified a product, own company, store and lot, and we want to calculate the ATP for date 2020/10/01. The physical availability for this date is 13 pcs, and before that date there are two unfulfilled, released store orders - one for receiving 7 pcs with date 2020/09/28 and one for issuing 4 pcs with date 2020/09/29. The documents after 2020/10/01 are as follows: 2020/10/03 - released issuing store order for 5 pcs, 3 pcs of which are fulfilled with a store transaction on the same date, so the unfulfilled quantity is 2 pcs; 2020/10/03 - released issuing store order for 5 pcs, which is fulfilled with a store transaction marked as single execution and contains 2 pcs from the same date, so the unfulfilled quantity is 0 pcs; 2020/10/04 - planned receipt store order for 16 pcs, unfulfilled; 2020/10/04 - planned issuing store order for 4 pcs, unfulfilled; 2020/10/07 - planned issuing store order for 8 pcs, unfulfilled; 2020/10/09 - planned issuing store order for 7 pcs, unfulfilled; 2020/10/14 - planned receipt store order for 8 pcs, unfulfilled; 2020/10/16 - planned receipt store order for 4 pcs, unfulfilled; 2020/10/16 - planned issuing store order for 9 pcs, unfulfilled; 2020/10/19 - planned issuing store order for 2 pcs, unfulfilled; The current availability is 8 pcs. It is calculated by adding the two issuing store transactions with date 2020/10/03 to the availability from 2020/10/01. The unfulfilled store orders chronology is as follows: Date Start quantity Receipt quantity Issue quantity End quantity 2020/10/01 3 - - 3 2020/10/03 - - 2 1 2020/10/04 - 16 4 13 2020/10/07 - - 8 5 2020/10/09 - - 7 -2 2020/10/14 - 8 - 6 2020/10/16 - 4 9 1 2020/10/19 - - 2 -1 The start quantity on 2020/10/01 is calculated by the two issuing store orders before 2020/10/01. For the next dates, the unfulfilled store orders from the specific date are added. Further reading: ATP algorithm ATP Reports"
  },
  "modules/logistics/inventory/concepts/index.html": {
    "href": "modules/logistics/inventory/concepts/index.html",
    "title": "Concepts | ERP.net Tech Docs",
    "summary": "Concepts Here, you will find common inventory management-related concepts and operations explained and illustrated with examples. Lots Store orders planning and due dates Available to promise Projected availability report Receipt and issue balance validation in store transfers"
  },
  "modules/logistics/inventory/concepts/lots.html": {
    "href": "modules/logistics/inventory/concepts/lots.html",
    "title": "Lots | ERP.net Tech Docs",
    "summary": "Lots Warehouse lots contain one row for each specific product, status, production batch and other specific warehousing conditions. Lot status can block certain operations. Items in a lot are all of the same type and produced under the same conditions, intended to have uniform quality and characteristics. The lots characteristics are: Product - the product of the lot; Lot number Receipt store transaction - if the lot isn't created manually, this field stores the receipt store transaction which created the current lot; Status - the status of the warehouse lot may be one of the following: blocked for document (sales or service order); blocked for party; blocked for inspection; free to use; Blocked for party - non-null when the warehouse lot is blocked specifically for some party. Blocked for document - if non-null, contains the document for which the lot is blocked. License No - the license number for this lot. Null when license number is N/A or unknown. Purchase lot number - identification of the purchase lost with which the products from this store lot are received. E.g. the document number of the receiving order. Description; Expiry date; Receipt date - the date of the first receipt of products in this lot."
  },
  "modules/logistics/inventory/concepts/planning-due-dates.html": {
    "href": "modules/logistics/inventory/concepts/planning-due-dates.html",
    "title": "Store orders - planning and due dates | ERP.net Tech Docs",
    "summary": "Store orders - planning and due dates The current article describes the purpose and usage of the planning and due dates in the store order headers - Planned Release date, Planned Completion date and Due date attributes. Planned release date The date specifies when, by plan, the execution of the store order should start. I.e. by plan on this date the first store transaction for the current store order should be released (if the store order is fulfilled at once, it would be the only store transaction). Planned completion date This is the date when, by plan, the execution of the store order should end. If can be considered as the date when the last store transaction for the current store order is released. But it would be more precise to say that this is the date when the last non-completed store transaction is completed, since the releasing of the store transaction does not guarantee that the process of execution of the store order is completed and the quantities and/or the costs may be modified by corrective documents to the released store transaction. Due date This is the end term for completion of the store order execution. The meaningful store order suggests the following to be true: Planned Release date =< Planned Completion date =< Due date. This still allows us to have different due dates and planned completion dates. For example, if we have the following dates: Planned release date = 2020/10/01 Planned completion date = 2020/10/05 Due date = 2020/10/08 It would mean that we plan to execute the order from 1th October to 5th October but the due date allows us a three days delay. This could happen if the execution plan is scheduled for this period (1th-5th October) because of purchase or production orders (because of resource optimisation, for example) but the due date is defined by another module (for example - by the delivery date to the customer). Thus, the planned release date and planned completion date are used because of the production and procurement plan while the Due date is because of other modules which generate Store orders and it is used for control of the deadline. Planned release date is essential for the available to promise calculation and the projected available balance. Thus, by the planning dates the user is able to define more precisely the information about when a specified quantity of a product is expected to be produced or delivered. For example, if a delivery of a large quantity of a product is expected but the delivery would be executed partially and not at once - several deliveries, so separated store orders could be created and each store order would define the different periods for each delivery stage. The advantage in this case is that the users would have more detailed information on when exactly the products are expected to be placed in the store. If we create one store order and the planned release date is the start of the first delivery, then the users would know that the whole quantity would be available at the first stage of the delivery. For more information, see available to promise. How are the attributes filled in by generation procedures? Here we explain how the planning and due dates are filled in when the store order is generated by another document. For more precise information about the specific generation procedure Wiki should be referred to. When generated by sales order All generation procedures from sales orders define the planning and due dates in the store orders as follows: Due date = Required Delivery date; Planned Release date = Required Delivery date; Planned Completion date = Required Delivery date. Required Delivery date is found in the sales order lines or in the sales order header (if the lines have no value). When generated by transfer orders For receipt store orders the dates are filled in as follows: Due date = Default Due date in; Planned Release date = Default Due date in; Planned Completion date = Default Due date in. For issue store orders the dates are filled in as follows: Due date = Default Due date out; Planned Release Date = Default Due date out; Planned Completion Date = Default Due date out. Default Due date in and Default Due date out are found in the transfer order lines. When generated by shipment orders Here, the planning and Due dates are filled in as follows: Due date = Required Delivery date; Planned Release Date = Required Delivery date; Planned Completion date = Required Delivery date. Required Delivery date is found in the Shipment order header. When generated by shipments Here, the planning and Due dates are filled in as follows: Due date = if the largest Required Delivery date has value - this is the date, if not - the Document date; Planned Release date = if the largest Required Delivery date has value - this is the date, if not - the Document date; Planned Completion date = if the largest Required Delivery Date has value - this is the date, if not - the Document date. The largest Required Delivery date is the largest Required Delivery date from the Shipments headers and the line Required Delivery date from the Shipment lines. When generated by consumption orders When issuing store orders are generated, the dates are filled in as follows: Due date - if the cheduled Date Time attribute from the Consumption order line has value - this is the date, else - the date of the first release of the consumption order; Planned Release date - Scheduled Date Time; Planned Completion date - Scheduled Date Time. Scheduled Date Time is found in the Consumption Order lines. When generated by output orders When receiving store orders are generated, the dates are filled in as follows: Due date - Due date from the work order; Planned Release date - Release date from the work order; Planned Completion date - Due date from the work order. For each output order line, the Due date and the Release date from the work order are the dates of the work order selected in the output order line. When generated by receiving order All generation procedures of store order from receiving order fill the planning and Due dates as follows: Due date - today's date; Planned Release date - Planned Release date from the receiving order; Planned Completion date - Planned Delivery date from the receiving order. Planned Release date and Planned Delivery date from the Receiving order are attributes of the Receiving order header. When generated by service activity All generation procedures of store order from receiving order fill the planning and Due dates as follows: Due date - today's date; Planned Release date - null/empty value; Planned Completion date - null/empty value."
  },
  "modules/logistics/inventory/concepts/projected-availability-report.html": {
    "href": "modules/logistics/inventory/concepts/projected-availability-report.html",
    "title": "Projected availability report | ERP.net Tech Docs",
    "summary": "Projected availability report This report is based on projected available balance and shows the inventory balance projected into the future. Fields This article describes the most important fields in the report: Document date - this is the planned release date of the store orders; On hand quantity base - the stock holds for today; Planned quantity base - planned movement of the product (negative number when issuing, positive number when receiving). The result is calculated from non-voided, at least released store transactions, with transactions timestamps equal to the Document date field; Planned quantity base to date - planned movement of the product so far. It is basically the running total of the Planned quantity base field. The result is calculated from non-voided at least released store orders with planned release date equal to the Document date field; Projected available balance - this is the planned stock holds after the planned movements happen; Available to promise - the minimum quantity available for use in future issuing operations and which will not violate the current issue operations, already planned or done with this product. This data is calculated for a specified store and/or product."
  },
  "modules/logistics/inventory/concepts/receipt-and-issue-balance-validation.html": {
    "href": "modules/logistics/inventory/concepts/receipt-and-issue-balance-validation.html",
    "title": "Receipt and issue balance validation in store transfers | ERP.net Tech Docs",
    "summary": "Receipt and issue balance validation in store transfers The current article describes the validation if the receipt does not exceed the issue in the product transfer. In this case a transfer may be any of the following actions: moving a product from one store to another store by a store transfer; products production (that it is considered that the materials are issued and transferred as a new product into another store); returning products by a customer (this is considered a transfer - the products are issued from one store and given to the customer and then they return\\transfer them to the same or other store); returning a rented asset which has been delivered to the customer (here the situation is similar to the returning of sold products except that the returning may happen or not, but after we delivered assets to the renters, we expect their return is mandatory when the rental contract expires). This validation is important so unrealistic situations can be avoided (for example - transactions with incorrect chronology) which may lead to incorrect goods cost. For more information on cost calculation, see Calculating cost for transferred products, Calculating cost for returned products, Calculating cost for produced products and Calculating cost when returning rented assets. Validation in transfer of one product Usually in store transfers one product is issued from one store and the same product is entered into the target store (the same record in the products nomenclature). The current article describes the validation in this usual type of transfer. Other transfers (such as production, where one product (or more) are issued from the first store and other products (or products) are entered into the target store) is not covered in the current article. The validation is applied on every issue and receipt transaction release (from the respective store). And the validation applies on every transfer row. All issue transactions and all receipt transactions, resulting from the current row, are summed up. At first, these operations are ordered. For every two store transactions - [transaction 1] and [transaction 2], their chronological order has to be defined. This is executed as follows: If the transaction timestamps of [transaction 1] and [transaction 2] are different - the transaction with a smaller timestamp is before the other If the transaction timestamps are equal, but the movement type is not the same (issue or receipt) - then the issue transaction is before the receipt transaction. If the transaction timestamps are equal and both transactions are issued - then the transaction with a bigger quantity is placed before the other. If the transaction timestamps are equal and both transactions are receipts - then the transaction with less quantity is placed before the other. After the transactions are ordered chronologically, the costs are set to zero: [issue quantity total] = 0 and [receipt quantity total] = 0. Then, for every element of the ordered list with transactions, depending on its direction - issue or receipt - its base quantity is added to the respective total. Then, the system checks if [issue quantity total] < [receipt quantity total] is true. If it is true, the current operation (transaction release) is aborted and an error message appears. If it is false, then the system moves to the next element of the ordered list of transactions. If the Transaction Timestamps are equal in receipt transactions, the transactions are in quantity ascending order because the following case is possible: the first transaction is an issue transaction of 10 PCS at 12:42, the next operation is a receipt transaction of 10 PCS at 13:17 and there are two more receipt transactions with equal Transaction Timestamps of 13:31 - one transaction for 3 PCS and one transaction for -3 PCS. The last two transactions may appear after correction of the receipt document of 10 PCS. So if the transactions are not in ascending order, it is possible to add the quantity of the transaction with quantity of 3 PCS first and in this moment the [issue quantity total] = 10 and [receipt quantity total] = 13, which may mislead us for imbalance between issue and receipt transactions, no matter that the next transaction immediately fixes it. Under the same considerations, the issue transactions with equal Transaction Timestamps are in quantity descending order. It is possible to correct the first operation with -3 PCS and this correction will have the same Transaction Timestamp as the original transaction. Then if the -3 PCS transaction is first, there will be redundant/non-existing imbalance - [issue quantity total] = -3 and [receipt quantity total] = 0. Validation in transfer of different products (production) In production there is a change in the algorithm above. As the products that are received in the target store (manufactured goods) are usually different from the ones that we issue from the first store, it is not appropriate to check directly if [issue quantity total] > [receipt quantity total]. Also, it is not appropriate to sum quantities of different materials/products in one total [issue quantity total]. This is the reason for the different calculation of the [issue quantity total]. Instead of summing the issue transactions in one [issue quantity total] , each material/product has its own total and the result is several totals. These totals and the quantities that are defined by the manufactured good recipes are used to calculate if enough materials are issued by the current moment. This quantity is added to the [issue quantity total]."
  },
  "modules/logistics/inventory/how-to/adjust-base-cost.html": {
    "href": "modules/logistics/inventory/how-to/adjust-base-cost.html",
    "title": "Adjust base costs | ERP.net Tech Docs",
    "summary": "Adjust base costs The Adjust base costs function is responsible for aligning the Original Cost of store products with their Base Cost. It achieves this by simultaneously deducting the Base Cost Adjustment of every product and adding it to its associated Line Base Cost. This speeds up the process of processing transactions, allowing them to assume the correct (or most correct) base costs of products. It also limits the need to make frequent cost corrections due to accumulated discrepancies between original and base cost calculations. Preliminary Setup 1. Create a New Document Type Create a new Document type of Inventory Transaction entity where the function will be invoked. This document type will be unified across the database and applicable to all stores. The document will not generate accounting entries but will generate a Cost Correction for the current document. 2. Configure Document Route for Cost Correction In the newly created document type, set up a Document Route for generating the Cost Correction for the current document. The goal is to transfer the cost brought in by the function from \"Line Base Cost\" to \"Base Cost Adjustment\" with opposite sign ensuring the total Adjusted Cost of the document remains zero. After executing the function and processing the document, the cumulative Corrected Cost for this inventory transaction will stay at zero, meaning the cost in the store will not change. Using Adjust base costs Here, you'll find detailed steps on how to effectively perform base cost adjustment. 1. Create a Cost Correction document You first need to create a cost correction responsible for adjusting your stores' costs over a specified period. This is typically done once every month. Fill in the from and thru date of the period and click Save. Then, navigate to the Functions tab and select Recalculate corrections for the period. Once prepared, Release the document. 2. Create a Cost correction transaction Start creating a cost correction transaction using the document type you've created. Required fields are: Store - the store for which the transaction will be issued Movement Type - set as Receipt Document Currency - main currency of the enterprise company Cost Source - source of the document, set automatically; after the function is applied, it changes to Adjustment. 3. Apply the function Save the document, navigate to Functions and select Adjust base costs. The function will load all available products from the selected store whose base costs are different from their original line costs. It is only after releasing this transaction that it will match their current base costs with their adjusted costs. Values added to the Line Base Cost will be simultaneously subtracted from the Base Cost Adjustment. Note Following a recent application of the function, transactions will now assume the correct (or most correct) base costs of products."
  },
  "modules/logistics/inventory/how-to/document-type-routes.html": {
    "href": "modules/logistics/inventory/how-to/document-type-routes.html",
    "title": "Use the Document Type from Routes to create a new document | ERP.net Tech Docs",
    "summary": "Use the Document Type from Routes to create a new document If certain conditions are met, it is possible to create new documents through Inventory Control by taking in mind both the Document Type specified in the Settings as well as the Document Type defined in the Document Routes for the respective order. This applies to the Receive and Issue operations, providing more flexibility when defining the final documents they can generate. Step-by-step process Perform a validation check for the receive/issue store order by filtering the following fields in the Document TypesFormRoutings panel of the StoreOrders data type: ProcessEvent: Must be \"Change of state\". ConditionStatesBitMask: Must include \"Released\". Destination DocumentType: Must be a document of data type \"Transactions\". When the store order is created, the Route’s activity must fit within the period specified in the ActivationDate and DeactivationDate fields. Keep in mind that these fields may be empty. IsActive: Must be \"True\". ConditionEnterpriseCompany: Must match the StoreOrder.EnterpriseCompany or be empty. AllowedGenerationTypes: Must be set to \"Only Manually\". Once the filtering procedure is complete, only the Document type is extracted from the remaining routes. Keeping in mind the results of the validation check as well as the Document Type specified in the Inventory Control Settings, you can encounter the following situations: No valid result is returned from the Document Routes and no Document Type is specified in the Inventory Control Settings for the receive or issue function. => An error will be thrown: \"No document type selected\". No valid result is returned from the Document Routes but a Document Type is specified in the Inventory Control Settings for the receive or issue function. => A store order of the respective type will be created based on what is provided in the Settings. Only one valid result is returned from the Document Routes (or multiple valid results all pointing to the same Document Type) => A Document Type is selected regardless of what is specified in the Inventory Control Settings. Multiple different results are returned from the Document Routes. => A selection menu is displayed with a dropdown list containing all returned results from the Document Routes plus the Document Type specified in the Inventory Control Settings. The dropdown list will have a default value, determined as follows: If at least one of the returned results matches the Document Type specified in the Inventory Control Settings, that Document Type is chosen as the default. If none of the returned results match the Document Type specified in the Inventory Control Settings, or if no Document Type is specified in these Settings, the default value is the Document Type Code with the smallest Code value. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/logistics/inventory/how-to/edit_quantity.html": {
    "href": "modules/logistics/inventory/how-to/edit_quantity.html",
    "title": "How to edit quantity | ERP.net Tech Docs",
    "summary": "How to edit quantity For the sake of accuracy, efficiency, and flexibility in inventory operations, workers can edit the executed quantity at operations Receive, Issue, Scrap, Transfer, and Quick Reconcile. Whether due to scanning errors, miscounts, or handling variations in products with lots and variants it is necessary to do on-the-go corrections directly during execution, eliminating the need for later adjustments in the Store transaction. Here is a detailed instruction on how to perform the corrections. Key details the editable field is accesible in tab Info only it is light-grey the edit is performed in a pop-up box the box is supplied with up/down keys plus you can input digits from the keyboard as well the edit needs confirmation multiple edits are possible Perform a quantity edit When any quantity is scanned it enters the designated field - executed, transfer, scrap, counted. Only the quantity field in tab Info is editable. Let say you transfer 500pcs of product X. You realize you need to correct the quantity to 250pcs. Steps: Navigate to tab Info of product X Click in the light-grey quantity field that contains \"500\" -> a pop-up edit-box will appear Enter the correct quantity \"250\" from the keyboard or use the down arrow Confirm with \"Ok\" Result: The new quantity is saved in the field The field in tab Transfer is edited too The quantity can be edited until a Transfer Order is created with button Finish Note Corrections to zero (0) are possible. Warning Corrections to \"0\" at Quick Reconcile mean \"counted 0 pcs\", not \"never counted\". Zero quantity lines in the finishing document will be created. Warning Corrections to \"0\" at the other operations do not create zero quantity lines."
  },
  "modules/logistics/inventory/how-to/execute-store-orders/index.html": {
    "href": "modules/logistics/inventory/how-to/execute-store-orders/index.html",
    "title": "Execute store orders function | ERP.net Tech Docs",
    "summary": "Execute store orders function This function allows easier work with the barcode scanner and more functional methods for the execution of one store order row by more than one transaction row. This is useful in case the user operates with lots or serial numbers, etc. The function contains two main components: Store Orders panel Input Data panel Store Orders panel It loads the unfulfilled store order rows according to the filters in the navigator. The data includes the ordered quantity of the row, the executed part of that quantity and the remaining quantity (the unfulfilled part). This data is read-only except for the Input Quantity which is used for easier data entering. Input Data panel This panel is editable by the users. They enter information about what store transactions are executed in the current moment and do not mark the specific store orders that they are executing. This is defined automatically by the system. The data that is entered is Product, Lot, Serial Number, Quantity, Measurement Unit and Base Quantity. There are several methods to enter such information: Manually. This is the rarest method used. To be more precise, it is for editing information entered by any other method. Using the Input Quantity field in the Store Orders panel. When the user enters data in it, it automatically creates new row in the Input data panel with the entered quantity and the product, lot, serial number and measurement unit copied from the store order row , Also, the new row in the Input data panel is marked as reserved for the row in the store order rows panel. This method's purpose is to support the old method from the old execution navigator, where the user always enters the exact Store order row that he is executing. Using barcode scanner (or other system for control/counting/marking the stocks). This is considered as the standard way to enter data, where the user does not specify the store order row and only marks the store transaction. Distributing the executions The data entered in the Input data panel has to be distributed through the rows from the Store Orders panel. This is performed after each change in the Input data panel. The distribution is executed by store order rows execution algorithm and all calculations about the quantity are based on Base Quantity. The store order rows form the list [ORD] and the data in the Input data panel forms the list [EXC]. There is a small difference from the algorithm - rows from the Input data panel reserved to specific store order row, always execute this specified row. The algorithm is not allowed to distribute them to other rows. The purpose of this is to avoid a situation when the user enters quantity in Input Quantity field and it is distributed to another store order row (just because the algorithm considers it as with higher priority than the one that the user has chosen). So this gives the user the ability to mark specific rows for execution. The distributed quantities are illustrated as sub-rows of the store order rows. They contain data (quantity, lot, serial number and more) from the Input data panel which may be different than the data in the Store order row. Creating transaction In the end, when the user creates transaction, its rows are based on the distributed executions. For example, if a store order row has 4 distributed sub-rows of execution, then the Transaction has 4 rows with the information from the Input data panel and all those rows are executing the specific store order row. When the transaction is created, the data in the Input data panel is deleted and the navigator is ready to be used again."
  },
  "modules/logistics/inventory/how-to/execute-store-orders/rows-execution-algorithm.html": {
    "href": "modules/logistics/inventory/how-to/execute-store-orders/rows-execution-algorithm.html",
    "title": "Store order rows execution algorithm | ERP.net Tech Docs",
    "summary": "Store order rows execution algorithm This algorithm is applied when there are many unfulfilled store orders or products going in and out of the store. The purpose is to create transactions, fulfilling the orders as correctly as possible. The idea behind the algorithm is that the system automatically defines which store orders should be fulfilled and what part of them - automatically, without user interference. This allows faster processing of the issue and receipt transactions, especially when the data (orders and products) volume is large. The starting data for the algorithm is two lists: list of unfulfilled store order rows - [ORD]. This list is usually a partial sample of all unfulfilled store orders in the database, e.g the orders from a certain customer/supplier or certain order. In [ORD] there are only the quantities which are unfulfilled, because if for a given store order row for 10 PCS there are released transactions with 7 PCS, then in [ORD] the quantity for this row would be 3 PCS. The rows completely fulfilled by transactions are not part of [ORD]; List of store transactions - [FUL], which contain data about products currently being moved in or out of the store. The data consist of Product, Lot, Serial Number and Quantity. Afterwards, data is saved in the newly created Transactions. The list [FUL] is usually the result of a control system (such as barcode scanner) which is placed at the entrance/exit of the store. Both lists must consist of the same type of operations - meaning [ORD] is a list of receipt store order rows and [FUL] is a list of receipt store order rows or if [ORD] contains only issue store order rows and [FUL] is a list of issue store order rows. If [ORD] and [FUL] contain both issue and receipt transactions, then the lists must be separated into two uniform parts and the algorithm will be applied on each part separately. Store orders execution algorithm The purpose of the algorithm is the distribution of all operations/quantities from [FUL] to the rows of [ORD]. It is possible that some operations are defined as fulfilment of one row from [ORD]. Besides, the quantities from one operation can be separated amongst more than one row. At first, the two lists are sorted. [FUL] is sorted according to the entering order of the operations. [ORD] is sorted by Document Date, Document Number and Line Number (this is standard sorting, but other types of sorting using data from CRM or SCM modules which has initialized the orders are also possible). These sortings set a kind of initial priority, which should be used for orders fulfilment. Then, the algorithm continues to 4 stages and at each operations/quantities from [FUL] are compared to [ORD] rows by defined criteria. At each stage the system goes through [FUL] (after it is sorted) and for each operation with quantity no equal to zero (the quantity may be 0 at a previous stage) the following actions are executed: Search for a row in [ORD] that matches the operation according to the current stage criteria. If there is no such row, the algorithm goes to step 7. If there is such a row, the algorithm continues to the next step. The part of the operation quantity this row fulfills is defined. At stage I, II and III the quantity is defined by comparison of the row quantities and the operations quantities. The smaller value is defined as quantity. Exception is stage IV where the algorithm takes the quantity in the operation. A new transaction row is created with the Product, Lot and Serial Number from the operation and the quantity defined in step 3. As a transaction timestamp in the transaction row, the current date and time is set. Also, the row from [ORD], which is found in step 1, is marked in the transaction row. The row from step 1 and the operation are edited and their quantity is decreased by the quantity from step 3 (i.e. the algorithm updates what is left for fulfilment). If the remaining quantity in the operation is different than 0, all steps by now are repeated. Otherwise, the algorithm goes to the next step. The processing of the current operation is over and the algorithm goes to the next one. So for each operation the algorithm finds a store order row, fulfilling it, according to the current criteria, and this is repeated until the quantity in the operation is 0 or there are no store orders found (that match the operation). The criteria by which the store order row is found for a given operation is a comparison between the row and the operation by their values of Product, Lot and Serial number. Three types of comparison exist: Exact match means that the row and the operation have the same value. For example, exact lot match means that either the row and the operation have the same lot or both have no lot specified. Weakened match means that either the value is the same in both (row, operation) or one of them may be null. For example, weakened lot match returns match even if the operation has a lot and in the row there is no lot. Free match means that the algorithm does not take into account the values and always returns a match. At the different stages there are the following criteria for store order rows fulfilment: Stage I: Searching for a match by Product and by Lot and by Serial number. Also, it is required that the quantity in the row should be different than 0 (in this stage this should be true for each row in [ORD]). Stage II: Searching for a match by Product and weakened match by Lot and by Serial number. Again, it is required that the quantities in the order rows are different than 0 (here, it is possible that zero quantity rows are found because of the update in stage I). Stage III: Searching for a match by Product, free match by Lot and by Serial number and non-zero quantities in the order rows. Stage IV: Searching for a match by Product and free match by Lot and by Serial number. The difference from stage III is that here the quantities in the rows can be zero. It becomes clear that in the first stage the algorithm tries to strictly comply with the product, lot and serial number, and during the next stages the algorithm weakens the criteria allowing violation of the lots and serial numbers from the store orders. At stage III over execution is still not allowed (because of the non-zero quantities criteria). The purpose of the last stage is to be used in cases when the user issues/receives more than what was ordered. So in the last stage the user is able to fulfill orders with zero quantities, combined with the way of defining the quantities of stage III - the over execution is allowed. If the quantities from [FUL] are not more than the quantities in [ORD], then stage IV will not be reached at all. Also, in each stage the algorithm requires exact match by Product. This means that if in [FUL] there are products that are not listed in [ORD], then they will remain even after stage IV. Those cases (by now) are not covered by the system and have to be managed by the user. Otherwise, after stage IV in all operations from [FUL] there would only be zero quantities. By this we reach the purpose that all quantities in [FUL] should be distributed to a row from [ORD]. Example 1: There are the following rows in [ORD] (serial numbers are null everywhere): row 10, Product #1, 4 PCS, Lot #ab17 row 20, Product #1, 3 PCS, Lot #ss54 row 30, Product #1, 2 PCS row 40, Product #1, 7 PCS, Lot #ts23 In [FUL] there is only one operation for Product #1, Lot#ab17, with no serial number and quantity of 14 PCS. So in stage I the algorithm will cover row 10 by 4 PCS from the operation, at stage II the algorithm will cover row 30 and at stage III the algorithm will cover part of row 40. This is how the lists [ORD] and [FUL] will look like at each stage: After stage I: |[ORD]|[FUL]| |:----|:----| row 10, Product #1, 0 PCS, lot #ab17|Product #1, lot #ab17, 10 PCS row 20, Product #1, 3 PCS, lot #ss54| row 30, Product #1, 2 PCS| row 40, Product #1, 7 PCS, lot #ts23| After stage II: |[ORD]|[FUL]| |:----|:----| row 10, Product #1, 0 PCS, lot #ab17|Product #1, lot #ab17, 8 PCS| row 20, Product #1, 3 PCS, lot #ss54| row 30, Product #1, 0 PCS| row 40, Product #1, 7 PCS, lot #ts23 After stage III: |[ORD]|[FUL]| |:----|:----| row 10, Product #1, 0 PCS, lot #ab17|Product #1, lot #ab17, 0 PCS| row 20, Product #1, 0 PCS, lot #ss54| row 30, Product #1, 0 PCS| row 40, Product #1, 2 PCS, lot #ts23| Example 2: If there are the same [ORD] and [FUL] except for the fact that the quantity in [FUL] is 18 PCS (i.e. 2 more than the orders). Then in stages I and II the fulfilments will be the same. At stage III row 40 will be fulfilled completely and at stage IV the remaining 2 PCS from [FUL] will cover row 10 and it will be over executed."
  },
  "modules/logistics/inventory/how-to/index.html": {
    "href": "modules/logistics/inventory/how-to/index.html",
    "title": "How To | ERP.net Tech Docs",
    "summary": "How To Here, you will find step-by-step guides on how to perform various actions within the Inventory module. This is typically achieved through executing different UI functions. Execute store orders Adjust base cost Calculate reconciliation based on counts Use the Document Type from Routings to create a new document Use the Bin Edit quantity"
  },
  "modules/logistics/inventory/how-to/reconciliation-based-counts.html": {
    "href": "modules/logistics/inventory/how-to/reconciliation-based-counts.html",
    "title": "Calculate reconciliation based on the counts | ERP.net Tech Docs",
    "summary": "Calculate reconciliation based on the counts The Calculate reconciliation, based on the counts function takes the rows of product quantities counted in the Counts panel of a reconciliation and summarizes them into lines in the Lines panel. For instance: There are six rows of counted quantities of the same product in the Counts panel. The function is run. All rows are summarized into a single line in the Lines panel. Warning It is not possible to run the function if: a Default Store and a Reconciliation Type are not specified for the document the document is in a state Released or higher Lines data Once product quantities from the Counts panel are summarized into lines, the following information is revealed for each line: Product - the product whose quantities are counted Quantity - a sum of the product's counted quantities, grouped by product QuantityUnit - the measurement unit of the product AvailableQuantityBase - the current product availability, filtered by Default Store and Default Product Group Store - the store to which the product belongs. Behavior based on Reconciliation type Depending on the Reconciliation type of the document, the function behaves in one of two ways: Partial Lines are created for all counted products and filled with the respective lines data. Products that are not counted don't have lines created for them and their current availability will not be changed. Full Lines are created for all counted products and filled with the respective lines data. Products that are not counted will have lines created for them with quantities set to \"0\". If a Default Product Group is assigned, uncounted quantities will be set to \"0\" only for products from that group. In that case, counted products from different product groups will not have lines created for them when the function is run. Note Products that are counted but are not part of the current store's availability will have lines created for them. Behavior based on zero counts Depending on whether zero quantities are present in the Counts panel, the function behaves in one of two ways: There's at least one counted zero quantity of a product as well as other quantities different from zero. In this scenario, all quantities of the same product are summed in the Lines panel. The only counted quantity for one or more products is zero. In this scenario, each product that has a zero quantity counted will get a line in the Lines panel with quantity set to \"0\". Execute the function Open a reconciliation, click on the Run button and select Calculate reconciliation, based on the counts You will be asked to confirm the execution of the function. Click OK. If all conditions are met, new product lines will be created in the Lines panel of the reconciliation. Important The function can be run as many times as needed in case additional counts need to be added, edited or deleted. Each run will result in the removal of all existing Lines and a new calculation for the counts will be started."
  },
  "modules/logistics/inventory/how-to/the_bin.html": {
    "href": "modules/logistics/inventory/how-to/the_bin.html",
    "title": "How to Use the Bin in Inventory Control | ERP.net Tech Docs",
    "summary": "How to Use the Bin in Inventory Control In our Inventory Control module, the bin plays a crucial role in managing product counts. There are two types of bins used in all operations, both available in the Info panel: Delete-all Bin (Large Bin) and Delete-row Bin (Small Bin) Using the Delete-all bin The \"large bin\" is located at the top, on the product row. It is used to delete all counts and executions for a specific product, marking it as unexecuted or not counted at all. The process is similar for all operations like Receive, Issue, Scrap, Transfer, Quick reconcile and Planned reconcile. Steps: Let say you execute a Receive operation of an Order consisting of three lines - products X, Y and Z. Each line has been executed as seen in tab Executed and in Executed field. You decide to delete all executed quantities for product X: Navigate to the Info tab of product X. Locate the large bin at the top of the product row. Click on the bin icon -> A pop-up message appears to confirm deletion. Choose Delete to confirm. Result: The quantity for product X in the Executed field is deleted The row related to this product in tab Executed is removed. After deletion, it appears as if the product was never executed. Another example at operation Planned Reconcile, in which you count 50pcs of product X and 20pcs of product Y. In field Counted is entered the quantity for each product and in tab Counted are registered the rows for the counted products. You decide to delete all counts for product X. Execute the forementioned steps (1-4). As a result all counted quantity for product X is deleted as if never counted. If you check the records in panel Counts in Reconciliation document, you will see that the line is also removed from there. Using the Delete-row bin The \"small\" bin is used to delete individual product count rows at all IC operations. It is helpful with products having lots or variants, allowing users to delete distributed quantities for specific lots or variants. For example, if a scanned quantity is spread across multiple lots, users can now remove the count for a chosen lot without affecting others. Steps: Let say you execute a Receive operation of an Order consisting of three lines, for two products X and Y, and product Y is ordered in a lot as well. Execution of 8pcs of product Y results in distribution of the quantity between the unspecified product lot (4pcs) and the specified lot (4pcs). Now each line has been executed as seen in tab Executed and in Executed field. You decide to delete the quantity of the unspecified lot of product Y: Navigate to the Info tab of product Y; Locate the small bin on the row, next to the desired qunatity (\"4\"); Click on the bin icon. Warning No confirmation message for the deletion will pop-up! Result: The quantity for the unspecified lot of product Y in the Executed field is deleted. The row related to this product and lot in tab Executed shows a dash \"-\". After deletion, it appears as if the lot was never executed. Another example at operation Quick Reconcile, and you count 4000pcs of product X. The amount is distributed between the available lots. You decide to delete the counted quantity of the specified lot (\"00022\"). Simply click on the bin in the row of the lot, next to quantity \"100\" and without any warning, it will be deleted. The row in tab Counted will also be deleted. By using these bin functionalities effectively, you can ensure accurate inventory management while maintaining flexibility in operations."
  },
  "modules/logistics/inventory/index.html": {
    "href": "modules/logistics/inventory/index.html",
    "title": "Inventory | ERP.net Tech Docs",
    "summary": "Inventory Inventory is designed to assist you in the process of inventory control and warehouse management. It includes the ability to create store orders, reconciliation documents, and transfer orders, including their respective invoices. You can further take advantage of Inventory's simplified Inventory Control application, designed to assist and speed up operations within shops and smaller stores. Definitions Stores This panel allows you to define virtual representations of your physical warehouse. To utilize all capabilities of Inventory, you must define at least one store. Lots Warehouse lots consist of individual entries for each distinct product, detailing its status, production batch, and specific warehouse conditions. The status of each lot can restrict certain operations within the warehouse. Serial Numbers These are assigned to items and tracked within documents. Each serial number generates a unique entry upon its initial occurrence in a document. These entries can be removed once the last occurrence of the serial number is deleted from the document. Requisition Plan You have the option to assign a current requisition (MRP) plan, which is designed to maintain optimal inventory levels to meet demand while minimizing excess stock and associated costs. This plan involves resetting and regenerating data during each planning cycle. Documents Transactions In this panel, you can find all transaction documents related to movements in and out of your warehouse’s existing stores. Receipt transactions reflect incoming goods, while issue store transactions denote outgoing goods. Transactions are always created as a result of a store order. Transfer Orders This panel allows for the creation of documents reflecting product quantities which you move from one of your existing stores to another. It's an essential part of inventory management and leads to the creation of a receipt transaction for the receiving store and an issue store transaction for the sending store. Reconciliations In this panel, you can create documents to update your warehouse or store's current availability. It allows for the creation of receipt store transactions (+) and issue store transactions (-) based on variations between initially counted quantities and actual availability. Views The Availability to Promise view provides quantities available for various date periods, including current and projected availability. The Availability to Promise by Lot view specifically tracks quantities available for different date periods, considering both current and projected availability, with a focus on individual lot quantities and those without lot specifications. Learn more about Inventory in the following articles: How To Concepts Available to promise Inventory Control Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/logistics/inventory/inventory-control/ChooseUnit.html": {
    "href": "modules/logistics/inventory/inventory-control/ChooseUnit.html",
    "title": "Measurement unit of the order | ERP.net Tech Docs",
    "summary": "Measurement unit of the order The store order can be created using different measurement units for the \"Quantity Unit\" field, even for the same product. These units could include kg, packet, carton box, liter, pcs, bulk, bottle, and more. To ease the process for users, the \"Choose Measurement Unit\" menu is available within the order. Its main purpose is to make the order execution more user-friendly and help streamline the counting of various storage and distribution units. How it works? The menu is available for operations Receive and Issue. It offers a choice, known as the measurement unit used for order visualization. The settings are remembered per user and independently for the forementioned operations. A user initiates a Receive operation for an Order. By default, the order lines are displayed in the ordered measurement units unless changed. In the example below, a Receive order includes three lines for products ordered in different measurement units. Product \"Grape Juice\" has a default measurement unit of \"Litre\" but is currently ordered in \"Carton box.\" The conversion is as follows: 1 Carton box = 6 Litres = 12 pcs (Base unit). When scanning 1 unit of \"Grape Juice\" (code: 963963), the system correctly recalculates the quantity using the ratio relative to the base measurement unit. This results in a recorded quantity of 1/6 of a Carton box (0.167) or 2 pcs (Base unit). Note The product code is permanently associated with the product's default measurement unit. This means that when you scan the product code, the system automatically identifies its default measurement unit and recalculates the quantity based on the selected visualization unit. By changing the display measurement unit through the menu, the ordered quantities are recalculated based on the product dimensions and predefined conversion ratios. During order execution, users can switch between measurement units for convenience. Upon order completion, the Store transaction is recorded in the originally ordered measurement units. With this innovation, workers can scan and process different units of the same product effortlessly, making inventory management more adaptable, efficient, and user-friendly. Try it out today and experience a new level of control over your operations!"
  },
  "modules/logistics/inventory/inventory-control/command-list.html": {
    "href": "modules/logistics/inventory/inventory-control/command-list.html",
    "title": "Command list | ERP.net Tech Docs",
    "summary": "Command list Here, you can find various barcodes which help you add quantities and apply different commands instantly. This can be handy for adding multiple instances of a product or performing certain operations like creating a document. Navigation In order to access the Command list, tap on the three-dot button at the bottom of the screen and select Command List. All barcodes are grouped into Quantities and Commands, and each group features short explanations on what its barcodes will achieve. While quantity barcodes immediately scan a fixed amount of instances of a product, commands execute specific operations. At any time, you can print and use this sheet externally. Simply scan a barcode and your desired operation will be reflected immediately, without the need to type anything."
  },
  "modules/logistics/inventory/inventory-control/index.html": {
    "href": "modules/logistics/inventory/inventory-control/index.html",
    "title": "Inventory Control | ERP.net Tech Docs",
    "summary": "Inventory Control Inventory Control is a mobile inventory management application designed to speed up and simplify basic operations with store orders. It's perfectly suitable for shops and smaller stores. It follows a similar logic to the BarCodeCommand panel from within the Desktop Client, but much simpler. It allows workers to complete their daily tasks quickly, without going through the more complex procedures of the WMS module. You can receive, issue, reconcile, transfer and scrap orders in just a few steps. These actions are not synchronized in real-time with the ERP.net system - you need to create the respective receipt transaction, issue transaction, transfer order, and reconciliation documents in order to reflect them. Prerequisites Before you start using Inventory Control, you'll be prompted to select the store for which you want to perform different operations. That store will be saved for follow-up operations but can easily be switched to a different one with the help of the Change button. Common features Here, you can observe the most commonly used features in the Inventory Control panel. Scanning In order to scan your products manually, you need to use the Scan field. It lets you quickly insert the instances of a product you want to add either manually or through barcode commands. For a list of available barcode templates, check out the Command list. Individual scan Simply type in a product's code once (e.g. \"0000001\") in order to add only one pcs of it. Tap the blue arrow to confirm. Every time you scan, you'll be taken to the Info tab for the respective product. Successfully scaned pcs are painted in green. If more lots are present for a product, the FEFO principle determines which lot has pcs add first. Incorrect product codes will generate an error. Multiple scans To scan more pcs or the exact number of pcs for a product, specify it first (e.g. \"50\"), add a \"*\", and then enter the product code. This can be done on one line (e.g. 50*1001150), or on two separate lines for each input. Tap the blue arrow to confirm. Note The trash bin button allows you to remove the latest operation, which will restore the previous operation value. Any one, two or three-number combination is automatically counted as a multiplier. You can insert it without adding \"*\" in the end. You can remove inserted multipliers by tapping the Clear button (X). Zero count If you enter a zero quantity in the Scan field, all of the entered quantities before will be set to zero. Select a product from the Info tab You also have the option to enter a product's code only by tapping on its code within the Info tab. When you do that, the product code will be automatically entered in the Scan field. If you need to scan multiple quantities of your product, you can provide a quantity into the Scan field. Once you tap on the product's code, you can enter all of the quantities at once. Scan a GS1 Inventory Control also supports GS1 Barcodes and recognizes a number of GS1 application identifiers. GS1 barcodes are a type of barcode used in retail and supply chain operations to identify items. They are used in many countries and are based on the international GS1 standard. These barcodes use a list of different application identifiers (AI) to encode additional data into the barcode such as quantity, lot, expiration date, serial number, and other attributes. Inventory Control works with some of the most popular GS1 identifiers to recognize the product and the additional information that comes with it and is also encoded into the barcode. A list of the identifiers that are recognized: Identifier Description Length (01) Global Trade Item Number (GTIN) 14 (02) Global Trade Item Number (GTIN) of contained trade items 14 (10) Lot number variable, up to 20 (21) Serial number variable, up to 20 (37) Count of trade items variable, up to 8 Once triggered, it tries to break the GS1 barcode into separate parts to extract the information encoded in it. If there are no errors during this operation, it starts looking for an appropriate line that can be executed with the recognized information. When it finds the best matching line, it starts its execution. If the information is enough to fulfill the line, then the system will not ask the user for anything and will automatically execute the line. If there is no matching line – it throws an error message and stops the execution. For example, if there is a Store Order line that contains a product with Part Number 000008, a specific lot 77677, and a quantity of 300 pcs and you scan the following barcode (02)000008(10)77677(37)300, this line will be automatically fulfilled. Note The identifier (21) Serial Number is also recognized, but for now, it's just saved in the memory of the IC application. Continue last started operation Inventory Control allows you to resume the last operation you were performing. If you exited a receive operation mid-way, for example, it will be displayed as a shortcut in the main menu. You can tap the Continue button to proceed with it. If you choose to begin a new operation before completing the latest one, a warning will appear, asking you to confirm the termination of the latest operation. Note If in the middle of the execution you decide to change Language, Company or Location from the User menu, you will be taken to the initial IC screen with no progress saved. Learn more about Inventory Control in the following articles: Settings Receive Issue Planned Reconcile Quick Reconcile Transfer Scrap Command list Note The screenshots taken for this article are from v.24 of the platform."
  },
  "modules/logistics/inventory/inventory-control/issue.html": {
    "href": "modules/logistics/inventory/inventory-control/issue.html",
    "title": "Issue | ERP.net Tech Docs",
    "summary": "Issue This section allows you to deduct product quantities from your inventory or shop's store, and create issue store transactions. Issued quantities which are successfully executed are counted out of your store's overall availability. Prerequisites Make sure you've set the correct document type for this operation within the Settings. You'll then be prompted to select the released order for which you want to issue product quantities. Available orders are filtered by enterprise company and location. If you tap on one, you'll be taken to the Issue order. Overview Issue is composed of three tabs: Ordered Executed Info Ordered This is where all of your ordered product quantities are listed, together with their lots and product lines, if present. Executed Here, you can find how many quantities of the products are issued as opposed to being ordered. For example, out of 30 ordered pcs, only 15 may be issued. This will be reflected in the issue store transaction. Info If you tap on a product from the Ordered tab, you'll be shown further information about it here. This includes revealing its part number and additional codes, if present, as well as ordered/executed quantities. If more lots are present, the ordered-executed ratio will be distributed based on the FEFO (first expire - first out) principle. Scanning In order to mark product quantities of an order as deducted from your store, you need to use the Scan field. It lets you quickly insert the instances of a product you want to confirm as issued either manually or through barcode commands. For a list of available barcode templates, check out the Command list. If you're unfamiliar with the process of scanning a product and require assistance, refer to our overview. Note The executed pcs of a product cannot be more than what is ordered. Zero count If the Executed bar is left with zero, this will be interpreted as the product having deducted \"0 pcs\". In the final issue store transaction, there will be no lines for the product. Create an issue store transaction Once you're done scanning the desired product quantities, you can go back to the Executed tab to see if you've made any mistakes. The Ordered value will be positioned above the Executed one, making it easy to compare these values. If all ordered product quantities have been issued, the Finish button will be painted in green. Tap on it once to create your issue store transaction. This will take you to a separate space with direct link to the document type for this operation. By tapping on it, you'll access the Inventory module from where you can release and complete the document. Note The screenshots taken for this article are from v24 of the Web Client."
  },
  "modules/logistics/inventory/inventory-control/planned-reconcile.html": {
    "href": "modules/logistics/inventory/inventory-control/planned-reconcile.html",
    "title": "Planned Reconcile | ERP.net Tech Docs",
    "summary": "Planned Reconcile This section allows you to count and update product quantities available in a store based on an existing reconciliation. Planned reconcile is ideal for larger inventories where annual reconciliations or planned audits are performed for individual stores and product groups. It also makes the process more flexible by offering one of two reconciliation types. In contrast, Quick reconcile is designed for fast, on-the-spot reconciliations, even when minor discrepancies are observed. Prerequisites You need to have at least one existing Planned or Firm planned reconciliation to use this module. Create a reconciliation When creating a reconciliation, you need to select a Default Store for it, and optionally choose a Default Product Group. There are two types of reconciliation: Full and Partial. Depending on which one you choose, you can determine what happens with counted and not counted product quantities. Full - Products that are not counted are considered missing and will get a quantity of \"0\" assigned. Partial - Products that are not counted are not reconciled and their availability will remain the same. Important If the Reconciliation Type is Full and a Default Product Group is assigned, uncounted quantities will be set to \"0\" only for products from that group. Note For a reconciliation to be recognized in Planned Reconcile, its state needs to Planned or Firm planned. Overview When you access Planned Reconcile, it will load a list of existing reconciliations filtered by the following criteria: Their Enterprise Company and Enterprise Company Location are the ones the user is currently logged into. All of them have a Default Store equivalent to the one selected for Inventory Control. Each document's Date is no older than seven days prior to the current day. Documents not matching these conditions will not be visualized. Note If a reconciliation has a Default Product Group assigned, it will be named by it. If not, its name will be replaced by a dash. Planned Reconcile is composed of three tabs: Availability Counted Info Availability This is where all of your store products are listed, together with their currently available quantities. If the reconciliation has a Default Product Group assigned, only products belonging to that group will be shown. In that case, attempting to scan a product from another product group will result in an error being thrown. Counted Here, you can find how many quantities of the products have been counted. Each count operation will have its own line, and the newest one will be positioned at the top. Info This tab includes details about the products, including additional codes, if present, as well as the total counted quantities up to this moment and the ability to delete them. If you tap on a product from the Availability tab, you'll be shown further information about it here. All registered counts feature the date and time when they occured, and can be individually deleted. Scanning In order to count quantities of products in Planned Reconcile, you need to use the Scan field. It lets you quickly insert the instances of a product you want to count either manually or through barcode commands. If you're unfamiliar with the process of scanning a product and require assistance, refer to our Inventory Control overview. Common features Just like in Quick Reconcile, you can: scan product quantities higher than the currently available ones introduce product quantities that haven't been previously counted Zero counts You can count zero quantities of products as many times as needed without changing the total counted quantity up to this moment. This will result in new lines being created. If the only count is \"0\", then the quantity of the product will be zero in the final reconciliation document. Note If you leave Planned Reconcile in the middle of counting, your progress will be saved. This applies even if you begin other operations within Inventory Control. Parallel counting Multiple workers can simultaneously count product quantities for the same reconciliation. Once another worker logs in, they can start counting their own counts within the same document. This is independent from previously started counts - every user will see only the quantities that they have counted. Calculate reconciliation based on the counts Once you are done counting product quantities, click Close. This will bring you back to the main Inventory Control application. Store managers responsible for completing the reconciliation procedure need to navigate to the respective reconciliation within the Inventory module. Inside, the Counts panel will have reflected all counted instances of the products, revealing further information about each, such as: Creation Time Utc Creation User Product Quantity Note Here, the manager will see all counted quantities from different users. These quantities can be edited manually from here, if needed. Using a UI function, you can consolidate individual quantity counts from the Counts panel into summarized lines in the Lines panel. This ensures that products counted in the same store are automatically summed up or represented by a zero quantity, depending on the selected reconciliation type (Partial or Full). For more information, please refer to Calculate reconciliation, based on the counts. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/logistics/inventory/inventory-control/quick-reconcile.html": {
    "href": "modules/logistics/inventory/inventory-control/quick-reconcile.html",
    "title": "Quick Reconcile | ERP.net Tech Docs",
    "summary": "Quick Reconcile This section allows you to update the available quantities of your inventory or shop's products, and create reconciliation documents. By occasionally counting everything, it may turn out that some products have fewer or higher quantities, or are no longer present. The reverse could also be true: new products may be identified but not entered into the system. Inventory Control allows you to reflect any of these changes within its Quick Reconcile section. Prerequisites Make sure you've set the correct document type for this operation within the Settings. You don't need an existing order to use this module. All of your store's product quantities will be listed. Overview Quick Reconcile is composed of three tabs: Availability Counted Info Availability This is where all of your products are listed, together with their current quantities and lots, if present. Counted Here, you can find how many quantities of the products have been counted as opposed to being available in total. For example, out of 150pcs, only 131 may be present. This will be reflected in the reconciliation document. Info If you tap on a product from the Availability tab, you'll be shown further information about it here. This includes revealing its part number and additional codes, if present, as well as counted quantities. If more lots are present, the available-counted ratio will be distributed based on the FEFO principle. Scanning In order to update the currently available quantities of your products, you need to use the Scan field. It lets you quickly insert the instances of a product you want to count either manually or through barcode commands. For a list of available barcode templates, check out the Command list. If you're unfamiliar with the process of scanning a product and require assistance, refer to our overview. Higher count The currently available pcs of a product may be more than what is set as available in the system. You can update the number by providing the higher counted value, which will be reflected in the final reconciliation document. New count If a product previously absent from the system is now available, you can add it by scanning it. Its pcs will be reflected immediately, and once a reconciliation document is released, the Available bar will be updated with the new quantity. Zero count You can enter a Zero quantity for the products that are missing from the store. Each zero count is interpreted as the product or lot having \"0 pcs\" in the final reconciliation document. Create a reconciliation document Once you're done scanning the product quantities, you can go back to the Counted tab to see if you've made any mistakes. The Available value will be positioned above the Counted one, making it easy to compare past and present values. If the counted number is greater than or equal to the available number, the Finish button will be painted in green. Tap on it once to create your reconciliation document. This will take you to a separate space with direct link to the document type for this operation. By tapping on it, you'll access the Inventory module from where you can release and complete the document. Note The screenshots taken for this article are from v24 of the Web Client."
  },
  "modules/logistics/inventory/inventory-control/receive.html": {
    "href": "modules/logistics/inventory/inventory-control/receive.html",
    "title": "Receive | ERP.net Tech Docs",
    "summary": "Receive This section allows you to confirm product quantities received by your inventory or shop's store, and create receipt store transactions. Ordered quantities which are successfully confirmed and executed are counted towards your store's overall availability. Prerequisites Make sure you've set the correct document type for this operation within the Settings. You'll then be prompted to select the released order for which you want to confirm received product quantities. Available orders are filtered by enterprise company and location. If you tap on one, you'll be taken to the Receive order. Overview Receieve is composed of three tabs: Ordered Executed Info Ordered This is where all of your ordered product quantities are listed, together with their lots and order lines, if present. One and the same document can have its quantities spread across multiple lots. Executed Here, you can find how many quantities of the products are executed as opposed to being ordered. For example, out of 30 ordered pcs, only 15 may be received. This will be reflected in the receipt store transaction. Info If you tap on a product from the Ordered tab, you'll be shown further information about it here. This includes revealing its part number and additional codes, if present, as well as ordered/executed quantities. If more lots are present, the ordered-executed ratio is distributed based on the FEFO (first expire - first out) principle. For example, 250 product quantities may be distributed across 3 lots with 100, 80 and 70 each. The lot with quantities whose date is closest to its expiration point will be prioritised in the execution process. Scanning In order to mark product quantities of an order as received, you need to use the Scan field. It lets you quickly insert the instances of a product you want to receive either manually or through barcode commands. For a list of available barcode templates, check out the Command list. If you're unfamiliar with the process of scanning a product and require assistance, refer to our overview. Note The executed pcs of a product cannot be more than what is ordered. Zero count If the Executed bar is left with zero, this will be interpreted as the product having received \"0 pcs\". In the final receipt store transaction, there will be no lines for the product. Create a receipt store transaction Once you're done scanning the ordered product quantities, you can go back to the Executed tab to see if you've made any mistakes. The Ordered value will be positioned above the Executed one, making it easy to compare these values. If all ordered product quantities have been received, the Finish button will be painted in green. Tap on it once to create your receipt store document. This will take you to a separate space with direct link to the transaction for this operation. By tapping on it, you'll access the Inventory module from where you can release and complete the document. Note The screenshots taken for this article are from v24 of the Web Client."
  },
  "modules/logistics/inventory/inventory-control/scrap.html": {
    "href": "modules/logistics/inventory/inventory-control/scrap.html",
    "title": "Scrap | ERP.net Tech Docs",
    "summary": "Scrap This section allows you to remove available quantities from your inventory or shop's products, and create issue store transactions. Scrapping is done when a product's expiry date is reached or the store no longer needs product quantities. Successfully scrapped quantities are counted out of your store's overall availability. Prerequisites Make sure you've set the correct document type for this operation within the Settings. You don't need an existing order to use this module. All of your store's product quantities will be listed. Overview Scrap is composed of three tabs: Availability Scrap Info Availability This is where all of your store products are listed, together with their current quantities and lots, if present. Scrap Here, you can find how many quantities of the products are selected for scrap as opposed to being available in total. For example, out of 30pcs, only 15 may be scrapped. This will be reflected in the issue store transaction. Info If you tap on a product from the Availability tab, you'll be shown further information about it here. This includes revealing its part number and additional codes, if present, as well as counted quantities. If more lots are present, the available-scrap ratio will be distributed based on the FEFO principle. Scanning In order to scrap currently available quantities of your products, you need to use the Scan field. It lets you quickly insert the instances of a product you want to scrap either manually or through barcode commands. For a list of available barcode templates, check out the Command list. If you're unfamiliar with the process of scanning a product and require assistance, refer to our overview. Note The executed pcs of a product cannot be more than what is ordered. Zero count If the Scrap bar is left with zero, this will be interpreted as the product having deducted \"0 pcs\". In the final issue store transaction, there will be no lines for the product. Create an issue order transaction Once you're done scanning the desired product quantities, you can go back to the Scrap tab to see if you've made any mistakes. The Available value will be positioned above the Scrap one, making it easy to compare these values. If all available product quantities are set to be scrapped, the Finish button will be painted in green. Tap on it once to create your issue store transaction. This will take you to a separate space with direct access to the document type for this operation. By tapping on it, you'll access the Inventory module from where you can release and complete the document. Note The screenshots taken for this article are from v24 of the Web Client."
  },
  "modules/logistics/inventory/inventory-control/settings.html": {
    "href": "modules/logistics/inventory/inventory-control/settings.html",
    "title": "Settings | ERP.net Tech Docs",
    "summary": "Settings This section lets you decide what type of document will be created following each of these actions: Receive Issue Transfer Scrap Reconcile It's crucial to link the right type to its respective action before beginning to do anything within Inventory Control. Important For the Receive and Issue functions, under certain conditions, the Document Type specified in the Document Routes of the respective order will also be taken into account when the final transaction is created. Navigation In order to access the Inventory Control Settings, tap on the context menu at the bottom of the screen and select Settings. Configuration If you tap on the downward arrows of any of the available options, you'll be taken to a list of your existing document types. It's possible to link any type to either the receive, issue, scrap, transfer or reconcile operation. One and the same document type can be used for multiple operations."
  },
  "modules/logistics/inventory/inventory-control/the_bin.html": {
    "href": "modules/logistics/inventory/inventory-control/the_bin.html",
    "title": "How to Use the Bin in Inventory Control | ERP.net Tech Docs",
    "summary": "How to Use the Bin in Inventory Control In our Inventory Control module, the bin plays a crucial role in managing product counts. There are two types of bins used in all operations, both available in the Info panel: Delete-all Bin (Large Bin) and Delete-row Bin (Small Bin) Using the Delete-all bin The \"large bin\" is located at the top, on the product row. It is used to delete all counts and executions for a specific product, marking it as unexecuted or not counted at all. The process is similar for all operations like Receive, Issue, Scrap, Transfer, Quick reconcile and Planned reconcile. Steps: Let say you execute a Receive operation of an Order consisting of three lines - products X, Y and Z. Each line has been executed as seen in tab Executed and in Executed field. You decide to delete all executed quantities for product X: Navigate to the Info tab of product X. Locate the large bin at the top of the product row. Click on the bin icon -> A pop-up message appears to confirm deletion. Choose Delete to confirm. Result: The quantity for product X in the Executed field is deleted The row related to this product in tab Executed is removed. After deletion, it appears as if the product was never executed. Another example at operation Planned Reconcile, in which you count 50pcs of product X and 20pcs of product Y. In field Counted is entered the quantity for each product and in tab Counted are registered the rows for the counted products. You decide to delete all counts for product X. Execute the forementioned steps (1-4). As a result all counted quantity for product X is deleted as if never counted. If you check the records in panel Counts in Reconciliation document, you will see that the line is also removed from there. Using the Delete-row bin The \"small\" bin is used to delete individual product count rows at all IC operations. It is helpful with products having lots or variants, allowing users to delete distributed quantities for specific lots or variants. For example, if a scanned quantity is spread across multiple lots, users can now remove the count for a chosen lot without affecting others. Steps: Let say you execute a Receive operation of an Order consisting of three lines, for two products X and Y, and product Y is ordered in a lot as well. Execution of 8pcs of product Y results in distribution of the quantity between the unspecified product lot (4pcs) and the specified lot (4pcs). Now each line has been executed as seen in tab Executed and in Executed field. You decide to delete the quantity of the unspecified lot of product Y: Navigate to the Info tab of product Y; Locate the small bin on the row, next to the desired qunatity (\"4\"); Click on the bin icon. Warning No confirmation message for the deletion will pop-up! Result: The quantity for the unspecified lot of product Y in the Executed field is deleted. The row related to this product and lot in tab Executed shows a dash \"-\". After deletion, it appears as if the lot was never executed. Another example at operation Quick Reconcile, and you count 4000pcs of product X. The amount is distributed between the available lots. You decide to delete the counted quantity of the specified lot (\"00022\"). Simply click on the bin in the row of the lot, next to quantity \"100\" and without any warning, it will be deleted. The row in tab Counted will also be deleted. By using these bin functionalities effectively, you can ensure accurate inventory management while maintaining flexibility in operations."
  },
  "modules/logistics/inventory/inventory-control/transfer.html": {
    "href": "modules/logistics/inventory/inventory-control/transfer.html",
    "title": "Transfer | ERP.net Tech Docs",
    "summary": "Transfer This section allows you to transfer available product quantities from one of your stores to another, and generate transfer orders. Transfer is useful when a store needs certain quantities available in another store. Upon every transfer, the sending store must generate a separate issue store transaction to reflect the transferred quantities, while the recipient store must generate a receipt store transaction. Both documents can be generated through Inventory Control or similar modules. Prerequisites Make sure you've set the correct document type for this operation within the Settings. You'll then be prompted to select the correct store from which you want to transfer, and the store to which you want to transfer. When done, tap Ok. You'll be taken to the Transfer module. Overview Transfer is composed of three tabs: Availability Transfer Info Availability This is where all of your store products are listed, together with their current quantities and lots, if present. Transfer Here, you can find how many quantities of the products are selected for transfer as opposed to being available in total. For example, out of 20pcs, only 10 may need to be transferred. This will be reflected in the transfer order. Info If you tap on a product from the Availability tab, you'll be shown further information about it here. This includes revealing its unique code, barcode and GTIN, if present, as well as how many instances of it will be transferred. If more lots are present, the available-transfer ratio will be distributed based on the FEFO principle. Scanning In order to transfer quantities of your products to another store, you need to use the Scan field. It lets you quickly insert the instances of a product you want to transfer either manually or through barcode commands. For a list of available barcode templates, check out the Command list. If you're unfamiliar with the process of scanning a product and require assistance, refer to our overview. Note The executed pcs of a product cannot be more than what is ordered. Zero count In case you've made a mistake and want to start the transfer process from scratch, type in \"0*\" followed by the affected product code. If the Transfer bar is left with zero, this will be interpreted as the product having \"0 pcs\" for transfer in the final transfer order. Generate a transfer order Once you're done scanning the desired product quantities, you can go back to the Transfer tab to see if you've made any mistakes. The Available value will be positioned above the Transfer one, making it easy to compare these values. If all available product quantities are transferred, the Finish button will be painted in green. Tap on it once to generate your transfer order. This will take you to a separate space with direct access to the document type for this operation. By tapping on it, you'll access the Inventory module from where you can release and complete the order. Note The screenshots taken for this article are from v24 of the Web Client."
  },
  "modules/logistics/inventory/pictures/index.html": {
    "href": "modules/logistics/inventory/pictures/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/logistics/planning/index.html": {
    "href": "modules/logistics/planning/index.html",
    "title": "Planning concepts and operations | ERP.net Tech Docs",
    "summary": "Planning concepts and operations Here, you will find concepts and operations related to logistics planning: Material requirements planning Projected available balance Replenish suggestions"
  },
  "modules/logistics/planning/material-requirements-planning.html": {
    "href": "modules/logistics/planning/material-requirements-planning.html",
    "title": "Material requirements planning | ERP.net Tech Docs",
    "summary": "Material requirements planning Material requirements planning (MRP) is a planning process designed to match supply with demand. MRP does this by creating supply (purchase/work/transfer) orders to meet or exceed the demand, according to the MRP parameters. Some information could be obtained from here: https://en.wikipedia.org/wiki/Material_requirements_planning The MRP process in ERP.net is an implementation which mostly follows the general theory. However, in order to use MRP, you need to do the ERP.net-specific setup. Document types and routes setup The document routes should be properly set-up. The main input parameter for MRP is demand. It is calculated based entirely on store orders with state Planned. Therefore, the document routes for sales orders, purchase orders, work orders, etc. should be adequately designed to generate store orders with a planned state. If a store order is generated solely for the purposes of MRP demand management, it can be set with the Planning_Only attribute. This attribute does not allow the setting of Firm Planned (or higher) states. Simplified description of a single MRP run When MRP is run for a warehouse (store), it does the following to each product: Calculates demand. Determines whether a supply action is needed. Determines the required quantity. Creates a purchase/work/transfer order for the desired quantity. When MRP is run for multiple warehouses (stores), the system tries to prioritize the supply order of the warehouses. This might not always be successful, especially in cases of circular supply orders. Terms There are many terms used in MRP. We will try to provide simple descriptions for some of them: Projected Available Balance (PAB)- An inventory balance projected into the future. It is the sum of on-hand inventory minus requirements plus scheduled receipts and planned orders. Planning Bucket - the smallest period whose demand and supply are planned as a single unit. In ERP.net, it is fixed as 1 day. In theory, it could be a day, week, month or some mixed system (for example, days in the near future, weeks in the far future, etc.). Planning Horizon - the period of time in the future for which demand is matched with supply. In ERP.net, it is currently fixed to 180 days. The Planning Buckets (also known as \"buckets\") exist only within the time frame specified by the Planning Horizon. When we say \"bucket\", it is a Planning Bucket in the future, but within the Planning Horizon. Time fences Time fences are boundaries between different periods in the planning horizon. From today to Demand Time Fence (DTF) - the time period in the (near) future for which actual demand is considered accurate, and forecasts - inaccurate. The planning process considers only demand. From DTF to Planning Time Fence (PTF) - the time period between the DTF and PTF for which it is unknown whether the demand or the forecast is more accurate. The planning process considers bigger either the demand or forecast for each bucket. After PTF - only the forecasts are considered accurate. The planning process considers only forecasts. Product supply definitions The MRP process is set-up through the product supply definitions. Each definition contains the planning parameters for one product and one warehouse (store). Every warehouse (store) needs to create a separate product supply definition for each product, which will be planned for this warehouse. The product supply definitions parametrize the when, how much, and how of the MRP planning system. Procurement type Procurement type specifies what to do when a supply order needs to be created. The options are: Buy - Create a purchase order Make - Create a work order Transfer - Create a transfer order Order policy The order policy specifies when the supply is not enough and a supply order needs to be created. The options are: MRP - a supply order is created for: any demand for a bucket OR if the Projected Available Balance for any bucket is less than the Planning Safety Stock. OPS - a supply order is created if the PAB for any bucket is less than the specified Order Point. OPT - a supply order is created if by the time of expected arrival of the ordered goods, the PAB is less than the specified Order Point. PRS - a supply order is created unconditionally on each order cycle. Planning Order Cycle Days specifies the number of days in the order cycle. Lot sizing method The lot sizing method specifies how much should be ordered. It is divided in two separate calculations: Algorithm calculations. Order modifiers The selected algorithm calculates some order quantity. Then, order modifiers adjust the quantity with minimum, maximum, and lot-size modifiers. The algorithms are: FOQ - Fixed Order Quantity - orders unconditionally what is specified in the Fixed Order Quantity. EOQ - Economic Order Quantity - orders the specified period in an efficient way, balancing between order-fixed and holding costs. For more information, see https://en.wikipedia.org/wiki/Economic_order_quantity. LFL - Lot For Lot - orders the calculated demand for the bucket. LFP - Lot For Period - orders the required quantity for the bucket but adds enough quantity for the specified period ahead. ROP - Reorder Point - orders up to the specified Planning Maximum Inventory. ROT - Reorder Point with Time Planning - orders up to the specified Planning Maximum Inventory but also adjusts the quantity with the expected usage for the time the goods are in transit."
  },
  "modules/logistics/planning/projected-available-balance.html": {
    "href": "modules/logistics/planning/projected-available-balance.html",
    "title": "Projected available balance | ERP.net Tech Docs",
    "summary": "Projected available balance Projected available balance (PAB) shows the inventory balance projected into the future. It is the running sum of the current stock holds with scheduled receipts added, minus planned issue stock orders. The projected available balance is used in the calculation of the available to promise. The algorithm In the projected available balance, two kinds of data are used: Current stock holds - this is the quantity available placed in store today; Chronology of the store orders which are not executed - includes all store orders (or their unfilled parts) which are not completed yet. Note that if there are expected store receipts or issues for a past date which are still not executed, the algorithm assumes that they are being executed today. For example: Let's assume that today (2021/05/05) we have 10 pcs from product A in store S; There is an expected delivery from 3 days ago (2021/05/02) for 8 pcs, which has not been executed yet; We have the following planned store movements: on 2021/05/07, planned receipt of 15 pcs; on 2021/05/09, planned issue of 4 pcs; on 2021/05/13, planned receipt of 10 pcs; on 2021/05/15, planned issue of 7 pcs; on 2021/05/15, planned receipt of 2 pcs; on 2021/05/20, planned issue of 3 pcs; With this data provided, we can calculate the following PAB: Date Start quantity Issue quantity Receipt quantity PAB 2021/05/05 10 - 8 18 2021/05/07 - - 15 33 2021/05/09 - 4 - 29 2021/05/13 - - 10 39 2021/05/15 - 7 2 34 2021/05/20 - 3 - 31 The PAB line can be seen on the following chart: All documents in ERP.net that may lead to store movements can be set to generate planned or firmed store orders - directly or through other documents. With this setting, the documents can be involved in the projected available balance and available to promise calculations."
  },
  "modules/logistics/planning/replenish-suggestions/index.html": {
    "href": "modules/logistics/planning/replenish-suggestions/index.html",
    "title": "Replenishing suggestions | ERP.net Tech Docs",
    "summary": "Replenishing suggestions Here, you will find common concepts and operations associated with the Suggest replenish functionality. Replenishing suggestions for work orders Replenishing suggestions for purchase orders Replenishing suggestions for transfer orders"
  },
  "modules/logistics/planning/replenish-suggestions/replenish-production.html": {
    "href": "modules/logistics/planning/replenish-suggestions/replenish-production.html",
    "title": "Replenishing suggestions for work orders | ERP.net Tech Docs",
    "summary": "Replenishing suggestions for work orders If your store is running low on product quantities, you can take advantage of replenishing suggestions to restore the supply to a desired number. By following the steps below, while issuing work orders, you'll be able to generate lines exclusively for replenishing product quantities. Prerequisites For the feature to work as expected, you need to have done two things in advance: Define a product supply suited for work orders. Go to General -> Products and select Product Supply. From there, add a new supply with the plus button. Make sure to go through each field carefully. Suggested replenishment requires specific values for certain fields in order to work. Product - The product for which the supply (and a work order) will be made. Procurement Type - The type of action associated with this product (in this case, produced products imply Make). Generate Document Type - The type of document which will be issued according to the supply rules (leave this as Production Order). Store - The store for which this product supply (and replenishment) will be made. Order Point Quantity Base - Quantity the product must drop to for replenishment to be triggered. Planning Maximum Inventory Quantity Base - Maximum possible quantity of product in the store. Planning Lead Time Days - Days needed to supply or manufacture the product. Order Minimum - Minimum quantity of product that can be ordered at a time. Order Maximum - Maximum quantity of product that can be ordered at a time. Order Multiple - Tick this box to make the produced product quantity multiple by lot size. Order Lot Size Quantity Base - The lot size value. Order Policy - The policy the replenishment system will follow (leave this as OPS - Order Point System). Manufacturing Policy - The manufcaturing product policy used by the replenishment system (must be MTS - Make-To-Stock). From Store - Used when the procurement type is Transfer. Preferred Supplier - Name of the supplier who must have produced the product (will be identical in the work order). Enterprise Company - Name of the enterprise company associated with the product supply (identical in the work order). When done, save the product supply. Create a new work order from the Production -> Shop Floor module or open an existing one. The status of the document should be below Released - most often New. Make sure the product, output store and materials store and are identical to the ones you defined for the product supply. Use Suggest replenish You can apply the Suggest replenish feature from within your existing work order document. Click the play button and select Suggest replenish. If the order has lines, they will be removed and new ones will be automatically generated for suggested product quantity replenishing."
  },
  "modules/logistics/planning/replenish-suggestions/replenish-purchase.html": {
    "href": "modules/logistics/planning/replenish-suggestions/replenish-purchase.html",
    "title": "Replenishing suggestions for purchase orders | ERP.net Tech Docs",
    "summary": "Replenishing suggestions for purchase orders If your store is running low on product quantities, you can take advantage of replenishing suggestions to restore the supply to a desired number. By following the steps below, while issuing purchase orders, you'll be able to generate lines exclusively for replenishing product quantities. Prerequisites For the feature to work as expected, you need to have done two things in advance: Define a product supply suited for purchase orders. Go to General -> Products and select Product Supply. From there, add a new supply with the plus button. Make sure to go through each field carefully. Suggested replenishment requires specific values for certain fields in order to work. Product - The product for which the supply (and a purchase order) will be made. Procurement Type - The type of action associated with this product (in this case, bought products imply Buy). Generate Document Type - The type of document which will be issued according to the supply rules (leave this as Purchase Order). Order Point Quantity Base - Quantity the product must drop to for replenishment to be triggered. Planning Maximum Inventory Quantity Base - Maximum possible quantity of product in the store. Planning Lead Time Days - Days needed to supply or manufacture the product. Order Minimum - Minimum quantity of product that can be ordered at a time. Order Maximum - Maximum quantity of product that can be ordered at a time. Order Multiple - Tick this box to make the purchased product quantity multiple by lot size. Order Lot Size Quantity Base - The lot size value. Order Policy - The policy the replenishment system will follow (leave this as OPS - Order Point System). Manufacturing Policy - Used when the procurement type is Make. From Store - Used when the procurement type is Transfer. Preferred Supplier - Name of the supplier who must have produced the product (will be identical in the purchase order). Enterprise Company - Name of the enterprise company associated with the product supply (identical in the purchase order). When done, save the product supply. Create a new purchase order from the Logistics -> Procurement module or open an existing one. The status of the document should be below Released - most often New. Make sure the product, supplier and store and are identical to the ones you defined for the product supply. Use Suggest replenish You can apply the Suggest replenish feature from within your existing purchase order document. Click the play button and select Suggest replenish. If the order has lines, they will be removed and new ones will be automatically generated for suggested product quantity replenishing."
  },
  "modules/logistics/planning/replenish-suggestions/replenish-transfer.html": {
    "href": "modules/logistics/planning/replenish-suggestions/replenish-transfer.html",
    "title": "Replenishing suggestions for transfer orders | ERP.net Tech Docs",
    "summary": "Replenishing suggestions for transfer orders If during transfers your main store is running low on product quantities, you can take advantage of replenishing suggestions to restore the supply to a desired number. By following the steps below, while issuing transfer orders, you'll be able to generate lines exclusively for replenishing product quantities. Prerequisites For the feature to work as expected, you need to have done two things in advance: Define a product supply suited for transfer orders. Go to General -> Products and select Product Supply. From there, add a new supply with the plus button. Make sure to go through each field carefully. Suggested replenishment requires specific values for certain fields in order to work. Product - The product for which the supply (and a transfer order) will be made. Procurement Type - The type of action associated with this product (in this case, choose Transfer). Generate Document Type - The type of document which will be issued according to the supply rules (leave this as Transfer Order). Store - The store for which this product supply (and replenishment) will be made. Order Point Quantity Base - Quantity the product must drop to for replenishment to be triggered. Planning Maximum Inventory Quantity Base - Maximum possible quantity of product in the store. Planning Lead Time Days - Days needed to supply or manufacture the product. Order Minimum - Minimum quantity of product that can be ordered at a time. Order Maximum - Maximum quantity of product that can be ordered at a time. Order Multiple - Tick this box to make the product quantity multiple by lot size. Order Lot Size Quantity Base - The lot size value. Order Policy - The policy the replenishment system will follow (leave this as OPS - Order Point System). Manufacturing Policy - Used when the procurement type is Make. From Store - The store from which product quantities will be requested (identical in the transfer order) Preferred Supplier - Name of the supplier who must have produced the product (will be identical in the transfer order). Enterprise Company - Name of the enterprise company associated with the product supply (identical in the transfer order). When done, save the product supply. Create a new transfer order from the Logistics -> Inventory module or open an existing one. The status of the document should be below Released - most often New. Make sure the product, output store and materials store and are identical to the ones you defined for the product supply. Use Suggest replenish You can apply the Suggest replenish feature from within your existing transfer order document. Click the play button and select Suggest replenish. If the order has lines, they will be removed and new ones will be automatically generated for suggested product quantity replenishing."
  },
  "modules/logistics/procurement/automatic-lot-creation.html": {
    "href": "modules/logistics/procurement/automatic-lot-creation.html",
    "title": "Automatic lot creation | ERP.net Tech Docs",
    "summary": "Automatic lot creation This function is used when the user wants to automatically create new lots when purchasing products. This is achievable by the product type definition and the Lot Auto Creation field. If checked, it specifies that lots are automatically created by the receiving orders with which the products are received. When such product is purchased, the following actions are performed for each purchase order row: if the Lot field has value, nothing happens; if the Lot field is empty, the system checks the value of the product type's definition Lot Auto Creation field (of the product of the current row): if it is false - nothing happens; if it is true - then an attempt to set a lot in the current row is performed: an already existing lot of the current product is searched, which has the number of the current document set in the Purchase Lot Number field; if such lot is found - it is filled in the current row; if no such lot is found - a new lot is created. New lot algorithm creation The new lot, created in the last step of the actions described above, is created as follows: the product from the purchase order row is set as 'Product' in the new lot definition; the 'Purchase Lot Description' from the purchase order header is set as 'Description' in the new lot definition; the Document Number of the current document is set as 'Purchase Lot Number' in the new lot definition; the 'Lot Number' of the new lot is formed by the biggest lot number (in alphabetic order) of the already existing ones (regardless of Product, Description or Purchase Lot Number), and this number is increased by 1; if there are no existing lots in the database '00001' is set."
  },
  "modules/logistics/procurement/index.html": {
    "href": "modules/logistics/procurement/index.html",
    "title": "Procurement | ERP.net Tech Docs",
    "summary": "Procurement This submodule serves as a comprehensive tool for overseeing and optimizing the sourcing of materials within the warehouse environment. It plays a pivotal role in streamlining the entire procurement process, from initial supplier selection to final product acquisition. By leveraging this space, you can effectively track and manage all aspects of procurement, including supplier relationships, purchase order creation, inventory replenishment, and receipt of goods. Definitions Suppliers First, it's necessary to establish one or more suppliers responsible for delivering products to the warehouse. Documents Requisitions This panel contains internal requisitions for products, which are then consolidated by the purchase department into purchase orders. A requisitions requires you to specify which store will get your order, the party that will deliver it and all the products that you need. When all the details are provided and a subsequent offer is accepted, you can proceed with creating a purchase order to confirm your purchase. Purchase Order This panel allows you to create a purchase order which is sent to suppliers to notify them of an order for goods or services. It includes the respective invoice and is handed to a store worker responsible for handling the delivered products. Purchase Invoice To finish a purchase request, you also need to create its respective invoice using this panel. A purchase invoice document requires the provision of a delivery warehouse and a supplier responsible for fulfilling the order. Depending on the chosen supplier, additional information such as credit limits and delivery times may be specified. Learn more about Procurement here; Automatic lot creation Setting cost when purchasing goods Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/logistics/procurement/pictures/index.html": {
    "href": "modules/logistics/procurement/pictures/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/logistics/procurement/setting-cost-when-purchasing-goods.html": {
    "href": "modules/logistics/procurement/setting-cost-when-purchasing-goods.html",
    "title": "Setting cost when purchasing goods | ERP.net Tech Docs",
    "summary": "Setting cost when purchasing goods In ERP.net goods are purchased in two stages: Stage one: recording the quantities. In this stage, only quantities are entered into the system - those which are actually received. This stage changes only the stock holds. In this stage also the user defines the lots. Stage two: recording the costs. This is done by separating store documents from the documents from stage one. This is because the cost is defined by the purchase invoices for the goods which do not always arrive along with the actual goods. The current article describes stage two. The documents that are part of both stages of the purchasing process are as follows: Receiving orders - These documents represent what we expect to receive and not what is actually received. Purchase invoices - created from or by receiving orders and contain the cost of the goods. This is the document sent by the supplier and the user enters it the way it is received; Store receipt orders - created from the receiving order and record the quantity that has to be entered in the store; Quantity transactions - created from or by the store orders. They contain the stocks that are entered into the store (they may be entered directly by a barcode scanner). These documents do not record the goods cost yet; Cost transactions - created from the receiving orders and record the cost, which is copied from the purchase invoice. They should get the exact lots and Transaction Timestamp from the quantity transactions. Stage one is represented by receiving order => store receipt orders => quantity transactions while the second stage is represented by receiving order => cost transactions and only after the purchase invoice is entered in the system. The cost is set only for the products which are received by the quantity transaction. I.e. if there is a receiving order with no quantity transaction then no cost transaction will be created. The cost is calculated when the quantities from the quantity transaction are multiplied by the unit cost, defined by the purchase invoice. So if there is no purchase invoice no cost transaction will be created. The unit cost for one row in the receiving order is defined as follows: All rows of released, non-voided purchase invoices for the current row from the receiving order are summed up. If there are no such rows, then the unit cost is 0. For each row from p.1,an end cost is defined: [End Cost] = [Line Amount] + [sum of the distributed amounts for the current row]. Note Only additional amounts that are marked with Add To Line as True. Also, the additional amount may be entered by other purchase invoices (for example - transport purchase invoice). At the end the [End Cost] for all rows from p.1 are summed up, the quantities for those rows are summed up and the end cost is divided by those quantities. If the quantities are 0 then the unit cost is also 0. Not: When summing up all end costs have to be converted to the currency of the receiving order, and all quantities have to be converted to the measurement unit of the receiving order row. Then, when creating cost transaction for a receiving order, for each row of the current receiving order the following calculations are made: All rows of released, non-voided cost transactions for the current row of the receiving order, are summed up; For each row from p.1, a new row in the transaction cost is created in which the quantity and the unit cost are 0, the lot and the transaction timestamp are copied from p.1. and the cost is equal to the quantity of the row multiplied by the unit cost for the row in the receiving order. Example 1: There is a Receiving Order #1 with two rows: row #10, Product A, 10 PCS; row #20, Product B, 12 PCS; The following quantity transactions are created: Transaction #1 for Receiving Order #1 row #10, Product A,Lot 12B, 4 PCS, Transaction Timestamp = 15/10/2020 12:59; Transaction #1 for Receiving Order #1 row #20, Product B,Lot 9A, 10 PCS, Transaction Timestamp = 15/10/2020 12:59; Transaction #2 for Receiving Order #1 row #10, Product A,Lot 17B, 3 PCS, Transaction Timestamp = 17/10/2020 14:15; Transaction #2 for Receiving Order #1 row #20, Product B,Lot 13A, 1 PCS, Transaction Timestamp = 17/10/2020 14:15. Also, there are two purchase invoices for Receiving order #1 and one purchase invoice for transport, which distributes an additional amount on the first two purchase invoices: Purchase Invoice #1, for Receiving Order #1 row #10, 8 PCS, 64 EUR; Purchase Invoice #1, for Receiving Order #1 row #20, 13 PCS, 39 EUR; Purchase Invoice #2, for Receiving Order #1 row #10, 1 PCS, 10 EUR; Purchase Invoice #3 with no rows and an additional amount of 44 EUR for transport which is distributed by the quantities. So the added amounts are 16 EUR, 26 EUR and 2 EUR; In this case, the cost transactions on this delivery should be as follows: Product A, lot 12B, 0 PCS, Transaction Timestamp = 15/10/2020 12:59, Line Cost = 4 PCS * ((64 EUR + 16 EUR + 10 EUR + 2 EUR) / (8 PCS + 1 PCS)) ~ 40.89 EUR; Product B, lot 9A, 0 PCS, Transaction Timestamp = 15/10/2020 12:59, Line Cost = 10 PCS * ((39 EUR + 26 EUR) / 13 PCS) = 50 EUR; Product A, lot 17B, 0 PCS, Transaction Timestamp = 17/10/2020 14:15, Line Cost = 4 PCS * ((64 EUR + 16 EUR + 10 EUR + 2 EUR) / (8 PCS + 1 PCS)) ~ 30.67 EUR; Product B, lot 13A, 0 PCS, Transaction Timestamp = 17/10/2020 14:15, Line Cost = 4 PCS * ((39 EUR + 26 EUR) / (16 PCS) = 5 EUR;"
  },
  "modules/logistics/shipment/index.html": {
    "href": "modules/logistics/shipment/index.html",
    "title": "Shipment | ERP.net Tech Docs",
    "summary": "Shipment This submodule is designed to assist the process of shipping products to different customers. Documents Shipment Orders This panel allows for the creation of shipment orders. When certain products from your warehouse are sold or leave it through any other means, you will need to create an issue order, including a respective issue store transaction. These documents lead to the creation of a shipment order, confirming that a certain number of products have left the store. Shipments Once you have created a shipment order based on an existing issue store order and transaction, you also need to create an additional shipment document, which includes a recipient party, delivery date and from which store the products are set to leave. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/logistics/shipment/pictures/index.html": {
    "href": "modules/logistics/shipment/pictures/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/logistics/wms/composite-products/control-levels.html": {
    "href": "modules/logistics/wms/composite-products/control-levels.html",
    "title": "Levels of control for composite products | ERP.net Tech Docs",
    "summary": "Levels of control for composite products It is very important to minimize errors when working with composite products. For example, it is crucial that the workers will not miss to dispatch some of the components or will not dispatch an additional component by mistake. This would make the customer, the management, or both unhappy and leads to additional costs for the company. WMS introduces several levels of control which can be set for proper and controlled task execution when working with composite products. The control levels are set up using the \"Kitting Controlling Level\" and \"Dekitting Controlling Level\" warehouse policies where you can specify the desired level. Note If no policy is specified or applicable for the particular line, then the default level is 50. The control is performed during the order execution in the WMS Worker App (link) and more specifically during the execution of the Kit/Dekit lines of the component product. It could be fully automated or might be performed by a person in accordance with the needs of the company and it depends on the specified level of control. Levels Level 50 - Check all This is the highest and therefore the most restrictive level. It requires all products to be scanned again after picking. When executing the Kit/Dekit line, the app shows a screen, where the workers must scan all components of the kit. The component products and product quantities must exactly match those in the composite product's definition, otherwise the system will not activate the Finish button and the line could not be fulfilled. Level 40 - Check all + Allow incomplete finish Same as level 50, but the application provides an option to still fulfill the order even when the exepected and the executed contents do not match. The option is available trough the \"Finish incomplete\" button, situated in the buttons menu. Level 30 - Just preview totals The app displays a screen with summarized information for the components of the product from its definition and the executed quantities for the selected order. The information available for counting or checking, but does not require rescanning of the components. The workers certifiy that they hav completed the check by pressing the Finish button. Level 20 - Check and complete The system checks if the whole order execution exactly matches the composite product's definition when a kit/dekit execution is attempted. If everything mathes – the kit/dekit is successfully executed. If there are differences and the validation is unsuccessful, the app shows an error. Level 10 - Autocomplete The system automatically executes the kit/dekit operation if all component lines are fulfilled and exactly match the composite product's definition. If the match validation is not successful the auto execution simply won’t work. Note Regardless of the level, if the worker tries to avoid the control and tries to execute/finish a kit/dekit line when there is a difference between the actual executed quantity of the components and their definition – it won’t be allowed by the system. It will show an error screen containing more details about where the problem is. The only exception of this rule is the “Finish incomplete” button of level 40."
  },
  "modules/logistics/wms/composite-products/index.html": {
    "href": "modules/logistics/wms/composite-products/index.html",
    "title": "Composite Products | ERP.net Tech Docs",
    "summary": "Composite Products Composite products are products composed of individual parts or components that may be stored and manipulated separately from one another. Since these components comprise the final distributed and sold product, their full set is treated as a single product and must be managed accordingly. This is very common in the furniture industry, where a single wardrobe can be stored in 3 separate boxes (components). In these cases: we are selling the final product (the wardrobe) the availability in the inventory module is also by final product (the wardrobe). Because the sales persons need to know how many wardrobes are available in order to know how much they can sell but the availability in the WMS module is by components – because in fact, the warehouse workers have to pick and dispatch all of the wardrobe components to the client The difference between ordinary Products, Composite Products, and Composite Product Components Ordinary Products - are sold and stored in their entirety. They are not stored in separate parts and accordingly, there are no defined Composite Product Components for them. Composite Products - are products that are sold in their entirety, but are stored as separate components (packages). Composite Product Components - are the separate parts (packages) in which the Composite Product is stored. How to create Composite Products? Composite Products are ordinary products that have defined components for them. In other words, when there is at least one active Composite Product Component that is defined for an ordinary product, then this Product is considered a Composite Product. Note Only products which are not using Variable Measurement Ratios can be defined as composite products. Component Product Components are ordinary products as well. They become components once they are set as a Composite Product Component for another product. It is not necessary each individual part to be defined as a separate component. Components are rather the packages of parts that are necessary to assemble 1 unit of the final product. For example - wardrobe doors, their handles and screws should be defined as 1 component if they are packed in the same (1) carton box. How do you create a Composite Product then – here is an example: Create a new Product. This will be your composite product, which you are going to be selling to the customers. Create a new Product for all of the composite product‘s components / packages. Add the Products created in step 2 in the Components panel of the Product created in step 1. Make sure that you specify the Quantity, as this is the number of packages of this component that are needed to compose the product. Further reading Working with Composite Products Levels of control for Composite Products"
  },
  "modules/logistics/wms/composite-products/working-with-composite-products.html": {
    "href": "modules/logistics/wms/composite-products/working-with-composite-products.html",
    "title": "Working with Composite Products | ERP.net Tech Docs",
    "summary": "Working with Composite Products Composite Products are usually sold and purchased in their entirety but are stored as separate components (boxes) in the warehouse. Selling a composite product We already set up our composite product definition, following the steps in the How to create Composite Products section. Now, let's imagine that we have a customer who wants to buy it, to buy a wardrobe. We are creating a Sales Order for 1 wardrobe. The Sales Order document flow generates a Store Order, which is the link to the WMS module. It generates an Outbound Warehouse Requisition that informs the WMS module that it needs to dispatch 1 wardrobe. The Warehouse Requisition creates an Outbound Warehouse Order but the WMS, and more precisely the LOG0502 generation procedure, recognizes that the product is, in fact, a composite product. For this reason, the requisition line is broken down into two types of lines: Dispatch (comp) – a component dispatch line for each one of the composite product’s components Kit – and a kit line for the composite product itself These lines are then executed by the warehouse workers using the WMS Worker app. Dispatch (comp) lines are executed as usual for dispatch operations. Kit line is executed after the Dispatch (comp) lines. It is used for fulfilling the parent (requisition) line and performing a control. How the control is performed depends on the specified level of control. For more information, see Levels of control for composite products . Once the Warehouse Order has been finished the execution information is returned to the Inventory module (the Store Order). Then the Inventory module creates a Store Transaction for the dispatch composite product and the flow continues as normal (as it would for an ordinary product). Purchasing a composite product The principles for purchasing a composite product are very similar to the principles for buying one. We are creating a procurement document for 1 wardrobe. This document could be a Requisition, Purchase Order, or Receiving Order depending on the company's usual process. The procurement document flow generates a Store Order, which is the link to the WMS module. It generates an Inbound Warehouse Requisition that informs the WMS module that it needs to receive 1 wardrobe. The Warehouse Requisition creates an Inbound Warehouse Order but the WMS, and more precisely the LOG0502 generation procedure, recognizes that the product is, in fact, a composite product (LOG0502). For this reason, the requisition line is broken down into two types of lines: Receive (comp) – a component receive line for each one of the composite product’s components Dekit – and a dekit line for the composite product itself These lines are then executed by the warehouse workers using the WMS Worker app. Receive (comp) lines are executed as usual for receive operations. Dekit line can be placed before or after the Receive (comp) lines. It is used for fulfilling the parent (requisition) line and performing a control. The position of the Dekit line and how the control is performed depends on the specified level of control. For more information, see Levels of control for composite products ."
  },
  "modules/logistics/wms/gs1-barcodes.html": {
    "href": "modules/logistics/wms/gs1-barcodes.html",
    "title": "| ERP.net Tech Docs",
    "summary": "GS1 Barcodes GS1 barcodes are a type of barcode used in retail and supply chain operations to identify items. They are used in many countries and are based on the international GS1 standard. These barcodes use a list of different application identifiers (AI) to encode additional data into the barcode such as quantity, lot, expiration date, serial number, and other attributes. ERP.net supports GS1 Barcodes and recognizes a number of GS1 application identifiers using different Barcode Parsers. For more information, about the supported AI and their implementation, see the documentation of the specific parser: P02: GS1 - Single Product P03: GS1 - SSCC"
  },
  "modules/logistics/wms/how-it-works/barcode-parsers/index.html": {
    "href": "modules/logistics/wms/how-it-works/barcode-parsers/index.html",
    "title": "Barcode Parsers | ERP.net Tech Docs",
    "summary": "Barcode Parsers Barcode parsers are used to read and interpret different barcodes by the Scan field in the Order Lines menu in the WMS Worker app. Their algorithm analyzes the barcodes and extracts the encoded data in them. The extracted data is then used by the WMS Worker app to easily find a suitable Warehouse Order Line and start its execution. How the barcode is recognized, how a suitable line is found, and how its execution is started depends on the action of the particular parser. NOTE: The list of the active parsers can be found in the Question mark button in the Scan field of the Order Lines screen in the WMS Worker app. Their order in this list also shows their application order during the barcode reading. Currently, all available parsers are enabled by default. They cannot be disabled and their application order cannot be changed. Here is a list of the available parsers: P01: Product Code P02: GS1 - Single Product P03: GS1 - SSCC P04:LUN Serial Code P05:Warehouse Location P06:Quantity"
  },
  "modules/logistics/wms/how-it-works/barcode-parsers/p01.html": {
    "href": "modules/logistics/wms/how-it-works/barcode-parsers/p01.html",
    "title": "| ERP.net Tech Docs",
    "summary": "P01: Product Code parser This parser recognizes product part numbers and additional product codes. Once triggered, the parser tries to find a product with the string specified in the barcode. If it finds a product, then it searches for an unexecuted Warehouse Order Line with this product. If there is a such line – it starts its execution. If not – it moves to the next active parser. A detailed description of the parser’s action: Try to find a product with the same Part Number as the scanned barcode. If the search is successful, then go to step 3. Else go to step 2. Try to find a Product with the same additional Product Code as the scanned barcode. If the search is successful, then go to step 3. Else go to step 5. Search for an unexecuted Warehouse Order Line with the recognized product. If there is a such line, go to step 4. Else go to step 5. Automatically start the line execution of the best matching line. Move to the next active parser."
  },
  "modules/logistics/wms/how-it-works/barcode-parsers/p02.html": {
    "href": "modules/logistics/wms/how-it-works/barcode-parsers/p02.html",
    "title": "| ERP.net Tech Docs",
    "summary": "P02: GS1 - Single Product parser This parser uses some of the most popular GS1 identifiers to recognize the product and the additional information that comes with it and is also encoded into the barcode. A list of the identifiers that are recognized by this parser: Identifier Description Length (01) Global Trade Item Number (GTIN) 14 (02) Global Trade Item Number (GTIN) of contained trade items 14 (10) Lot number variable, up to 20 (17) Expiration date (YYMMDD) 6 (20) Product variant 2 (21) Serial number variable, up to 20 (37) Count of trade items variable, up to 8 Once triggered, the parser tries to break the GS1 barcode into separate parts to extract the information encoded in it. If there are no errors during this operation, it starts looking for an appropriate line that can be executed with the recognized information. When it finds the best matching line, it starts its execution. If the information is enough to fulfill the line, then the system will not ask the user for anything and will automatically execute the line. If there is missing information, then it will show the respective screens so the user can fill it in. If there is no matching line – it throws an error message and stops the execution. Specifics and optimizations during the line execution: If there is a specified Location in the line and there is no warehouse policy that requires scanning it – then the line is executed automatically with the specified location. If the barcode contains a Lot information, the Lot is not yet created into the database and the matching line is with Receive or Component Receive task type - then the Lot is automatically created by the system. If there is an Expiry Date in the barcode, then this information is written into the new Lot definition as well. If the barcode contains Serial Number information, the Serial Number is not yet created into the database and the matching line is with Receive or Component Receive task type - then the Serial Number is automatically created by the system. If the barcode contains information about the Count of trade items, then the line is executed with the specified Quantity in it. As a Measurement Unit is considered the Default Measurement System of the Coding System that was used to recognize the product. If none, then the Default Measurement Unit of the Product is taken. A detailed description of the parser’s action: If the barcode starts with “(“ OR it starts with “01 or 02 and the scanned barcode length is = 16 symbols”, then go to step 2. Else, go to step 10. Brake the barcode into segments. If the barcode starts with “(“ it is broken down directly, else it is parsed to a barcode with () segments. The recognized identifiers are specified in the table above, all other identifiers are ignored. Go to step 3. Make segment validations. The barcode must contain one of the segments (01) or (02) It must not contain both segments (01) and (02) at the same time. If it contains segment (37) it must contain segment (02) as well If all validations are successful, go to step 4. Else, throw an error message and stop. Try to find a product with the same Part Number or additional Product Code as the scanned barcode. If the search is unsuccessful, then throw \"Product not found.\". Else go to step 5. Extract the data from the rest of the recognized identifiers – for Lot, Expiry Date, Serial Number…. Go to step 6. Validate the extracted data If it contains a Lot segment. Check if there is a Lot with this Lot Number for the particular Product. If no Lot is found, but the line task type of the line is Receive or Component Receive, then the Lot will be created automatically during the line Execution. Else, throw \"No lot was found for product\" and stop. If it contains a Variant segment. Check if there is a Variant with this Short Code for the particular Product. If no Variant is found, throw \"No variant was found for product\" and stop. If it contains a Serial Number segment. Check if there is a Serial Number with this Code for the particular Product. If no Serial Number is found but the line task type of the line is Receive or Component Receive, then the Serial Number will be created automatically during the line Execution. Else, throw \"No serial was found for product\" and stop. If all validations are successful, go to step 7. Search for an unexecuted Warehouse Order Line that can be fulfilled with the extracted information. If there is a such line, go to step 8. Else, throw \"No unexecuted line found that matches the scanned data.\" and stop. Automatically start the line execution of the best matching line with the data extracted from the barcode. If the Warehouse Order Line contains a Location AND the applicable warehouse policy “RequireResourseScan != true”, then the line will be automatically executed with the specified location. If the information is enough to fulfill the line, then the system will not ask the user for anything and will automatically execute the line. If there is missing information, e.g. for Quantity, then it will show the corresponding screens so that the user can fill it in. If the barcode contains segment (37) and not all quantity was exhausted by the first line, then start the execution of the next matching line. When finished, move to step 9. Return to the lines menu. Move to the next active parser."
  },
  "modules/logistics/wms/how-it-works/barcode-parsers/p03.html": {
    "href": "modules/logistics/wms/how-it-works/barcode-parsers/p03.html",
    "title": "| ERP.net Tech Docs",
    "summary": "P03: GS1 – SSCC parser This parser is used for executing the Warehouse Order lines with the contents of a Logistic Unit (LU). It is especially useful during the receiving process when the information of the LU's content is pre-received in an Advance Ship Notice (ASN). This way you can create the LU's definitions with their SSCC codes and content information and advance. This would speed up the receiving process significantly, as the worker only needs to scan the barcode upon receipt and the program will automatically find and execute the appropriate order lines. The LU recognition is performed using the GS1 SSCC code and the (00) identifier. Once triggered, the parser looks for an active LU with the same Serial Code as the scanned barcode. If there is such LU the parser tries to automatically execute the Warehouse Orders lines with the content of the scanned LU. Specifics and optimizations during the line execution: If the lines' task type is Receive, then check if the LU is not yet received. This check prevents us from mistakenly scanning the same LU more than once during the receiving process. If there is a specified Location in all best matching lines and there is no warehouse policy that requires scanning it – then the line is executed automatically with the specified location. If not all LU contents have a matching line in the current Warehouse Order, then the system will stop the execution and will throw an error message and will stop the execution. A detailed description of the parser’s action: If the barcode starts with “(00)“ OR it starts with “00 and the scanned barcode length is = 20 symbols”, then go to step 2. Else, go to step 10. Try to find a Logistic Unit (LU) with the same Serial Number as the scanned barcode. If a LU is found, then go to step 3. Else, throw „SSCC not found. Before scanning, first define the logistic unit.“ and stop. Get the Logistic Unit’s Contents. Go to step 4. Check if any of the Content has a LogisticUnitContent.LotNumber and LogisticUnitContent.Lot is empty, then check if there is a Lot in the database for which Product = LogisticUnitContent.Product and Number = LogisticUnitContent.LotNumber. If there is no such record, throw \"No lot '{ LogisticUnitContent.LotNumber }' was found for product '{ LogisticUnitContent.Product}'.\" and stop. Else, go to step 5. Search for matching unexecuted Warehouse Order Lines that can be fulfilled with the LU contents information. Go to step 6. Check if there is a matching Warehouse Order line for all of the LU contents. If all Contents have a match, go to step 7. Else, throw \"The lines of the order do not correspond to line {Content-a който няма match.LineNo} of the logistic unit.\" and stop. Check if the unexecuted Quantity of the matching Warehouse Order lines is enough to fulfill the LU contents. If it is enough, go to step 8. Else, throw \"The quantity of the content is more than the remaining quantity of the lines.\" and stop. Automatically start the line execution of the best matching lines with the extracted LU contents. If all best-matching Warehouse Order Lines contain the same Location AND the applicable warehouse policy “RequireResourseScan != true”, then the line will be automatically executed with the specified location. Go to step 9. Refresh the lines menu. Move to the next active parser."
  },
  "modules/logistics/wms/how-it-works/index.html": {
    "href": "modules/logistics/wms/how-it-works/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Barcode Parsers Component Dispatch task type Component Receive task type Count task type Dekit task type Dispatch task type Kit task type Move task type Pack task type Recalculate quantities in the WMS Worker Receive task type Task types Unpack task type User task - task type Using the SCAN field in WMS worker"
  },
  "modules/logistics/wms/how-it-works/recalculate-quantities.html": {
    "href": "modules/logistics/wms/how-it-works/recalculate-quantities.html",
    "title": "Recalculate quantities in the WMS Worker | ERP.net Tech Docs",
    "summary": "Recalculate quantities in the WMS Worker If a product has a defined additional coding system with a default base measurement category, it is possible to recalculate the product's quantities when scanning in the WMS Worker app. For example: You have an order which contains dozens of pcs of coffee which arrive in a box with its own unique code. The box is defined for the coffee as a coding system and has a default base measurement category of 20 pcs. You will be able to instantly execute 20 pcs of coffee with a single scan of the box's product code. This overrides the product's own default unit. If no measurement category is set, the product will still be recognized but its default unit (e.g. 1pcs) will be taken into account instead. Prerequisites Make sure your product has a defined coding system. You can find a list of all coding systems and create new ones on-demand in the Web Client. Use the WMS Worker App to start an order and scan the product code of the coding system of the product(s). How it works Assuming your order consists of a box with several instances of products, you can scan their coding system's product code right away. Within the SCAN field, provide the respective code, or use your mobile device to scan the barcode of the box. The standard Quantity step will be skipped and you will only need to select a lot. You will get an auto-suggested product quantity based on the provided measurement unit of the coding system. Tap Next to confirm the operation. Several or all pcs of your product will be executed instantly. Note You can multiply a coding system's code just like a regular product unit. For instance, if the coding system has a default measurement unit of 25pcs, multiplying it by 4 will give you 100pcs of the product ready to be scanned in one-go. *The attached screenshots are from version 24."
  },
  "modules/logistics/wms/how-it-works/scan-field.html": {
    "href": "modules/logistics/wms/how-it-works/scan-field.html",
    "title": "Using the SCAN field in WMS worker | ERP.net Tech Docs",
    "summary": "Using the SCAN field in WMS worker The SCAN field in the Warehouse Order Lines menu of the WMS Worker app allows you to scan and recognize various types of Barcode Parsers. How to use it: Depending on the Config options settings, the system can automatically enter a quantity of one pce for the product when scanned or when the product code is entered, and it will skip the Quantity screen. The SCAN field also provides a quick option for entering or scanning larger quantities of the selected product. Simply enter the total quantity and press \"OK\" or \"Enter,\" after which you can scan the product's barcode or enter the product code. In this way, the Quantity screen will not be displayed. You can even sum up sequentially entered quantities for a single product. Example: If you expect to receive 25 units of the product \"Robusta Coffee 250 g\" for Inbound Warehouse Order 0000000041, you can enter \"5 OK/Enter\" and then \"10 OK/Enter.\" The system will automatically sum the quantities, and you can scan the product's barcode or enter the product code and confirm with \"OK/Enter.\" This results in a total of 15 executed units out of the expected 25. Note For quantities up to 999, simply enter the digit and press \"OK/Enter,\" while for quantities above 1000, add \"*\" after the digit and then press \"OK/Enter."
  },
  "modules/logistics/wms/how-it-works/task-types/comp-dispatch.html": {
    "href": "modules/logistics/wms/how-it-works/task-types/comp-dispatch.html",
    "title": "Component Dispatch task type | ERP.net Tech Docs",
    "summary": "Component Dispatch task type The Component Dispatch task type is used when working with Composite Products. Its purpose is to issue the composite product's components from the warehouse. It can usually be seen in Warehouse Order Lines that are a result of the document generation of the sales order document flow when it contains composite products. Result The Component Dispatch lines do NOT create Document Fulfillments, as they represent the dispatching of 1 component of a whole kit. The fulfillment is trigerred by the dispatching of the whole kit and it is performed trough the Kit task type line. When executed, the system creates only a Warehouse Transaction, as follows: WarehouseOrder = WarehouseOrderLine.WarehouseOrder WarehouseOrderLine = WarehouseOrderLine TaskType = ComponentDispatch Direction = OUT ManagedWarehouse = WarehouseOrderLine.WarehouseOrder.ManagedWarehouse ManagedWarehouseLocation = the Warehouse Location specified during the line execution LogisticUnit = the LogisticUnit specified during the line execution Product = the Product specified during the line execution ProductVariant = the Variant specified during the line execution Lot = the Lot specified during the line execution SerialNumber = the SerialNumber specified during the line execution Quantity = the Quantity specified during the line execution QuantityUnit = the QuantityUnit specified during the line execution QuantityBase = the QuantityBase specified during the line execution StandardQuantity = If Product.AllowVariableMeasurementRatios == true, then get QuantityBase, else CONVERT(Qauntity, BaseMeasurementUnit) CreationUser = CurrentUser CreationTimeUtc = NOW(Utc)"
  },
  "modules/logistics/wms/how-it-works/task-types/comp-receive.html": {
    "href": "modules/logistics/wms/how-it-works/task-types/comp-receive.html",
    "title": "Component Receive task type | ERP.net Tech Docs",
    "summary": "Component Receive task type The Component Receive task type is used when working with Composite Products. Its purpose is to receipt the composite product's components into the warehouse. It can usually be seen in Warehouse Order Lines that are a result of the document generation of the procurement document flow when it contains composite products. Result The Component Receive lines do NOT create Document Fulfillments, as they represent the receiving of 1 component of a whole kit. The fulfillment is trigerred by the receiving of the whole kit and it is performed trough the Dekit task type line. When executed, the system creates only a Warehouse Transaction, as follows: WarehouseOrder = WarehouseOrderLine.WarehouseOrder WarehouseOrderLine = WarehouseOrderLine TaskType = ComponentReceive Direction = IN ManagedWarehouse = WarehouseOrderLine.WarehouseOrder.ManagedWarehouse ManagedWarehouseLocation = the Warehouse Location specified during the line execution LogisticUnit = the LogisticUnit specified during the line execution Product = the Product specified during the line execution ProductVariant = the Variant specified during the line execution Lot = the Lot specified during the line execution SerialNumber = the SerialNumber specified during the line execution Quantity = the Quantity specified during the line execution QuantityUnit = the QuantityUnit specified during the line execution QuantityBase = the QuantityBase specified during the line execution StandardQuantity = If Product.AllowVariableMeasurementRatios == true, then get QuantityBase, else CONVERT(Qauntity, BaseMeasurementUnit) CreationUser = CurrentUser CreationTimeUtc = NOW(Utc)"
  },
  "modules/logistics/wms/how-it-works/task-types/count.html": {
    "href": "modules/logistics/wms/how-it-works/task-types/count.html",
    "title": "Count task type | ERP.net Tech Docs",
    "summary": "Count task type Count task types are used for warehouse reconciliation. The reconciliation is performed as an ad hoc (single) operation using the Reconcile menu of WMS Worker. Result As a result the reconciliation generates Warehouse Transaction with Count task type. The Warehouse Transaction can be with IN or OUT direction, depending on the difference between the avalability before and after the reconciliation.If the counted quantity is exactly the available quantity for this reconciled operation, then the warehouse transaction will be entered in the direction IN with zero quantity. This is useful for checking the reconciled results. Note If the counted product uses varible measurement ratios, then Warehouse Transaction will be created in the default Measurement Unit of the product, instead of the Base Unit. This is needed, because the variable quantity measured during the reconciliation could be (and ususally is) different from the standard measurement ratios. But but this is a contradiction to the rule that Quantity and Standard Quantity values must always follow the measurement rations. For this reason, the Quantity is converted to the default Measurement Unit of the product."
  },
  "modules/logistics/wms/how-it-works/task-types/dekit.html": {
    "href": "modules/logistics/wms/how-it-works/task-types/dekit.html",
    "title": "Dekit task type | ERP.net Tech Docs",
    "summary": "Dekit task type The Dekit task type is used when working with Composite Products. It can usually be seen in Warehouse Order Lines that are a result of the document generation of the procurement document flow when it contains composite products. The purpose of the Dekit task type is to report the dekitting (receiving) of the composite product to the parent line and to carry out control. The Dekit task type lines do NOT create Warehouse Transactions, as the availability of the composite product itself is kept in the Inventory module. Though, the Dekit line's purpose is very important because it creates DocumentFulfillments to the parent line. With this, it informs it that all components of the composite product are received and therefore the parent line is fullfilled. The control during the dekitting process depends on the specified level. For more information, see Levels of control for composite products. The Warehouse Order Lines with Dekit task type can be executed using the WMS Worker or the Execute lines function. Note that Dekit lines can only be executed after all of its components' receive lines have completed execution. Result The Dekit task type lines do NOT create Warehouse Transaction, as the availability of the composite product is kept in the Inventory module. It creates only a DocumentFulfillment, as follows: Document = WarehouseOrder DocumentLineId = WarehouseOrderLineId LineNo = WarehouseOrderLine.LineNo FulfillmentType = Completed IsFinal = false LineType = Line QuantityBase = WarehouseOrder.QuantityBase StandardQuantity = WarehouseOrder.StandardQuantity Product = WarehouseOrder.Product Lot = WarehouseOrder.Lot SerialNumber = WarehouseOrder.SerialNumber ProductVariant = WarehouseOrder.ProductVariant CreationUser = CurrentUser CreationTimeUtc = NOW(Utc) DestinationEntityName = n/a"
  },
  "modules/logistics/wms/how-it-works/task-types/dispatch.html": {
    "href": "modules/logistics/wms/how-it-works/task-types/dispatch.html",
    "title": "Dispatch task type | ERP.net Tech Docs",
    "summary": "Dispatch task type The Dispatch task type's purpose is to issue goods from the warehouse. It is usually used in Warehouse Order Lines that are a result of the document generation of the sales order document flow. The Warehouse Order Lines with Dispatch task type can be executed using the the Orders menu in WMS Worker or the Execute lines function of the Warehouse Order. Result When executed, the system creates 1 Warehouse Transaction and 1 Document Fulfillment as follows: Warehouse Transactions WarehouseOrder = WarehouseOrderLine.WarehouseOrder WarehouseOrderLine = WarehouseOrderLine TaskType = Dispatch Direction = OUT ManagedWarehouse = WarehouseOrderLine.WarehouseOrder.ManagedWarehouse ManagedWarehouseLocation = the Warehouse Location specified during the line execution LogisticUnit = the LogisticUnit specified during the line execution Product = the Product specified during the line execution ProductVariant = the Variant specified during the line execution Lot = the Lot specified during the line execution SerialNumber = the SerialNumber specified during the line execution Quantity = the Quantity specified during the line execution QuantityUnit = the QuantityUnit specified during the line execution QuantityBase = the QuantityBase specified during the line execution StandardQuantity = If Product.AllowVariableMeasurementRatios == true, then get QuantityBase, else CONVERT(Qauntity, BaseMeasurementUnit) CreationUser = CurrentUser CreationTimeUtc = NOW(Utc) Document Fulfillment Document = WarehouseOrder DocumentLineId = WarehouseOrderLineId LineNo = WarehouseOrderLine.LineNo FulfillmentType = Completed IsFinal = false LineType = Line Product = the Product specified during the line execution ProductVariant = the Variant specified during the line execution Lot = the Lot specified during the line execution SerialNumber = the SerialNumber specified during the line execution QuantityBase = the QuantityBase specified during the line execution StandardQuantity = If Product.AllowVariableMeasurementRatios == true, then get QuantityBase, else CONVERT(Quantity, BaseMeasurementUnit) CreationUser = CurrentUser CreationTimeUtc = NOW(Utc) DestinationEntityName = Wms_Warehouse_Transactions"
  },
  "modules/logistics/wms/how-it-works/task-types/index.html": {
    "href": "modules/logistics/wms/how-it-works/task-types/index.html",
    "title": "Task types | ERP.net Tech Docs",
    "summary": "Task types Task types define the type of the operation (task), which should be performed. E.g. receiving goods, moving products from one location to another, reconciliation and oth. Depending on the task type, the system will guide the user through specific screens and will process the results of the work done in the appropriate way for the task. Мore about the details of the different task types, you can see in topics: Component Dispatch task type Component Receive task type Count task type Dekit task type Dispatch task type Kit task type Move task type Pack task type Receive task type Unpack task type User task - task type"
  },
  "modules/logistics/wms/how-it-works/task-types/kit.html": {
    "href": "modules/logistics/wms/how-it-works/task-types/kit.html",
    "title": "Kit task type | ERP.net Tech Docs",
    "summary": "Kit task type The Kit task type is used when working with Composite Products. It can usually be seen in Warehouse Order Lines that are a result of the document generation of the sales order document flow when it contains composite products. The purpose of the Kit task type is to report the kitting (dispatching) of the composite product to the parent line and to carry out control. The Kit task type lines do NOT create Warehouse Transactions, as the availability of the composite product itself is kept in the Inventory module. Though, the Kit line's purpose is very important because it creates DocumentFulfillments to the parent line. With this, it informs it that all components of the composite product's kit are dispatched and therefore the parent line is fullfilled. The control during the kitting process depends on the specified level. For more information, see Levels of control for composite products. The Warehouse Order Lines with Kit task type can be executed using the WMS Worker or the Execute lines function. Note that Kit lines can only be executed after all of its components' dispatch lines have completed execution. Result The Kit task type lines do NOT create Warehouse Transaction, as the availability of the composite product is kept in the Inventory module. It creates only a DocumentFulfillment, as follows: Document = WarehouseOrder DocumentLineId = WarehouseOrderLineId LineNo = WarehouseOrderLine.LineNo FulfillmentType = Completed IsFinal = false LineType = Line QuantityBase = WarehouseOrder.QuantityBase StandardQuantity = WarehouseOrder.StandardQuantity Product = WarehouseOrder.Product Lot = WarehouseOrder.Lot SerialNumber = WarehouseOrder.SerialNumber ProductVariant = WarehouseOrder.ProductVariant CreationUser = CurrentUser CreationTimeUtc = NOW(Utc) DestinationEntityName = n/a"
  },
  "modules/logistics/wms/how-it-works/task-types/move.html": {
    "href": "modules/logistics/wms/how-it-works/task-types/move.html",
    "title": "Move task type | ERP.net Tech Docs",
    "summary": "Move task type Move task type's purpose is to move goods from one warehouse location to another location within the same warehouse. The moving can be done as an ad hoc operation or can be performed as a part of a Warehouse Order. As an ad hoc (single) operation it is performed using the Move menu of WMS Worker. While Warehouse Order Lines with Move task type can be executed using the Orders menu in WMS Worker or the Execute lines function of the Warehouse Order. Result The moving results in creating 2 Warehouse Transaction - 1 for the goods issue of the previous location and 1 for the goods receipt into the destination location. A Document Fulfillment will be created as well, but only if the moving is performed trough executing a Warehouse Order Line. The Warehouse Transactions and the Document Fulfillment are created as follows: Warehouse Transactions WarehouseTransaction1 for the goods issue WarehouseOrder = if it is an ad hoch operation, then NULL, else WarehouseOrderLine.WarehouseOrder WarehouseOrderLine = if it is an ad hoch operation, then NULL, else WarehouseOrderLine TaskType = Move Direction = OUT ManagedWarehouse = WarehouseOrderLine.WarehouseOrder.ManagedWarehouse ManagedWarehouseLocation = the Warehouse Location specified during the line execution LogisticUnit = the LogisticUnit specified during the line execution Product = the Product specified during the line execution ProductVariant = the Variant specified during the line execution Lot = the Lot specified during the line execution SerialNumber = the SerialNumber specified during the line execution Quantity = the Quantity specified during the line execution QuantityUnit = the QuantityUnit specified during the line execution QuantityBase = the QuantityBase specified during the line execution StandardQuantity = If Product.AllowVariableMeasurementRatios == true, then get QuantityBase, else CONVERT(Qauntity, BaseMeasurementUnit) CreationUser = CurrentUser CreationTimeUtc = NOW(Utc) WarehouseTransaction2 for the goods receipt WarehouseOrder = if it is an ad hoch operation, then NULL, else WarehouseOrderLine.WarehouseOrder WarehouseOrderLine = if it is an ad hoch operation, then NULL, else WarehouseOrderLine TaskType = Move Direction = IN ManagedWarehouse = WarehouseOrderLine.WarehouseOrder.ManagedWarehouse ManagedWarehouseLocation = ManagedWarehouseLocation = the Destination Location set during the line execution LogisticUnit = the LogisticUnit specified during the line execution Product = the Product specified during the line execution ProductVariant = the Variant specified during the line execution Lot = the Lot specified during the line execution SerialNumber = the SerialNumber specified during the line execution Quantity = the Quantity specified during the line execution QuantityUnit = the QuantityUnit specified during the line execution QuantityBase = the QuantityBase specified during the line execution StandardQuantity = If Product.AllowVariableMeasurementRatios == true, then get QuantityBase, else CONVERT(Qauntity, BaseMeasurementUnit) CreationUser = CurrentUser CreationTimeUtc = NOW(Utc) Document Fulfillment Document = WarehouseOrder DocumentLineId = WarehouseOrderLineId LineNo = WarehouseOrderLine.LineNo FulfillmentType = Completed IsFinal = false LineType = Line Product = the Product specified during the line execution ProductVariant = the Variant specified during the line execution Lot = the Lot specified during the line execution SerialNumber = the SerialNumber specified during the line execution QuantityBase = the QuantityBase specified during the line execution StandardQuantity = If Product.AllowVariableMeasurementRatios == true, then get QuantityBase, else CONVERT(Qauntity, BaseMeasurementUnit) CreationUser = CurrentUser CreationTimeUtc = NOW(Utc) DestinationEntityName = Wms_Warehouse_Transactions"
  },
  "modules/logistics/wms/how-it-works/task-types/pack.html": {
    "href": "modules/logistics/wms/how-it-works/task-types/pack.html",
    "title": "Pack task type | ERP.net Tech Docs",
    "summary": "Pack task type Pack task type's purpose is to add Contents to a Logistic Unit (LU) and respectively to create new LUs. The packing is performed as an ad hoc operation using the Pack menu of WMS Worker. Result The packing results in creating 2 Warehouse Transaction for each line of the LU's Contents. The first Warehouse Transaction is needed to issue of content before it was a part of a LU. The second performs the receipt of the content as a part of the LU. WarehouseTransaction1 for the issue of the content before it was a part of a LU: WarehouseOrder = NULL WarehouseOrderLine = NULL TaskType = Pack Direction = OUT ManagedWarehouse = the current Warehouse ManagedWarehouseLocation = the Warehouse Location specified during the packing LogisticUnit = NULL Product = the Product specified during the packing ProductVariant = the Variant specified during the packing Lot = the Lot specified during the packing SerialNumber = the SerialNumber specified during the packing Quantity = the Quantity specified during the packing QuantityUnit = the QuantityUnit specified during the packing QuantityBase = the QuantityBase specified during the packing StandardQuantity = If Product.AllowVariableMeasurementRatios == true, then get QuantityBase, else CONVERT(Qauntity, BaseMeasurementUnit) CreationUser = CurrentUser CreationTimeUtc = NOW(Utc) WarehouseTransaction2 for the receipt of the content as a part of the LU: WarehouseOrder = NULL WarehouseOrderLine = NULL TaskType = Pack Direction = IN ManagedWarehouse = the current Warehouse ManagedWarehouseLocation = the Destination location specified during the packing LogisticUnit = the LU specified or created during the packing Product = the Product specified during the packing ProductVariant = the Variant specified during the packing Lot = the Lot specified during the packing SerialNumber = the SerialNumber specified during the packing Quantity = the Quantity specified during the packing QuantityUnit = the QuantityUnit specified during the packing QuantityBase = the QuantityBase specified during the packing StandardQuantity = If Product.AllowVariableMeasurementRatios == true, then get QuantityBase, else CONVERT(Qauntity, BaseMeasurementUnit) CreationUser = CurrentUser CreationTimeUtc = NOW(Utc)"
  },
  "modules/logistics/wms/how-it-works/task-types/receive.html": {
    "href": "modules/logistics/wms/how-it-works/task-types/receive.html",
    "title": "Receive task type | ERP.net Tech Docs",
    "summary": "Receive task type Receive task type's purpose is to receipt new goods into the warehouse. It is usually used in Warehouse Order Lines that are a result of the document generation of the procurement document flow. The Warehouse Order Lines with Receive task type can be executed using the WMS Worker or the Execute lines function. Result When executed, the system creates 1 Warehouse Transaction and 1 Document Fulfillment as follows: Warehouse Transactions WarehouseOrder = WarehouseOrderLine.WarehouseOrder WarehouseOrderLine = WarehouseOrderLine TaskType = Receive Direction = IN ManagedWarehouse = WarehouseOrderLine.WarehouseOrder.ManagedWarehouse ManagedWarehouseLocation = the Warehouse Location specified during the line execution LogisticUnit = the LogisticUnit specified during the line execution Product = the Product specified during the line execution ProductVariant = the Variant specified during the line execution Lot = the Lot specified during the line execution SerialNumber = the SerialNumber specified during the line execution Quantity = the Quantity specified during the line execution QuantityUnit = the QuantityUnit specified during the line execution QuantityBase = the QuantityBase specified during the line execution StandardQuantity = If Product.AllowVariableMeasurementRatios == true, then get QuantityBase, else CONVERT(Qauntity, BaseMeasurementUnit) CreationUser = CurrentUser CreationTimeUtc = NOW(Utc) Document Fulfillment Document = WarehouseOrder DocumentLineId = WarehouseOrderLineId LineNo = WarehouseOrderLine.LineNo FulfillmentType = Completed IsFinal = false LineType = Line Product = the Product specified during the line execution ProductVariant = the Variant specified during the line execution Lot = the Lot specified during the line execution SerialNumber = the SerialNumber specified during the line execution QuantityBase = the QuantityBase specified during the line execution StandardQuantity = If Product.AllowVariableMeasurementRatios == true, then get QuantityBase, else CONVERT(Qauntity, BaseMeasurementUnit) CreationUser = CurrentUser CreationTimeUtc = NOW(Utc) DestinationEntityName = Wms_Warehouse_Transactions"
  },
  "modules/logistics/wms/how-it-works/task-types/unpack.html": {
    "href": "modules/logistics/wms/how-it-works/task-types/unpack.html",
    "title": "Unpack task type | ERP.net Tech Docs",
    "summary": "Unpack task type Unack task type's purpose is to unpack the Contents of an Logistic Unit Logistic Unit (LU). The packing is performed as an ad hoc operation using the Unpack menu of WMS Worker. Result The packing results in creating 2 Warehouse Transaction for each line of the LU's availability. The first Warehouse Transaction is needed to issue the products which are no longer the contents of a logistic unit, at the specified destination location. WarehouseTransaction1 for the issue of the content from the LU: WarehouseOrder = NULL WarehouseOrderLine = NULL TaskType = Unpack Direction = OUT ManagedWarehouse = the current Warehouse ManagedWarehouseLocation = the Warehouse Location specified during the unpacking LogisticUnit = the LU specified during the unpacking Product = the available Product ProductVariant = the available Variant Lot = the available Lot SerialNumber = the available SerialNumber Quantity = QuantityBaseAvailable QuantityUnit = BaseUnit QuantityBase = QuantityBaseAvailable StandardQuantity = StandardQuantityAvailable CreationUser = CurrentUser CreationTimeUtc = NOW(Utc) WarehouseTransaction2 for the receipt the products that are no longer a part of the LU: WarehouseOrder = NULL WarehouseOrderLine = NULL TaskType = Unpack Direction = IN ManagedWarehouse = the current Warehouse ManagedWarehouseLocation = the Destination location specified during the unpacking LogisticUnit = NULL Product = the available Product ProductVariant = the available Variant Lot = the available Lot SerialNumber = the available SerialNumber Quantity = QuantityBaseAvailable QuantityUnit = BaseUnit QuantityBase = QuantityBaseAvailable StandardQuantity = StandardQuantityAvailable CreationUser = CurrentUser CreationTimeUtc = NOW(Utc)"
  },
  "modules/logistics/wms/how-it-works/task-types/user-task.html": {
    "href": "modules/logistics/wms/how-it-works/task-types/user-task.html",
    "title": "User task - task type | ERP.net Tech Docs",
    "summary": "User task - task type A user task is a task (work) that needs to be done by a human actor (the worker). When the process arrives at such task, the process execution stops and the application displays a text that guides the user of what needs to be done for this task. The text to be displayed must be indicated in advance in the Notes field of the particular Warehouse Order Line. Once the users (workers) have completed the execution of this task, they have to manually confirm that the job is completed. When the task is confirmed as completed, the process continues to the next task that needs to be done (if any). Result When executed, the warehouse order lines with a 'User task' task type create a finished Document Fulfillment. If there is atleast one document fulfillment for this line, then the user task is considered as completed."
  },
  "modules/logistics/wms/how-to/assign-worker.html": {
    "href": "modules/logistics/wms/how-to/assign-worker.html",
    "title": "Assign worker | ERP.net Tech Docs",
    "summary": "Assign worker The Assign worker UI function allows setting a worker responsible for a task in a warehouse order document. Note This function is accessible only for Warehouse Orders in a state lower than Released. If the current document is Released, you can change the worker by using the Change Worker UI function. Step-by-step guide Open a warehouse order in a state New, Planned or Firm planned. Click on the Run button and choose Assign worker. This action triggers a dropdown list of available warehouse workers. The displayed workers are filtered based on the warehouse selected in the document. Select the preferred worker from the dropdown list and confirm your choice by clicking OK. This executes the function. After refreshing the document, the Warehouse Worker field will show the selected worker. Assign multiple workers Using the Multi select UI feature embedded into panels, you can assign workers to multiple warehouse orders simultaneously. This saves time and effort as you don't have to go through each order individually. Navigate to your Warehouse Orders list and choose Multi select from the panel's menu. Select two or more warehouse orders with or without workers assigned. Make sure they are all in a state lower than Released. Then, click the Run button and execute the Assign worker function. Choose a worker to assign and hit OK. The selected worker will be immediately assigned to the respective orders."
  },
  "modules/logistics/wms/how-to/change-worker.html": {
    "href": "modules/logistics/wms/how-to/change-worker.html",
    "title": "Change worker | ERP.net Tech Docs",
    "summary": "Change worker The \"Change worker\" UI function allows changing the worker responsible for a task in a \"Warehouse Order\" document. It’s designed to be used in cases of force majeure, when there is a need to replace the initially chosen warehouse worker with another worker due to unexpected situations (like illness). Upon changing the previous worker, the modified task will no longer be present in his tasks list within the WMS Worker interface. Instead, the task will become visible in the task list of the new worker. Note The function is available only for Warehouse Orders with \"Released\" status. The change is recorded through an adjustment document. How to use it: Open the relevant warehouse order in \"Released\" status that needs reassignment. Click on the \"RUN“ button and choose \"Change worker.\" This action triggers a dropdown list of Warehouse Workers. The displayed workers are filtered based on the warehouse selected in the document. Select the preferred Warehouse Worker from the dropdown list and confirm your choice by clicking \"OK.\" This initiates the function. After refreshing the document, the Warehouse Worker field will show the updated worker, in accordance with the changes made."
  },
  "modules/logistics/wms/how-to/check-can-be-fulfilled.html": {
    "href": "modules/logistics/wms/how-to/check-can-be-fulfilled.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Check if a dispatch order can be fulfilled Planning a dispatch Warehouse Order usually leads to the question “Can this order be fulfilled?” i.e. \"Is there enough availability to dispatch all lines of this order\"? To help you answer this question, we have created a set of three calculated attributes: \"Can Be Fulfilled\" attribute in the Warehouse Order Header Returns “true” if there is enough availability for all lines of the current Warehouse Order. The attribute can be shown in the Warehouse Orders navigator to help guide the planners on which Warehouse Orders require their attention. \"Line Can Be Fulfilled\" attribute in the Warehouse Order Lines Returns “true” if there is enough availability to fulfill the current line. If it returns “false” it means that there is not enough availability and the planner needs to review it and probbaly make some decisions and adjustments before releasing the order – e.g. to select a different lot, to cancel the order, to execute as much as is available and request the rest, etc. \"Available Quantity Base\" attribute in the Warehouse Order Lines Returns the sum of the Available Quantity Base for this line. It takes into account whether there is a particular Warehouse Location, Lot, Serial Number, Variant, or Logistic Unit that is specified in the line and shows the availability according to these criteria. Calculated attributes expression Here is a list with the calculated attribute expressions. Of course, еach attribute can be modified by the implementatior according to the organization's needs. Note You can easily create these attributes in your database by copy-pasting their expression into your database. \"Can Be Fulfilled\" attribute Repository: Logistics.Wms.WarehouseOrders Exp No Operator Parameter1 P1 Value Parameter2 P2 Value Parameter3 P3 Value 10 IIF EXP 20 CONST FALSE CONST TRUE 20 GTE EXP 30 CONST 1 30 COUNT EXP 40 40 FILTER CHILD Lines EXP 50 50 EQUAL ATTRIB #LineCanBeFulfilled CONST FALSE \"Line Can Be Fulfilled\" attribute Repository: Logistics.Wms.WarehouseOrderLines Exp No Operator Parameter1 P1 Value Parameter2 P2 Value Parameter3 P3 Value 10 IIF EXP 20 CONST TRUE CONST FALSE 20 GTE ATTRIB #AvailableQuantityBase ATTRIB QuantityBaseValue \"Available Quantity Base\" attribute Repository: Logistics.Wms.WarehouseOrderLines Exp No Operator Parameter1 P1 Value Parameter2 P2 Value Parameter3 P3 Value 100 SUM EXP 200 ATTRIB QuantityBaseAvailable 200 IIF EXP 210 EXP 300 EXP 230 210 EQUAL EXP 220 CONST NULL 220 GETOBJVALUE INPUT 100 ATTRIB WarehouseLocationId 230 FILTER EXP 300 EXP 240 240 EQUAL ATTRIB WarehouseLocationId EXP 250 250 GETOBJVALUE INPUT 100 ATTRIB WarehouseLocationId 300 IIF EXP 310 EXP 400 EXP 330 310 EQUAL EXP 320 CONST NULL 320 GETOBJVALUE INPUT 100 ATTRIB LotId 330 FILTER EXP 400 EXP 340 340 EQUAL ATTRIB LotId EXP 350 350 GETOBJVALUE INPUT 100 ATTRIB LotId 400 IIF EXP 410 EXP 500 EXP 430 410 EQUAL EXP 420 CONST NULL 420 GETOBJVALUE INPUT 100 ATTRIB SerialNumberId 430 FILTER EXP 500 EXP 440 440 EQUAL ATTRIB SerialNumberId EXP 450 450 GETOBJVALUE INPUT 100 ATTRIB SerialNumberId 500 IIF EXP 510 EXP 600 EXP 530 510 EQUAL EXP 520 CONST NULL 520 GETOBJVALUE INPUT 100 ATTRIB ProductVariantId 530 FILTER EXP 600 EXP 540 540 EQUAL ATTRIB ProductVariantId EXP 550 550 GETOBJVALUE INPUT 100 ATTRIB ProductVariantId 600 IIF EXP 610 EXP 1000 EXP 630 610 EQUAL EXP 620 CONST NULL 620 GETOBJVALUE INPUT 100 ATTRIB LogisticUnitId 630 FILTER EXP 2000 EXP 640 640 EQUAL ATTRIB LogisticUnitId EXP 650 650 GETOBJVALUE INPUT 100 ATTRIB LogisticUnitId 1000 FILTER EXP 2000 EXP 1100 1100 EQUAL ATTRIB ProductId EXP 1200 1200 GETOBJVALUE INPUT 100 ATTRIB ProductId 2000 SELECT REPO Logistics.Wms.WarehouseAvailabilityView EXP 2100 2100 WHERE EXP 2200 EXP 2400 2200 EQUAL ATTRIB ProductId EXP 2300 2300 GETOBJVALUE INPUT 100 ATTRIB ProductId 2400 GT ATTRIB StandardQuantityAvailable CONST 0"
  },
  "modules/logistics/wms/how-to/document-flow.html": {
    "href": "modules/logistics/wms/how-to/document-flow.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Document flow in WMS The link between other modules/processes in the system and the WMS module is performed through the Inventory module. And more precisely, the document that communicates with the WMS module is the Inventory Store Order. The Store Order creates both: the Warehouse Requisition that informs the WMS module what is requested by the other modules/processes; and the Store Transaction, which contains the information on how these requests are actually fulfilled by the WMS module. How set it up? Here is the scheme of the document and execution flow. The flow can be divided into two general phases: generation and execution - steps (1) - (3.1) AND completion - steps (3.2) - (6) Generation and execution phase This phase starts with the release of the Store Order. (1) The Store Order (SO) generates a Warehouse Requisition (WR) using the LOG0205 generation procedure. The Warehouse Requisition is the document that informs the WMS Module what is requested by the other modules/processes. Usually, the Warehouse Requisition is almost an exact copy of the Store Order. The document fulfillment between the SO and WR is calculated using the Fulfillment table method. The generation procedure creates Planned Document Fulfillments (DF), which records how much of the ordered quantity of the SO lines has been fulfilled by WR lines. (2) The WR generates a Warehouse Order (WO) using the LOG0501 or LOG0502 generation procedure, depending on whether the organization uses Composite Products or not. The Warehouse Order is the document that contains the actual plan that needs to be executed by the WMS module. The generation of its lines is the place where all plan optimizations, algorithms, and AI should happen. The document fulfillment between the WR and WO is also calculated using the Fulfillment table method. The generation procedure creates Planned DF, which records how much of the quantity of the WR lines has been fulfilled by WO lines. (3) The released WO loads in the Orders menu of WMS Worker, where it is executed by the warehouse workers using the handheld devices. When a WO line is executed, the system generates 2 real-time records: (3.1) Warehouse Transaction - which updates the availability according to the workers actions (move, dispatch, receive); (3.2) Completed DF - which records how much of the quantity of the WO lines has been fulfilled by the workers and with what details (product, lot, variant). Completion phase This phase practically starts in step (3.2) and more precisely, when the step is fully completed. The completion process is triggered by the warehouse workers but it is usually finished by the person controlling the flow of processes in the warehouse - the warehouse dispatcher or manager. (3.2) When all WO lines are fully executed and have Completed Document Fulfillments, then the WO document can be Completed. Its state is usually changed by the warehouse workers, using the \"Complete order\" button that shows automatically on their devices after the execution of the last order line. (4) Once the WO's state is changed to Completed it brings the fulfillment information (quantity, product, lot, variant) back to the parent WR. The information is brought by generating Completed DF for the WR using the R33563 business rule. Note that, the rule will be triggered only if the \"Complete Parent Fulfillments\" field in the WO's DocumentType is checkmarked. (5) Once the WR's state is changed to Completed it brings the fulfillment information (quantity, product, lot, variant) back to the parent SO. The information is again brough by generating Completed DF for the SO by another rule R32687. Note that, the rule will be again triggered only if the \"Complete Parent Fulfillments\" field in the WR's DocumentType is checkmarked. The WR is usually completed by the warehouse dispatcher or manager. \"When?\" depends on the method of control that has been chosen by the organization: two-stage control - by completing the WR and then completing the SO OR one-stage control - by automatically completing the WR during the completion of the SO If the organization uses two-stage control the warehouse dispatcher or manager can track which WRs are fully executed using the Warehouse Requisition navigator that contains a \"Is Executed* calculated attribute that has been set up in advance. The calculated attribute expressions are added at the end of this topic. Then, the executed documents can be completed using the bulk function \"Change state of selected documents => Completed\" in the same navigator. If the organization uses the one-stage control, the WR is completed in step (5). (6) Once the SO's state is changed to Completed it generates a Store Transaction (ST) using the LOG0207 generation procedure. The ST lines creation is based on the fulfillment information (quantity, product, lot, variant) of the WMS module, which is contained by the parent SO's completed fulfillments. The SO is usually completed by the warehouse dispatcher or manager. He can track which SOs are fully executed by the WMS module using the Store Orders navigator that contains a \"Is Executed* calculated attribute that has been set up in advance. The calculate attribute expressions are added at the end of this topic. If the organization uses two-stage control, the executed SOs are completed using the bulk function \"Change state of selected documents => Completed\" in the Store Orders navigator. If the organization uses the one-stage control, the executed SOs are completed along with their child WR's the bulk function \"Change state of selected documents => Complete with subdocuments\" in the same navigator. Generation for further execution (manual generation only) In Warehouses, it is not always possible to execute all ordered quantities. For instance, there might be insufficient availability of certain products preventing you from Dispatching the entire order. In these cases, you might want to Dispatch what you have now and Dispatch the rest when it becomes available. The same applies if the supplier has sent a less quantity than requested. In such scenarios, you should complete the Warehouse Order with the currently available quantities and when the missing quantities become available you can execute the rest from the same SO using the LOG0209 generation procedure. This action will create a new (WR) for the differences between the ordered quantities in the SO and the quantities already fulfilled. You can initiate this generation whenever a WR is needed for further execution. Once you Create the new WR, the execution process continues following the same logic as the standard WR execution. Note You have to set up this Generation in the Document flow by using only Manually in the Allowed generation types field. Recommended settings for the Document flow and Document Types Document Types: create different Document types for Receipt and Issue Store Order, which are used only for WMS; create different Document types for standard and Further Warehouse Requisitions, separated by movement type; create different Document types for standard and Further Warehouse Orders, separated by movement type; set True to \"Create Fulfillments On Completion\" field in the WR and WO document types - this is required to bring the fulfillments from WO through WR to SO. Store Order Document Flow settings: (1) To set up the creation of Warehouse Requisition some of the fields in the Route should be set as: Process Event - Change of state; Condition States Bit Mask - Released; Procedure Name - LOG0205 Allowed Generation Types - Both (Auto and Manually) Destination State - Released; (2) To set up the creation of Store Transaction the fields in the Route should be set as: Process Event - Change of state; Condition States Bit Mask: - Released, Completed - the completed state is used when you don't want to do any further executions; - Completed Warehouse Requisition - this event is used when you want to generate the Store Transaction automatically when the warehouse requisition state is changed to completed. Allowed Generation Types - Both (Auto and Manually) Procedure Name - LOG0207; (3) To set up the creation of Warehouse Requisition for Further Execution some of the fields in the Route should be set as: Process Event - Change of state; Condition States Bit Mask - Released; Procedure Name - LOG0209; Allowed Generation Types - Manually Destination State - Released; Warehouse Requisition Document Flow settings: To set up the creation of Warehouse Order some of the fields in the Route should be set as: Process Event - Change of state; Condition States Bit Mask - Released; Procedure Name - LOG0501; Allowed Generation Types - Both (Auto and Manually) Destination State - Firm Planned - the WO should be created to Firm Planned state because you have to assign a Worker for it. Depending on the Warehouse processes you can Assign Workers one by one or use Assign Worker for multiple rows UI function. You also can leave the Order without Assignment so the Workers can Take the Orders by themselves through the WMS Worker before they start to execute it; \"Is Executed\" calculated attributes The information whether the WR or a SO is fully executed is collected using three calculated attributes. They allow us to have that information on three different stages of the Completion phase which are of great importance: an attribute in WR lines - that shows if the particular line is fully executed a second attribute in WR - that uses the first attribute that shows if the whole WR is fully executed i.e. if all of its lines are. and a third attribute in SO - that shows if the document is fully executed by the WMS module i.e. if all its child WRs are fully executed. Here is a list with the calculated attribute expressions. Of course, еach attribute can be modified by the implementator according to the organization's needs. NOTE: You can easily create these attributes in your database by copy-pasting their expression into your database. \"Is Executed\" attribute in WR lines Repository: Logistics.Wms.WarehouseRequisitionLines Exp No Operator Parameter1 P1 Value Parameter2 P2 Value Parameter3 P3 Value 10 IIF EXP 20 CONST TRUE CONST FALSE 20 LTE EXP 30 EXP 100 30 SUM EXP 40 ATTRIB StandardQuantity 40 FILTER EXP 50 EXP 60 50 GETOBJVALUE REF WarehouseRequisition CHILD Fulfillments 60 AND EXP 70 EXP 90 70 EQUAL ATTRIB DocumentLineId EXP 80 80 GETOBJVALUE INPUT 10 ATTRIB Id 90 EQUAL EXP 95 CONST 0 95 CAST ATTRIB FulfillmentType CONST System.Int32 100 SUM EXP 110 ATTRIB StandardQuantity 110 FILTER EXP 120 EXP 130 120 GETOBJVALUE REF WarehouseRequisition CHILD Fulfillments 130 AND EXP 140 EXP 160 140 EQUAL ATTRIB DocumentLineId EXP 150 150 GETOBJVALUE INPUT 10 ATTRIB Id 160 EQUAL EXP 170 CONST 1 170 CAST ATTRIB FulfillmentType CONST System.Int32 \"Is Executed\" attribute in WR Repository: Logistics.Wms.WarehouseRequisitions Exp No Operator Parameter1 P1 Value Parameter2 P2 Value Parameter3 P3 Value 10 IIF EXP 20 CONST FALSE CONST TRUE 20 GTE EXP 30 CONST 1 30 COUNT EXP 40 40 FILTER CHILD Lines EXP 50 50 EQUAL ATTRIB #IsExecutedWRLines CONST FALSE \"Is Executed\" attribute in SO Repository: Logistics.Inventory.StoreOrders Exp No Operator Parameter1 P1 Value Parameter2 P2 Value Parameter3 P3 Value 10 IIF EXP 20 CONST FALSE CONST TRUE 20 GTE EXP 30 CONST 1 30 COUNT EXP 31 31 FILTER EXP 40 EXP 32 32 EQUAL ATTRIB #IsExecutedWR CONST FALSE 40 SELECT REPO Logistics.Wms.WarehouseRequisitions EXP 50 50 WHERE EXP 60 60 EQUAL ATTRIB ParentDocumentId EXP 70 70 GETOBJVALUE INPUT 10 ATTRIB DocumentId"
  },
  "modules/logistics/wms/how-to/execute-order-lines.html": {
    "href": "modules/logistics/wms/how-to/execute-order-lines.html",
    "title": "How to execute order lines | ERP.net Tech Docs",
    "summary": "How to execute order lines А warehouse order (WO) is the document that contains the actual plan that needs to be executed by the WMS module. The WO lines can be executed through the Orders menu of the WMS Worker or through the Execute lines UI function. How these lines are executed depends on their task type. NOTE! Not all task types are currently available for order lines execution. Some, such as count, are available only as ad hoch operation (e.g. the Reconciliation menu of the WMS Worker). If you're not familiar with how Orders menu The WMS Worker is our WMS mobile application available on all compatible Android devices, including handheld devices. The Orders menu is used by the warehouse worker to execute the lines of the warehouse orders that have been assigned to them. Execute lines UI function This function is available in the definition of each warehouse order. When initiated, it executes warehouse order lines based on the specified information, such as product, quantity, lot, warehouse location, and other details. As a result, it creates warehouse transactions, document fulfillments, or both, depending on the particular line's task type. The function is especially useful when entering initial availability in the warehouse or as a backup way to execute lines without using the WMS Worker, in case there is a problem with mobile devices, for example. Step-by-step To begin, go to the definition of the warehouse wrder you want to execute. Make sure that its state is released. If it's not, release the document before starting the function. Then, click the UI Functions and select Execute lines. You'll get a confirmation message preceding the operation. Confirm that you want to perform it by clicking OK. The line execution functionality processes every line separately. If the execution of all lines is successful, the function will finish with a success message. If there's problem during the execution of the lines, the function will stop running and it will display a message giving more details about the problem and its cause. Once the error is identified and resolved, you can continue the execution process from where it was stopped. The system will automatically detect the unexecuted lines left from the previous attempt (based on the document fulfillments that have been created) and proceed with their execution."
  },
  "modules/logistics/wms/how-to/index.html": {
    "href": "modules/logistics/wms/how-to/index.html",
    "title": "How To | ERP.net Tech Docs",
    "summary": "How To Here, you will find step-by-step guides on how to perform various actions within the WMS module. Set up a warehouse Set up a document flow Enter initial availability Execute order lines Assign worker Change worker Check if a dispatch order can be fulfilled Reconcile Apply other settings"
  },
  "modules/logistics/wms/how-to/initial-availability.html": {
    "href": "modules/logistics/wms/how-to/initial-availability.html",
    "title": "Enter initial availability | ERP.net Tech Docs",
    "summary": "Enter initial availability When working in the WMS module, one of the first things you need to do is enter the initial availability balance. The system comes with two functions that will help you ease the process – one for loading the current availability from the Inventory module and another that will apply the reviewed availability to the WMS module. Here are more details on what they do and how to use them. Loading the inventory availability using the 'Load initial available balance' UI function The first function is located in the Managed Warehouse definition. With it, you can enter availability for the current Warehouse by loading the current availability from an existing Store of the Inventory management module. The function loads availability from the selected Store and creates Warehouse Orders for the corresponding Warehouse. The lines of these Warehouse Orders contain the loaded availability. Then, they can be reviewed, edited (if necessary), and executed by the second function. To begin, click on the UI Functions button and select Load initial available balance. This will pop up a window, in which you can select the Store whose availability you would like to load and the Document type of the Warehouse Order that will be created. Once you’ve made your selections, click OK. The availabilities from the selected store will be loaded, and you'll receive a message containing the link(s) with the created document/s that contains the result. Click on the link to open the definition of the created order/s. Review and edit the results When you open the definition of the created order/s, you can review and edit the results of the previous function i.e. the warehouse order lines. The information specified in these lines will be directly used to form the availability. Therefore this is the step, where you should review the quantities, assign the Warehouse Locations and the Logistic Units (if any), and make any additional changes to the information in the lines to achieve the desired availability. Please specify a warehouse worker as well, as it is a required field to release the document. You can select any worker you prefer. Execute the lines to form the availability Once all the information in the lines is filled and reviewed, it is time to release the document and execute its line using the second function - the \"Execute lines\" function. For more information about the function and how to use it, see the \"Execute lines UI function\"."
  },
  "modules/logistics/wms/how-to/other-settings/change-order-display-format.html": {
    "href": "modules/logistics/wms/how-to/other-settings/change-order-display-format.html",
    "title": "Modify the displayed information in an order | ERP.net Tech Docs",
    "summary": "Modify the displayed information in an order You have the ability to specify exactly what kind of information is displayed on the first line of each of your orders in the WMS Worker. Additionally, you can modify the information for fields Product and Location inside the order. This can be achieved using a configuration key specified in an appropriate string interpolation format. Having access to order data before you even take it allows you to instantly learn what it's about even if a few basic details are provided. How to do it To change the information displayed on the first line of your orders, you need to edit the /WMS/WMS-Worker/OrderDisplayFormat config key. You can learn more about it in the OrderDisplayTextFormat. Once you open the key, change its Key Value using appropriate string interpolation notation. Based on what you provide for Key Value, different information will be displayed on the first line of all of your orders in the WMS Worker. For example, in order to keep the worker informed about who the client is (ToParty), Time for execution (@TFEX: V, which is a custom property value) and any important Notes (DocumentNotes), chain these fields into the string and the information will be on top row. Key Value: Customer: {ToParty}, Time for execution: {@TFEX: V}, Important: {DocumentNotes} The same information is now available not only in the list of orders, but also inside the Warehouse order. Customizable data in fields Product and Location Just the same way users can set which desired information to be at hand in the forementioned fields, inside the warehouse order. Workers can better orient themselves regarding product and location details. Config options put to use are: ProductDisplayTextFormat LocationDisplayTextFormat Behaviour in particular cases Here is the expected behavior of changing the order display format in certain cases: • If there is no config key set, the information displayed will be retrieved from the To Party field. This is the default behaviour. • If there is a key set, but the Key Value field is left blank, the displayed information will also be retrieved from To Party field. • If there is a config key set, but the assigned parameters are not returning any value, the displayed information is going to be “-“."
  },
  "modules/logistics/wms/how-to/other-settings/index.html": {
    "href": "modules/logistics/wms/how-to/other-settings/index.html",
    "title": "Other settings | ERP.net Tech Docs",
    "summary": "Other settings Here, you can find instructions on configuring various settings within the WMS Worker. Modify the displayed information in an order"
  },
  "modules/logistics/wms/how-to/pictures/index.html": {
    "href": "modules/logistics/wms/how-to/pictures/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/logistics/wms/how-to/reconcile.html": {
    "href": "modules/logistics/wms/how-to/reconcile.html",
    "title": "Reconcile | ERP.net Tech Docs",
    "summary": "Reconcile The reconciliation process in name is performed in two steps. First warehouse workers are performing the actual counting of the Warehouse Availability in the Warehouse Locations using the WMS Worker app. The next step is applying the results of the reconciliation made in the WMS module to the Inventory module and its avalability using the Reconcile document and the Add the reconciliation lines from the WMS module UI function. Reconcile the availability in the Warehouse Locations The first step is to reconcile the availability in the desired Warehouse Location/s. This step is performed by the warehouse workers that count the availability in the chosen warehouse location/s using their handheld devices and the Reconcile menu the WMS Worker mobile app. As a result, the app generates Warehouse Transactions with Count task type that adjust the warehouse availability according to the differences that were found during the reconciliation. The Warehouse Availability in this/these Location/s is now correct, but we still need to update the Availability in the Inventory module. Update the availability in the Inventory Module The next step is to update the Inventory Availability. This is performed using the Add the reconciliation lines from the WMS module UI function that can be found in the Reconciliation document’s definition. The functions loads all Count Warehouse Transactions that were now yet applied to the Inventory module and creates Reconciliation lines for them. There, these results can be reviewed, edited (if necessary), and applied to the inventory availability by releasing the Reconcile document and generating Store Transactions. To begin, create a new Reconciliation document from the Logistics --> Inventory section. Fill it with the necessary information, including the Default Store in which the reconciliation is done, and Save the document. To add reconciliation lines from the WMS module to an existing document, click the UI Functions button at the upper-left corner of the screen and then select the Add the reconciliation lines from the WMS module option. Define the period on which you want the data to be based (in days), and click OK. This will check which Warehouse Transactions with Count task type haven’t apllied to the Iventory module using Reconciliation documents yet, and will create lines for them. Review and edit (if needed) the results i.e. the created renciliation order lines. Once the review is done, you can release the document which will generate Store Transactions for the differences and will update the Inventory Availability."
  },
  "modules/logistics/wms/how-to/setup-warehouse/enter-quantity-of-one-pce.html": {
    "href": "modules/logistics/wms/how-to/setup-warehouse/enter-quantity-of-one-pce.html",
    "title": "Enter quantity of one pce | ERP.net Tech Docs",
    "summary": "Enter quantity of one pce You can configure what happens when you enter a barcode in the WMS Worker app. To adjust this setting, use the following config options reference: /WMS/WMS-Worker/SingleBarcodeScanEntersQuantityOfOnePce When the value of this config is set to \"1\", any PCE you input will be scanned automatically, bypassing the Quantity screen. When the value is set to \"0\", the WMS Worker locates the line and switches to execute mode for that line."
  },
  "modules/logistics/wms/how-to/setup-warehouse/index.html": {
    "href": "modules/logistics/wms/how-to/setup-warehouse/index.html",
    "title": "Warehouse setup | ERP.net Tech Docs",
    "summary": "Warehouse setup To start working with Warehouse Management Module (WMS), you need to complete the setup of the general warehouse definitions – warehouse, locations, workers, and policies. Create warehouse definition/s Setting up a warehouse, naturally starts with the creation of the definitions of the warehouse themselves. A single warehouse definition represents a complete physical warehouse. It may a contain several individual buildings that together form a complete warehouse complex, which is treated as a single entity by the other processes. Typically, warehouses largely follow the structure of stores in the Inventory Module, but it is not mandatory. Link the warehouse definitions to the stores they will be serving We have created warehouse definitions, the next step is to link these warehouses to the existing stores of the Inventory Module. This way, when we have a warehouse requisition coming from the Inventory Module, we will know which warehouse from the WMS module corresponds to it and therefore has to fulfill the requisition. The link is made trough the Managed Warehouse field in the store’s definition. Usually, the link is one to one - one warehouse is linked to only one store. We can still link a single warehouse to two or more stores. We must bear in mind, however, that if a warehouse is linked to more than one stores - the reverse operations, such as warehouse reconciliation may require manual post-processing. What to do next? You can continue setting up your warehouse by creating zones, locations, workers and policies. More information can be found in the following topics: Zones and locations Warehouse workers Warehouse policies NOTE: Note that in order to work with or test the module or the WMS Worker app, you need to create at least one warehouse, zone, location and worker."
  },
  "modules/logistics/wms/how-to/setup-warehouse/warehouse-policies.html": {
    "href": "modules/logistics/wms/how-to/setup-warehouse/warehouse-policies.html",
    "title": "Warehouse policies | ERP.net Tech Docs",
    "summary": "Warehouse policies Warehouse policies are a hierarchical system for applying policies when working with the WMS module. The most important properties that any policy has are policy kind and value. Policy kinds are predifined system types, which specify the usage of the policy. Different policy kinds have different effect on the system. Some kinds manage certain restrictions during the operations execution of operations, others affect the WMS Worker app's interface, while others store important values that are used by the calculation algorithms. Warehouse policies can be set up for different warehouses, zones or even product groups, depening on the meaning of the kind of the particular policy. We can also specify if one policy is more important than another policy of the same kind, which compliments the hierarchical structure of the policies and allows flexibility. Available policy kinds Policy kinds specify what the actual action of the policy is. The list of the policy kinds is system predifined. Kind Details AllowProductChange Description: Allows execution with a different product than the ordered. Possible values: true, false Action: Used in the Orders execution in the WMS Worker app. If there is an applicable policy to the line and its value is „false“, then the Product which was initially specified in the Warehouse Order Line cannot be changed during the line execution. If the user tries to enter a different product, the app will make a negative sound and will display a pop message: “Product change is not allowed. Please select the suggested product.” Otherwise, the Product can be changed during the execution. AllowLotChange Description: Allows execution with a different lot than the ordered. Possible values: true, false Action: Used in the Orders execution in the WMS Worker app. If there is an applicable policy to the line and its value is „false“, then the Lot (if any) which was initially specified in the Warehouse Order Line cannot be changed during the line execution. If the user tries to enter a different lot, the app will make a negative sound and will display a pop message: “Lot change is not allowed. Please select the suggested lot.” Otherwise, the Lot can be changed during the execution. AllowLocationChange Description: Allows execution from a different location than the ordered. Possible values: true, false Action: Used in the Orders execution in the WMS Worker app. If there is an applicable policy to the line and its value is „false“, then the Warehouse Location (if any) which was initially specified in the Warehouse Order Line cannot be changed during the line execution. If the user tries to enter a different location, the app will make a negative sound and will display a pop message: \"Location change is not allowed. Please select the suggested location.\" Otherwise, the Location can be changed during the execution. AllowUnitChange Description:_ Allows execution of a quantity in a different measurement unit than the ordered. Possible values: true, false Action: Used in the Orders execution in the WMS Worker app. If there is an applicable policy to the line and its value is „false“, then the Quantity Unit which was initially specified in the Warehouse Order Line cannot be changed during the line execution. If the user tries to enter a different quantity unit, the app will make a negative sound and will display a pop message: \"Quantity Unit change is not allowed. Please select the suggested quantity unit.\" Otherwise, the Unit can be changed during the execution. RequireSourceScan Description: Requires scanning of the source location when receiving, moving or dispatching. Possible values: true, false Action: Used in the Orders execution in the WMS Worker app. If there is an applicable policy to the line and its value is „true“, then the interface of the Location screen won‘t allow easy selection of the Warehouse Location. The USE button will be hidden and the selection through the availability table will be inactive. RequireDestinationScan Description: Requires scanning of the destination location when moving. Possible values: true, false Action: Used in the Orders execution in the WMS Worker app. If there is an applicable policy to the line and its value is „true“, then the interface of the Destination screen won‘t allow easy selection of the Warehouse Location. The USE button will be hidden and the selection through the availability table will be inactive. RequireProductScan Description: Requires scanning of the product. Possible values: true, false Action: Used in the Orders execution in the WMS Worker app. If there is an applicable policy to the line and its value is „true“, then the interface of the Product screen won‘t allow easy selection of the Product. The USE button will be hidden and the selection through the availability table will be inactive. AllowLineSkip Description: Allows skipping of an order line when executing (allow quantity = 0). Not planned for release at the moment. ZoneType Description: Specifies the type of zone for receiving, shipping, packing, etc. Can be saved only if the Warehouse and Zone fields are filled in. The policy is hierarchical, this means that if it set for a particular zone it will applies to all of its subzones. Possible values: picking, packing, receiving, shipping, and storage. Action: Currenty only the picking value is taken into account of the algorithms. It is used by the Suggest warehouse locations funtion. KittingControllingLevel Description: Used when working with composite products. Specifies the level of control during the kitting of the composite product’s components. Possible values: 10, 20, 30, 40, 50 Action: Depends on the specified level. For more information, see Levels of control for composite products . DekittingControllingLevel Description: Used when working with composite products. Specifies the level of control during the dekitting of the composite product. Possible values: 10, 20, 30, 40, 50 Action: Depends on the specified level. For more information, see Levels of control for composite products . GS1SSCCCompanyPrefix Description: Used when working with logistic units and GS1 SSCC barcodes. Specifies the GS1 company prefix issued by the national GS1 organization. Possible values: а digit number Action: Used by alghorithm that generates SSCC codes of the logistic units. GS1SSCCNextSerial Description: Used when working with logistic units and GS1 SSCC barcodes. Specifies the next reference serial number used when generating SSCC codes. А digit number acting as a counter: e.g. 0000001, 0000002… Must be set up after the GS1SSCCCompanyPrefix policy, because its allowed lenght depends on the GS1SSCCCompanyPrefix value's lenght. Possible values: а digit number, with lenght that is equal to \"16 - GS1CompanyPrefix value's lenght\". Action: Used by alghorithm that generates SSCC codes of the logistic units. CustomRouting Description: Specifies a custom routing, based on a user-defined attribute of the locations. The policy specifies the code of the user-defined attribute, whose values contain the sequence of the route. The custom routing is employed by the Suggest Routing function and can be defined only at warehouse level. Possible values: all values are possible, but only a value of a Custom Property Code, which has values in the Warehouse Locations table will affect the Suggest Routing Function Action: The Suggest Routing function in the Warehouse Order Execution will use the Custom Property Values in the Warehouse Locations panel. The Suggest Routings function will suggest Locations in the order described in the Custom Property Values. The values are taken as a string, so you have to write the values in this format 001,002,003...010..100. The policy can be defined only at warehouse level. UnassignedOrdersSectionVisibility Description: Depending on your warehouse's organization, you can prevent warehouse workers from seeing and taking Unassigned orders. Possible values: true, false Action: Used in the Orders list in the WMS Worker app. If there is an applicable policy to the Warehouse and its value is „false“, then the Unassigned section will be hidden from the Workers' orders list in this Warehouse. If there is an applicable policy to the Warehouse and its value is „true“ or there is no defined policy, then the Unassigned section will be visible in the Workers' orders list in this Warehouse. The policy can be defined only at warehouse level. StartedByOthersSectionVisibility Description: Depending on your warehouse's organization, you can prevent warehouse workers from seeing and joining Started by others orders. Possible values: true, false Action: Used in the Orders list in the WMS Worker app. If there is an applicable policy to the Warehouse and its value is „false“, then the Stared by Others section will be hidden from the Workers' orders list in this Warehouse. If there is an applicable policy to the Warehouse and its value is „true“ or there is no defined policy, then the Started by Others section will be visible in the Workers' orders list in this Warehouse. The policy can be defined only at warehouse level. AssignedToOthersSectionVisibility Description: Depending on your warehouse's organization, you can prevent warehouse workers from seeing and taking Assigned to Others orders. Possible values: true, false Action: Used in the Orders list in the WMS Worker app. If there is an applicable policy to the Warehouse and its value is „false“, then the Assigned to Others section will be hidden from the Workers' orders list in this Warehouse. If there is an applicable policy to the Warehouse and its value is „true“ or there is no defined policy, then the Assigned to Others section will be visible in the Workers' orders list in this Warehouse. The policy can be defined only at warehouse level. LogisticUnitScreenVisibility Description: When executing an order line, with this policy you can decide when a logistic unit screen is visible. Possible values: always, default, never Action: Used in the Executing orders' lines in the WMS Worker app. If there is an applicable policy to the Warehouse and its value is „always“, then the Logistic Unit screen will always show up when executing lines. If there is an applicable policy to the Warehouse and its value is „default“ or there is no defined policy, then the Logistic Unit screen will show up only if you selected one in the Warehouse Order Line before executing it with the WMS Worker. And also when there is an availability in some Logistic unit for this Product. If there is an applicable policy to the Warehouse and its value is „never“, then the Logistic Unit screen will never show up when executing lines. BarcodeScanEntersQuantityOfOnePce Description: If no quantity is entered, scanning a barcode in the SCAN field enters 1 PCE. Possible values: true/false Action: Used in the Executing orders' lines in the WMS Worker app. If there is an applicable policy to the Warehouse and its value is „true“, then If no quantity is entered, scanning a barcode in the SCAN field enters 1 PCE. If there is an applicable policy to the Warehouse and its value is „false“ or there is no defined policy, the default behavior is used. A quantity of 1 PCE will not be entered and the quantity is expected to be entered in the quantity screen. Note: If more quantity is scanned, for example, 300 PCE (300*), and then the barcode is scanned, the accepted quantity will be 300 PCE. But this has always happened regardless of the policy value. RoutingAlgorithm Description: Used for Suggest Routing UI function in Warehouse Order Lines.The policy specifies how the UI function will be executed, depence of the value of this policy. Possible values: fixed, smart Action: If there is an applicable policy to the Warehouse and its value is „fixed“, the suggested locations will follow exactly the string of their addresses or their Priorities defined by the Custom Routing policy. There won't be any considerations about the availability of the locations, except for the zero quantities. If there is an applicable policy to the Warehouse and its value is „smart“ or there is no defined policy, then default behavior is used. The suggested locations again will follow the string of their addresses or their Priorities defined by the Custom Routing policy, but also their availabilities will be consider. The policy can be defined only at warehouse level. Applicability You set up each warehouse policy by defining the conditions where it applies, to which products and for how long. Each warehouse policy can apply to: Warehouse Zone and its sub-zones Product group and its sub-groups Product type Specific product From date To date Note Some policies can be applied only at the warehouse or zone level. Importance Policies have importance. When evaluating a policy, the setting with the highest importance is applied. For example, if a policy is applied to a root zone and to a sub-zone, the importance of the sub-zone setting determines which setting will be applied: If the sub-zone setting has higher priority, it will be applied. This can be used for hierarchical application of policies for zones. If the root zone setting has higher priority, it will be applied. This can be used for root zone (or even warehouse level) setting, which overrides the setting for specific zones. Importance is an integer value, allowing even negative numbers (for very low importance)."
  },
  "modules/logistics/wms/how-to/setup-warehouse/warehouse-workers.html": {
    "href": "modules/logistics/wms/how-to/setup-warehouse/warehouse-workers.html",
    "title": "Warehouse workers | ERP.net Tech Docs",
    "summary": "Warehouse workers Warehouse workers are human or robot workers who can execute warehouse tasks. They reside in the Workers panel of the respective managed warehouse, where you can view and modify their records. Worker details Within the panel, you can find the following information about every worker: Name - The worker's full name. Person - The person representing the worker, as specified in the worker's User definition. If a User is not set, this field will be NULL, which means that the worker's identity may be unknown or they might be a non-person entity. Notes - Additional information or special instructions related to the worker's role and responsibilities. Is Active - Specifies whether the worker is active and capable of executing tasks. Active From - The date the worker's record became active in the warehouse. This helps in tracking the duration of the worker's service. Active To - The termination date of the worker's activity in the warehouse. This can be NULL for workers who are still active and have not been terminated previously. User - Refers to the user account associated with the worker. This applies only to internal and virtual users. WMS Worker app access One and the same user may be assigned to multiple warehouses. The WMS Worker app determines which warehouses to show to the currently logged-in worker based on the User they're associated with. In other words, workers will only have access to those warehouses where their user accounts are added."
  },
  "modules/logistics/wms/how-to/setup-warehouse/zones-and-locations.html": {
    "href": "modules/logistics/wms/how-to/setup-warehouse/zones-and-locations.html",
    "title": "Warehouse zones and locations | ERP.net Tech Docs",
    "summary": "Warehouse zones and locations Warehouse zones are used to organize the different storage areas of the warehouse. Zone hierarchy The zones are organized in a hierarchy, where each zone can have sub-zones, which can have its own sub-zones and so on. For example: Picking Aisle P1 Rack P1.1 Shelf P1.1.1 Shelf P1.1.2 Shelf P1.1.3 Aisle P2 Refrigeration Aisle R1 Rack R1.1 Aisle R2 Carts Cart C1 Bulk Rack B1 Rack B2 Primary and sub-zones In the above example, Picking, Refrigeration, Carts and Bulk are primary zones. Aisle M1, Rack M1.1, etc. are called sub-zones. The primary zones have no parent zone. Sub-zones always have a parent zone. Locations The warehouse locations (sometimes called bins) are used for the actual storage of the goods. They are the leafs in the hierarchy and are structured under the warehouse zones. For example: Zone \"Shelf P1.1.3\" can contain 3 locations: P1.1.3-A P1.1.3-B P1.1.3-C"
  },
  "modules/logistics/wms/index.html": {
    "href": "modules/logistics/wms/index.html",
    "title": "WMS | ERP.net Tech Docs",
    "summary": "WMS For larger warehouses with multiple locations where real-time tracking of stock availability is essential, you can take advantage of the warehouse management system. WMS follows the concepts of warehouse management systems. The main objective for implementing a WMS is to optimize the efficiency of the warehouse operations in the managed warehouses. Managed warehouses are physical warehouses, which have managed operation. They exist outside of existing store definitions. The Stores concept is used for the management of inventory levels and general ledger (accounting) entries. Managed Warehouses are sub-level, which is used to manage all warehouse activities, including: Picking Put-Away Counting Packing/Unpacking Inspection Robot interactions etc. Note One managed warehouse can encapsulate the storage and operations of multiple legal entities (Enterprise companies). While the existing store concept is strictly bound to the enterprise company, the warehouse can accommodate goods of multiple entities. It can even be used to store goods from external companies. The most important part for achieving operational effectiveness is to properly organize the layout of the warehouses. Layout optimization is outside the scope of this document. Managed warehouses are organized using zones and locations. Zones are sub-divisions of a warehouse. Note Zones are used to accommodate different storage needs, such as different temperature requirements or turnover rate of the products. The zones are further divided in locations. Locations have name (like #1-8-20), which is used to uniquely identify them. Note Use warehouse management to increase efficiency by automating warehouse routing and identifying storage locations for your products. The two most basic documents of WMS are: Warehouse requisitions (W.R.) They contain outside requests for warehouse operations (usually inbound/outbound). Warehouse orders (W.O.) They are the internal plan for execution of W.R. They contain routes, locations, workers, etc. The basic operation flow of WMS is the following: The steps, noted in (parens) in the diagram are as follows: The outside module/department creates W.R. based on its needs. The connection is performed trough the Iventory Store Orders (S.O.). Inside the WMS, the team devises a plan for execution and stores it as a W.O. In the best-case scenario, the creation of WO is totally automated. The workers use their handheld devices and the WMS Worker app to execute the order. Each step is recorded as both document fulfillments (3.1) and warehouse transactions (3.2). After the W.O. is fully executed (completed), the warehouse requisition fulfillments are updated with the execution information. After the W.R. is fully executed (completed), the store transaction fulfillments are updated with the execution information. After the S.O. is fully executed (completed), it creates the Inventory Store Transaction based in the execution information returned by the WMS. Typically, managed warehouse operations are executed using some sort of handheld device, which is used to scan bar-codes, NFC tags, etc. Note You can take advantage of the dedicated WMS Worker application to better control and speed up operations within your managed warehouse. Push and Pull task management When a warehouse requisition document comes in, there are many ways we can plan how to fulfill it. The plan is represented by warehouse order documents. But how these order documents are created? There are at least two main ways to organize the work. Pull system The pull system is the easiest way to organize the execution. Under some circumstances, it can also be the most efficient. In the pull system, each warehouse worker decides when to get (pull) work. Whenever they are ready, they request more work through their mobile app. Pros: Do not require a central planner. Effective for small orders, usually e-Commerce. Very easy to setup. Easy to maintain - no need to plan for workers missing, overloaded, etc. Efficient - workers achieve high efficiency without central planning (but might need more control). Cons: Not good for B2B, because large orders are better served with Push System. Without a central planner, worker control needs to be better controlled. Cannot implement complex order mixing, splitting or other complex work procedures. Push system Under the push system, there is a central planner, who plans the work and pushes it to the workers. The push system might be required in more complicated execution environments. Pros: A central planner can better allocate the worker and machine resources to fulfill the requisitions. In complicated execution, the pull system might be inappropriate. Worker task management is taken away from the workers and controlled centrally. Cons: More expensive - require a central planner. The efficiency of the workers depends heavily on the planner. Choosing the right strategy There can be other organizations of the workflow within a warehouse. The ERP.net data model allows implementing almost any conceivable strategy, with the most prominent ones built-in. However, planning the execution can be externalized to custom apps and services. Applying AI/ML strategies for achieving better efficiency is a possible direction. Also, mixing robots with human workers might require using custom strategies. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/logistics/wms/logistic-units/How-to/Create_New_LU.html": {
    "href": "modules/logistics/wms/logistic-units/How-to/Create_New_LU.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Create a new LU To create a new logistic unit, click on the circular \"+\" button located on the Logistic Units panel or select one of the logistic unit types under the Create button. Alternatively, you can click the title of the panel and then the New button located at the top-left corner of the units table. Note Choosing a logistic unit type remains optional. You can create a unit without one. Once you've completed the previous steps, a separate page will open, where you need to fill out several fields: Serial Code - Serial code of the unit (required). Logistic Unit Type - If you've selected a unit type, it will be automatically specified here. Expected Weight - This is the expected weight of the unit in the measurement unit specified in its type. Measured Weight - This is the actual weight of the unit in the measurement unit specified in its type. Cargo Type - General type of the cargo that will be used for the unit. Select one from the drop-down menu. Notes - Additional notes can be added here. Represented As Product - When the logistics unit is also a tradeable item, this field specifies the product used to trade the unit. Active Status - Check this box to make the logistic unit active. When you are ready, click on the Save and reload button to finish the creation process"
  },
  "modules/logistics/wms/logistic-units/How-to/create_LUNs.html": {
    "href": "modules/logistics/wms/logistic-units/How-to/create_LUNs.html",
    "title": "Create multiple LUNs | ERP.net Tech Docs",
    "summary": "Create multiple LUNs Creating several LUNs of the same series In order to facilitate the creation of new LUNs and organize better the received/dispatched packages you can initiate the creation of a number of LUNs of the same series at once. 1. Choose the series type, select its last LUN code and run the UI function “Create multiple LUNs”. 2. Input the desired number of new LUNs and the system will generate active LUNs in an ascending coding, belonging to the same series. For example, if the last LUN bears the code 012A01, and we initiate the creation of 10 more LUNs, they will bear the same coding style. The new last LUN will be 012A11. Having the new LUNs at hand you can print labels and stick them to the designated items."
  },
  "modules/logistics/wms/logistic-units/How-to/index.html": {
    "href": "modules/logistics/wms/logistic-units/How-to/index.html",
    "title": "Work with Logistic Units | ERP.net Tech Docs",
    "summary": "Work with Logistic Units Logistic Units (LU) are an item established for logistics operations, such as receving, storage, movement, and dispathing. It represents all physical units handled in the same manner during logistic operations. When working with LUs, it is possible to execute inbound, outbound,internal warehouse operations, as well as create them with ease. Create multiple LUNs Work with Logistic Units"
  },
  "modules/logistics/wms/logistic-units/How-to/working-with-lu.html": {
    "href": "modules/logistics/wms/logistic-units/How-to/working-with-lu.html",
    "title": "Work with Logistic Units | ERP.net Tech Docs",
    "summary": "Work with Logistic Units Using Logistic Units in the Receiving Process Using LUs in the receiving process can significantly reduce the amount of time and effort it requires, especially if the the data about the expected Logistic Units contents is exchanged prior the shipment arrival via using an Advance Shipping Notice (ASN), for example. Here is what to do depending on whether you have information about the SSCC codes and its prior the shipment or not. The LU’s data is exchanged prior the shipment arrival In these cases it is highly advisable to create their definitions into the database before the arrival of the units. This will allow receiving the unit with a single scan of its SSCC code. The worker needs to simply scan the SSCC barcode into the Scan field of the Orders menu of the WMS Worker app. The P03: GS1 – SSCC barcode parser will automatically find the appropriate Warehouse Order Lines and will automatically execute them with the logistic unit’s Contents. The LU’s data is NOT exchanged prior the shipment arrival If the shipping label contains trade item information If the LU is homogeneous, then its Shipping Label probably contains trade item information about the product, lot, etc.. This means then you can still receive the LU contents by simply scanning the trade information label. If the shipping label DOES NOT contain trade item information In these cases you need to inspect the LU content in order to know what it actually is. Once you know its content, you can receive it by executing the Order lines for each product. Once, the content is received, you can decide whether you still want to handle it as a whole Logistic Unit? If you do, you can assing your own SSCC code. In this case you need to pack the content using the Pack menu in WMS Worker and choose its “Create logic unit now” button. This will automatically create new LU with the new SSCC code, the scanned contents and appropriate specifications. Then you just need to print and attach new logistics labels with the newly assigned SSCC barcode. Alternatively, you use the SSCC code that has been assigned by the supplier. In this case you need to manually create the LU definition into the database, where you need to specify both its SSCC and Contents. Then you still have to Pack its content by using the Pack menu in WMS Worker by selecting the defined LU. This will update the availability with the information that these product are now contained in this LU. Using Logistic Units in the Dispatching Process Here we have two situations depending on whether you are dispatching an existing LUs or you want to create LUs to pack the dispatched content of an Sales Order. Dispatching existing LU То dispatch an existing LU you need to simply scan the SSCC barcode into the Scan field of the Orders menu of the WMS Worker app. The P03: GS1 – SSCC barcode parser will automatically execute the appropriate Warehouse Order lines with the logistic unit’s Contents. Creating new LUs to pack a dispatched Sales Order You have completed the dispatching of a Sales Order and now you want to pack its products into Logistic Units? You can do that by using the Label menu in WMS Worker. With it you can select the completed Sales Order and create new LU’s for its content. Then you can print logistics labels and attach them to each unit."
  },
  "modules/logistics/wms/logistic-units/asn.html": {
    "href": "modules/logistics/wms/logistic-units/asn.html",
    "title": "Advance Shipping Notice (ASN) | ERP.net Tech Docs",
    "summary": "Advance Shipping Notice (ASN) The Advance Shipping Notice (ASN) is a document used in supply chain management to provide detailed information about a pending shipment of goods. It is typically generated by the supplier or manufacturer and sent to the customer or retailer before the actual delivery of the goods. The ASN provides important details about the shipment, such as the items included in the shipment, the quantity of each item, the unit of measure and weight of the shipment and the expected delivery date. This information allows the customer to prepare for the delivery of the goods, such as arranging for the necessary receiving staff, ensuring that there is sufficient space to receive the goods. It is especially useful when receiving Logistic Units. The ASN allows the exchange of data linked with the logistic units’ SSCC code and the logistic units’ contents in advance. This way the receiving company can create the logistic units definitions before the shipment arrival, which will allow receiving the unit with a single scan of its SSCC code (for more info, see GS1 – SSCC barcode parser). By providing accurate and timely information about pending shipments and its content, ASN can help to reduce the amount of time and effort required to process and manage the receiving process."
  },
  "modules/logistics/wms/logistic-units/index.html": {
    "href": "modules/logistics/wms/logistic-units/index.html",
    "title": "Logistic Units | ERP.net Tech Docs",
    "summary": "Logistic Units Logistic Units are physical objects or containers that are used to transport goods or products from one location to another. These units are typically standardized and can be handled and transported easily by machinery such as forklifts or conveyor belts. Logistic Units can come in many different forms, including pallets, containers, and boxes. They are designed to hold a specific amount of products or goods, and their size and shape are usually determined by the requirements of the transportation mode or the storage facility. In the context of logistics and warehousing, logistic units play an important role in the efficient movement of goods through the supply chain. By using standard units, companies can ensure that products are packed and transported in a consistent and predictable way. This helps to reduce the risk of damage or loss during transit, and it also makes it easier to track and manage inventory as it moves through different stages of the supply chain. Logistic unit’s definition Logistic Units definition in ERP.net contains important information about the unit’s serial number, type, weight, its contents, and specifications. The Logistic Units are identified using their unique Serial Number. If it is used GS1 coding, this is actually the SSCC code. For SSCC codes it is recommended that the serial number includes the leading two zeroes “00” that represent the GS1 SSCC identifier. This way you will be able to search in the Logistic Units drop down lists by scanning its barcode. Serial Codes can be reused if needed, but it this case the “old” LU with the same serial number must be deactivated. The Contents panel holds information about what the content of the logistics unit is – what products, what is their quantity, lot, serial number, etc. Note that this is the theoretical content of the unit, the actual content may be different and can be seen in the Warehouse Availability menu. The Specifications panel contains synthesized information about the Logistic Unit. The database can contain any kind of specification, but most client applications and integrated methods process GS1 specifications (Application Identifiers). These specifications are usually used when generating Logistic Labels. Serial Shipping Container Code (SSCC) As mentioned above, one of the most common methods for identifying Logistic Units is SSCC codes. SSCC (Serial Shipping Container Code) is a unique 18-digit code used to identify shipping containers, typically used in the supply chain industry. It is used to track and manage the movement of goods as they move through the supply chain, from production to delivery to the end customer. Because the SSCC provides a unique number for the delivery, it can be used as a lookup number to provide not only detailed information regarding the contents of the load, but also as part of the Advance Shipping Notice (ASN) process. Typically, this means that just one scan of the SSCC that is printed on the Logistic Label at a receiving bay can be linked to a pre-received electronic Advance Shipping Notice (ASN) of the contents of the logistic unit to facilitate speedy receiving, reconciliation, and put-away processes. Alternatively, when tracking a unit in transit, the SSCC provides all the information required for accurate identification. The SSCC code is generated by the organization that is packing/ creating the logistic unit and it is formed by several parts, , including a GS1 Company Prefix, a unique serial number, and a check digit. Example: (00) 0 9123456 000000009 5 , where: (00) is the Application Identifier (AI). It is not a part of the 18-digit code. Therefore, it is not included in the code in the SSCC specification in the logistic unit’s definition. The leading 00 still should be included in the Serial Number field in order to be able to search in the LU drop down lists by scanning the SSCC barcode. **0 is the Extension Digit. It can take values from 0 to 9. Its determined by company generating the logistics label and serves to increase the capacity of the Serial Reference within the SSCC. Currently, ERP.net simply sets “0” as a constant. 9123456 is the GS1 Company Prefix. This is a globally unique number issued to a GS1 member company. It is assigned and provided to the company by the GS1 National Organization. The company prefix gives uniqueness to the generated SSCC, but does not indicate the origin of the goods. The prefix can be of different lengths, depending on the capacity of the prefixes offered by the relevant GS1 National Organization. In ERP.net the GS1 Company Prefix is specified in the “GS1 SSCC Company Prefix” warehouse policy. 000000009 is a Serial Reference. This is a serial number that is assigned by the company that has created the logistics unit. The reference number has the function of a sequence counter: for example 0000001, 0000002, 0000003,.....0000010, 0000011........9999999. Its length varies depending on the length of the GS1 company prefix and is calculated as a function of it: (Extension digit + GS1 Company Prefix + Serial Reference) = 17 digits. In ERP.net the Serial Reference is specified in the “GS1 SSCC Next Serial” warehouse policy. 5 is a Check Digit. It is a one-digit number used for data integrity. It is calculated automatically by ERP.net when generating the SSCC code. Logistic units types When it comes to the content a logistic unit can either be homogeneous or heterogeneous. The homogeneous logistic units contain one type of trade item. This means that all the items at the highest level of packaging are the same and are identified with the same GTIN. Example: a pallet containing 50 trade item groupings (e.g. boxes) of shampoo. In this case information of GTIN and other trade item information such as Lot, Quantity and , etc. CAN be included in the GS1 barcode and on the logistic label. I.e., for homogeneous logistic units and logistic units that are trade items it is possible to include information about the trade item(s) on the logistic label. This can be useful in situations where no Advance Shipping Notice (ASN) is used or is unavailable and the receiving company is not aware of the content of each specific logistic unit in advance. The heterogeneous logistic units contain different types of trade items at the highest level of packaging that are identified with different GTINs. Example: a pallet containing 30 standard trade item groupings (e.g. boxes) of shampoo and 20 standard trade item groupings (e.g. boxes) of conditioner. In this case information of GTIN and other trade item information such as Lot, Quantity and , etc. CANNOT be included in the GS1 barcode and on the logistic label. I.e., for heterogeneous logistic units it is not possible to include trade item information on the logistic label and therefore the use of advance exchange of and Advance Shipping Notice (ASN) is strongly encouraged. This will allow the exchange of data linked with the SSCC and the logistic units’ content in advance. This way the receiving company can create the logistic units definitions before the shipment arrival, which will allow receiving the unit with a single scan of its SSCC code (for more info, see GS1 – SSCC barcode parser)."
  },
  "modules/logistics/wms/logistic-units/logistic-labels.html": {
    "href": "modules/logistics/wms/logistic-units/logistic-labels.html",
    "title": "Logistic Labels | ERP.net Tech Docs",
    "summary": "Logistic Labels GS1 logistic labels are standardized labels used to identify and track products throughout the supply chain. GS1 is a global organization that sets standards for product and Logistic Units identification and communication, and their logistic labeling standards are widely used in the retail and healthcare industries. The GS1 logistic label consists of three sections: The top section of the label contains information in free format that can be used by the label-making company for various purposes. The middle section contains the encoded data in readable text format, in accordance with GS1 Standards. The last section contains the barcode symbols. For the encoding of the information are used GS1 barcode identifiers. The SSCC is the single mandatory element for all GS1 Logistic Labels. Other information, when needed, shall comply with the specifications in this document and with the proper use of GS1 Application Identifiers. If the Logistic Unit is homogeneous (for more information, see Logistic units types) and therefore contains one type of trade item, in addition to the SSCC code, these labels can include trade item information. This typically includes a Global Trade Item Number (GTIN), which is a unique identifier assigned to each product, as well as other information such as the product description, batch or lot number, and expiration date. If the Logistic Unit is heterogeneous (for more information, see Logistic units types) and therefore contains different types of trade items that are identified with different GTINs, then it is NOT possible to include trade item information on the logistic label. In these cases the data about the expected Logistic Units contents is exchanged prior the shipment arrival using an Advance Shipping Notice (ASN). By using standardized logistic labels, companies can improve the efficiency and accuracy of their supply chain operations, reduce the risk of errors and delays, and improve customer satisfaction by ensuring that the right products are delivered on time. Logistic Labels in ERP.net In ERP.net, the logistic labels are created and printed using the standard report and printout functionality. They are usually printed from the Logistic Unit definition. The printout as set up using the Reports functionality in ERP.net, as a report for which the “One Row” check-mark is set. The information in the logistic label is gathered from the logistic unit's Specifications panel. The Pack functiallity in WMS Worker automatically fills in Specifications with the oppropriate information, following the GS1 Standards and you can directly use this information in your labels. Here is a picture of the mandatory settings for the barcode field in order to generate GS1 barcodes from the Specifications. The special FNC1 symbol by default is #, meaning it should be included at the beginning of the barcode and as a separator for the variable length identifiers. The barcode information is extracted using calculated fields. An example of a calculated field that generates the GS1 barcode in a printout: '#'+[Related: Logistic Unit - Specifications 02].[Code]+[Related: Logistic Unit - Specifications 02].[Value]+[Related: Logistic Unit - Specifications 10].[Code]+[Related: Logistic Unit - Specifications 10].[Value]+'#'+[Related: Logistic Unit - Specifications 17].[Code]+[Related: Logistic Unit - Specifications 17].[Value]+[Related: Logistic Unit - Specifications 37].[Code]+[Related: Logistic Unit - Specifications 37].[Value] Here is an archive with the the source and layuot files of an sample printout report in the logistic unit's definition. The report can be use as a base and be adjusted according to the specific company's needs: Download \"Sample Logistic Label Report Layout and Data Source\" The labels are typically printed on adhesive labels that are affixed to Logistic Unit, and they are scanned at various points in the supply chain to ensure the product is properly tracked and accounted for."
  },
  "modules/logistics/wms/managed-warehouses/index.html": {
    "href": "modules/logistics/wms/managed-warehouses/index.html",
    "title": "Managed Warehouses | ERP.net Tech Docs",
    "summary": "Managed Warehouses Managed warehouses are visual representations of complex storage facilities that necessitate efficient inventory management. In ERP.net, they are organized into various locations and zones, each enforcing its own policies and consisting of one or more workers. This structured approach allows for precise tracking, better organization and streamlined logistics within the managed warehouse. You can find more information on how to set up a warehouse here. Navigation To access your managed warehouses, navigate to the Managed Warehouses panel of the WMS section. Clicking the panel's title will take you to a table listing all of your existing managed warehouses as well as the ability to create new ones. Warehouse components The building blocks of a managed warehouse are established during its creation. They can be subsequently modified if the warehouse experiences any changes. Warehouse This panel contains the name of the warehouse and some optional notes about it. Workers This panel contains a list of workers assigned to the managed warehouse. The access each has to the warehouse is determined by the User they're associated with. Policies In the Policies panel, you can find details about the policies of the current managed warehouse. Each policy has a kind and a value and is associated with a particular product group and code. Locations In the Locations panel, you can find details about all existing locations of the current managed warehouse. Each location is identified by its unique address within a warehouse zone. Zones In the Zones panel, you can find details about the zones of the managed warehouse. Each zone has a name and may include a parent zone as well as a unique code for identification."
  },
  "modules/logistics/wms/pictures/zone-based-routing.html": {
    "href": "modules/logistics/wms/pictures/zone-based-routing.html",
    "title": "Zone based routing | ERP.net Tech Docs",
    "summary": "Zone based routing The basic idea With zone based routing, the rules for processing the goods are determined based on the zone, in which the goods are stored for each step. The zones are sequentially numbered, relative to their \"closeness\" to final shipping. For example: 1 IN -> 2 INSP -> 3 BULK -> 4 PICK -> 5 KIT -> 6 PACK -> 7 OUT RECEIVE ------------> --OPTIMIZE--> ----------------> DISPATCH The main processes in the warehouse - receive, optimize and dispatch, are ordered consecutively through the zone sequence. The receive process starts at the inbound docks and runs until goods are placed in bulk. The optimization process usually deals with replenishment of the picking zones, but can also be used for pre-kitting. The planning of the dispatch process works backwards - from the final step (the dispatch from the outbound docks) to the first step (usually picking). This is similar to how MRP/DRP works, but applied for WMS. Zone based routing and sequencing provides great flexibility in the route formation process, while keeping things simple and understandable for the process designers. It allows the process designers to focus separately on each zone, leaving the complex full routing formation to the system. Zone based routing allows programming of very complicated routes, while still keeping things simple and maintainable. How it works? For each zone, there are rules, which define how the goods will be processed, when they pass the zone. The rules for a zone are defined separately for each of the WMS processes - receive, dispatch and replenishment. The full route is the concatenation of all route steps for each consecutive zone. Hierarchical rules Since zones are hierarchical, for any given zone there might be multiple rules, coming from different levels of the hierarchy. All rules in the hierarchy are combined when creating the routing. Combining the rules is performed separately for each STEP NO within each zone. To determine the \"winning\" rule for each step, the RULE PRIORITY is used within all rules, which satisfy the RULE CONDITIONS. Start and finish of the process The receive process starts at the inbound dock and is planned through the zones, until there are no more steps. Usually, it finishes at the BULK zone. The dispatch process works in the opposite way - it first determines the quantities needed at the outbound docks, and than determines what previous steps could supply these quantities. The optimization process is a middle ground - it just runs for all zones, for which there is a definition for the optimization process. Movement between the zones When a rule has a MOVE task, it orders movement of the goods to another zone. The algorithm for determining the routing steps is then restarted for this new zone and so on until the goods reach their final destination and state. Rule and task conditions Rule conditions are evaluated when the routing is determined. They can be used to alter the routes based on conditions, which are known by the time the route is created. Rule conditions include such things as product group, zone characteristics, etc. Task conditions are evaluated later in the process and hence allow processing based on what is know in real time during the execution of the order. They are first copied to the warehouse order. Then, upon actual execution of the order, they are evaluated in real time. Task conditions can be based on runtime characteristics like quality inspection status, lot characteristics, etc."
  },
  "modules/logistics/wms/push-and-pull-task-management.html": {
    "href": "modules/logistics/wms/push-and-pull-task-management.html",
    "title": "Push and pull task management | ERP.net Tech Docs",
    "summary": "Push and pull task management When a warehouse requisition document comes in, there are many ways we can plan how to fulfil it. The plan is represented by warehouse order documents. But how are these order documents created? There are at least two main ways to organize the work. Pull system The pull system is the easiest way to organize the execution. Under some circumstances, it can also be the most efficient. In the pull system, each warehouse worker decides when to get (pull) work. Whenever they are ready, they request more work through their mobile app. Pros: Do not require a central planner. Effective for small orders, usually e-commerce. Very easy to set up. Easy to maintain - no need to plan for workers missing, overloaded, etc. Efficient - workers achieve high efficiency without central planning (but might need more control). Cons: Not good for B2B, because large orders are better served with push system. Without a central planner, worker control needs to be better controlled. Cannot implement complex order mixing, splitting or other complex work procedures. Push system Under the push system, there is a central planner, who plans the work and pushes it to the workers. The push system might be required in more complicated execution environments. Pros: A central planner can better allocate the worker and machine resources to fulfil the requisitions. In complicated execution, the pull system might be inappropriate. Worker task management is taken away from the workers and controlled centrally. Cons: More expensive - require a central planner. The efficiency of the workers depends heavily on the planner. Choosing The right strategy There can be other organizations of the workflow within a warehouse. The ERP.net data model allows implementing almost any conceivable strategy, with the most prominent ones built-in. However, planning the execution can be externalized to custom apps and services. Applying AI/ML strategies for achieving better efficiency is a possible direction. Also, mixing robots with human workers might require using custom strategies."
  },
  "modules/logistics/wms/wms-worker/availability.html": {
    "href": "modules/logistics/wms/wms-worker/availability.html",
    "title": "Availability | ERP.net Tech Docs",
    "summary": "Availability The system provides quick and easy availability checks. A location, product or LUN should be selected to get the search engine up and running: If you select Location for example, the availability shows after your selection: You will find the following information about the product: Location - The location of the product LUN - Logistic Unit Prd - Product name/code Var - Product variations Lot - Lot Information Ser - Serial number Qty - Quantity available Unit - Unit for the shown quantity If you select a LUN, the availability of this particular LUN is shown. In the LUN field, you can enter values from LogisticUnits.SerialCode. The location is only one, you can read more about preventing LUN from being in different locations. You will see the availability only in this LUN:"
  },
  "modules/logistics/wms/wms-worker/index.html": {
    "href": "modules/logistics/wms/wms-worker/index.html",
    "title": "WMS Worker | ERP.net Tech Docs",
    "summary": "WMS Worker WMS Worker is a warehouse management application with a contemporary and intuitive easy to use design. It allows warehouse workers to complete tasks such as order receiving and picking in a more efficient, productive, and accurate manner. This is all synchronized in real-time with your ERP.net system. The algorithm of the application works in such a way that it can give instructions not only to humans but also to robots. Learn more about the WMS Worker in the following articles: Orders Availability Move Pack Unpack Reconcile Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/logistics/wms/wms-worker/move.html": {
    "href": "modules/logistics/wms/wms-worker/move.html",
    "title": "Move | ERP.net Tech Docs",
    "summary": "Move The Move page allows you to make a warehouse transfer. To move products from one location to another, you must first select or scan: the current location of the product the product itself Availability indicates the amount of product available at a location. To transfer the whole quantity or the Lot of one product, you can click on the corresponding row in the Availability table. Lot (you can use the suggested value Quantity and unit To add more products, you need to click the Add More button (from the menu button at the bottom of the page). If you move several products at the same time, they will all be transferred to the same place. If you want to transfer them to different places, they must be moved separately. Press the Move button to finish the process. The last step is to set the new destination of the products. When you are ready you need to press the button. If all the steps are performed correctly, a message will appear confirming that the operation was successful:"
  },
  "modules/logistics/wms/wms-worker/orders/index.html": {
    "href": "modules/logistics/wms/wms-worker/orders/index.html",
    "title": "Orders | ERP.net Tech Docs",
    "summary": "Orders This screen gives access to all upcoming warehouse orders that are available for execution. They are distributed into five sections and sorted in an ascending order in each. Search and totals Above the sections, there is a search bar that can be used to filter the existing orders. You can search by scanning or entering an order number, a party name (if any), or any information set up by Order display format For reference, the Total number of orders can be checked at the bottom-left corner of the page. Context menu The Orders screen features a Context menu, accessible through the three-dot button at the bottom. It allows you to execute the following actions: Refresh - When triggered, it will instantly refresh the contents of the page, taking into account orders previously not added and dismissing the ones that have been voided. Order details Once you open an order, you can see the following details about it: Order Display Format - the same Display format from the orders list Assigned To - the Worker to which the order is assigned Document Date - the date of the order Creation Time - the time and date of creation of the order Status - the status of the order Lines Count - the number of the order's lines Total Qty - the sum of product quantities; if there are lines in different measurement units, there will be separate totals for each unit Total Base Qty - the overall quantity of individual products, grouped according to the respective measurement unit (e.g. 8 sets total qty equals 96 pcs base qty). Section breakdown The Orders screen consists of five sections. Depending on a warehouse's organization and processes, the warehouse manager can assign orders to workers or they can take the orders they want to execute. In some warehouses, orders can be executed by one or multiple workers. Started by me These are all orders assigned by the warehouse manager to a specific worker who is expected to execute them. They are all Released and appear only for the currently logged-in user in this section. Assigned to me Similarly to Started by me, the orders in this section are assigned by the warehouse manager to a specific worker who is supposed to execute them. The section contains Planned and Firm Planned orders which are assigned to the currently logged-in user. Unassigned This section is meant for scenarios where warehouse managers do not assign orders but workers simply take them instead. It contains Planned and Firm Planned orders which are not assigned to a specific worker and can be executed by anyone who takes them. Started by others In this section, orders can be executed by two or more workers, one of which is responsible for the orders and the other cooperating in their execution. It contains Released orders which are assigned to users different from the currently logged-in one. Assigned to others The orders in this section are assigned to a specific worker and visible to the current user (who can also take them). It contains Planned and Firm Planned orders which are assigned to users different from the currently logged-in one. Action buttons When accessing an order, different buttons will be visualized based on the section you access the order from. They indicate the action you're able to perform. Clicking some of them will result in the order being moved to a different section. Started by me Accessing an order from here reveals general information about it, as well as a dedicated Continue button. Upon clicking it, you'll open the order and will be able to continue with its processing. Assigned to me Accessing an order from here reveals general information about it, as well as a dedicated Start button. Upon clicking it, the order will be released and opened. Unassigned Accessing an order from here reveals general information about it, as well as a dedicated Take & Start button. Upon clicking it, the order will be assigned to you, released and opened. Started by others Accessing an order from here reveals general information about it, as well as a dedicated Join button. Upon clicking it, you'll open the order. Assigned to others Accessing an order from here reveals general information about it, as well as a dedicated Take & Start button. Upon clicking it, the order will be re-assigned to you, released and opened. Policies for order section visibility There are three warehouse policies determining which sections can be seen and which will remain hidden. They apply for the entire store, not taking into account any provided zones, products, or other filters. Here's a brief summary of each: Unassigned Orders Section Visibility - covers the \"Unassigned\" section If set to True, the section will be visible for all workers defined for the respective store If set to False, it will be hidden from them If a policy is not specified, the section will be revealed by default. Started by Others Section Visibility - covers the \"Started by others\" section If set to True, the section will be visible for all workers defined for the respective store If set to False, it will be hidden from them If a policy is not specified, the section will be revealed by default. Assigned to Others Section Visibility - covers the \"Assigned to others\" section If set to True, the section will be visible for all workers defined for the respective store If set to False, it will be hidden from them If a policy is not specified, the section will be revealed by default. Note For more information about these policies, please refer to Warehouse policies. Order lines Once an order is taken, started, continued or joined, a summary of its lines will show up: On this screen, you will find three tabs dedicated to line execution: All - shows all lines of the order regardless of whether they have been executed or not Remaining - shows rows that have not yet been executed Executed - shows the rows that have already been executed All lines contain information about the requested product and its quantity. No - shows the line number and its associated task (e.g. Receive) Location - shows the location of the product Product - shows the product itself Order/Exec - shows what quantity of the product needs to be procured compared to what quantity has already been executed A check mark will appear on the right of the Order/Exec counter only if the line is fully executed. More details about each line, e.g. the full name of the product, the ordered lot, variant, serial number, etc. can be accessed via the line's respective info button. If an execution has already taken place, the Info screen will include details about it as well. At the top of the screen, there is a general Scan field. When scanning a value in this field, a matching unexecuted line is searched through the lines list. If such a line is found, its execution is started automatically. Note The scanned value recognition is done by Barcode Parsers such as Product Code and GS1 - Single Product. The list of currently active parsers can be seen by accessing the vertical three-dot Menu button at the bottom of the app. Order line actions At the bottom of the screen, there are buttons for managing the order: Stop - terminates the order Execute - allows for line execution; will change to Complete Order when all lines have been executed Menu - allows access to several additional functions like: Refresh, which will instantly refresh the contents of the order Suggest Routing Active Parsers"
  },
  "modules/logistics/wms/wms-worker/orders/lines-execution.html": {
    "href": "modules/logistics/wms/wms-worker/orders/lines-execution.html",
    "title": "Lines Execution | ERP.net Tech Docs",
    "summary": "Lines Execution Order line execution begins when you press the Execute button in the lines list or scan a code that matches a line. Before starting, ensure you are familiar with the scanning process. Once execution starts, you will go through several steps. Step 1: Location The system first prompts you to scan the location of the product. If a suggested location exists, you can either scan the actual location or click Use to apply the suggested one. If there is a Current Location already stored (as described in the previous documentation), the location screen will be skipped, and the system will automatically apply the stored location to the order. If there is no suggested location or if you prefer to scan a different one, simply scan the correct location. Step 2: LUN (Logistic Unit) After the location is confirmed, the system will prompt you to scan the Logistic Unit (LUN). If a suggested LUN is available, you can either scan it or click Use to apply the suggested one. If there is a Current LUN already stored (as described in the previous documentation), the LUN screen will be skipped, and the system will automatically apply the stored LUN to the order. If there is no suggested LUN or you prefer to scan a different one, simply scan the correct LUN. Step 3: Product After confirming the location and LUN, the system will prompt you to scan the product. If the product is already entered in the SCAN field, the Product screen will be skipped, and the system will automatically apply the scanned or suggested product. If the product has not been scanned or suggested, you will need to manually scan or select the correct product. Step 4: Lot (if applicable) If the product belongs to a lot, the system will ask for the lot number. A suggested lot might appear, and you can use it by clicking Use, or enter the lot manually if it is not pre-filled or scanned. You can refer to the Availability screen if you need to check lot details. Step 5: Serial Number (if applicable) For products with serial numbers, the system will request the serial number, which may or may not have a suggestion. You can either scan the serial or use the suggested one. Once the serial number is confirmed, the Quantity field will be skipped automatically. Step 6: Quantity Next, the system prompts for the quantity of the product. You can either manually enter the quantity or click the arrow button to use the suggested quantity. If a quantity has already been entered in the SCAN field or if there is an active policy that allows accepting a quantity of one, the Quantity screen will be skipped, and the system will automatically apply the entered quantity. If necessary, you can also change the unit of measurement for the product. Note Standard Quantity For products with variable measurement ratios, the system will display a standard quantity value. Modifying the base quantity will automatically recalculate the standard quantity, but the standard quantity itself cannot be directly modified. Info Panels The system includes several info panels available on all screens during order execution: Info, Availability, Order, and Picture. These panels display context-specific information, such as stock details by location on the Location screen, by logistic unit on the LUN screen, etc. The system tracks the last state of each panel (opened or closed). Depending on your usage, the panel will maintain its previous state when you continue with your tasks, streamlining the workflow. Complete Order Once all information is confirmed (location, product, LUN, lot, serial number, and quantity), you can proceed to complete the order. Press the Complete Order button to finalize the process. A confirmation dialog will appear, asking for permission to change the order status to Completed. After confirming, the system will return you to the main Orders page, where you can select a new order to execute. Conclusion As in previous versions, you can also scan or enter a product directly into the SCAN field. If a location, product, and logistic unit (LUN) are all scanned, followed by a quantity, and no additional information such as lots or serial numbers is required, the system will skip the usual execution steps for that line. Instead, the line will be automatically executed with the scanned or entered data, including the location, product, LUN, and quantity, without the need to go through the individual screens for each step."
  },
  "modules/logistics/wms/wms-worker/orders/scanning.html": {
    "href": "modules/logistics/wms/wms-worker/orders/scanning.html",
    "title": "| ERP.net Tech Docs",
    "summary": "Single Scan To scan a product once, simply scan or manually enter its product or additional code into the SCAN field and tap the blue arrow button. This will initiate the execution of the line for that product. During execution, the system will guide you through the necessary screens for Location, Lot, Logistic Unit, and any other required information. After completing these steps, you will be prompted to enter the Quantity. Note This topic is only for scanning simple codes, if you want to read about GS1 or SSCC codes, click here: GS1 Barcodes Work with quantity, current location, and currnet logistic units (LUNs): Note Next functionalities correspond to Parsers (P04, P05, and P06). If you'd like to learn more about barcode parsers, click here: Barcode Parsers Multiple Scans To scan a product multiple times, scan or manually enter the desired quantity into the SCAN field and tap the blue arrow button to confirm. Quantities over 999 must be followed by (\"*\"), while for quantities up to 999, the asterisk is optional. If the asterisk is omitted for smaller numbers, the system will still recognize it as a quantity. For example, scanning or entering \"200\" will be understood as a quantity of 200, and \"200*\" is also valid. The quantity entered will be displayed in a separate field under the main SCAN field, and this quantity will apply to the product scanned after it. Current Location The SCAN field recognizes locations. When scanning a valid location from the Logistics.Wms.WarehouseLocations entity (ERP.net Domain Model), the location will appear as a line under the SCAN field, similar to how quantities are displayed. The location line will appear below the quantity line. Once a location is scanned, it will be stored in the WMS Worker’s memory until another location is scanned or it is removed by clicking the X. If a location is scanned and then a product from the list is scanned, both the location and product screens will be skipped, taking you directly to the quantity screen (unless there are lots, serial numbers, etc.). After completing a line, the worker will return to the line list, with the current location remaining. If another product is scanned, the same process will repeat. If there is a current location and you execute a line instead of scanning a product, the location screen will be skipped, and the stored location will be automatically applied to that line. Current Logistic Unit The SCAN field supports scanning Logistic Units (LUNs) that are not in SSCC format. When a valid LUN is scanned, it will be displayed as a line under the SCAN field, following the same structure as quantities and locations. The LUN line will appear below both the quantity and location lines. Once a LUN is scanned, it will remain stored in WMS Worker’s memory until another LUN is scanned or the current LUN is removed by clicking the X. If a LUN is scanned followed by a product from the list, the LUN screen will be skipped. If there is also a current location, both the location and product screens will be skipped, and the user will go directly to the quantity screen (unless there are lots, serial numbers, etc.). After completing a line, the worker will return to the line list, and the current LUN will remain. If another product is scanned, the same process will repeat. If a current LUN is stored and a line is executed without scanning a product, the LUN screen will be skipped, and the stored LUN will be automatically applied to that line. Note A logistic unit (LUN) cannot have availability in more than one location. If an attempt is made to place a logistic unit in a location while it already has availability in another location, an error will be thrown. So if availability exists for the selected current LUN, the system will automatically set the Current Location to match the LUN's assigned location. Updated Scan Priorities The updated scanning priorities are as follows (from highest to lowest): Quantity, Location, LUN, Product. If the same code is used for both a location and a LUN (which is rare), the scan will be treated as a location. If the scanned code is not recognized as a quantity, location, LUN, or product, an error message will be displayed: EN: \"No location, LUN, or product was found with the scanned code.\""
  },
  "modules/logistics/wms/wms-worker/orders/suggest-routing.html": {
    "href": "modules/logistics/wms/wms-worker/orders/suggest-routing.html",
    "title": "Suggest Routing | ERP.net Tech Docs",
    "summary": "Suggest Routing Workers who physically pick items for warehouse orders utilize picking routes to efficiently navigate the process. Such routes are calculated using the Suggest Routing UI function, accessible in the Orders menu of the WMS worker. Parameters to consider A picking route considers various parameters configured for the warehouse, including: Zones: These are designated as picking zones through the \"Zone Type\" policy. To properly use the function, ensure that \"TaskType == Dispatch\" and \"ZoneType = picking\". Location Addresses: These addresses are essential for calculating the optimal route through the warehouse. For each address, ensure that \"ZoneType == Picking\". Availability: The system suggests locations with enough availability to execute the respective order lines. However, this can be disabled in favor of a more custom setting, where locations are suggested as strings based on their Address or the user-defined value specified in the CustomRouting policy. In all cases, only locations with availability greater than zero are suggested. Lot Expiry Date: This ensures that items nearing expiration are prioritized. Note The Suggest Routing function can only be utilized for dispatch warehouse orders, specifically those whose lines consist solely of \"Dispatch\" or \"Comp-dispatch\" task types. Policy The Suggest Routing function follows a specific RoutingAlgorithm policy through which it calculates how to suggest locations. This policy allows users to define their own routes for collecting warehouse products. It achieves this by assuming the Code of a location as its primary value. Therefore, the policy can have one of two values applied: Fixed - Suggested locations are ordered by the strings of their addresses or by priority values specified in the CustomRouting policy. Availability of the locations is not taken into account, except that it must be greater than zero. Smart - Suggested locations are ordered by the strings of their addresses or by priority values specified in the CustomRouting policy. Locations must have enough availability to fulfill the specific line in order to be suggested. In case no policy is defined, the default Smart behaviour is applied. Upon identifying whether the policy is Fixed or Smart, the Suggest Routing function is able to return the appropriate location(s). Note If a Fixed RoutingAlgorithm policy is applied, it will come into effect in the WMS Worker and the warehouse order definition, as they both can utilize the Suggest Routing function. Using the function Start by opening the Orders menu of WMS Worker. This takes you to the list of orders that are available for execution for the current worker. Click on the outbound order you would like to execute. This will open a screen containing the lines of the order and their details. At the bottom of the screen, you will find a three-dot button, from which you can access the Suggest Routing function. This will start the processing of the lines and the calculation of the function. When the processing is done, the function will load all Locations that were successfully determined in the Location column. This will form the route that you need to follow sequentially to collect all products from the order. The lines will be automatically sorted by the location address or user-defined values specified in the CustomRouting policy. If defined, the RoutingAlgorithm policy will determine whether locations with enough availability or any availability greater than zero are shown. To begin following the route, click the Execute button. This will lead you to the first screen which contains information about the suggested Location. When you reach the Location, scan it and perform the rest of the line execution as usual. Once the execution of the first line is finished, the system will bring you back to the lines menu. The next line will be automatically selected and available for execution, thus leading you to the next Location of the route. Incomplete suggestions Order lines for which the function could not find a suitable Location to suggest will be sorted last - after all lines with successfully suggested locations. This way, when you finish following the suggested route, you can still execute the remaining lines without suggestions. The system will not guide you to a particular location. However, the Location screen during the line execution will contain convenient panels like Availability, which you can use to find a location from where you can still pick the product."
  },
  "modules/logistics/wms/wms-worker/pack.html": {
    "href": "modules/logistics/wms/wms-worker/pack.html",
    "title": "Pack | ERP.net Tech Docs",
    "summary": "Pack The Pack menu allows you to add Contents to a Logistic Unit (LU). Using this menu, you can either create a new Logistic Unit or choose to add the contents to an existing one. If you are creating a new LU, then the system will automatically assign an SSCC code, and fill in the Contents and the applicable Specifications. To Pack the contents, first, select or scan the Location where they are contained: The system will open a screen with a list of the Location’s content that is available to pack. There you can: Scan each Product you want to pack and specify its Lot, Variant, Serial (if applicable), and Quantity Click on any of the lines of the content to select it and specify the quantity you want to pack or if you want to pack all of the Location’s contents, you can simply choose the Select All option in the buttons menu. Once, you have selected the desired content, press the Pack button. This will show a screen where you need to choose the logistic unit you want to pack the Contents – you can either create a new one or select an existing LU. You can create a new LU using the Create logistic unit now button. This will automatically assign/create a new LU with a new SSCC code, and fill in the Contents and the applicable Specifications. The SSCC code is calculated according to the algorithm specified here. The Contents panel of the new LU is filled in with the selected content during the Pack, which can be reviewed in the Contents table on the current screen. The Specifications are filled in according to the following criteria: Code Name Value Applicable 00 SSCC LogisticUnit.SerialCode Always 02 CONTENT Product’s GTIN* Only if the LU has 1 content 10 LOT CONTENT.Lot Only if the LU has 1 content 17 EXPIRY CONTENT.Lot.ExpiryDate Only if the LU has 1 content 20 VARIANT CONTENT.Variant Only if the LU has 1 content 21 SERIAL CONTENT.Serial Only if the LU has 1 content 37 COUNT CONTENT.Quantity Only if the LU has 1 content AND CONTENT.Quantity is integer *Product’s GTIN – If there is a CodingSystem with the Name “GTIN” and it contains a Product Code for this product, then it is taken. Else take the CONTENT.Product.PartNumber. If you want to select an existing LU you can scan it in the Logistic Unit field or to choose it from the dropdown list. Note that in this case the LU's Contents and Specifications will not be updated automatically. The last step is to select the new Destination location of the LU and press the Finish button to complete the process. If all the steps are performed correctly, a message will appear confirming that the operation was successful:"
  },
  "modules/logistics/wms/wms-worker/reconcile.html": {
    "href": "modules/logistics/wms/wms-worker/reconcile.html",
    "title": "WMS Worker - Reconcile Menu | ERP.net Tech Docs",
    "summary": "WMS Worker - Reconcile Menu The Reconcile menu allows you to make a comparison between the quantity of the product counted by the employees and the expected availability. The final records for any discrepancies are saved when the Finish button is clicked. Reconcile by Location or Logistic Unit (LUN) You can choose to perform the reconcile by Location or by Logistic Unit (LUN): Reconcile by Location: If you scan or select a Location, the system will then ask you to enter the Logistic Unit (LUN). After selecting the LUN, the system will proceed to the next screen, where a list of products contained within that LUN is displayed. Reconcile by LUN: If you enter or scan a LUN directly, the system will automatically identify the associated Location and skip asking for it. You will be taken directly to the list of products contained in that LUN. Product Information The system will give you a summary of the information it has for that product: The last column in the table shows the Expected availability compared to the one counted by the employee (Counted). Entering Quantities When you have counted the quantity of a product, you can enter it in the Quantity field (either click on the row in the table or click Next until you are asked for the quantity): After clicking the Next button, the corresponding row in the table will be colored. If Expected and Counted are equal, the row will be colored green, but if the numbers are different, it will be colored red, indicating an error: Deleting Counted Data If the Counted data needs to be deleted, this can be done by clicking on the Recycle bin icon on the right. Review and Total Difference When the counting is complete, you can see a Review of all rows in the table with their matches and differences. If there are rows in which no counted information is entered, they will be displayed with negative values of the expected quantity. This means that these products may have been available, but since they were not reported, they are recorded as missing. Review shows the results of the counting and in that sense - the Reconcile of the whole location. Total difference shows the reported differences at this Location. Finish and Save The button means that the counting is complete, and you are ready to save the data to the system. If all the steps are performed correctly, a message will appear confirming that the operation was successful:"
  },
  "modules/logistics/wms/wms-worker/start.html": {
    "href": "modules/logistics/wms/wms-worker/start.html",
    "title": "Start | ERP.net Tech Docs",
    "summary": "Start Important The following function is scheduled to be deprecated in v24. For more up-to-date information, please refer to Orders. The \"Start\" function allows the warehouse worker to initiate work on a selected Warehouse Order (WO) from his „ASSIGNED TO ME“ task list. After clicking on the WO, a window containing general information about it opens, and in the lower right corner of the window, you will find the \"Start\" button. By clicking the \"Start\" button, the order execution window is automatically loaded, enabling work to begin immediately."
  },
  "modules/logistics/wms/wms-worker/system-requirements.html": {
    "href": "modules/logistics/wms/wms-worker/system-requirements.html",
    "title": "System requirements | ERP.net Tech Docs",
    "summary": "System requirements Although WMS workin is web-based and does not require any installation, there are some minimum system requirements that should be met. Browser WMS Worker is supported in the browsers shown in the following table. Browser Version Google Chrome, including Android Current* *Current refers to the latest version of the browser. OS The minimmum requirement of the operational system is Android 8.0 (Oreo) or higher. Devices Mobile RF handheld devices Requirements: Minimum RAM: 1 GiB, recommended: 2 GiB or higher Minimum Processor: 1 GHz Recommendations: The manufacturers device software should allow to configure following scanner settings on the device: Convert barcode input via scan head or camera to text Possibility to give an automatic ENTER after a scan Identifies GS1-128/EAN128 barcodes (when such is used in the warehouse) Note Please consult with both your implementatorand and device provider before purchasing a device. They will help you determine the specific requirements that would be most appropriate for the specifics of your business. Compatible devices The following Android devices have been tested: Zebra MC9300 Zebra TC77 M3 Mobile SL20 Note Other models may work as well when meeting the other requirements in this document but cannot be guaranteed. Test device compatibility You have a mobile RF handheld devices and you want to make sure it is compatible with WMS Worker? We've created a test environment where you can test your device and the WMS Worker in action. Тo test your device, just follow these steps: Open the following link in the browser of the mobile terminal https://testdb.my.erp.net/cl/wmsworker user: admin password: 123 Select Orders Select Warehouse Order 0000000011 Click Open => the first line is atomatically selected. Click Execute Scan the Location Scan the Product Enter the lot \"AL00001\" code using the keyboard or select it from the drop-down list. Enter the quantity 5 PCS using the keyboard. Press Next You have successfully executed a warehouse order line with your device!"
  },
  "modules/logistics/wms/wms-worker/take.html": {
    "href": "modules/logistics/wms/wms-worker/take.html",
    "title": "Take | ERP.net Tech Docs",
    "summary": "Take Important The following function is scheduled to be deprecated in v24. For more up-to-date information, please refer to Orders. In the \"Orders\" menu of the WMS Worker, two categories are displayed: „ASSIGNED TO ME“ and “UNASSIGNED”. The “Take” function allows the warehouse worker to select a Warehouse Order (WO) from the “UNASSIGNED” list and assign it to himself. The WO will quickly and easily appear in their „ASSIGNED TO ME“ task list for execution. Note All Warehouse Orders in the \"UNASSIGNED\" list are in \"Planned\" or \"Firm planned\" state. From the order navigator, by pressing the “Take” button in the bottom left corner of the screen of the corresponding WO, the warehouse worker takes the chosen unassigned order. After confirmation, the window for execution the order automatically opens, allowing him to start working on it immediately. The \"Assigned to\" field is automatically filled with his own name, the state of the Warehouse Order is changed to \"Released\", and it becomes visible in his \"ASSIGNED TO ME\" tasks list."
  },
  "modules/logistics/wms/wms-worker/unpack.html": {
    "href": "modules/logistics/wms/wms-worker/unpack.html",
    "title": "Unpack | ERP.net Tech Docs",
    "summary": "Unpack The Unpack menu allows you to unpack the Contents of an Logistic Unit (LU). Note that this menu is used to unpack the entire LU. If you want to unpack only part of the LU contents, you can use the Move menu, where you can uncheck the \"Move the whole logistic unit\" option. To Unpack a LU, first, select or scan the desired Logistic Unit: The system will list of the availability in this LU. The last step is to select the new Destination location of thе unpacked contents and press the Finish button to complete the process. If all the steps are performed correctly, a message will appear confirming that the operation was successful:"
  },
  "modules/my/calendar.html": {
    "href": "modules/my/calendar.html",
    "title": "My Calendar | ERP.net Tech Docs",
    "summary": "My Calendar The ERP.net Calendar is a powerful time-management tool, allowing you to efficiently organize, monitor and synchronize your personal activities, events and tasks. It also sums up group activities from the social groups you take part in, whenever you are marked as the responsible person, organizer, or a participant. Time period The Calendar allows users to specify custom time periods, such as specific hours within a day or a range of dates spanning multiple days, weeks, months, or years, depending on their scheduling needs. To change the calendar's display, access the dropdown menu at the top left of your page and select either Month or Workweek views. Note You can also adjust the Calendar display view from the Panel menu of the Calendar page. To revisit past events or navigate to a specific week or month, use the arrow buttons. Depending on whether you're in the Month or Week view, this will adjust the calendar accordingly. Depending on your current view, you can select a specific week or month from the blue-colored menu. Use the mini-calendar to select a specific date, month, or year. If you've navigated away and wish to return to the present date, simply click Today. Create an event Your events are summarized and displayed within the Calendar, with their titles fitting into the respective time slots, covering activities where you are designated as assigned owner status, or added as a participant. To start creating an event, you have to click on the date and press the Create button. With this button you can choose to create meeting, task or to mark the day as a sick day. This action will lead you to a dedicated page where you can provide necessary information regarding the activity and individuals who may be involved. Another way is to doble click on the selected date and you will find yourself on the New Activity creation form, where you can fill in basic information for the meeting, task or reminder you want to set. In the process of event creation it is important to fill the filds that will provide the information about the event. These fields serve as crucial conduits for relaying essential information to all intended participants. You can add the name of the document, of the subject you wish to discuss, priority level of the meeting and responsible person for the task. When you're finished, click Save and reload, and the activity will be added to your Calendar. You can also create events from the Panel menu of the Calendar page. When you click on the selected date and click Panel menu that will give you the chance to create event. Access an event If you want to check a specific information about your event you can access it through the calendar. When you click on a date containing an event, a circular button will emerge at the top-right corner, giving you access to more details, like the event's scheduled hours. Edit Event You can open the event by clicking on its title, which will display all its details and list of potential participants. If you wish to edit any aspect, such as the subject, the date or any other aspects you can click the edit button on the top left corner. Upon saving the changes, they will be immediately reflected in the Calendar. Panel menu In the Panel menu you can maximize your screen, adjust Calendar view types and create events. The Calendar is not confined to a single location. Upon accessing your personalized Dashboard, you will find it integrated as a panel, accessible whenever needed. Here, all its features are centralized alongside other vital ** My** components, offering a cohesive user experience. Additionally, you have the freedom to rearrange the Calendar panel by opening the Customize window of the Dashboard and dragging it to your preferred position."
  },
  "modules/my/groups/create-a-group.html": {
    "href": "modules/my/groups/create-a-group.html",
    "title": "A step-by-step guide on how to create a group | ERP.net Tech Docs",
    "summary": "A step-by-step guide on how to create a group Here, you will find a detailed guide on how to create a new group ERP.net. Creation process Access Groups by first navigating to the My section in the menu, then selecting Groups. To create a group, click the icon on the top right of the group list. Then, a new tab will open where you can add the users you wish to include in the new group and provide a name for the group. As you begin typing a user's name, the platform will offer suggestions to streamline the process. Following this, you'll need to compose the first message for the group and send it. This action will complete the creation process."
  },
  "modules/my/groups/features-in-groups.html": {
    "href": "modules/my/groups/features-in-groups.html",
    "title": "Features in Groups | ERP.net Tech Docs",
    "summary": "Features in Groups Groups is a sub-section of My that provides a convenient platform for effortless communication, document exchange, task scheduling, and assignment among you and your colleagues. Groups are created by an admin in the platform when they are needed, between people in the same company. Chat The Chat feature facilitates rapid communication among group participants. It offers standard industry features such as message previewing and sending, reacting to and replying to messages from others, and even editing one's messages. Calendar The calendar feature enables authorized members to create and view a range of events and meetings, visible to the entire group. Any group activities you create or participate in will also be reflected in your Calendar. Time period of the calendar To adjust the time period displayed on the calendar, utilize the dropdown menu. You can select whether you prefer the period type to be Month or Workweek. Create a new activity Use the Create button to create a new activity. Choose the type of activity you want to create from the drop-down list. To create a new activity you need to fill a form with information about the activity and the participants in it. Once you filled every field, click Save and reload and the activity will be added to the calendar. To Do The To Do tab showcases tasks assigned to both yourself and fellow group members, allowing you to mark those ready for completion. With Member or Admin permissions, you can create new tasks and assign them to others. Any to-dos added or assigned to you will also be visible in your personal Do space. Create a task To create a task click on the circular button with a + on it. You can establish both a reminder and a due date for the task. Once you’ve given a name and have set up the reminder, the person it’s assigned to, and the due date, click on the Create button to add it to the list of tasks. Once the task is completed, click on the radio button next to it to mark it as done. Tasks also offer various statuses like New, In** Progress**, or Waiting to indicate their progress. Files Within the Files tab, you have access to file attachments uploaded by either yourself or other group members. Each file includes details such as its format, the name of the author, and the date and time of upload. Upload files To upload files to the group, click on the cloud icon located at the top left of the screen. Upon doing so, a new window will appear. Here, you have the option to either drag and drop the file you wish to upload or browse your files and select the desired one. File settings To download or delete a file from the group, click on the three-dot button situated on the right side of the file. From there, you can select the desired option to proceed. Members The Members tab contains a list of all members within the current group along with their respective roles. Admins have the exclusive authority to add or remove participants and adjust their permission levels as needed. Admin settings Users assigned the Admin role within the group possess the authority to add members, modify their roles, and remove them from the group. Add member To add a new member to the group, click the Add member button in the top left corner. This action will prompt a new window to appear, where you'll need to input the individual's name or email address and specify their role within the group. As you begin typing the name or email, a drop-down menu will provide suggestions to assist you in locating the user. After completing the necessary steps, click OK to confirm and finalize the process. Change role To modify a member's role, click on the settings icon located on the right side of the user's profile. Then, click on the Change role to option. This will open the roles drop-down menu, allowing you to select the new role you wish to assign to the member. Remove participant To modify a member's role, click on the settings icon located on the right side of the user's profile. Once you’ve done that click the Remove participant button."
  },
  "modules/my/groups/index.html": {
    "href": "modules/my/groups/index.html",
    "title": "Tech overview of Groups | ERP.net Tech Docs",
    "summary": "Tech overview of Groups Groups, found within the My section, serve as a convenient platform for seamless communication, document sharing, task scheduling, and assignment among you and your colleagues. Admins within the platform create groups as needed, facilitating collaboration among individuals within the same company. Features Here's a brief overview of the features at your disposal: Chat - Enables rapid communication with message previewing, replying, and editing capabilities. Calendar - Facilitates event creation and viewing with options to adjust periods and create new activities. To Do - Displays tasks assigned to group members, allowing task creation, assignment, and marking as complete. Files - Provides access to uploaded file attachments with options for uploading, downloading, and deleting files. Members - Lists group members and their roles, with Admins having authority over adding, modifying roles, and removing participants."
  },
  "modules/my/groups/pictures/index.html": {
    "href": "modules/my/groups/pictures/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/my/index.html": {
    "href": "modules/my/index.html",
    "title": "Overview | ERP.net Tech Docs",
    "summary": "Overview The My module is a personalized environment housing information that is essential to your day-to-day activities. It consists of several applications that are simultaneously independent, interconnected, and can also be integrated as panels in other ERP.net modules. In the My module, you can find the following applications: Dashboard Groups Calendar To Do Timeline Tiles Favorites Notifications Documents If you want to learn more about them, please refer to their respective technical guides. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/production/index.html": {
    "href": "modules/production/index.html",
    "title": "Production | ERP.net Tech Docs",
    "summary": "Production To be updated."
  },
  "modules/projects/index.html": {
    "href": "modules/projects/index.html",
    "title": "Project Management | ERP.net Tech Docs",
    "summary": "Project Management To be updated."
  },
  "modules/system/index.html": {
    "href": "modules/system/index.html",
    "title": "System | ERP.net Tech Docs",
    "summary": "System The System module forms the foundational infrastructure of ERP.net, facilitating functions such as data management, security configuration, process monitoring, and business automation. It enables efficient customization, secure access control, and integration with external systems, ensuring operational support and regulatory compliance. Business Processes Business Processes automates and visualizes business workflows through user-defined rules, calculated attributes, and property management. It supports process optimization and ensures seamless operational efficiency with detailed process diagrams. Configuration Configuration centralizes the setup and management of system-wide options, jobs, translations, and web integrations. It provides the tools to customize and optimize system behaviour and performance according to organizational needs. Document Flow Document Flow handles the management and customization of document-related processes, including roles, print layouts, and types. It supports efficient document transactions and workflow management through configurable data sources and numbering sequences. Monitoring Monitoring tracks and manages system activities, audit logs, and performance metrics. It offers dynamic views and definitions to ensure operational efficiency, compliance, and real-time system health monitoring. Security Security provides robust mechanisms for managing user access, permissions, and roles, ensuring data protection and secure integration with external applications. It includes tools for setting up user domains, groups, and system-wide permissions. Internal System Data Internal System Data manages and tracks the essential data elements and configurations within the system. It ensures data consistency, version control, and comprehensive auditing for robust data management."
  },
  "modules/system/security/groups/index.html": {
    "href": "modules/system/security/groups/index.html",
    "title": "Groups | ERP.net Tech Docs",
    "summary": "Groups Groups are designed to provide predefined level of access to secure data for specific users. This is integral to ensuring the appropriate allocation of responsibilities within the platform. Group types Any custom groups can be created freely. However, there are only a few types that can be assigned to them: Normal user-definable group Default type with limited access to the platform. System group for one user (cannot be modified as it is system-defined) Full access to the platform and its features. Exclusive to one user. Administrators (cannot be modified as it is system-defined) Full access to the platform and its features. Everybody (cannot be modified as it is system-defined) General access to the platform without limitations to user participation. Power users (cannot be modified as it is system-defined) Expanded access that offers more than the user-definable group but less than that for administrators."
  },
  "modules/system/security/groups/pictures/index.html": {
    "href": "modules/system/security/groups/pictures/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/system/security/groups/power-users.html": {
    "href": "modules/system/security/groups/power-users.html",
    "title": "Power Users | ERP.net Tech Docs",
    "summary": "Power Users Power Users is a system-defined group type that serves as an intermediate tier between administrators and regular users. It offers elevated permissions without granting full administrative privileges. The Power Users group can manage access rights via the Security panel (Desktop) and Access Permissions panel (Web), which are hidden by default for regular users. This reduces Power Users' dependency on administrators for certain security tasks. System Data GroupType Value: P Description: PowerUsers Database Value: P Model Value: 4 Note The Power Users group is assigned the Manage Access Permissions key which enables it to view and interact with the Security/Access permissions panel. Key features Members are always manually added to the Power Users group. Unlike in the Administrators group type, there is no checkbox or automated assignment process. The Power Users group cannot be edited directly by users. This includes changing its name and header. Any attempt by users to modify it will result in an error, handled by business rule R37166."
  },
  "modules/system/security/index.html": {
    "href": "modules/system/security/index.html",
    "title": "Security | ERP.net Tech Docs",
    "summary": "Security The Security section focuses on managing access controls and permissions within the system to safeguard sensitive data and ensure adequate user interactions. It plays a crucial role in maintaining the integrity and confidentiality of ERP.net system data and operations. It offers features such as defining user roles, configuring system permissions, managing access keys for data security, and controlling the visibility of UI elements based on roles and preferences. In addition, you can perform a variety of UI functions. Definitions Groups Groups of users with collective access to secure data. Trusted Applications Applications trusted to access ERP.net data securely. Users All user logins with assigned roles within the system. Setup Domains Represents user domains with distinct email configurations, organizing users into separate administrative units. Entities Contains entities which can have specific access permissions granted. Roles Various roles granting different permissions and capabilities, applicable to existing users. Views System Permissions Controls access to different parts of ERP.net based on predefined permissions. System Data Access Keys Provides a basic locking mechanism for data security by assigning access keys to records. Column Permissions Manages user permissions for accessing specific system data columns. External Applications Lists external applications authorised to run operations. Visual Permissions Manages permissions for client applications to show/hide UI elements based on user roles and preferences."
  },
  "modules/system/security/system-permissions/index.html": {
    "href": "modules/system/security/system-permissions/index.html",
    "title": "System Permissions | ERP.net Tech Docs",
    "summary": "System Permissions The System Permissions panel serves as a central hub for managing user access to various platform functionalities. Administrators can grant or restrict permissions by assigning specific system keys to security groups. These keys define what actions users can perform and which sections they can access. Each security group can have its own set of specific permissions. If a system key is not assigned to any group, all users automatically have access to it. For instance, the visibility of the Security panel (Desktop) and the Access Permissions panel (Web) is controlled by the Manage Access Permissions key."
  },
  "modules/system/security/system-permissions/manage-access-permissions.html": {
    "href": "modules/system/security/system-permissions/manage-access-permissions.html",
    "title": "Manage Access Permissions | ERP.net Tech Docs",
    "summary": "Manage Access Permissions The Manage Access Permissions key grants selected security groups access to the Security panel (Desktop) and the Access Permissions panel (Web). Only groups assigned this key can view and access the panel in its respective environment. Key features The Manage Access Permissions key: Allows the Power Users and Administrators groups to see and access the Security/Access Permissions panel. Restricts visibility to this panel for groups not having the key."
  },
  "modules/system/security/system-permissions/pictures/index.html": {
    "href": "modules/system/security/system-permissions/pictures/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "modules/system/security/ui-functions/confirm-email.html": {
    "href": "modules/system/security/ui-functions/confirm-email.html",
    "title": "Confirm Email | ERP.net Tech Docs",
    "summary": "Confirm Email The Confirm Email function allows administrators to quickly send a confirmation request to the email address specified in a user's profile. It streamlines the overall email verification process by saving time and ensuring a provided address is up-to-date. Important The function will not work if: you're in Edit mode for the user profile; in this case, it will be greyed out the Email field of the user is empty; in this case, it will result in an error the email of the user is already confirmed; in this case, it will result in an error. Using the function in the ERP.net Web Client Below is a step-by-step guide for using the Confirm Email function in the ERP.net Web Client. Navigate to the Users panel and open the user whose email you want to confirm. Make sure this email is specified in their Email field. To trigger the function, click the Run button and select Confirm Email. This will not be possible if you enter Edit mode for the user. A pop-up will appear asking whether you want to send the confirmation email. Click OK to proceed. The user should receive their confirmation request provided that their email address hasn't been already verified. Inside, the message will look like this: \"Hi [User Name], We have received a request to update your email address. Please confirm this change by following this link below: [Link] Thank you for your cooperation. If you did not initiate this process, please contact the system administrator for assistance.\" Note Upon clicking their verification link, a user will be taken to a one-time login form where they need to enter their credentials in order to access their profile. Inside, they can confirm their email address by either changing it or keeping the one they've provided. Using the function in the ERP.net Desktop Client The Confirm Email function can also be executed in the ERP.net Desktop Client. Navigate to the Users navigator and open the user whose email you want to confirm. Navigate to the Functions tab and click on the Confirm Email function. A pop-up will appear asking whether you want to send the confirmation email. Click OK to proceed. The user should receive their confirmation request provided that their email address hasn't been already verified. Email Confirmed status Starting from ERP.net version 25, the Email Confirmed field in the definition of the user will automatically get a check mark if the email confirmation process is successful. This field cannot be modified manually. However, its check mark will disappear if the Email of the user is changed or deleted. In that case, a new confirmation process will be necessary for the email to be verified. If the process is successful, the Email Confirmed field of the respective user will receive a check mark once again. Note This feature will be available from version 25 onward. Your current platform instance may not support it yet. Note The screenshots taken for this article are from v24 of the platform."
  },
  "modules/system/security/ui-functions/index.html": {
    "href": "modules/system/security/ui-functions/index.html",
    "title": "UI Functions | ERP.net Tech Docs",
    "summary": "UI Functions UI functions in the ERP.net Security section consist of automated tools and features designed to speed up the process of user management, ensuring data security and facilitating compliance with organizational policies and regulations. Here, you can learn more about: Confirm email"
  },
  "modules/system/security/ui-functions/pictures/index.html": {
    "href": "modules/system/security/ui-functions/pictures/index.html",
    "title": "| ERP.net Tech Docs",
    "summary": ""
  },
  "reference/config-options-reference.html": {
    "href": "reference/config-options-reference.html",
    "title": "Config options reference | ERP.net Tech Docs",
    "summary": "Config options reference Config options are system settings with global and key importance for the operation of the database. Some of them can be set manually, while others are serviced automatically at system level. IMPORTANT: These settings are of great importance and must be changed with great care and only by trained consultants. The options set for the database are visible in the Configurations navigator and can have different values in each database. А list of configuration keys, their action and possible values: 1. AllowFirmPlannedParentForReleasedChild a.Action: When the key has value and this value is \"1\" the following is allows: released subdocuments of FirmPlanned document are allowed. b.The user sets it manually. 2. CheckForNonVoidedReferencingDocumentsDisabled a.Action: When the key has value and this value is \"1\", verification for references between the documents is not performed when a document is made void. In all other cases, the verification is performed. b.The user sets it manually. 3. CheckForOverexecutionDisabled a.Action: When the key has value and this value is \"1\", verification for over execution of the parent order documents is not performed. In all other cases, the verification is performed. b.The user sets it manually. 4. CheckForOverinvoicedQuantityInSalesOrderLinesDisabled a.Action: When the key has value and this value is \"1\", verification for invoicing greater quantity than the sold quantity is not performed. In all other cases, the verification is performed. b.The user sets it manually. 5. CheckForTransactionMovementTypeDifferentThanParentStoreOrderMovementTypeDisabled a.Action: When the key has value and this value is \"1\", verification that the movement type of the store transaction is the same as the movement type(s) of the parent store order(s) is not performed. In all other cases, the verification is performed. b.The user sets it manually. 6. Default language a.Action: Defines the default language of multi-language fields. For example: en - English, bg - Bulgarian. b.The user sets it manually. 7. Default_Enterprise_Company_Location_Id/XXX a.Action: Defines the default company location. XXX is the ID of the enterprise company. The value is the ID of the default company location. b.Set automatically by the system of the user. 8. Documents/OnlySaveNewVersionsToHistory a.This key is used for compatibility with older versions of the software. The old method of saving a document in the document history is to save the previous version before the current version is saved. The new method is to save the current version. b.Action: When the key has value and this value is \"1\", the new method is applied. In all other cases, the old method is applied. c.The user sets it manually. 9. DontCheckForNegativeUnitPrice a.Action: When the key has value and this value is \"1\", verification for negative values in the Unit Price field is not performed. In all other cases, the verification is performed. b.The user sets it manually. 10. Inv/CheckForNegativeAvailability a.Action: When the key has value \"1\", verification for negative stock balance is performed. The verification checks if the stock balance after the current operation would not become negative and also if the document date is not today's date, the validation checks for not negative stock balance for the dates in the transaction timestamps in the store transaction rows. If the key has an empty value (null) or its value is different than \"1\" the described validations are not performed. b.The user sets it manually. 11. InvoiceFiscalPrintChangeToState (DEPRECATED) a.Action: This key specifies the document state to which an invoice is switched to after the receipt is printed. The key value is the numeric value of the document states (0 = New, 10 = Planned, 20 = FirmPlanned, 30 = Released, 40 = Completed). In all other cases, the invoice is switched to Released state. b.The user sets it manually. 12. InvoiceFiscalPrintUseDistributedAmountsForUnitPrice a.Action: When the key has value and this value is \"1\", the unit price which is sent to the fiscal printer is calculated through the distributed amounts, which are added to the products. In all other cases, the unit price is calculated as follows: the unit price in the document line with VAT included and discounts in the row. b.The user sets it manually. 13. Last_Used_Enterprise_Company_Id a.Action: Defines the last used by the user enterprise company. The value is the id of the enterprise company. b.Set automatically by the system of the user. 14. Last_Used_Enterprise_Company_Location_Id/XXX a.Defines the last used by the user enterprise company location. The value is the id of the enterprise company location. b.Set automatically by the system of the user. 15. Кеу - SalesOrderFiscalPrintChangeToState (DEPRECATED) a.Action: This key specifies the document state to which a sales order is switched to after the receipt is printed. The key value is the numeric value of the document states (0 = New, 10 = Planned, 20 = FirmPlanned, 30 = Released, 40 = Completed). In all other cases, the sales order is switched to Released state. b.The user sets it manually. 16. SalesOrderFiscalPrintUseDistributedAmountsForUnitPrice a.Action: When the key has value and this value is \"1\", the unit price which is sent to the fiscal printer is calculated through the distributed amounts, which are added to the products. In all other cases, the unit price is calculated as follows: the unit price in the sales order line with VAT included and discounts in the row. b.The user sets it manually. 17. SalesOrdersOverduePaymentOrdersCheckDisabled a.Action: When the key has value and this value is \"1\", on sales order document release overdue payment orders check is not performed. In all other cases, such check is performed. b.The user sets it manually. 18. SimpleFilterLayout a.Action: When the value of the key is \"1\", then the \"Use simple layout for filter panels\" option is check-marked and the visualization of the navigator filter panels for the specified user is in the format \"Field OR Value\". If the value of the key is \"0\", then the \"Use simple layout for filter panels\" option is not check-marked and the visualization of the navigator filter panels for the specified user is in the format \"Field: Value\". b.The user sets it manually through File tab → Settings → \"Use simple layout for filter panels\". But if the key is not configured for the particular user, then the system will use the default value. The default value depends on the system version: until Version 2019.1 - the default value is \"0\"; in Version 2019.1 and later - the default value is \"1\" 19. CheckInvoiceLinesQuantityUnitDisabled a.Action: When the key has value and this value is \"1\", when an invoice is released the validation if the measurement unit of the invoice line and the invoiced sales order line are the same is not performed. b.The user sets it manually. 20. AllowBaseAmountsFromThirdDocument a.Action: The action of the current key impacts how the additional amounts are distributed. If amount S and B are distributed on document D1 and amount S depends on amount B. When the current key has value and this value is \"1\" the calculation of the additional amounts is performed as follows: - Each B amount which is distributed on the rows of document D1 participates in the calculation of the base amount of amount S no matter which document defines the B amount. When the current key has a value different from \"1\" or the key does not exist: - Amount B participate in the base amount of S amount only if the B amount is defined by the same document as S amount in the referent document of S amount. The preferred document of S amount is the document on which rows S amount is distributed. b.The user sets it manually. 21. CreateReconciliationsByTimestamp a.Action: When this key has value and this value is \"1\", the function \"Add the available products\" in the reconciliation form and the manually added new rows would use the date of the transaction timestamp in the row, and not the date of the document, to calculate the stocks availability. The stocks availability may be looked at by one of the following methods: - Stock movements in the store by the document date; - Stock movements in the store by the date of the transaction timestamp. b.Usually, the \"i\" method is used to define stock availability (i.e. the quantities at a specified date), and method \"ii\" is used to define the stocks cost (at a specified time) c.The user sets it manually. 22. CostCorrectionsCalculateCostTransferDocumentsCostByDocumentCurrencyReevaluation a.Action: the current key regulates the recalculation of the products costs by the documents which transfer costs (store transfers, work orders, sales returns). When the key has value and this value is \"1\", the recalculation is performed as follows: all costs of the issue and receipt store documents are converted to the currency of the master document (the document which transfers the cost). If not, usually the base currency of the issue and receipt store documents is used for the recalculation. b.The user sets it manually. 23. ActiveLanguages a.Action: Displays the languages which are active in the current database. If there is no value, all languages are active (currently 140 languages are supported). b.Automatically by the form for editing the languages list, which opens from the Edit Languages menu. 24. CheckForTransactionInvalidLotDisabled a.Action: When this key has value and this value is \"1\", the validation for an invalid lot in the store transaction on document release is not performed. An invalid lot is a lot that is defined for a product, different than the product in the store transaction line. In all other cases, the validation is performed. b.The user sets it manually 25. VisualPasteDisabled - suspended a.Action: When this key has value and this value is \"1\", when rows are pasted in a grid they are pasted all at the same time (as it was in version 2.3). In all other cases when rows are pasted in a grid, they are pasted visually - row by row and field by field. Every value is searched between allowed values in drop-down lists. b.The user sets it manually Note This key is suspended in version 2019.1. In its place there are two new functions in forms and navigators: - Paste Rows - Paste Rows Without On-Screen Validation 26. RealTimeEventsDisabled a.When this key has value and this value is \"1\", ERP.net would not proceed connection with the server which sends real-time events. b.The user sets it manually 27. RealTimeEventsTimeoutSeconds a.Action: Sets the timeout period for waiting for a server response for real-time events, in seconds. If the server does not raise an event in the specified time, the client sends a new request. The value is a number between 5 and 240. If null, the timeout time is 240 seconds (4 minutes). b.The user sets it manually 28. Require strong passwords a.Action: When this key has value and this value is \"1\", strong password validation is performed. Strong password requirements are as follows: the password is at least 8 characters; the password contains characters from 3 out of 4 groups: small letters, capital letters, Nonalphanumeric characters, numbers; the password does not contain the username; the password does not contain \"123\", \"1234\", \"12345\", \"123456\". b.The user sets it manually 29. DisableAccountKeyPropertyDotCheck a.Action: When this key has value and this value is \"1\", when an item key is formed in the accounting voucher rows the validation for no '.' (dot) in the values of the key custom, properties are not performed. For the normal working process of the system, it is important no dots to be part of the values of the key custom properties because the dot is a system character used for item key compilation. b.The user sets it manually 30. AllowPlannedDocumentStateInClient a.Action: When this key has value and this value is \"1\", the document state menu would contain Planned state. In all other cases, the user would not be able to select the Planned state on any document. b.The user sets it manually 31. DisableProductCopyPropertiesFromOtherProduct a.Action: When this key has value and this value is \"1\", the Product configurator feature for copying the values to custom properties from the custom property which values are products is deactivated. b.The user sets it manually 32. PaymentTransactionFiscalPrintChangeToState (DEPRECATED) a.This key specifies the document state to which a payment transaction is switched to after the receipt is printed. The key value is the numeric value of the document states (0 = New, 10 = Planned, 20 = FirmPlanned, 30 = Released, 40 = Completed). In all other cases, the payment transaction is switched to Released state. b.The user sets it manually. 33. Crm/Sales/SalesOrders/ShowFillLotsInLines a.Action: When this key has value and this value is \"1\", the sales order function \"Fill lots in lines\" is activated. b.The user sets it manually. 34. General/Contacts/LoadCalendarForLimitedTime a.Action: When this key has value and this value is \"1\", the calendar in the Activities navigator loads data only for the displayed period (+/- 1 month) when the user scrolls through the calendar. b.The user sets it manually. 35. DisableDocumentRecalculationOnIdle a.Action: When this key has value and this value is \"1\", in the document forms the recalculation of additional amounts, bonus programs, payment plans and etc in real-time would not be performed (Application.Idle event). In such cases, the document would be recalculated only before the COMMIT event and not in real-time while the user enters the b.data in the document form. The method referred by the current key is \"Document.Recalculate\" which performs different actions in the different entities. c.The user sets it manually. 36. DisableParentDocumentReset a.Action: When this key has value and this value is \"1\", on document state change the parent document state is not reset. b.The user sets it manually. 37. RevokedBusinessRules a.Action: When this key has value, the validation and the action of the business rules, which codes are specified as a key value, is not performed. The codes of the business rules must be listed comma-separated (for example 27407, 26881 ..). Since version 2018.2, business rules' codes must be set with their full code including \"R\" (eg R27408, R26881 ...). If the key value is changed, the client application requires a restart. b.The user sets it manually. 38. DisableQueryingForSaveOnClose a.Action: When this key has value and this value is \"1\", on closing of a form which is not saved, if there is a change in any table of the form, no information message for saving or undo of the changes appears. b.The user sets it manually. 39. UseLegacyLoadForLotsIssue a.Action: When this key has value and this value is \"1\", for the calculation of the quantity \"Available to promise by lots\" is used the method that was developed before Version 2018.2. In all other cases, is used the current for Version 2018.2 method which is advisable and has a better performance. b.The user sets it manually. 40. ReservedLicenses (not implemented/ cancelled) 41. EnableCreateGroupForUser a.Action: When this key has value and this value is \"1\" or \"true\" (case-insensitive), when creating a new user into the database a new group with the user’s name will be created automatically as well. b.The user sets it manually. c.The key is introduced in version: - 2019.1 (in implementation) Note Before version 2019.1 a new user group was created automatically every time when a new user is created and this behaviour could not be disabled. Since version 2019.1 the behaviour is disabled by default and could be activated manually using the current registry key. 42. DocumentVersioningSystem a.Action: When the value of this key is \"VH\" the system will use the \"old\" document versioning system. If the key's value is \"TC\" the system will not create records using the \"old\" document versioning system and will instead use the Track changes system. The minimum level that is going to be tracked when the \"TC\" option is activated is \"Track Changes Level 3\". If for the particular document entity is chosen a specific level, then this level will be applied only if it is a higher level than level 3. (For more information about the track changes system and its levels, please see topic Track changes Note Please note that the current key affects only entities which are a successor of document entity (such as sales orders, store orders ...) and NOT entities such as product groups, bonus programs.. b.The user sets it manually, but if the key is not configured for the particular database or its value is different from \"VH\" or \"TC\", then the system will use the default value. The default value depends on the system version: Version 2019.1 - the default value is \"VH\"; Version 2020.1 and later - the default value is \"TC\"; c.The key is introduced in version: - 2019.1 43. Crm/Pos/PrintGroupedSalesLinesType a.Action: When the value of this key is \"ShortName\" then items in the fiscal receipt are grouped by \"ShortName\" field in the product. When the value of this key is \"ProductGroup\" then items in the fiscal receipt are grouped by the product group of the product. When the value of this key is different or the key is missing then items in the fiscal receipt are not grouped. b.The key is introduced in version: - 2019.1 44. UseStartScreen a.Action: When the value of this key is: \"1\" - the form that is going to be opened when the program is started by the specified user will be the Start screen. \"2\" - the starting form will be the Main menu. \"0\", different from \"1\" and \"2\" or the key is not configured for the particular database and user - the system will use the default value. The default value for version 2020.1 is Main Menu.Warning: The current key's value will be taken into account only if there is no global policy specifying the use of the start screen for the whole database using the key \"UseStartScreenPolicy\" b.The user sets it manually. c. The key is introduced in version: - 2020.1 45. UseStartScreenPolicy a.Action: When the value of this key is: \"1\" - the form that is going to be opened when the program is started will be the Start screen. This applies to all users into the database, regardless of the \"UseStartScreen\" option. \"2\" - the starting form will be the Main menu. This applies to all users into the database, regardless of the \"UseStartScreen\" option/key. \"0\", different from \"1\" and \"2\" or the key is not configured for the particular database - there is no global policy. Each user decides whether they want to use the start screen using \"UseStartScreen\" option/key. b.The user sets it manually. c.The key is introduced in version: - 2020.1 46. UseDefaultMailClient a.Action: When this key has a value for the particular user and this value is \"1\", then when creating an email the system will start the default Windows mail client. This will apply even if there is a mailbox defined for the user. b. The user sets it manually (directly in the registry or using the option available in tab File => Settings => Use default Windows mail client). c.The key is introduced in version: - 2019.1 47. CodeNameFormat a.Action: The default display text format for entities that provide Code and Name. The value is an integer number from 1 to 4: \"1\" - {Code}: {Name} \"2\" - {Code} \"3\" - {Name} ({Code}) \"4\" - {Name} b.The user sets it manually. c.The key is introduced in version: - 2022 48. AllowBasicAuthForAllUsers a.When this key has value and this value is \"1\", all users can use basic authentication, regardless of their setting. b.The user sets it manually c.The key is introduced in version: - 2023 49. Calendar/TimePresets a.When this key has value and conforms to the format below, it overrides the time presets in the calendar control. <PresetName1>=<H>:<M>;<PresetName2>=<H>:<M>;... e.g., Morning=10:00;Lunch=12:30;Afternoon=15:00;Dinner=19:00 b.The user sets it manually c.The key is introduced in version: - 2023 50. InventoryControl/ReceiveDocumentType a.The key defines the document type of the created document when using the Receive function of Inventory Control b.The user sets it manually c.The key is introduced in version: - 23.2 51. InventoryControl/IssueDocumentType a.The key defines the document type of the created document when using the Issue function of Inventory Control b.The user sets it manually c.The key is introduced in version: - 23.2 52. InventoryControl/ScrapDocumentType a.The key defines the document type of the created document when using the Scrap function of Inventory Control b.The user sets it manually c.The key is introduced in version: - 23.2 53. InventoryControl/ReconcileDocumentType a.The key defines the document type of the created document when using the Reconcile function of Inventory Control b.The user sets it manually c.The key is introduced in version: - 23.2 54. /WMS/WMS-Worker/SingleBarcodeScanEntersQuantityOfOnePce - DEPRECATED v.25 a.Action: When the value of this key is: \"1\" - When Scan single barcode then this is accepted as 1 PCE \"0\" - Wnen Scan single barcode then No quantity is accepted, the WMS-Worker APP just finds the line and goes to execute mode for this line. b.The user sets it manually. c.The key is introduced in version: - 23.2 55. /WMS/WMS-Worker/OrderDisplayFormat a.Action: When this key is defined, the WMS Worker application will display the data you need replacing the first row with Order information in the WO list and inside the WO. Depending on the entered key value - in the orders list and inside the WO, you can see the data you need from the current Warehouse order header. The value is entered as an interpolated string. You can use also format specifiers. For example \"My info - {@Property1: VD} ; my store: {Warehouse}\" will be displayed as \"My info - 01:yes ; my store: Warehouse1\" b.If the key is not defined, the WMS Worker will display the default information, which is coming from To Party field in the WO header. c.The user sets it manually. 56. DataSourceTableOptimizationDisabled a.Action: When this key has value and this value is \"1\", all tables in the data source of the printout will be extracted from the database. In all other cases, only the data that is actually used by the layout of the printout will be extracted. b.The user sets it manually 57. /TrackChanges/AttributeChangesRetentionMonths a.Action: When the key is defined and has a value, its value specifies the retention period, in months, of attribute changes history data (these are the records in the Attribute Changes table, which are generated by the Track Changes system). The retention period starts from the date the change was made, which is set in ObjectChangeset.TimeUtc field. When the key is not defined or has no value, the retention period is set to 36 months by default. If the J35666 Delete attribute changes history job is configured and active - the old history data for attribute changes, whose retention period is expired, will be deleted. c.The user sets it manually. d.The key is introduced in version: - 24 58. /Acc/DisableAccountFilterLimit a.Action: When the key is not defined or has value and this value is \"0\", data loading is not allowed in Chronological Statement Navigator if a filter is applied for more than 10 accounts or no accounts. An error message will be displayed. When the key has value \"1\" the warning message will be displayed and then data will be loaded. b.The user sets it manually 59. AI/Assistant/DebugMode a.Action: When this key has a value of '1', it determines whether an AI assistant will operate in debug mode. b.The user sets it manually c.The key is introduced in version: - 24 60. AI/Assistant/AdditionalInstructions a.Action: Additional instructions, passed to the AI assistant. b.The user sets it manually c.The key is introduced in version: - 24 61. /WMS/WMS-Worker/ProductDisplayFormat a.Action: When this key is defined, the WMS Worker application will display the data you need replacing the Product field in the Warehouse order line list. Depending on the entered key value - in the orders line list, you can see the data you need from the current Warehouse order line. The value is entered as an interpolated string. You can use also format specifiers. For example \"my product: {Product.PartNumber}; size: {Product.@Property1: VD}\" will be displayed as \"my product: 0000001 ; size: 01:big\" b.If the key is not defined, the WMS Worker will display the default information, coming from the Product field and follow the default Web client display text format for Product, which is Product.Name. c.The user sets it manually. 62. /WMS/WMS-Worker/LocationDisplayFormat a.Action: When this key is defined, the WMS Worker application will display the data you need replacing the Location field in the Warehouse order line list. Depending on the entered key value - in the orders list, you can see the data you need from the current Warehouse order line. The value is entered as an interpolated string. You can use also format specifiers. For example \"location: {Location} ; forklift - {Document.@Property2: VD}\" will be displayed as \"location: 01-02-A2 ; forklift: 01:yes\" b.If the key is not defined, the WMS Worker will display the default information, which is coming from the Location field. c.With the Suggest Routing function the string for the location is called with a dollar sign: {$WarehouseLocation} d.The user sets it manually. 63. /Inv/ListAllStoresForTransfers a.Action: When the value of this key is: \"1\" - When the key is defined and its value is 1, all defined stores will be listed in the ToStore field in the Transfer function. \"0\" - When a key is defined and its value is 0 or there is no defined key, only the stores to which the user has permission will be listed. b.The user sets it manually. c.The key is introduced in version: - 24 SP5 64. /Documents/AllowCompleteWithSubdocumentsIncludingUnreleased a.Action: When the value of this key is: \"1\" - When the key is defined and set to 1, 'Complete with sub-documents, including unreleased' will be available as a Completed status option. \"0\" - When the key is defined and set to 0, or if no key is defined, 'Complete with sub-documents, including unreleased' will not be available as a Completed status option. b.The user sets it manually. c.The key is introduced in version: - 25 65. /JobsManager/IgnoreSessionsForIdleSchedule a.Action: When the value of this key is: \"1\" - When the key is defined and set to 1, Jobs marked as Run On Idle will start automatically at the scheduled time regardless of current server sessions. \"0\" - When the key is defined and set to 0 or a value different from 1, or if no key is defined, Jobs marked as Run On Idle will start automatically at the scheduled time only if the server sessions are less than 5. b.The user sets it manually. c.The key is introduced in version: - 24 SP7 66. /Monitoring/AuditLogEntriesRetentionMonths a.Action: When the key is defined and has a value, its value specifies the retention period, in months, of audit log entries (these are the records in the Audit Log Entries table). The retention period starts from the date set in AuditLogEntries.Event_Time_Utc field. When the key is not defined or has no value, the retention period is set to 12 months by default. If the J38417 Delete old audit logs job is configured and active - the audit log entries, whose retention period is expired, will be deleted. b.The user sets it manually. c.The key is introduced in version: - 25 67. /id/UserNameAutoComplete a.Action: When the value of this key is: \"1\" - When the key is defined and set to 1, the autocomplete option for the user/email field of the Desktop client login screen is turned on. This means that previously entered login credentials will be suggested when clicking into the field. \"0\" - When the key is defined and set to 0 or a value different from 1, or if no key is defined, the autocomplete option for the user/email field of the Desktop client login screen is turned off. b.The user sets it manually. c.The key is introduced in version: - 24 SP10 68. /Finance.Accounting/RCDate_EC{EnterpriseCompany.Id} a.Action: Defines the parameter LastProcessedDate. EnterpriseCompany.Id is the ID of the enterprise company. The value is the LastProcessedDate parameter for the job type J38662 Calculate Historical Reporting Currency Amounts b.Set automatically by the Job J38662."
  },
  "reference/country-specific-functionality.html": {
    "href": "reference/country-specific-functionality.html",
    "title": "Country-specific functionality | ERP.net Tech Docs",
    "summary": "Country-specific functionality ERP.net contains some country, region, or other specific functionalities that are needed in order to meet legal or regulatory requirements. Such functionality is the creation of VAT returns and the VAT export files for submission to the National Revenue Agency (Bulgaria), for example. Party applicable legislations In parties, there is a child table with the applicable legislations for the particular party. The table contains information about the countries, states, unions, or other entities whose regulations apply to the party. The records in this table are used when determining if a business rule must be activated when, for example, it incorporates rules that are specific for the particular country's laws. Bulgaria (BG) List of the system deal types and their correlation with the sales and purchases ledger's columns The VAT declaration in ERP.net is a document that serves as a basis for the creation of a VAT return and the VAT export files for submission to the National Revenue Agency. The information in the VAT declaration is based on the VAT entries created in the system for the particular period. The entries amounts (Amount base and VAT amount base) are entered in different columns of the sales and purchases ledger of the VAT declaration depending on their deal type. For more information about entries' deal type and amount calculation, see Defining VAT and base for VAT Entries. This article contains information about the correlation between the system deal types and the columns of the sales and purchases ledgers according to which the entries amounts are distributed to those columns. Sales ledger Column Column name (EN) Column name (BG) Deal type (BG) Value Additional Conditions Column8a_Data Delivery, art. 163a, or Import, art. 167a Доставка по чл. 163а или внос по чл. 167а от ЗДДС Внос или вътреобщностно придобиване на хляб 07 Apply_Date >= '20220701' Column8a_Data Delivery, art. 163a, or Import, art. 167a Доставка по чл. 163а или внос по чл. 167а от ЗДДС Внос или вътреобщностно придобиване на брашно 08 Apply_Date >= '20220701' Column8a_Data Delivery, art. 163a, or Import, art. 167a Доставка по чл. 163а или внос по чл. 167а от ЗДДС Доставки на хляб 07 Apply_Date >= '20220701' Column8a_Data Delivery, art. 163a, or Import, art. 167a Доставка по чл. 163а или внос по чл. 167а от ЗДДС Доставки на брашно 08 Apply_Date >= '20220701' Column9_Data Total Base Amount Общ размер на данъчните основи ВОД Base Amount - Column9_Data Total Base Amount Общ размер на данъчните основи Доставка по чл. 163а от ЗДДС част I (отпадъци) на Приложение 2 Base Amount - Column9_Data Total Base Amount Общ размер на данъчните основи Доставка по чл. 163а от ЗДДС част II (земеделска продукция) на Приложение 2 Base Amount - Column9_Data Total Base Amount Общ размер на данъчните основи Доставка по чл.140,146,173(1) или 173(4) Base Amount - Column9_Data Total Base Amount Общ размер на данъчните основи Износ по глава трета от ЗДДС Base Amount - Column9_Data Total Base Amount Общ размер на данъчните основи Облагаеми доставки 7/9% Base Amount - Column9_Data Total Base Amount Общ размер на данъчните основи Облагаеми сделки Base Amount - Column9_Data Total Base Amount Общ размер на данъчните основи Самоначисляване на ДДС по чл.82,ал.2-5 Base Amount - Column9_Data Total Base Amount Общ размер на данъчните основи Самоначисляване на ДДС при ВОП Base Amount - Column9_Data Total Base Amount Общ размер на данъчните основи Внос или вътреобщностно придобиване на хляб Base Amount Apply_Date >= '20220701' Column9_Data Total Base Amount Общ размер на данъчните основи Внос или вътреобщностно придобиване на брашно Base Amount Apply_Date >= '20220701' Column9_Data Total Base Amount Общ размер на данъчните основи Доставки на хляб Base Amount Apply_Date >= '20220701' Column9_Data Total Base Amount Общ размер на данъчните основи Доставки на брашно Base Amount Apply_Date >= '20220701' Column10_Data Total VAT Amount Всичко начислен ДДС Начислен ДДС при ползване за лични нужди VAT Amount Apply_Date >= '20160201' Column10_Data Total VAT Amount Всичко начислен ДДС Начисляване на ДДС в др. случаи VAT Amount - Column10_Data Total VAT Amount Всичко начислен ДДС Облагаеми доставки 7/9% VAT Amount - Column10_Data Total VAT Amount Всичко начислен ДДС Облагаеми сделки VAT Amount - Column10_Data Total VAT Amount Всичко начислен ДДС Самоначисляване на ДДС по чл.82,ал.2-5 VAT Amount - Column10_Data Total VAT Amount Всичко начислен ДДС Самоначисляване на ДДС при ВОП VAT Amount - Column10_Data Total VAT Amount Всичко начислен ДДС Внос или вътреобщностно придобиване на хляб VAT Amount Apply_Date >= '20220701' Column10_Data Total VAT Amount Всичко начислен ДДС Внос или вътреобщностно придобиване на брашно VAT Amount Apply_Date >= '20220701' Column11_Data Base Amount 20 Percent Данъчна основа 20% Доставка по чл. 163а от ЗДДС част I (отпадъци) на Приложение 2 Base Amount - Column11_Data Base Amount 20 Percent Данъчна основа 20% Доставка по чл. 163а от ЗДДС част II (земеделска продукция) на Приложение 2 Base Amount - Column11_Data Base Amount 20 Percent Данъчна основа 20% Облагаеми сделки Base Amount - Column12_Data VAT Amount 20 Percent Начислен ДДС 20% Начисляване на ДДС в др. случаи VAT Amount Apply_Date >= '20160201' Column12_Data VAT Amount 20 Percent Начислен ДДС 20% Облагаеми сделки VAT Amount - Column13_Data Base Amount EUPurchase Данъчна основа на ВОП Самоначисляване на ДДС при ВОП Base Amount - Column13_Data Base Amount EUPurchase Данъчна основа на ВОП Внос или вътреобщностно придобиване на хляб Base Amount Apply_Date >= '20220701' Column13_Data Base Amount EUPurchase Данъчна основа на ВОП Внос или вътреобщностно придобиване на брашно Base Amount Apply_Date >= '20220701' Column14_Data Base Amount VATL Article 82 Данъчна основа на доставките по чл.82, ал. 2 - 5 Самоначисляване на ДДС по чл.82,ал.2-5 Base Amount - Column15_Data VAT Amount EUPurchase VATL Article 82 Начислен ДДС за ВОП и доставките по чл.82, ал. 2 - 5 Самоначисляване на ДДС по чл.82,ал.2-5 VAT Amount - Column15_Data VAT Amount EUPurchase VATL Article 83 Начислен ДДС за ВОП и доставките по чл.82, ал. 2 - 5 Самоначисляване на ДДС при ВОП VAT Amount - Column15_Data VAT Amount EUPurchase VATL Article 83 Начислен ДДС за ВОП и доставките по чл.82, ал. 2 - 5 Внос или вътреобщностно придобиване на хляб VAT Amount Apply_Date >= '20220701' Column15_Data VAT Amount EUPurchase VATL Article 83 Начислен ДДС за ВОП и доставките по чл.82, ал. 2 - 5 Внос или вътреобщностно придобиване на брашно VAT Amount Apply_Date >= '20220701' Column16_Data VAT amout in case of personal use Начислен данък при ползване за лични нужди Начислен ДДС при ползване за лични нужди VAT Amount Apply_Date >= '20160201' Column16_Data VAT amout in case of personal use Начислен данък при ползване за лични нужди Начисляване на ДДС в др. случаи VAT Amount Apply_Date < '20160201' Column17_Data Base Amount 9 % Данъчна основа 9 % Облагаеми доставки 7/9% Base Amount - Column18_Data VAT Amount 9 % Начислен ДДС 9 % Облагаеми доставки 7/9% VAT Amount - Column19_Data Base Amount 0 Percent VATL Chapter 3 Данъчна основа 0 % по глава трета от ЗДДС Износ по глава трета от ЗДДС Base Amount - Column19_Data Base Amount 0 Percent VATL Chapter 3 Данъчна основа 0 % по глава трета от ЗДДС Доставки на хляб Base Amount Apply_Date >= '20220701' Column19_Data Base Amount 0 Percent VATL Chapter 3 Данъчна основа 0 % по глава трета от ЗДДС Доставки на брашно Base Amount Apply_Date >= '20220701' Column20_Data Base Amount 0 Percent EUSale Данъчна основа 0 % на ВОД ВОД Base Amount - Column21_Data Base Amount 0 Percent VATL Articles 140 146 173 Данъчна основа 0 % по чл. 140, чл. 146 ал. 1 и чл. 173, ал. 1 и 4 Доставка по чл.140,146,173(1) или 173(4) Base Amount - Column22_Data Base Amount Service Sales VATL Article 21 Данъчна основа на услугите по чл. 21, ал. 2 Доставка по чл.21(2) в друга държава членка Base Amount - Column23_Data Base Amount VATL Article 69 Данъчна основа почл. 69, ал. 2 Доставка по чл.69(2) и дистанц. продажба към др.членка Base Amount - Column24_Data Base Amount Exempted Sales And EUPurchases Данъчна основа на освободени доставки и ВОП Освб. дост. по чл. 21(2), в рамките на ЕС Base Amount - Column24_Data Base Amount Exempted Sales And EUPurchases Данъчна основа на освободени доставки и ВОП Освободени ВОД, извън територията на България Base Amount - Column24_Data Base Amount Exempted Sales And EUPurchases Данъчна основа на освободени доставки и ВОП Освободени доставки и освободени ВОП Base Amount - Column25_Data Base Amount Third Party Operation Данъчна основа от посредник в тристранна операция Доставки като посредник при тристранна операция Base Amount - Column25_Data Base Amount Third Party Operation Данъчна основа от посредник в тристранна операция Доставки като посредник при тристранна операция (авансови плащания) Base Amount - The \"Нулеви сделки\" Deal Type fills in the data in columns 1 through 8. They are used in combination with \"Внос по чл. 167а от ЗДДС\". Purchases ledger Column Column name (EN) Column name (BG) Deal type (BG) Value Additional conditions Column8a_Data Delivery, art. 163a, or Import, art. 167a Доставка по чл. 163а или внос по чл. 167а от ЗДДС Внос или вътреобщностно придобиване на хляб 07 Apply_Date >= '20220701' Column8a_Data Delivery, art. 163a, or Import, art. 167a Доставка по чл. 163а или внос по чл. 167а от ЗДДС Внос или вътреобщностно придобиване на брашно 08 Apply_Date >= '20220701' Column9_Data Base Amount Without Tax Credit Данъчна основа без право на данъчен кредит Сделки, внос и ВОП без право на данъчен кредит Base Amount - Column10_Data Base Amount With Full Tax Credit Данъчна основа с право на пълен данъчен кредит Сделки, внос и ВОП с право на пълен данъчен кредит Base Amount - Column10_Data Base Amount With Full Tax Credit Данъчна основа с право на пълен данъчен кредит Внос или вътреобщностно придобиване на хляб Base Amount Apply_Date >= '20220701' Column10_Data Base Amount With Full Tax Credit Данъчна основа с право на пълен данъчен кредит Внос или вътреобщностно придобиване на брашно Base Amount Apply_Date >= '20220701' Column11_Data VAT Amount With Full Tax Credit ДДС с право на пълен данъчен кредит Сделки, внос и ВОП с право на пълен данъчен кредит VAT Amount - Column11_Data VAT Amount With Full Tax Credit ДДС с право на пълен данъчен кредит Внос или вътреобщностно придобиване на хляб VAT Amount Apply_Date >= '20220701' Column11_Data VAT Amount With Full Tax Credit ДДС с право на пълен данъчен кредит Внос или вътреобщностно придобиване на брашно VAT Amount Apply_Date >= '20220701' Column12_Data Base Amount With Partial Tax Credit Данъчна основа с право на частичен данъчен кредит Сделки, внос и ВОП с право на частичен данъчен кредит Base Amount - Column13_Data VAT Amount With Partial Tax Credit ДДС с право на частичен данъчен кредит Сделки, внос и ВОП с право на частичен данъчен кредит VAT Amount - Column14_Data Annual Correction Годишна корекция Годишна корекция VAT Amount - Column15_Data Base Amount Third Party Operation Данъчна основа от посредник в тристранна операция Придобиване от посредник в тристранна операция Base Amount - The \"Нулеви сделки\" Deal Type fills in the data in columns 1 through 8. They are used in combination with \"Внос по чл. 167а от ЗДДС\"."
  },
  "reference/forms-with-activated-domain-front-end-logic.html": {
    "href": "reference/forms-with-activated-domain-front-end-logic.html",
    "title": "Forms with activated domain front-end logic | ERP.net Tech Docs",
    "summary": "Forms with activated domain front-end logic When a domain front-end logic is activated for a particular form, this means that it is activated for all referent panels in this form which are a part of the aggregate. E.i. if it is activated for the sales ordes form - it is also activated for panels such as Sales orders lines and Payment plan which are a part of the sales order's aggregate, but not for panels such as Document amounts which are a part of the document's aggregate. Module Form Activated BindDomainLogic Version Sales module Customer Types YES 20.1 CustomerCompanyLocations YES 20.1 Customers YES 20.1 Customers - Companies YES 20.1 Customers - Persons YES 20.1 Dealers YES 20.1 Dealers - Companies YES 20.1 Dealers - Persons YES 20.1 Offers YES 2017.1 Price Lists YES 20.1 Price Types YES 20.1 Sales Orders YES 2017.1 Sales Persons YES 20.1 Deals YES 22.1 Line Discounts YES 22.1 Product Prices YES 22.1 Promotional Packages YES 22.1 POS module POS Devices YES 20.1 POS Locations YES 20.1 POS Operators YES 20.1 POS Roles YES 20.1 POS Work Terminals YES 20.1 Product Types - Tax Groups YES 20.1 Invoicing module Invoice Orders YES 20.1 Invoices YES 20.1 Products module Coding Systems YES 20.1 Measurement Categories YES 20.1 Measurement Units YES 20.1 Product - Pictures YES 20.1 Product Groups YES 20.1 Product Types YES 20.1 Products YES 20.1 Products - Codes YES 20.1 Products - Dimensions YES 20.1 Products - Distribution channels YES 20.1 Products - Variants YES 2017.1 Product variants - Colors YES 22.1 Product variants - Sizes YES 22.1 Product variants - Styles YES 22.1 Configurator module Product Groups YES 20.1 Products YES 20.1 Product group - Required properties YES Product - Custom properties YES Contacts & Tasks module Activities YES 20.1 ActivityParticipants YES 22.1 Areas YES 20.1 Call detail YES 20.1 Companies YES 20.1 Companies - Departments YES 20.1 Company EU configurator YES 20.1 Contact Mechanisms YES 20.1 Party - Pictures YES 20.1 Party Relationship Types YES 20.1 Party Relationships YES 20.1 Reminders YES 20.1 Resources YES 22.1 Resources - Availability YES 20.1 Resources - Resource instances YES 20.1 Resource Groups YES 22.1 Activities - Time intervals YES 22.1 Companies - Divisions YES 22.1 Companies - Employees YES 22.1 Companies - Locations YES 22.1 Parties YES 22.1 Persons YES 22.1 Marketing module Bonus Programs YES 20.1 Campaingns YES 20.1 Distribution Channels YES 20.1 Forecast Items YES 20.1 Marketing Activities YES 20.1 Product Catalogs YES 20.1 Target Groups YES 20.1 Distribution module Customers - Products YES 20.1 Sales Person Groups YES 20.1 Sales Person Targets YES 22.1 Sales Persons YES 20.1 Pricing module Pricing Models YES 20.1 Products YES 20.1 Types YES Shipment module Shipment Orders YES 20.1 Shipments YES 20.1 Inventory Management module Lots YES 20.1 Products - Default Store Bins YES 20.1 Products - Valuation Groups YES 20.1 Scrap Types YES 20.1 Serial Numbers YES 20.1 Store Bins YES 20.1 Store Groups YES 20.1 Store Orders YES 20.1 Stores YES 20.1 Transactions YES 20.1 Cost Corrections YES 22.1 Reconciliations YES 22.1 Transfer Orders YES 22.1 Logistics Planning module Product Supply YES 22.1 Procurement module Receiving Orders YES 20.1 Suppliers YES 20.1 Suppliers - Companies YES 20.1 Suppliers - Persons YES 20.1 Purchase Control Documents YES 22.1 Purchase Operation Types YES 22.1 Purchase Orders YES 22.1 Purchase Price Lists YES 22.1 Purchase Product Prices YES 22.1 Requisitions YES 22.1 Supplier Types YES 22.1 Products and Technologies module Products YES 20.1 Principal Recipies YES 22.1 Recipies YES 2015 Production Planning module Product Supply YES 22.1 Resources module Function Groups YES 22.1 Functions YES 22.1 Operation Groups YES 22.1 Operations YES 22.1 Resource Groups YES 22.1 Resources YES 22.1 Workgroups YES 22.1 Workgroups - Resources YES 22.1 Work Schedules YES 22.1 Shop Floor module Consumption Orders YES 22.1 Output Orders YES 22.1 Work Orders YES 22.1 Projects Management module Project Tasks YES 22.1 Projects YES 22.1 Projects - Risks YES 22.1 Projects Budgeting module Resources YES 22.1 Resource Groups YES 22.1 Gen_Resources - Resource Instances YES 20.1 Resources - Availability YES 20.1 Product Variants YES 22.1 Projects Executuion module Work Reports YES 22.1 Projects Setup module Project Types YES 22.1 Project Types - Participants Roles YES 22.1 Project Types - Work Elements YES 22.1 Project Types - Work Types YES 22.1 Task Types YES 22.1 Payments module Bulk Payment Orders YES 20.1 Parties - Bank Accounts YES 20.1 Payment Accounts YES 20.1 Payment Orders YES 20.1 Payment Reasons YES 20.1 Payment Slips YES 20.1 Payment Transfers YES 20.1 Payment Types YES 20.1 Payment Transactions YES 22.1 Expenses module Supliers YES 20.1 Supliers - Companies YES 20.1 Supliers - Persons YES 20.1 Purchase Invoice YES 22.1 Accounting module Account Groups YES Accounts YES 22.1 Cost Centers YES Operations YES Profit Centers YES Templates YES 22.1 Vouchers NO - Cost Accounting module Cost Distributions YES Cost Types YES Financial Statements YES VAT module Deal Types YES 22.1 Declaring Person YES 22.1 Document Type VAT Codes YES Entries YES 22.1 VAT Declarations YES Intrastat module Intrastat Declarations YES 22.1 Fixed Assets module Acquire and Retire Orders YES 22.1 Asset Categories YES 22.1 Asset Groups YES 22.1 Asset Transactions YES 22.1 Assets YES 22.1 Depreciation Methods YES 22.1 Depreciation Plans YES 22.1 Depreciations YES 22.1 Valuation Methods YES 22.1 Lease-Out Management module Asset Groups YES 22.1 Asset Types - Consumables YES 22.1 Asset Types - Properties YES 22.1 Assets YES 22.1 Assets - Consumables YES 22.1 Assets Types YES 22.1 Service module Service Activities YES 22.1 Service Agreements YES 22.1 Service Object Types YES 22.1 Service Objects YES 22.1 Service Orders YES 22.1 Service Types YES 22.1 Services YES 22.1 Services - Ivoicing YES 22.1 Vehicles module Crews YES 22.1 Equipment Types YES 22.1 Map Points YES 22.1 Trips YES 22.1 Vehicle Equipment YES 22.1 Vehicle Sets YES 22.1 Vehicles YES 22.1 Mail module Mail Messages YES 22.1 Mailboxes YES 22.1 Data Warehouse module Data Measures YES Data Measures Groups YES Data Values YES Personal Data (GDPR) module Personal Data Management Processes YES 22.1 Processing Consents YES 22.1 Rights Requests YES 22.1 Asset Maintenance module Maintenance Orders YES 22.1 Maintenance Types Groups YES 22.1 Maintenance Types YES 22.1 Managed Asset Groups YES 22.1 Managed Asset Types YES 22.1 Managed Assets YES 22.1 Service Centers YES 22.1 Tracked Parameters YES 22.1 General Administrative Regions YES 22.1 Countries YES 22.1 Currencies YES 22.1 Currency Directories YES Custom Properties YES 22.1 Custom Properties Categories YES 22.1 Enterprise Companies YES 22.1 Communities Notification Settings YES 22.1 Notifications YES 22.1 Document Model Document Amount Types YES 22.1 Document Types - Amounts YES Document Types YES 22.1 Document Types - Security Conditions YES Printouts YES Printouts - Layouts YES 22.1 Processes YES 22.1 Routes YES 22.1 Sales Orders - Default Payment Plans YES 22.1 Sequence Generators YES Sequences YES Business Rules Calculated Attributes YES 2018.1 User Business Rules YES 2018.1 Business Processes Business Processes YES 22.1 Process Elements YES Process Groups YES 22.1 Process Instance YES 22.1 Process Lanes YES 22.1 Security Access Keys YES Audit Log Entries YES 22.1 Column Permissions YES 22.1 Domains YES Entities YES Groups YES Roles YES Roles - Users YES Trusted Applications YES User Groups YES Users YES Tools Data Sources YES 22.1 Document Jobs YES External Applications YES Jobs YES Reports YES 22.1 Translations YES 22.1 Web Hosts YES Web Sites YES"
  },
  "reference/index.html": {
    "href": "reference/index.html",
    "title": "Reference section | ERP.net Tech Docs",
    "summary": "Reference section This section contains topics about reference data. Select a topic from the list below to learn more. Config options reference Module codes Country-specific functionality System permissions Forms with activated domain front-end logic"
  },
  "reference/module-codes.html": {
    "href": "reference/module-codes.html",
    "title": "Module codes | ERP.net Tech Docs",
    "summary": "Module codes This topic contains an up-to-date list of ERP.net modules. Generic access licenses CAL01 - Concurrent client access license ED01 - Edition - Mini ED02 - Edition - Small business ED03 - Edition - Standard ED04 - Edition - Corporate Applications APP01 - Applications - Project management APP02 - Applications - Lease-out management APP03 - Applications - Vehicle management APP04 - Applications - Mail APP05 - Applications - Personal data management APP06 - Applications - Data warehouse APP07 - Applications - Enterprise asset management APP08 - Applications - ERP.net POS CRM CRM01 - Clients - Sales CRM02 - Clients - Invoices CRM03 - Clients - Products CRM04 - Clients - Product configuration CRM05 - Clients - Contacts and tasks CRM06 - Clients - Marketing CRM07 - Clients - Service CRM08 - Clients - Distribution CRM09 - Clients - Unified communications CRM10 - Clients - Pricing CRM11 - Clients - POS sales Finance FIN01 - Finance - Payments FIN02 - Finance - Expenses FIN03 - Finance - Accounting FIN04 - Finance - VAT FIN05 - Finance - Fixed assets FIN06 - Finance - Financial analysis FIN07 - Finance - Intrastat reporting FIN08 - Finance - Cost accounting Logistics LOG01 - Logistics - Shipment LOG02 - Logistics - Inventory management LOG03 - Logistics - Planning LOG04 - Logistics - Procurement LOG05 - Logistics - Warehouse management LOG06 - Logistics - Transportation Production PRD01 - Production - Products and technologies PRD02 - Production - Planning PRD03 - Production - Resources PRD04 - Production - Shop floor control Security SEC01 - Security - Sign in with Azure AD Web WEB02 - Web - Client center Extras X01 - Extras - 10 Companies X02 - Extras - Unlimited companies X03 - Extras - Store bins X04 - Extras - Pictures editor X05 - Extras - Business intelligence X06 - Extras - Barcode controlling X07 - Extras - ERP.net API X08 - Extras - Business process management X09 - Extras - CSharp scripting"
  },
  "reference/system-permissions.html": {
    "href": "reference/system-permissions.html",
    "title": "System permissions | ERP.net Tech Docs",
    "summary": "System permissions In ERP.net there are some predefined system permissions that are created in order to serve certain business cases and allow giving or restricting access of particular functionalities in the system. Each system permission has a specific access key ID that is the same in each database. The records for that which system permission is granted to which user groups is kept in the Group access keys table. We are adding a list with the predefined system permissions and their access key IDs. This information could, for example, be used to monitor the changes of those permissions using the Track changes system. System permission Access key ID Description Allow edit persist lot in shipment orders 17f56001-681a-4972-a75f-425e21158e4c Allow credit limit override in sales orders 39c19335-cdd2-4548-8d0d-b10d5fc9fc9f Allow edit unit price in offers and sales orders b85c23e3-f314-467a-9022-53e43c08b585 Allow edit historical unit cost in sales orders c88e4f8a-7e55-4029-9615-a7e2b12ddd1b Allow edit persist lot in sales orders b2a3cef0-e6e3-11e1-aff1-0800200c9a66 Allow edit line discount in offers and sales orders e71c31d2-e315-4a72-d021-f3143c08b58a Allow edit persist lot in store orders aebcc95b-41d1-494e-92f8-e01501b353a8 Allow release of correct logistics transactions that are not validated orders 61e43e33-5bc4-484c-b581-3737e05b0978 Use personal layout views 850945b7-91da-4aa4-9e55-9f8feb72e423 Show more than 2,000 rows d7208a56-2a02-4069-bbe7-a8ce65085094 Show more than 20,000 rows 4a3c7106-e15b-4c97-bae1-5500c0cf47c6 Show more than 200,000 rows 10c58661-8210-4a77-8444-5126b0d99c91 Advanced User 06051ccb-19ef-49f0-a224-2ce2bcea87cf Super User 0ee5ee4b-3cbc-4fd2-aa50-42b1c5fa1d9a Server Control c10b3c23-2cf0-470b-b80d-549e0533c190 Give access to Exec Stats"
  }
}